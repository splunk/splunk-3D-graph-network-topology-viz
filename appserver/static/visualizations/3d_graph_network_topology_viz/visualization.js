define(["vizapi/SplunkVisualizationBase","vizapi/SplunkVisualizationUtils"], function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Visualization source
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	            __webpack_require__(1),
	            __webpack_require__(2),
	            __webpack_require__(3),
	            __webpack_require__(4),
	            __webpack_require__(5),
	            __webpack_require__(40),
	            __webpack_require__(174)
	            // Add required assets to this list
	        ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	            $,
	            _,
	            SplunkVisualizationBase,
	            SplunkVisualizationUtils,
	            d3,
	            ForceGraph3D,
	            ForceGraph
	        ) {

	    var MAX_EDGE_SZ = 18; // 18px

	    var COLOR_SRC_NODE_FIELDNAME = "color_src";
	    var COLOR_DEST_NODE_FIELDNAME = "color_dest";
	    var SZ_SRC_NODE_FIELDNAME = "weight_src";
	    var SZ_DEST_NODE_FIELDNAME = "weight_dest";
	    var COLOR_EDGE_FIELDNAME = "edge_color";
	    var SZ_EDGE_FIELDNAME = "edge_weight";

	    // Extend from SplunkVisualizationBase
	    return SplunkVisualizationBase.extend({

	        initialize: function() {
	            this.logging = false;
	            if(this.logging) console.log('initialize() - Entered');

	            SplunkVisualizationBase.prototype.initialize.apply(this, arguments);
	            this.graph = null;
	            this.graph3d = null;
	            this.initialized = false;
	            this.disableDagMode = false;

	            this.$el = $(this.el);
	            this.uuid = this._getUUID();
	            // this.$el.css('id','viz_base')
	            this.$el.append('<div class="graphviz-container" name="3d' + this.uuid + '"></div>');
	            this.$el.append('<div class="graphviz-container" name="' + this.uuid + '"></div>');
	            var controllerbar = '<div class="graphviz-controllers" name="cntl' + this.uuid + '">' +
	                                    '<a id="btnPlayAnimation" style="margin: 8px;" href="#" class="btn btn-primary">' +
	                                        '<i class="icon-play"></i></a>' +
	                                    '<a id="btnPauseAnimation" style="margin: 8px;" href="#" class="btn btn-primary">' +
	                                        '<i class="icon-pause"></i></a>' +
	                                '</div>';
	            this.$el.append(controllerbar);

	            var that = this;

	            setTimeout(() => {
	              $('div[name=cntl'+that.uuid+'] > a#btnPlayAnimation').on('click', event => {
	                event.preventDefault(); // to avoid re-direction
	                that._toggleAnimation(1);
	              });

	              $('div[name=cntl'+that.uuid+'] > a#btnPauseAnimation').on('click', event => {
	                event.preventDefault(); // to avoid re-direction
	                that._toggleAnimation(0);
	              });
	            }, 100);
	        },

	        // Called at every change to visualization format
	        // config contains only the change to the viz configuration
	        onConfigChange: function(config) {
	            if(this.logging) console.log('onConfigChange() - Entered');

	            var key_tokens = Object.keys(config)[0].split(/[\s.]+/);

	            if (this.disableDagMode && ('dagMode') === key_tokens[key_tokens.length-1]) {
	                var dagMode = this._normalizeNull(this._getEscapedProperty('dagMode', config) || 'null');

	                if (dagMode !== null) {
	                    // Show error
	                    $('splunk-select[name$=dagMode] > a').css("border", "2px solid red");
	                    var errMsg = "DAG mode must be disabled as current data contains cycle nodes",
	                        errMsgHtml = '<div class="error-msg">' +
	                                        '<span>' + errMsg + '</span>' +
	                                     '</div>';

	                    if ($('div.error-msg').length < 1)
	                        $('splunk-select[name$=dagMode]').parents('splunk-control-group').append(errMsgHtml);

	                    return;
	                }

	                // Remove error message and restore style
	                $('splunk-select[name$=dagMode] > a').css("border", "1px solid rgb(195, 203, 212)");
	                $('div.error-msg').remove();
	            }

	            if ('showAnimationBar' === key_tokens[key_tokens.length-1]){
	                var showAnimationBar = SplunkVisualizationUtils.normalizeBoolean(this._getEscapedProperty('showAnimationBar', config));

	                this._toggleAnimationBar(showAnimationBar);

	            } else {
	              // Re-rendering the viz to apply config changes
	              this.invalidateUpdateView();
	            }
	        },

	        // Optionally implement to format data returned from search.
	        // The returned object will be passed to updateView as 'data'
	        formatData: function(data) {
	            if(this.logging) console.log('formatData() - Entered');
	            // Expects:
	            // <search> | stats count by src dst

	            var config = this.getCurrentConfig();
	            var fields = data.fields;
	            var rows = data.rows;
	            var that = this;
	            var nodes = [],
	                links = [],
	                idxLkColor = -1,
	                idxLkWidth = fields.findIndex(obj => obj.name === SZ_EDGE_FIELDNAME),
	                idxNdColor = -1,
	                idxNdSize = -1,
	                idxNdColorDst = -1,
	                idxNdSizeDst = -1;

	            if (rows.length < 1 && fields.length < 1) {
	                return false;
	            }

	            // Extra customisation fields given
	            if (fields.length > 3) {
	                if(this.logging) console.log('formatData() - Got extra customisation fields');

	                idxNdColor = fields.findIndex(obj => obj.name === COLOR_SRC_NODE_FIELDNAME);
	                idxNdSize = fields.findIndex(obj => obj.name === SZ_SRC_NODE_FIELDNAME);
	                idxNdColorDst = fields.findIndex(obj => obj.name === COLOR_DEST_NODE_FIELDNAME);
	                idxNdSizeDst = fields.findIndex(obj => obj.name === SZ_DEST_NODE_FIELDNAME);
	                idxLkColor = fields.findIndex(obj => obj.name === COLOR_EDGE_FIELDNAME);
	            }

	            // Avoid duplicates!
	            let nodeIds = new Set();
	            var defaultColors = {
	                "node": this._getEscapedProperty('ndColor', config) || '#EDCBB1',
	                "link": this._getEscapedProperty('lkColor', config) || '#ffffff'
	            };

	            _.each(rows, function(row) {
	                // Iterating over 0-1 to get row columns
	                _.each([...Array(2).keys()], function(ix) {
	                  var id = row[ix],
	                      name = id;
	                      // name = fields[ix].name + ": " + id;

	                  if (!nodeIds.has(id)){
	                    var newNode = {
	                        "id": id,
	                        "name": name,
	                        "val": 1,
	                        "has_custom_color": 0,
	                        "color": defaultColors['node']
	                    };
	                    // Setting custom weigth and colors
	                    if (ix < 1) {
	                        if (idxNdColor > 0) {
	                          newNode['color'] = row[idxNdColor];
	                          newNode['has_custom_color'] = 1;
	                        }
	                        if (idxNdSize > 0) newNode['val'] = row[idxNdSize];
	                    } else {
	                        if (idxNdColorDst > 0) {
	                          newNode['color'] = row[idxNdColorDst];
	                          newNode['has_custom_color'] = 1;
	                        }
	                        if (idxNdSizeDst > 0) newNode['val'] = row[idxNdSizeDst];
	                    }

	                    // Sanity checks
	                    if (newNode.hasOwnProperty('color')) {
	                        if (newNode['color'] && !newNode['color'].match("^#")) {
	                          throw new SplunkVisualizationBase.VisualizationError(
	                              'Check the Statistics tab. To assign custom colors to nodes, valid hex codes shall be returned.'
	                          );
	                        }
	                    }
	                    if (newNode['val'] && newNode['val'] != parseFloat(newNode['val'])) {
	                        throw new SplunkVisualizationBase.VisualizationError(
	                            'Check the Statistics tab. To assign custom weights to nodes, valid numbers shall be returned.'
	                        );
	                    }

	                    nodes.push(newNode);
	                    nodeIds.add(id);
	                  }
	                });

	                // Check for loops in data > DAG mode limited
	                if (row[0] === row[1]) that.disableDagMode = true;

	                var newLink = {
	                    "source": row[0],
	                    "target": row[1],
	                    "width": idxLkWidth > 0 ? row[idxLkWidth] : 0,
	                    "has_custom_color": 0,
	                    "color": defaultColors['link']
	                };

	                // Setting custom color to link
	                if (idxLkColor > 0 && row[idxLkColor].length > 0) {
	                    // Sanity checks
	                    if (!row[idxLkColor].match("^#")) {
	                        throw new SplunkVisualizationBase.VisualizationError(
	                            'Check the Statistics tab. To assign custom colors to edges, valid hex codes shall be returned.'
	                        );
	                    }
	                    newLink["color"] = row[idxLkColor];
	                    newLink["has_custom_color"] = 1;
	                }

	                links.push(newLink);
	            });

	            return {
	              "fields": fields,
	              "content": {
	                "nodes": nodes,
	                "links": links
	              }
	            };
	        },

	        // Implement updateView to render a visualization.
	        //  'data' will be the data object returned from formatData or from the search
	        //  'config' will be the configuration property object
	        updateView: function(data, config) {
	            if (this.logging) console.log("updateView() - Entering");

	            // check for data
	            if (!data || data.content.nodes.length < 1) {
	                if(this.logging) console.log('updateView() - Error: no data');
	                return;
	            }

	            var $elem = $('div.graphviz-container[name=' + this.uuid + ']'),
	                $elem3d = $('div.graphviz-container[name=3d' + this.uuid + ']');

	            var that = this;
	            var enable3D = SplunkVisualizationUtils.normalizeBoolean(this._getEscapedProperty('enable3D', config));
	            var showAnimationBar = SplunkVisualizationUtils.normalizeBoolean(this._getEscapedProperty('showAnimationBar', config));
	            var params = {
	              "bgColor": this._getEscapedProperty('bgColor', config) || '#000011',
	              "dagMode": this._normalizeNull(this._getEscapedProperty('dagMode', config) || 'null'),
	              "lkColor": this._getEscapedProperty('lkColor', config) || '#ffffff',
	              "ndColor": this._getEscapedProperty('ndColor', config) || '#EDCBB1',
	              "cameraController": this._getEscapedProperty('cameraController', config) || 'trackball'
	            };
	            this.useDrilldown = this._isEnabledDrilldown(config);

	            // Show/Hide Animation Bar
	            this._toggleAnimationBar(showAnimationBar);
	            
	            if (!this.initialized) {
	                if (this.logging) console.log("updateView() - Initializing graphs");
	                // Load graphs
	                this._load3DGraph($elem3d.get(0), params);
	                this._load2DGraph($elem.get(0), params);
	                // Render graphs
	                this.graph3d($elem3d.get(0)).graphData(data.content);
	                this.graph($elem.get(0)).graphData(data.content);

	                this.initialized = true;
	            } else {
	                if (this.logging) console.log("updateView() - Refreshing graphs");
	                var graph = (enable3D) ? this.graph3d : this.graph;
	                graph.linkColor(link => link.color = link.has_custom_color < 1 ? params['lkColor'] : link.color)
	                    .nodeColor(node => node.color =
	                        node.has_custom_color < 1 ? params['ndColor'] : node.color)
	                    .backgroundColor(params["bgColor"])
	                    .dagMode(params["dagMode"]);
	            }

	            // Display only one graph
	            if (enable3D) {
	              $elem.addClass("hide");
	              $elem3d.removeClass("hide");
	            } else {
	              $elem3d.addClass("hide");
	              $elem.removeClass("hide");
	            }
	        },

	        // Search data params
	        getInitialDataParams: function() {
	            return ({
	                outputMode: SplunkVisualizationBase.ROW_MAJOR_OUTPUT_MODE,
	                count: 0
	            });
	        },

	        _load2DGraph: function(elem, params){
	          var that = this;

	          this.graph = ForceGraph()(elem)
	              .backgroundColor(params['bgColor'])
	              .linkWidth(link => link.width > MAX_EDGE_SZ ? MAX_EDGE_SZ : link.width)
	              .dagMode(params['dagMode'])
	              .onNodeHover(node => {
	                // Change cursor when hovering on nodes (if drilldown enabled)
	                elem.style.cursor = node && that.useDrilldown ? 'pointer' : null;
	              })
	              .onNodeClick(that._drilldown.bind(that));
	        },

	        _load3DGraph: function(elem, params){
	            const distance = 1000;
	            var that = this;

	            this.graph3d = ForceGraph3D({ controlType: params['cameraController'] })(elem)
	              .cameraPosition({ z: distance })
	              .onNodeHover(node => {
	                // Change cursor when hovering on nodes (if drilldown enabled)
	                elem.style.cursor = node && that.useDrilldown ? 'pointer' : null;
	              })
	              .onNodeClick(that._drilldown.bind(that))
	              .backgroundColor(params['bgColor'])
	              .linkWidth(link => link.width > MAX_EDGE_SZ ? MAX_EDGE_SZ : link.width)
	              .dagMode(params['dagMode']);
	        },

	        _getUUID: function () {
	          return '_' + Math.random().toString(36).substr(2, 9);
	        },

	        _isEnabledDrilldown: function(config) {
	          return (config['display.visualizations.custom.drilldown']
	                  && config['display.visualizations.custom.drilldown'] === 'all');
	        },

	        _drilldown: function(d, i) {
	            if(this.logging) console.log("drilldown() - Entered");

	            var fields = this.getCurrentData().fields;
	            var drilldownDescription = {
	                action: SplunkVisualizationBase.FIELD_VALUE_DRILLDOWN,
	                data: {}
	            };

	            drilldownDescription.data[fields[0].name] = d.id;

	            this.drilldown(drilldownDescription, d3.event);
	        },

	        _getEscapedProperty: function(name, config) {
	            var propertyValue = config[this.getPropertyNamespaceInfo().propertyNamespace + name];
	            if (propertyValue !== undefined ) propertyValue = propertyValue.replace(/"/g, '');
	            return SplunkVisualizationUtils.escapeHtml(propertyValue);
	        },

	        _toggleAnimation: function(value) {
	            if(this.logging) console.log('_toggleAnimation() - Resuming Animation ? ' + value);

	            var resumeAnimation = SplunkVisualizationUtils.normalizeBoolean(value);

	            var config = this.getCurrentConfig();
	            var enable3D = SplunkVisualizationUtils.normalizeBoolean(this._getEscapedProperty('enable3D', config));
	            var graph = (enable3D) ? this.graph3d : this.graph;

	            if (enable3D) {
	                resumeAnimation ? graph.resumeAnimation() : graph.pauseAnimation();
	                return;
	            }

	            // Handle Animation for 2D Graph
	            if (!resumeAnimation) {
	                graph.pauseAnimation();
	                graph.enableZoomPanInteraction(false);

	                // Work-around a library misbehaviour
	                var max = 2,
	                    cnt = 0,
	                    id = setInterval(() => {
	                      while(cnt < max) {
	                        graph.resumeAnimation();
	                        graph.pauseAnimation();
	                        cnt = cnt + 1;
	                      }
	                      clearInterval(id);
	                    }, 50);
	                return;
	            }

	            // Work-around a library misbehaviour
	            graph.pauseAnimation();
	            graph.resumeAnimation();
	            graph.enableZoomPanInteraction(true);
	        },

	        _toggleAnimationBar: function(value) {
	            if (this.logging) console.log("_toggleAnimationBar() - Entered {"+value+"}");

	            var $elem = $('div.graphviz-controllers[name=cntl'+this.uuid+']');
	            
	            if (value && !$elem.hasClass("show")) {
	                $elem.toggleClass("show");
	            } else if (!value && $elem.hasClass("show")) {
	                $elem.toggleClass("show");
	            }
	        },

	        _hexToRgb: function(hex) {
	            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

	            return "rgb(" + parseInt(result[1], 16)
	                    + "," + parseInt(result[2], 16)
	                    + "," + parseInt(result[3], 16) + ")";
	        },

	        _normalizeNull: function(value) {
	            return value === "null" ? null : value;
	        }

	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}

			return key === undefined || hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define('underscore', factory) :
	  (function() {
	  	var current = global._;
	  	var exports = factory();
	  	global._ = exports;
	  	exports.noConflict = function() { global._ = current; return exports; };
	  })();
	}(this, (function () {

	  //     Underscore.js 1.10.2
	  //     https://underscorejs.org
	  //     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	  //     Underscore may be freely distributed under the MIT license.

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = typeof self == 'object' && self.self === self && self ||
	            typeof global == 'object' && global.global === global && global ||
	            Function('return this')() ||
	            {};

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;

	  // Create references to these builtin functions because we override them.
	  var _isNaN = root.isNaN,
	      _isFinite = root.isFinite;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // The Underscore object. All exported functions below are added to it in the
	  // modules/index-all.js using the mixin function.
	  function _(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  }

	  // Current version.
	  var VERSION = _.VERSION = '1.10.2';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  function optimizeCb(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      // The 2-argument case is omitted because we’re not using it.
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  }

	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result — either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  function baseIteratee(value, context, argCount) {
	    if (value == null) return identity;
	    if (isFunction(value)) return optimizeCb(value, context, argCount);
	    if (isObject(value) && !isArray(value)) return matcher(value);
	    return property(value);
	  }

	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = iteratee;
	  function iteratee(value, context) {
	    return baseIteratee(value, context, Infinity);
	  }

	  // The function we actually call internally. It invokes _.iteratee if
	  // overridden, otherwise baseIteratee.
	  function cb(value, context, argCount) {
	    if (_.iteratee !== iteratee) return _.iteratee(value, context);
	    return baseIteratee(value, context, argCount);
	  }

	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the function’s
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6’s "rest parameter".
	  function restArguments(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function() {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0: return func.call(this, rest);
	        case 1: return func.call(this, arguments[0], rest);
	        case 2: return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  }

	  // An internal function for creating a new object that inherits from another.
	  function baseCreate(prototype) {
	    if (!isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  }

	  function shallowProperty(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  }

	  function _has(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  }

	  function deepGet(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  }

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  function isArrayLike(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  }

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  function each(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var _keys = keys(obj);
	      for (i = 0, length = _keys.length; i < length; i++) {
	        iteratee(obj[_keys[i]], _keys[i], obj);
	      }
	    }
	    return obj;
	  }

	  // Return the results of applying the iteratee to each element.
	  function map(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  }

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function(obj, iteratee, memo, initial) {
	      var _keys = !isArrayLike(obj) && keys(obj),
	          length = (_keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[_keys ? _keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = _keys ? _keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };

	    return function(obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  var reduce = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  var reduceRight = createReduce(-1);

	  // Return the first value which passes a truth test.
	  function find(obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  }

	  // Return all the elements that pass a truth test.
	  function filter(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  }

	  // Return all the elements for which a truth test fails.
	  function reject(obj, predicate, context) {
	    return filter(obj, negate(cb(predicate)), context);
	  }

	  // Determine whether all of the elements match a truth test.
	  function every(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  }

	  // Determine if at least one element in the object matches a truth test.
	  function some(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  }

	  // Determine if the array or object contains a given item (using `===`).
	  function contains(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return indexOf(obj, item, fromIndex) >= 0;
	  }

	  // Invoke a method (with arguments) on every item in a collection.
	  var invoke = restArguments(function(obj, path, args) {
	    var contextPath, func;
	    if (isFunction(path)) {
	      func = path;
	    } else if (isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return map(obj, function(context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });

	  // Convenience version of a common use case of `map`: fetching a property.
	  function pluck(obj, key) {
	    return map(obj, property(key));
	  }

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  function where(obj, attrs) {
	    return filter(obj, matcher(attrs));
	  }

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  function findWhere(obj, attrs) {
	    return find(obj, matcher(attrs));
	  }

	  // Return the maximum element (or element-based computation).
	  function max(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  }

	  // Return the minimum element (or element-based computation).
	  function min(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  }

	  // Shuffle a collection.
	  function shuffle(obj) {
	    return sample(obj, Infinity);
	  }

	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  function sample(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = values(obj);
	      return obj[random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? clone(obj) : values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  }

	  // Sort the object's values by a criterion produced by an iteratee.
	  function sortBy(obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return pluck(map(obj, function(value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  }

	  // An internal function used for aggregate "group by" operations.
	  function group(behavior, partition) {
	    return function(obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  }

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  var groupBy = group(function(result, value, key) {
	    if (_has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  var indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  var countBy = group(function(result, value, key) {
	    if (_has(result, key)) result[key]++; else result[key] = 1;
	  });

	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  function toArray(obj) {
	    if (!obj) return [];
	    if (isArray(obj)) return slice.call(obj);
	    if (isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return map(obj, identity);
	    return values(obj);
	  }

	  // Return the number of elements in an object.
	  function size(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : keys(obj).length;
	  }

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  var partition = group(function(result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. The **guard** check allows it to work with `map`.
	  function first(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return initial(array, array.length - n);
	  }

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  function initial(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  }

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  function last(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return rest(array, Math.max(0, array.length - n));
	  }

	  // Returns everything but the first entry of the array. Especially useful on
	  // the arguments object. Passing an **n** will return the rest N values in the
	  // array.
	  function rest(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  }

	  // Trim out all falsy values from an array.
	  function compact(array) {
	    return filter(array, Boolean);
	  }

	  // Internal implementation of a recursive `flatten` function.
	  function _flatten(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (isArray(value) || isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0, len = value.length;
	          while (j < len) output[idx++] = value[j++];
	        } else {
	          _flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  }

	  // Flatten out an array, either recursively (by default), or just one level.
	  function flatten(array, shallow) {
	    return _flatten(array, shallow, false);
	  }

	  // Return a version of the array that does not contain the specified value(s).
	  var without = restArguments(function(array, otherArrays) {
	    return difference(array, otherArrays);
	  });

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  function uniq(array, isSorted, iteratee, context) {
	    if (!isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  var union = restArguments(function(arrays) {
	    return uniq(_flatten(arrays, true, true));
	  });

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  function intersection(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  }

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  var difference = restArguments(function(array, rest) {
	    rest = _flatten(rest, true, true);
	    return filter(array, function(value){
	      return !contains(rest, value);
	    });
	  });

	  // Complement of zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  function unzip(array) {
	    var length = array && max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = pluck(array, index);
	    }
	    return result;
	  }

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  var zip = restArguments(unzip);

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of pairs.
	  function object(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  }

	  // Generator function to create the findIndex and findLastIndex functions.
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test.
	  var findIndex = createPredicateIndexFinder(1);
	  var findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  function sortedIndex(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  }

	  // Generator function to create the indexOf and lastIndexOf functions.
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  var indexOf = createIndexFinder(1, findIndex, sortedIndex);
	  var lastIndexOf = createIndexFinder(-1, findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](https://docs.python.org/library/functions.html#range).
	  function range(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  }

	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  function chunk(array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0, length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  }

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (isObject(result)) return result;
	    return self;
	  }

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  var bind = restArguments(function(func, context, args) {
	    if (!isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function(callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `partial.placeholder` for a custom placeholder argument.
	  var partial = restArguments(function(func, boundArgs) {
	    var placeholder = partial.placeholder;
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });

	  partial.placeholder = _;

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  var bindAll = restArguments(function(obj, _keys) {
	    _keys = _flatten(_keys, false, false);
	    var index = _keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = _keys[index];
	      obj[key] = bind(obj[key], obj);
	    }
	  });

	  // Memoize an expensive function by storing its results.
	  function memoize(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  }

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  var delay = restArguments(function(func, wait, args) {
	    return setTimeout(function() {
	      return func.apply(null, args);
	    }, wait);
	  });

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  var defer = partial(delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  function throttle(func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};

	    var later = function() {
	      previous = options.leading === false ? 0 : now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };

	    var throttled = function() {
	      var _now = now();
	      if (!previous && options.leading === false) previous = _now;
	      var remaining = wait - (_now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = _now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };

	    throttled.cancel = function() {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };

	    return throttled;
	  }

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  function debounce(func, wait, immediate) {
	    var timeout, result;

	    var later = function(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };

	    var debounced = restArguments(function(args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = delay(later, wait, this, args);
	      }

	      return result;
	    });

	    debounced.cancel = function() {
	      clearTimeout(timeout);
	      timeout = null;
	    };

	    return debounced;
	  }

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  function wrap(func, wrapper) {
	    return partial(wrapper, func);
	  }

	  // Returns a negated version of the passed-in predicate.
	  function negate(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  }

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  function compose() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  }

	  // Returns a function that will only be executed on and after the Nth call.
	  function after(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  }

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  function before(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  }

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  var once = partial(before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, _keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = isFunction(constructor) && constructor.prototype || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_has(obj, prop) && !contains(_keys, prop)) _keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !contains(_keys, prop)) {
	        _keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  function keys(obj) {
	    if (!isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var _keys = [];
	    for (var key in obj) if (_has(obj, key)) _keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, _keys);
	    return _keys;
	  }

	  // Retrieve all the property names of an object.
	  function allKeys(obj) {
	    if (!isObject(obj)) return [];
	    var _keys = [];
	    for (var key in obj) _keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, _keys);
	    return _keys;
	  }

	  // Retrieve the values of an object's properties.
	  function values(obj) {
	    var _keys = keys(obj);
	    var length = _keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[_keys[i]];
	    }
	    return values;
	  }

	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to map it returns an object.
	  function mapObject(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var _keys = keys(obj),
	        length = _keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  }

	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of object.
	  function pairs(obj) {
	    var _keys = keys(obj);
	    var length = _keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [_keys[i], obj[_keys[i]]];
	    }
	    return pairs;
	  }

	  // Invert the keys and values of an object. The values must be serializable.
	  function invert(obj) {
	    var result = {};
	    var _keys = keys(obj);
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      result[obj[_keys[i]]] = _keys[i];
	    }
	    return result;
	  }

	  // Return a sorted list of the function names available on the object.
	  function functions(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  }

	  // An internal function for creating assigner functions.
	  function createAssigner(keysFunc, defaults) {
	    return function(obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            _keys = keysFunc(source),
	            l = _keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = _keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  }

	  // Extend a given object with all the properties in passed-in object(s).
	  var extend = createAssigner(allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  var extendOwn = createAssigner(keys);

	  // Returns the first key on an object that passes a predicate test.
	  function findKey(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = keys(obj), key;
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      key = _keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  }

	  // Internal pick helper function to determine if `obj` has key `key`.
	  function keyInObj(value, key, obj) {
	    return key in obj;
	  }

	  // Return a copy of the object only containing the whitelisted properties.
	  var pick = restArguments(function(obj, _keys) {
	    var result = {}, iteratee = _keys[0];
	    if (obj == null) return result;
	    if (isFunction(iteratee)) {
	      if (_keys.length > 1) iteratee = optimizeCb(iteratee, _keys[1]);
	      _keys = allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      _keys = _flatten(_keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      var key = _keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });

	  // Return a copy of the object without the blacklisted properties.
	  var omit = restArguments(function(obj, _keys) {
	    var iteratee = _keys[0], context;
	    if (isFunction(iteratee)) {
	      iteratee = negate(iteratee);
	      if (_keys.length > 1) context = _keys[1];
	    } else {
	      _keys = map(_flatten(_keys, false, false), String);
	      iteratee = function(value, key) {
	        return !contains(_keys, key);
	      };
	    }
	    return pick(obj, iteratee, context);
	  });

	  // Fill in a given object with default properties.
	  var defaults = createAssigner(allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  function create(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) extendOwn(result, props);
	    return result;
	  }

	  // Create a (shallow-cloned) duplicate of an object.
	  function clone(obj) {
	    if (!isObject(obj)) return obj;
	    return isArray(obj) ? obj.slice() : extend({}, obj);
	  }

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  function tap(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  }

	  // Returns whether an object has a given set of `key:value` pairs.
	  function isMatch(object, attrs) {
	    var _keys = keys(attrs), length = _keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = _keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  }


	  // Internal recursive comparison function for `isEqual`.
	  function eq(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a;
	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  }

	  // Internal recursive comparison function for `isEqual`.
	  function deepEq(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
	                               isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var _keys = keys(a), key;
	      length = _keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = _keys[length];
	        if (!(_has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  }

	  // Perform a deep comparison to check if two objects are equal.
	  function isEqual(a, b) {
	    return eq(a, b);
	  }

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  function isEmpty(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (isArray(obj) || isString(obj) || isArguments(obj))) return obj.length === 0;
	    return keys(obj).length === 0;
	  }

	  // Is a given value a DOM element?
	  function isElement(obj) {
	    return !!(obj && obj.nodeType === 1);
	  }

	  // Internal function for creating a toString-based type tester.
	  function tagTester(name) {
	    return function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  }

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  var isArray = nativeIsArray || tagTester('Array');

	  // Is a given variable an object?
	  function isObject(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  }

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  var isArguments = tagTester('Arguments');
	  var isFunction = tagTester('Function');
	  var isString = tagTester('String');
	  var isNumber = tagTester('Number');
	  var isDate = tagTester('Date');
	  var isRegExp = tagTester('RegExp');
	  var isError = tagTester('Error');
	  var isSymbol = tagTester('Symbol');
	  var isMap = tagTester('Map');
	  var isWeakMap = tagTester('WeakMap');
	  var isSet = tagTester('Set');
	  var isWeakSet = tagTester('WeakSet');

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  (function() {
	    if (!isArguments(arguments)) {
	      isArguments = function(obj) {
	        return _has(obj, 'callee');
	      };
	    }
	  }());

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
	    isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  function isFinite(obj) {
	    return !isSymbol(obj) && _isFinite(obj) && !_isNaN(parseFloat(obj));
	  }

	  // Is the given value `NaN`?
	  function isNaN(obj) {
	    return isNumber(obj) && _isNaN(obj);
	  }

	  // Is a given value a boolean?
	  function isBoolean(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  }

	  // Is a given value equal to null?
	  function isNull(obj) {
	    return obj === null;
	  }

	  // Is a given variable undefined?
	  function isUndefined(obj) {
	    return obj === void 0;
	  }

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  function has(obj, path) {
	    if (!isArray(path)) {
	      return _has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  }

	  // Utility Functions
	  // -----------------

	  // Keep the identity function around for default iteratees.
	  function identity(value) {
	    return value;
	  }

	  // Predicate-generating functions. Often useful outside of Underscore.
	  function constant(value) {
	    return function() {
	      return value;
	    };
	  }

	  function noop(){}

	  // Creates a function that, when passed an object, will traverse that object’s
	  // properties down the given `path`, specified as an array of keys or indexes.
	  function property(path) {
	    if (!isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function(obj) {
	      return deepGet(obj, path);
	    };
	  }

	  // Generates a function for a given object that returns a given property.
	  function propertyOf(obj) {
	    if (obj == null) {
	      return function(){};
	    }
	    return function(path) {
	      return !isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  }

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  function matcher(attrs) {
	    attrs = extendOwn({}, attrs);
	    return function(obj) {
	      return isMatch(obj, attrs);
	    };
	  }

	  // Run a function **n** times.
	  function times(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  }

	  // Return a random integer between min and max (inclusive).
	  function random(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  }

	  // A (possibly faster) way to get the current timestamp as an integer.
	  var now = Date.now || function() {
	    return new Date().getTime();
	  };

	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  function createEscaper(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  }
	  var escape = createEscaper(escapeMap);
	  var unescape = createEscaper(unescapeMap);

	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  function result(obj, path, fallback) {
	    if (!isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  }

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  function uniqueId(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  }

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  var templateSettings = _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  function template(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  }

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  function chain(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  }

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  function chainResult(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  }

	  // Add your own custom functions to the Underscore object.
	  function mixin(obj) {
	    each(functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  }

	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return String(this._wrapped);
	  };

	  var allExports = ({
	    'default': _,
	    VERSION: VERSION,
	    iteratee: iteratee,
	    restArguments: restArguments,
	    each: each,
	    forEach: each,
	    map: map,
	    collect: map,
	    reduce: reduce,
	    foldl: reduce,
	    inject: reduce,
	    reduceRight: reduceRight,
	    foldr: reduceRight,
	    find: find,
	    detect: find,
	    filter: filter,
	    select: filter,
	    reject: reject,
	    every: every,
	    all: every,
	    some: some,
	    any: some,
	    contains: contains,
	    includes: contains,
	    include: contains,
	    invoke: invoke,
	    pluck: pluck,
	    where: where,
	    findWhere: findWhere,
	    max: max,
	    min: min,
	    shuffle: shuffle,
	    sample: sample,
	    sortBy: sortBy,
	    groupBy: groupBy,
	    indexBy: indexBy,
	    countBy: countBy,
	    toArray: toArray,
	    size: size,
	    partition: partition,
	    first: first,
	    head: first,
	    take: first,
	    initial: initial,
	    last: last,
	    rest: rest,
	    tail: rest,
	    drop: rest,
	    compact: compact,
	    flatten: flatten,
	    without: without,
	    uniq: uniq,
	    unique: uniq,
	    union: union,
	    intersection: intersection,
	    difference: difference,
	    unzip: unzip,
	    zip: zip,
	    object: object,
	    findIndex: findIndex,
	    findLastIndex: findLastIndex,
	    sortedIndex: sortedIndex,
	    indexOf: indexOf,
	    lastIndexOf: lastIndexOf,
	    range: range,
	    chunk: chunk,
	    bind: bind,
	    partial: partial,
	    bindAll: bindAll,
	    memoize: memoize,
	    delay: delay,
	    defer: defer,
	    throttle: throttle,
	    debounce: debounce,
	    wrap: wrap,
	    negate: negate,
	    compose: compose,
	    after: after,
	    before: before,
	    once: once,
	    keys: keys,
	    allKeys: allKeys,
	    values: values,
	    mapObject: mapObject,
	    pairs: pairs,
	    invert: invert,
	    functions: functions,
	    methods: functions,
	    extend: extend,
	    extendOwn: extendOwn,
	    assign: extendOwn,
	    findKey: findKey,
	    pick: pick,
	    omit: omit,
	    defaults: defaults,
	    create: create,
	    clone: clone,
	    tap: tap,
	    isMatch: isMatch,
	    isEqual: isEqual,
	    isEmpty: isEmpty,
	    isElement: isElement,
	    isArray: isArray,
	    isObject: isObject,
	    isArguments: isArguments,
	    isFunction: isFunction,
	    isString: isString,
	    isNumber: isNumber,
	    isDate: isDate,
	    isRegExp: isRegExp,
	    isError: isError,
	    isSymbol: isSymbol,
	    isMap: isMap,
	    isWeakMap: isWeakMap,
	    isSet: isSet,
	    isWeakSet: isWeakSet,
	    isFinite: isFinite,
	    isNaN: isNaN,
	    isBoolean: isBoolean,
	    isNull: isNull,
	    isUndefined: isUndefined,
	    has: has,
	    identity: identity,
	    constant: constant,
	    noop: noop,
	    property: property,
	    propertyOf: propertyOf,
	    matcher: matcher,
	    matches: matcher,
	    times: times,
	    random: random,
	    now: now,
	    escape: escape,
	    unescape: unescape,
	    result: result,
	    uniqueId: uniqueId,
	    templateSettings: templateSettings,
	    template: template,
	    chain: chain,
	    mixin: mixin
	  });

	  // Add all of the Underscore functions to the wrapper object.
	  var _$1 = mixin(allExports);
	  // Legacy Node.js API
	  _$1._ = _$1;

	  return _$1;

	})));
	//# sourceMappingURL=underscore.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', { value: true });

	var d3Array = __webpack_require__(6);
	var d3Axis = __webpack_require__(7);
	var d3Brush = __webpack_require__(8);
	var d3Chord = __webpack_require__(17);
	var d3Collection = __webpack_require__(20);
	var d3Color = __webpack_require__(13);
	var d3Contour = __webpack_require__(21);
	var d3Dispatch = __webpack_require__(9);
	var d3Drag = __webpack_require__(10);
	var d3Dsv = __webpack_require__(23);
	var d3Ease = __webpack_require__(16);
	var d3Fetch = __webpack_require__(24);
	var d3Force = __webpack_require__(25);
	var d3Format = __webpack_require__(27);
	var d3Geo = __webpack_require__(28);
	var d3Hierarchy = __webpack_require__(30);
	var d3Interpolate = __webpack_require__(12);
	var d3Path = __webpack_require__(19);
	var d3Polygon = __webpack_require__(31);
	var d3Quadtree = __webpack_require__(26);
	var d3Random = __webpack_require__(32);
	var d3Scale = __webpack_require__(33);
	var d3ScaleChromatic = __webpack_require__(36);
	var d3Selection = __webpack_require__(11);
	var d3Shape = __webpack_require__(37);
	var d3Time = __webpack_require__(34);
	var d3TimeFormat = __webpack_require__(35);
	var d3Timer = __webpack_require__(15);
	var d3Transition = __webpack_require__(14);
	var d3Voronoi = __webpack_require__(38);
	var d3Zoom = __webpack_require__(39);

	var version = "5.15.1";

	Object.keys(d3Array).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Array[k];
			}
		});
	});
	Object.keys(d3Axis).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Axis[k];
			}
		});
	});
	Object.keys(d3Brush).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Brush[k];
			}
		});
	});
	Object.keys(d3Chord).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Chord[k];
			}
		});
	});
	Object.keys(d3Collection).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Collection[k];
			}
		});
	});
	Object.keys(d3Color).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Color[k];
			}
		});
	});
	Object.keys(d3Contour).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Contour[k];
			}
		});
	});
	Object.keys(d3Dispatch).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Dispatch[k];
			}
		});
	});
	Object.keys(d3Drag).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Drag[k];
			}
		});
	});
	Object.keys(d3Dsv).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Dsv[k];
			}
		});
	});
	Object.keys(d3Ease).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Ease[k];
			}
		});
	});
	Object.keys(d3Fetch).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Fetch[k];
			}
		});
	});
	Object.keys(d3Force).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Force[k];
			}
		});
	});
	Object.keys(d3Format).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Format[k];
			}
		});
	});
	Object.keys(d3Geo).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Geo[k];
			}
		});
	});
	Object.keys(d3Hierarchy).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Hierarchy[k];
			}
		});
	});
	Object.keys(d3Interpolate).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Interpolate[k];
			}
		});
	});
	Object.keys(d3Path).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Path[k];
			}
		});
	});
	Object.keys(d3Polygon).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Polygon[k];
			}
		});
	});
	Object.keys(d3Quadtree).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Quadtree[k];
			}
		});
	});
	Object.keys(d3Random).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Random[k];
			}
		});
	});
	Object.keys(d3Scale).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Scale[k];
			}
		});
	});
	Object.keys(d3ScaleChromatic).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3ScaleChromatic[k];
			}
		});
	});
	Object.keys(d3Selection).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Selection[k];
			}
		});
	});
	Object.keys(d3Shape).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Shape[k];
			}
		});
	});
	Object.keys(d3Time).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Time[k];
			}
		});
	});
	Object.keys(d3TimeFormat).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3TimeFormat[k];
			}
		});
	});
	Object.keys(d3Timer).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Timer[k];
			}
		});
	});
	Object.keys(d3Transition).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Transition[k];
			}
		});
	});
	Object.keys(d3Voronoi).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Voronoi[k];
			}
		});
	});
	Object.keys(d3Zoom).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Zoom[k];
			}
		});
	});
	exports.version = version;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function pairs(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function cross(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function deviation(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	}

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function identity(x) {
	  return x;
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	}

	function histogram() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	}

	function max(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function mean(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	}

	function median(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	}

	function merge(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function permute(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	}

	function scan(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	}

	function shuffle(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var slice = Array.prototype.slice;

	function identity(x) {
	  return x;
	}

	var top = 1,
	    right = 2,
	    bottom = 3,
	    left = 4,
	    epsilon = 1e-6;

	function translateX(x) {
	  return "translate(" + (x + 0.5) + ",0)";
	}

	function translateY(y) {
	  return "translate(0," + (y + 0.5) + ")";
	}

	function number(scale) {
	  return function(d) {
	    return +scale(d);
	  };
	}

	function center(scale) {
	  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
	  if (scale.round()) offset = Math.round(offset);
	  return function(d) {
	    return +scale(d) + offset;
	  };
	}

	function entering() {
	  return !this.__axis;
	}

	function axis(orient, scale) {
	  var tickArguments = [],
	      tickValues = null,
	      tickFormat = null,
	      tickSizeInner = 6,
	      tickSizeOuter = 6,
	      tickPadding = 3,
	      k = orient === top || orient === left ? -1 : 1,
	      x = orient === left || orient === right ? "x" : "y",
	      transform = orient === top || orient === bottom ? translateX : translateY;

	  function axis(context) {
	    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
	        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
	        spacing = Math.max(tickSizeInner, 0) + tickPadding,
	        range = scale.range(),
	        range0 = +range[0] + 0.5,
	        range1 = +range[range.length - 1] + 0.5,
	        position = (scale.bandwidth ? center : number)(scale.copy()),
	        selection = context.selection ? context.selection() : context,
	        path = selection.selectAll(".domain").data([null]),
	        tick = selection.selectAll(".tick").data(values, scale).order(),
	        tickExit = tick.exit(),
	        tickEnter = tick.enter().append("g").attr("class", "tick"),
	        line = tick.select("line"),
	        text = tick.select("text");

	    path = path.merge(path.enter().insert("path", ".tick")
	        .attr("class", "domain")
	        .attr("stroke", "currentColor"));

	    tick = tick.merge(tickEnter);

	    line = line.merge(tickEnter.append("line")
	        .attr("stroke", "currentColor")
	        .attr(x + "2", k * tickSizeInner));

	    text = text.merge(tickEnter.append("text")
	        .attr("fill", "currentColor")
	        .attr(x, k * spacing)
	        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

	    if (context !== selection) {
	      path = path.transition(context);
	      tick = tick.transition(context);
	      line = line.transition(context);
	      text = text.transition(context);

	      tickExit = tickExit.transition(context)
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	      tickEnter
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	    }

	    tickExit.remove();

	    path
	        .attr("d", orient === left || orient == right
	            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
	            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

	    tick
	        .attr("opacity", 1)
	        .attr("transform", function(d) { return transform(position(d)); });

	    line
	        .attr(x + "2", k * tickSizeInner);

	    text
	        .attr(x, k * spacing)
	        .text(format);

	    selection.filter(entering)
	        .attr("fill", "none")
	        .attr("font-size", 10)
	        .attr("font-family", "sans-serif")
	        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

	    selection
	        .each(function() { this.__axis = position; });
	  }

	  axis.scale = function(_) {
	    return arguments.length ? (scale = _, axis) : scale;
	  };

	  axis.ticks = function() {
	    return tickArguments = slice.call(arguments), axis;
	  };

	  axis.tickArguments = function(_) {
	    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
	  };

	  axis.tickValues = function(_) {
	    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
	  };

	  axis.tickFormat = function(_) {
	    return arguments.length ? (tickFormat = _, axis) : tickFormat;
	  };

	  axis.tickSize = function(_) {
	    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeInner = function(_) {
	    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeOuter = function(_) {
	    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
	  };

	  axis.tickPadding = function(_) {
	    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
	  };

	  return axis;
	}

	function axisTop(scale) {
	  return axis(top, scale);
	}

	function axisRight(scale) {
	  return axis(right, scale);
	}

	function axisBottom(scale) {
	  return axis(bottom, scale);
	}

	function axisLeft(scale) {
	  return axis(left, scale);
	}

	exports.axisTop = axisTop;
	exports.axisRight = axisRight;
	exports.axisBottom = axisBottom;
	exports.axisLeft = axisLeft;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-brush/ v1.1.5 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(10), __webpack_require__(12), __webpack_require__(11), __webpack_require__(14)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function BrushEvent(target, type, selection) {
	  this.target = target;
	  this.type = type;
	  this.selection = selection;
	}

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	var MODE_DRAG = {name: "drag"},
	    MODE_SPACE = {name: "space"},
	    MODE_HANDLE = {name: "handle"},
	    MODE_CENTER = {name: "center"};

	function number1(e) {
	  return [+e[0], +e[1]];
	}

	function number2(e) {
	  return [number1(e[0]), number1(e[1])];
	}

	function toucher(identifier) {
	  return function(target) {
	    return d3Selection.touch(target, d3Selection.event.touches, identifier);
	  };
	}

	var X = {
	  name: "x",
	  handles: ["w", "e"].map(type),
	  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
	  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
	};

	var Y = {
	  name: "y",
	  handles: ["n", "s"].map(type),
	  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
	  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
	};

	var XY = {
	  name: "xy",
	  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
	  input: function(xy) { return xy == null ? null : number2(xy); },
	  output: function(xy) { return xy; }
	};

	var cursors = {
	  overlay: "crosshair",
	  selection: "move",
	  n: "ns-resize",
	  e: "ew-resize",
	  s: "ns-resize",
	  w: "ew-resize",
	  nw: "nwse-resize",
	  ne: "nesw-resize",
	  se: "nwse-resize",
	  sw: "nesw-resize"
	};

	var flipX = {
	  e: "w",
	  w: "e",
	  nw: "ne",
	  ne: "nw",
	  se: "sw",
	  sw: "se"
	};

	var flipY = {
	  n: "s",
	  s: "n",
	  nw: "sw",
	  ne: "se",
	  se: "ne",
	  sw: "nw"
	};

	var signsX = {
	  overlay: +1,
	  selection: +1,
	  n: null,
	  e: +1,
	  s: null,
	  w: -1,
	  nw: -1,
	  ne: +1,
	  se: +1,
	  sw: -1
	};

	var signsY = {
	  overlay: +1,
	  selection: +1,
	  n: -1,
	  e: null,
	  s: +1,
	  w: null,
	  nw: -1,
	  ne: -1,
	  se: +1,
	  sw: +1
	};

	function type(t) {
	  return {type: t};
	}

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultExtent() {
	  var svg = this.ownerSVGElement || this;
	  if (svg.hasAttribute("viewBox")) {
	    svg = svg.viewBox.baseVal;
	    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
	  }
	  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	// Like d3.local, but with the name “__brush” rather than auto-generated.
	function local(node) {
	  while (!node.__brush) if (!(node = node.parentNode)) return;
	  return node.__brush;
	}

	function empty(extent) {
	  return extent[0][0] === extent[1][0]
	      || extent[0][1] === extent[1][1];
	}

	function brushSelection(node) {
	  var state = node.__brush;
	  return state ? state.dim.output(state.selection) : null;
	}

	function brushX() {
	  return brush$1(X);
	}

	function brushY() {
	  return brush$1(Y);
	}

	function brush() {
	  return brush$1(XY);
	}

	function brush$1(dim) {
	  var extent = defaultExtent,
	      filter = defaultFilter,
	      touchable = defaultTouchable,
	      keys = true,
	      listeners = d3Dispatch.dispatch("start", "brush", "end"),
	      handleSize = 6,
	      touchending;

	  function brush(group) {
	    var overlay = group
	        .property("__brush", initialize)
	      .selectAll(".overlay")
	      .data([type("overlay")]);

	    overlay.enter().append("rect")
	        .attr("class", "overlay")
	        .attr("pointer-events", "all")
	        .attr("cursor", cursors.overlay)
	      .merge(overlay)
	        .each(function() {
	          var extent = local(this).extent;
	          d3Selection.select(this)
	              .attr("x", extent[0][0])
	              .attr("y", extent[0][1])
	              .attr("width", extent[1][0] - extent[0][0])
	              .attr("height", extent[1][1] - extent[0][1]);
	        });

	    group.selectAll(".selection")
	      .data([type("selection")])
	      .enter().append("rect")
	        .attr("class", "selection")
	        .attr("cursor", cursors.selection)
	        .attr("fill", "#777")
	        .attr("fill-opacity", 0.3)
	        .attr("stroke", "#fff")
	        .attr("shape-rendering", "crispEdges");

	    var handle = group.selectAll(".handle")
	      .data(dim.handles, function(d) { return d.type; });

	    handle.exit().remove();

	    handle.enter().append("rect")
	        .attr("class", function(d) { return "handle handle--" + d.type; })
	        .attr("cursor", function(d) { return cursors[d.type]; });

	    group
	        .each(redraw)
	        .attr("fill", "none")
	        .attr("pointer-events", "all")
	        .on("mousedown.brush", started)
	      .filter(touchable)
	        .on("touchstart.brush", started)
	        .on("touchmove.brush", touchmoved)
	        .on("touchend.brush touchcancel.brush", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  brush.move = function(group, selection) {
	    if (group.selection) {
	      group
	          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
	          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
	          .tween("brush", function() {
	            var that = this,
	                state = that.__brush,
	                emit = emitter(that, arguments),
	                selection0 = state.selection,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
	                i = d3Interpolate.interpolate(selection0, selection1);

	            function tween(t) {
	              state.selection = t === 1 && selection1 === null ? null : i(t);
	              redraw.call(that);
	              emit.brush();
	            }

	            return selection0 !== null && selection1 !== null ? tween : tween(1);
	          });
	    } else {
	      group
	          .each(function() {
	            var that = this,
	                args = arguments,
	                state = that.__brush,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
	                emit = emitter(that, args).beforestart();

	            d3Transition.interrupt(that);
	            state.selection = selection1 === null ? null : selection1;
	            redraw.call(that);
	            emit.start().brush().end();
	          });
	    }
	  };

	  brush.clear = function(group) {
	    brush.move(group, null);
	  };

	  function redraw() {
	    var group = d3Selection.select(this),
	        selection = local(this).selection;

	    if (selection) {
	      group.selectAll(".selection")
	          .style("display", null)
	          .attr("x", selection[0][0])
	          .attr("y", selection[0][1])
	          .attr("width", selection[1][0] - selection[0][0])
	          .attr("height", selection[1][1] - selection[0][1]);

	      group.selectAll(".handle")
	          .style("display", null)
	          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
	          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
	          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
	          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
	    }

	    else {
	      group.selectAll(".selection,.handle")
	          .style("display", "none")
	          .attr("x", null)
	          .attr("y", null)
	          .attr("width", null)
	          .attr("height", null);
	    }
	  }

	  function emitter(that, args, clean) {
	    return (!clean && that.__brush.emitter) || new Emitter(that, args);
	  }

	  function Emitter(that, args) {
	    this.that = that;
	    this.args = args;
	    this.state = that.__brush;
	    this.active = 0;
	  }

	  Emitter.prototype = {
	    beforestart: function() {
	      if (++this.active === 1) this.state.emitter = this, this.starting = true;
	      return this;
	    },
	    start: function() {
	      if (this.starting) this.starting = false, this.emit("start");
	      else this.emit("brush");
	      return this;
	    },
	    brush: function() {
	      this.emit("brush");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) delete this.state.emitter, this.emit("end");
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function started() {
	    if (touchending && !d3Selection.event.touches) return;
	    if (!filter.apply(this, arguments)) return;

	    var that = this,
	        type = d3Selection.event.target.__data__.type,
	        mode = (keys && d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
	        signX = dim === Y ? null : signsX[type],
	        signY = dim === X ? null : signsY[type],
	        state = local(that),
	        extent = state.extent,
	        selection = state.selection,
	        W = extent[0][0], w0, w1,
	        N = extent[0][1], n0, n1,
	        E = extent[1][0], e0, e1,
	        S = extent[1][1], s0, s1,
	        dx = 0,
	        dy = 0,
	        moving,
	        shifting = signX && signY && keys && d3Selection.event.shiftKey,
	        lockX,
	        lockY,
	        pointer = d3Selection.event.touches ? toucher(d3Selection.event.changedTouches[0].identifier) : d3Selection.mouse,
	        point0 = pointer(that),
	        point = point0,
	        emit = emitter(that, arguments, true).beforestart();

	    if (type === "overlay") {
	      if (selection) moving = true;
	      state.selection = selection = [
	        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
	        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
	      ];
	    } else {
	      w0 = selection[0][0];
	      n0 = selection[0][1];
	      e0 = selection[1][0];
	      s0 = selection[1][1];
	    }

	    w1 = w0;
	    n1 = n0;
	    e1 = e0;
	    s1 = s0;

	    var group = d3Selection.select(that)
	        .attr("pointer-events", "none");

	    var overlay = group.selectAll(".overlay")
	        .attr("cursor", cursors[type]);

	    if (d3Selection.event.touches) {
	      emit.moved = moved;
	      emit.ended = ended;
	    } else {
	      var view = d3Selection.select(d3Selection.event.view)
	          .on("mousemove.brush", moved, true)
	          .on("mouseup.brush", ended, true);
	      if (keys) view
	          .on("keydown.brush", keydowned, true)
	          .on("keyup.brush", keyupped, true);

	      d3Drag.dragDisable(d3Selection.event.view);
	    }

	    nopropagation();
	    d3Transition.interrupt(that);
	    redraw.call(that);
	    emit.start();

	    function moved() {
	      var point1 = pointer(that);
	      if (shifting && !lockX && !lockY) {
	        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
	        else lockX = true;
	      }
	      point = point1;
	      moving = true;
	      noevent();
	      move();
	    }

	    function move() {
	      var t;

	      dx = point[0] - point0[0];
	      dy = point[1] - point0[1];

	      switch (mode) {
	        case MODE_SPACE:
	        case MODE_DRAG: {
	          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
	          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
	          break;
	        }
	        case MODE_HANDLE: {
	          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
	          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
	          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
	          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
	          break;
	        }
	        case MODE_CENTER: {
	          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
	          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
	          break;
	        }
	      }

	      if (e1 < w1) {
	        signX *= -1;
	        t = w0, w0 = e0, e0 = t;
	        t = w1, w1 = e1, e1 = t;
	        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
	      }

	      if (s1 < n1) {
	        signY *= -1;
	        t = n0, n0 = s0, s0 = t;
	        t = n1, n1 = s1, s1 = t;
	        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
	      }

	      if (state.selection) selection = state.selection; // May be set by brush.move!
	      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
	      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

	      if (selection[0][0] !== w1
	          || selection[0][1] !== n1
	          || selection[1][0] !== e1
	          || selection[1][1] !== s1) {
	        state.selection = [[w1, n1], [e1, s1]];
	        redraw.call(that);
	        emit.brush();
	      }
	    }

	    function ended() {
	      nopropagation();
	      if (d3Selection.event.touches) {
	        if (d3Selection.event.touches.length) return;
	        if (touchending) clearTimeout(touchending);
	        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	      } else {
	        d3Drag.dragEnable(d3Selection.event.view, moving);
	        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
	      }
	      group.attr("pointer-events", "all");
	      overlay.attr("cursor", cursors.overlay);
	      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
	      if (empty(selection)) state.selection = null, redraw.call(that);
	      emit.end();
	    }

	    function keydowned() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          shifting = signX && signY;
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_HANDLE) {
	            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	            mode = MODE_CENTER;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE; takes priority over ALT
	          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
	            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
	            mode = MODE_SPACE;
	            overlay.attr("cursor", cursors.selection);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }

	    function keyupped() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          if (shifting) {
	            lockX = lockY = shifting = false;
	            move();
	          }
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	            mode = MODE_HANDLE;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE
	          if (mode === MODE_SPACE) {
	            if (d3Selection.event.altKey) {
	              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	              mode = MODE_CENTER;
	            } else {
	              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	              mode = MODE_HANDLE;
	            }
	            overlay.attr("cursor", cursors[type]);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }
	  }

	  function touchmoved() {
	    emitter(this, arguments).moved();
	  }

	  function touchended() {
	    emitter(this, arguments).ended();
	  }

	  function initialize() {
	    var state = this.__brush || {selection: null};
	    state.extent = number2(extent.apply(this, arguments));
	    state.dim = dim;
	    return state;
	  }

	  brush.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
	  };

	  brush.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
	  };

	  brush.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush) : touchable;
	  };

	  brush.handleSize = function(_) {
	    return arguments.length ? (handleSize = +_, brush) : handleSize;
	  };

	  brush.keyModifiers = function(_) {
	    return arguments.length ? (keys = !!_, brush) : keys;
	  };

	  brush.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? brush : value;
	  };

	  return brush;
	}

	exports.brush = brush;
	exports.brushSelection = brushSelection;
	exports.brushX = brushX;
	exports.brushY = brushY;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dispatch/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var noop = {value: function() {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	exports.dispatch = dispatch;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-drag/ v1.2.5 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(11)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Selection) { 'use strict';

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	function nodrag(view) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", noevent, true);
	  } else {
	    root.__noselect = root.style.MozUserSelect;
	    root.style.MozUserSelect = "none";
	  }
	}

	function yesdrag(view, noclick) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", null);
	  if (noclick) {
	    selection.on("click.drag", noevent, true);
	    setTimeout(function() { selection.on("click.drag", null); }, 0);
	  }
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", null);
	  } else {
	    root.style.MozUserSelect = root.__noselect;
	    delete root.__noselect;
	  }
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
	  this.target = target;
	  this.type = type;
	  this.subject = subject;
	  this.identifier = id;
	  this.active = active;
	  this.x = x;
	  this.y = y;
	  this.dx = dx;
	  this.dy = dy;
	  this._ = dispatch;
	}

	DragEvent.prototype.on = function() {
	  var value = this._.on.apply(this._, arguments);
	  return value === this._ ? this : value;
	};

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultContainer() {
	  return this.parentNode;
	}

	function defaultSubject(d) {
	  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	function drag() {
	  var filter = defaultFilter,
	      container = defaultContainer,
	      subject = defaultSubject,
	      touchable = defaultTouchable,
	      gestures = {},
	      listeners = d3Dispatch.dispatch("start", "drag", "end"),
	      active = 0,
	      mousedownx,
	      mousedowny,
	      mousemoving,
	      touchending,
	      clickDistance2 = 0;

	  function drag(selection) {
	    selection
	        .on("mousedown.drag", mousedowned)
	      .filter(touchable)
	        .on("touchstart.drag", touchstarted)
	        .on("touchmove.drag", touchmoved)
	        .on("touchend.drag touchcancel.drag", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
	    if (!gesture) return;
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
	    nodrag(d3Selection.event.view);
	    nopropagation();
	    mousemoving = false;
	    mousedownx = d3Selection.event.clientX;
	    mousedowny = d3Selection.event.clientY;
	    gesture("start");
	  }

	  function mousemoved() {
	    noevent();
	    if (!mousemoving) {
	      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
	      mousemoving = dx * dx + dy * dy > clickDistance2;
	    }
	    gestures.mouse("drag");
	  }

	  function mouseupped() {
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
	    yesdrag(d3Selection.event.view, mousemoving);
	    noevent();
	    gestures.mouse("end");
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches = d3Selection.event.changedTouches,
	        c = container.apply(this, arguments),
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
	        nopropagation();
	        gesture("start");
	      }
	    }
	  }

	  function touchmoved() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        noevent();
	        gesture("drag");
	      }
	    }
	  }

	  function touchended() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        nopropagation();
	        gesture("end");
	      }
	    }
	  }

	  function beforestart(id, container, point, that, args) {
	    var p = point(container, id), s, dx, dy,
	        sublisteners = listeners.copy();

	    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
	      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
	      dx = s.x - p[0] || 0;
	      dy = s.y - p[1] || 0;
	      return true;
	    })) return;

	    return function gesture(type) {
	      var p0 = p, n;
	      switch (type) {
	        case "start": gestures[id] = gesture, n = active++; break;
	        case "end": delete gestures[id], --active; // nobreak
	        case "drag": p = point(container, id), n = active; break;
	      }
	      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
	    };
	  }

	  drag.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
	  };

	  drag.container = function(_) {
	    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
	  };

	  drag.subject = function(_) {
	    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
	  };

	  drag.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
	  };

	  drag.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? drag : value;
	  };

	  drag.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
	  };

	  return drag;
	}

	exports.drag = drag;
	exports.dragDisable = nodrag;
	exports.dragEnable = yesdrag;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-selection/ v1.4.1 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none() {}

	function selector(selector) {
	  return selector == null ? none : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function empty() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, parents);
	}

	function matcher(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	}

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	var keyPrefix = "$"; // Protect against keys like “__proto__”.

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that don’t fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = {},
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	      if (keyValue in nodeByKeyValue) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue[keyValue] = node;
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = keyPrefix + key.call(parent, data[i], i, data);
	    if (node = nodeByKeyValue[keyValue]) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue[keyValue] = null;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function selection_data(value, key) {
	  if (!value) {
	    data = new Array(this.size()), j = -1;
	    this.each(function(d) { data[++j] = d; });
	    return data;
	  }

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = value.call(parent, parent && parent.__data__, j, parents),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_join(onenter, onupdate, onexit) {
	  var enter = this.enter(), update = this, exit = this.exit();
	  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
	  if (onupdate != null) update = onupdate(update);
	  if (onexit == null) exit.remove(); else onexit(exit);
	  return enter && update ? enter.merge(update).order() : update;
	}

	function selection_merge(selection) {

	  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection(sortgroups, this._parents).order();
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  var nodes = new Array(this.size()), i = -1;
	  this.each(function() { nodes[++i] = this; });
	  return nodes;
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  var size = 0;
	  this.each(function() { ++size; });
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)
	      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove : typeof value === "function"
	            ? styleFunction
	            : styleConstant)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction
	          : textConstant)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  var clone = this.cloneNode(false), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_cloneDeep() {
	  var clone = this.cloneNode(true), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	var filterEvents = {};

	exports.event = null;

	if (typeof document !== "undefined") {
	  var element = document.documentElement;
	  if (!("onmouseenter" in element)) {
	    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	  }
	}

	function filterContextListener(listener, index, group) {
	  listener = contextListener(listener, index, group);
	  return function(event) {
	    var related = event.relatedTarget;
	    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	      listener.call(this, event);
	    }
	  };
	}

	function contextListener(listener, index, group) {
	  return function(event1) {
	    var event0 = exports.event; // Events can be reentrant (e.g., focus).
	    exports.event = event1;
	    try {
	      listener.call(this, this.__data__, index, group);
	    } finally {
	      exports.event = event0;
	    }
	  };
	}

	function parseTypenames(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, capture) {
	  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	  return function(d, i, group) {
	    var on = this.__on, o, listener = wrap(value, i, group);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, capture);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, capture) {
	  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  if (capture == null) capture = false;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	  return this;
	}

	function customEvent(event1, listener, that, args) {
	  var event0 = exports.event;
	  event1.sourceEvent = exports.event;
	  exports.event = event1;
	  try {
	    return listener.apply(that, args);
	  } finally {
	    exports.event = event0;
	  }
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	var root = [null];

	function Selection(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection([[document.documentElement]], root);
	}

	Selection.prototype = selection.prototype = {
	  constructor: Selection,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  join: selection_join,
	  merge: selection_merge,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection([[selector]], root);
	}

	function create(name) {
	  return select(creator(name).call(document.documentElement));
	}

	var nextId = 0;

	function local() {
	  return new Local;
	}

	function Local() {
	  this._ = "@" + (++nextId).toString(36);
	}

	Local.prototype = local.prototype = {
	  constructor: Local,
	  get: function(node) {
	    var id = this._;
	    while (!(id in node)) if (!(node = node.parentNode)) return;
	    return node[id];
	  },
	  set: function(node, value) {
	    return node[this._] = value;
	  },
	  remove: function(node) {
	    return this._ in node && delete node[this._];
	  },
	  toString: function() {
	    return this._;
	  }
	};

	function sourceEvent() {
	  var current = exports.event, source;
	  while (source = current.sourceEvent) current = source;
	  return current;
	}

	function point(node, event) {
	  var svg = node.ownerSVGElement || node;

	  if (svg.createSVGPoint) {
	    var point = svg.createSVGPoint();
	    point.x = event.clientX, point.y = event.clientY;
	    point = point.matrixTransform(node.getScreenCTM().inverse());
	    return [point.x, point.y];
	  }

	  var rect = node.getBoundingClientRect();
	  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	}

	function mouse(node) {
	  var event = sourceEvent();
	  if (event.changedTouches) event = event.changedTouches[0];
	  return point(node, event);
	}

	function selectAll(selector) {
	  return typeof selector === "string"
	      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
	      : new Selection([selector == null ? [] : selector], root);
	}

	function touch(node, touches, identifier) {
	  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

	  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	    if ((touch = touches[i]).identifier === identifier) {
	      return point(node, touch);
	    }
	  }

	  return null;
	}

	function touches(node, touches) {
	  if (touches == null) touches = sourceEvent().touches;

	  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
	    points[i] = point(node, touches[i]);
	  }

	  return points;
	}

	exports.clientPoint = point;
	exports.create = create;
	exports.creator = creator;
	exports.customEvent = customEvent;
	exports.local = local;
	exports.matcher = matcher;
	exports.mouse = mouse;
	exports.namespace = namespace;
	exports.namespaces = namespaces;
	exports.select = select;
	exports.selectAll = selectAll;
	exports.selection = selection;
	exports.selector = selector;
	exports.selectorAll = selectorAll;
	exports.style = styleValue;
	exports.touch = touch;
	exports.touches = touches;
	exports.window = defaultView;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-interpolate/ v1.4.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(13)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Color) { 'use strict';

	function basis(t1, v0, v1, v2, v3) {
	  var t2 = t1 * t1, t3 = t2 * t1;
	  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	      + (4 - 6 * t2 + 3 * t3) * v1
	      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	      + t3 * v3) / 6;
	}

	function basis$1(values) {
	  var n = values.length - 1;
	  return function(t) {
	    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
	        v1 = values[i],
	        v2 = values[i + 1],
	        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
	        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	}

	function basisClosed(values) {
	  var n = values.length;
	  return function(t) {
	    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
	        v0 = values[(i + n - 1) % n],
	        v1 = values[i % n],
	        v2 = values[(i + 1) % n],
	        v3 = values[(i + 2) % n];
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function linear(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function hue(a, b) {
	  var d = b - a;
	  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
	}

	var rgb = (function rgbGamma(y) {
	  var color = gamma(y);

	  function rgb(start, end) {
	    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
	        g = color(start.g, end.g),
	        b = color(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb.gamma = rgbGamma;

	  return rgb;
	})(1);

	function rgbSpline(spline) {
	  return function(colors) {
	    var n = colors.length,
	        r = new Array(n),
	        g = new Array(n),
	        b = new Array(n),
	        i, color;
	    for (i = 0; i < n; ++i) {
	      color = d3Color.rgb(colors[i]);
	      r[i] = color.r || 0;
	      g[i] = color.g || 0;
	      b[i] = color.b || 0;
	    }
	    r = spline(r);
	    g = spline(g);
	    b = spline(b);
	    color.opacity = 1;
	    return function(t) {
	      color.r = r(t);
	      color.g = g(t);
	      color.b = b(t);
	      return color + "";
	    };
	  };
	}

	var rgbBasis = rgbSpline(basis$1);
	var rgbBasisClosed = rgbSpline(basisClosed);

	function numberArray(a, b) {
	  if (!b) b = [];
	  var n = a ? Math.min(b.length, a.length) : 0,
	      c = b.slice(),
	      i;
	  return function(t) {
	    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
	    return c;
	  };
	}

	function isNumberArray(x) {
	  return ArrayBuffer.isView(x) && !(x instanceof DataView);
	}

	function array(a, b) {
	  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
	}

	function genericArray(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	}

	function date(a, b) {
	  var d = new Date;
	  return a = +a, b = +b, function(t) {
	    return d.setTime(a * (1 - t) + b * t), d;
	  };
	}

	function number(a, b) {
	  return a = +a, b = +b, function(t) {
	    return a * (1 - t) + b * t;
	  };
	}

	function object(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = value(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	}

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	    reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	function string(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: number(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	}

	function value(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant(b)
	      : (t === "number" ? number
	      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
	      : b instanceof d3Color.color ? rgb
	      : b instanceof Date ? date
	      : isNumberArray(b) ? numberArray
	      : Array.isArray(b) ? genericArray
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : number)(a, b);
	}

	function discrete(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	function hue$1(a, b) {
	  var i = hue(+a, +b);
	  return function(t) {
	    var x = i(t);
	    return x - 360 * Math.floor(x / 360);
	  };
	}

	function round(a, b) {
	  return a = +a, b = +b, function(t) {
	    return Math.round(a * (1 - t) + b * t);
	  };
	}

	var degrees = 180 / Math.PI;

	var identity = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	function decompose(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	}

	var cssNode,
	    cssRoot,
	    cssView,
	    svgNode;

	function parseCss(value) {
	  if (value === "none") return identity;
	  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	  cssNode.style.transform = value;
	  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	  cssRoot.removeChild(cssNode);
	  value = value.slice(7, -1).split(",");
	  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	}

	function parseSvg(value) {
	  if (value == null) return identity;
	  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode.setAttribute("transform", value);
	  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	var rho = Math.SQRT2,
	    rho2 = 2,
	    rho4 = 4,
	    epsilon2 = 1e-12;

	function cosh(x) {
	  return ((x = Math.exp(x)) + 1 / x) / 2;
	}

	function sinh(x) {
	  return ((x = Math.exp(x)) - 1 / x) / 2;
	}

	function tanh(x) {
	  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	}

	// p0 = [ux0, uy0, w0]
	// p1 = [ux1, uy1, w1]
	function zoom(p0, p1) {
	  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
	      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
	      dx = ux1 - ux0,
	      dy = uy1 - uy0,
	      d2 = dx * dx + dy * dy,
	      i,
	      S;

	  // Special case for u0 ≅ u1.
	  if (d2 < epsilon2) {
	    S = Math.log(w1 / w0) / rho;
	    i = function(t) {
	      return [
	        ux0 + t * dx,
	        uy0 + t * dy,
	        w0 * Math.exp(rho * t * S)
	      ];
	    };
	  }

	  // General case.
	  else {
	    var d1 = Math.sqrt(d2),
	        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
	        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
	        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
	        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	    S = (r1 - r0) / rho;
	    i = function(t) {
	      var s = t * S,
	          coshr0 = cosh(r0),
	          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
	      return [
	        ux0 + u * dx,
	        uy0 + u * dy,
	        w0 * coshr0 / cosh(rho * s + r0)
	      ];
	    };
	  }

	  i.duration = S * 1000;

	  return i;
	}

	function hsl(hue) {
	  return function(start, end) {
	    var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
	        s = nogamma(start.s, end.s),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.s = s(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hsl$1 = hsl(hue);
	var hslLong = hsl(nogamma);

	function lab(start, end) {
	  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
	      a = nogamma(start.a, end.a),
	      b = nogamma(start.b, end.b),
	      opacity = nogamma(start.opacity, end.opacity);
	  return function(t) {
	    start.l = l(t);
	    start.a = a(t);
	    start.b = b(t);
	    start.opacity = opacity(t);
	    return start + "";
	  };
	}

	function hcl(hue) {
	  return function(start, end) {
	    var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
	        c = nogamma(start.c, end.c),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.c = c(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hcl$1 = hcl(hue);
	var hclLong = hcl(nogamma);

	function cubehelix(hue) {
	  return (function cubehelixGamma(y) {
	    y = +y;

	    function cubehelix(start, end) {
	      var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
	          s = nogamma(start.s, end.s),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.s = s(t);
	        start.l = l(Math.pow(t, y));
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }

	    cubehelix.gamma = cubehelixGamma;

	    return cubehelix;
	  })(1);
	}

	var cubehelix$1 = cubehelix(hue);
	var cubehelixLong = cubehelix(nogamma);

	function piecewise(interpolate, values) {
	  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
	  while (i < n) I[i] = interpolate(v, v = values[++i]);
	  return function(t) {
	    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
	    return I[i](t - i);
	  };
	}

	function quantize(interpolator, n) {
	  var samples = new Array(n);
	  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
	  return samples;
	}

	exports.interpolate = value;
	exports.interpolateArray = array;
	exports.interpolateBasis = basis$1;
	exports.interpolateBasisClosed = basisClosed;
	exports.interpolateCubehelix = cubehelix$1;
	exports.interpolateCubehelixLong = cubehelixLong;
	exports.interpolateDate = date;
	exports.interpolateDiscrete = discrete;
	exports.interpolateHcl = hcl$1;
	exports.interpolateHclLong = hclLong;
	exports.interpolateHsl = hsl$1;
	exports.interpolateHslLong = hslLong;
	exports.interpolateHue = hue$1;
	exports.interpolateLab = lab;
	exports.interpolateNumber = number;
	exports.interpolateNumberArray = numberArray;
	exports.interpolateObject = object;
	exports.interpolateRgb = rgb;
	exports.interpolateRgbBasis = rgbBasis;
	exports.interpolateRgbBasisClosed = rgbBasisClosed;
	exports.interpolateRound = round;
	exports.interpolateString = string;
	exports.interpolateTransformCss = interpolateTransformCss;
	exports.interpolateTransformSvg = interpolateTransformSvg;
	exports.interpolateZoom = zoom;
	exports.piecewise = piecewise;
	exports.quantize = quantize;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-color/ v1.4.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex = /^#([0-9a-f]{3,8})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  copy: function(channels) {
	    return Object.assign(new this.constructor, this, channels);
	  },
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: color_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: color_formatHex,
	  formatHsl: color_formatHsl,
	  formatRgb: color_formatRgb,
	  toString: color_formatRgb
	});

	function color_formatHex() {
	  return this.rgb().formatHex();
	}

	function color_formatHsl() {
	  return hslConvert(this).formatHsl();
	}

	function color_formatRgb() {
	  return this.rgb().formatRgb();
	}

	function color(format) {
	  var m, l;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
	      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
	      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
	      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
	      : null) // invalid hex
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (-0.5 <= this.r && this.r < 255.5)
	        && (-0.5 <= this.g && this.g < 255.5)
	        && (-0.5 <= this.b && this.b < 255.5)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: rgb_formatHex,
	  formatRgb: rgb_formatRgb,
	  toString: rgb_formatRgb
	}));

	function rgb_formatHex() {
	  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	}

	function rgb_formatRgb() {
	  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	  return (a === 1 ? "rgb(" : "rgba(")
	      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	      + (a === 1 ? ")" : ", " + a + ")");
	}

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  formatHsl: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "hsl(" : "hsla(")
	        + (this.h || 0) + ", "
	        + (this.s || 0) * 100 + "%, "
	        + (this.l || 0) * 100 + "%"
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	var deg2rad = Math.PI / 180;
	var rad2deg = 180 / Math.PI;

	// https://observablehq.com/@mbostock/lab-and-rgb
	var K = 18,
	    Xn = 0.96422,
	    Yn = 1,
	    Zn = 0.82521,
	    t0 = 4 / 29,
	    t1 = 6 / 29,
	    t2 = 3 * t1 * t1,
	    t3 = t1 * t1 * t1;

	function labConvert(o) {
	  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
	  if (o instanceof Hcl) return hcl2lab(o);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = rgb2lrgb(o.r),
	      g = rgb2lrgb(o.g),
	      b = rgb2lrgb(o.b),
	      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
	  if (r === g && g === b) x = z = y; else {
	    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
	    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
	  }
	  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
	}

	function gray(l, opacity) {
	  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
	}

	function lab(l, a, b, opacity) {
	  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
	}

	function Lab(l, a, b, opacity) {
	  this.l = +l;
	  this.a = +a;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Lab, lab, extend(Color, {
	  brighter: function(k) {
	    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  darker: function(k) {
	    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  rgb: function() {
	    var y = (this.l + 16) / 116,
	        x = isNaN(this.a) ? y : y + this.a / 500,
	        z = isNaN(this.b) ? y : y - this.b / 200;
	    x = Xn * lab2xyz(x);
	    y = Yn * lab2xyz(y);
	    z = Zn * lab2xyz(z);
	    return new Rgb(
	      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
	      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
	      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
	      this.opacity
	    );
	  }
	}));

	function xyz2lab(t) {
	  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	}

	function lab2xyz(t) {
	  return t > t1 ? t * t * t : t2 * (t - t0);
	}

	function lrgb2rgb(x) {
	  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	}

	function rgb2lrgb(x) {
	  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	}

	function hclConvert(o) {
	  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
	  if (!(o instanceof Lab)) o = labConvert(o);
	  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
	  var h = Math.atan2(o.b, o.a) * rad2deg;
	  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
	}

	function lch(l, c, h, opacity) {
	  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function hcl(h, c, l, opacity) {
	  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function Hcl(h, c, l, opacity) {
	  this.h = +h;
	  this.c = +c;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	function hcl2lab(o) {
	  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
	  var h = o.h * deg2rad;
	  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
	}

	define(Hcl, hcl, extend(Color, {
	  brighter: function(k) {
	    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
	  },
	  darker: function(k) {
	    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
	  },
	  rgb: function() {
	    return hcl2lab(this).rgb();
	  }
	}));

	var A = -0.14861,
	    B = +1.78277,
	    C = -0.29227,
	    D = -0.90649,
	    E = +1.97294,
	    ED = E * D,
	    EB = E * B,
	    BC_DA = B * C - D * A;

	function cubehelixConvert(o) {
	  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	      bl = b - l,
	      k = (E * (g - l) - C * bl) / D,
	      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
	      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
	  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
	}

	function cubehelix(h, s, l, opacity) {
	  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
	}

	function Cubehelix(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Cubehelix, cubehelix, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
	        l = +this.l,
	        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
	        cosh = Math.cos(h),
	        sinh = Math.sin(h);
	    return new Rgb(
	      255 * (l + a * (A * cosh + B * sinh)),
	      255 * (l + a * (C * cosh + D * sinh)),
	      255 * (l + a * (E * cosh)),
	      this.opacity
	    );
	  }
	}));

	exports.color = color;
	exports.cubehelix = cubehelix;
	exports.gray = gray;
	exports.hcl = hcl;
	exports.hsl = hsl;
	exports.lab = lab;
	exports.lch = lch;
	exports.rgb = rgb;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-transition/ v1.3.2 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(11), __webpack_require__(9), __webpack_require__(15), __webpack_require__(12), __webpack_require__(13), __webpack_require__(16)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) { 'use strict';

	var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	function schedule(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	}

	function init(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > STARTED) throw new Error("too late; already running");
	  return schedule;
	}

	function get(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = d3Timer.timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return d3Timer.timeout(start);

	      // Interrupt the active transition, if any.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions.
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("cancel", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    d3Timer.timeout(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(node, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	function interrupt(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule.state > STARTING && schedule.state < ENDING;
	    schedule.state = ENDED;
	    schedule.timer.stop();
	    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	}

	function selection_interrupt(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	}

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule.tween = tween1;
	  };
	}

	function transition_tween(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	}

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule = set(this, id);
	    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get(node, id).value[name];
	  };
	}

	function interpolate(a, b) {
	  var c;
	  return (typeof b === "number" ? d3Interpolate.interpolateNumber
	      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
	      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
	      : d3Interpolate.interpolateString)(a, b);
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttribute(name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrConstantNS(fullname, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttributeNS(fullname.space, fullname.local);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttribute(name);
	    string0 = this.getAttribute(name);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function attrFunctionNS(fullname, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    string0 = this.getAttributeNS(fullname.space, fullname.local);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function transition_attr(name, value) {
	  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
	      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
	}

	function attrInterpolate(name, i) {
	  return function(t) {
	    this.setAttribute(name, i.call(this, t));
	  };
	}

	function attrInterpolateNS(fullname, i) {
	  return function(t) {
	    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
	  };
	}

	function attrTweenNS(fullname, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_attrTween(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = d3Selection.namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	}

	function delayFunction(id, value) {
	  return function() {
	    init(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init(this, id).delay = value;
	  };
	}

	function transition_delay(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get(this.node(), id).delay;
	}

	function durationFunction(id, value) {
	  return function() {
	    set(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set(this, id).duration = value;
	  };
	}

	function transition_duration(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get(this.node(), id).duration;
	}

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set(this, id).ease = value;
	  };
	}

	function transition_ease(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get(this.node(), id).ease;
	}

	function transition_filter(match) {
	  if (typeof match !== "function") match = d3Selection.matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	}

	function transition_merge(transition) {
	  if (transition._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	}

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init : set;
	  return function() {
	    var schedule = sit(this, id),
	        on = schedule.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule.on = on1;
	  };
	}

	function transition_on(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	}

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	function transition_remove() {
	  return this.on("end.remove", removeFunction(this._id));
	}

	function transition_select(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	}

	function transition_selectAll(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	}

	var Selection = d3Selection.selection.prototype.constructor;

	function transition_selection() {
	  return new Selection(this._groups, this._parents);
	}

	function styleNull(name, interpolate) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name),
	        string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, string10 = string1);
	  };
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function styleFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name),
	        value1 = value(this),
	        string1 = value1 + "";
	    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function styleMaybeRemove(id, name) {
	  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
	  return function() {
	    var schedule = set(this, id),
	        on = schedule.on,
	        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

	    schedule.on = on1;
	  };
	}

	function transition_style(name, value, priority) {
	  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
	  return value == null ? this
	      .styleTween(name, styleNull(name, i))
	      .on("end.style." + name, styleRemove(name))
	    : typeof value === "function" ? this
	      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
	      .each(styleMaybeRemove(this._id, name))
	    : this
	      .styleTween(name, styleConstant(name, i, value), priority)
	      .on("end.style." + name, null);
	}

	function styleInterpolate(name, i, priority) {
	  return function(t) {
	    this.style.setProperty(name, i.call(this, t), priority);
	  };
	}

	function styleTween(name, value, priority) {
	  var t, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
	    return t;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_styleTween(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	function transition_text(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction(tweenValue(this, "text", value))
	      : textConstant(value == null ? "" : value + ""));
	}

	function textInterpolate(i) {
	  return function(t) {
	    this.textContent = i.call(this, t);
	  };
	}

	function textTween(value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_textTween(value) {
	  var key = "text";
	  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, textTween(value));
	}

	function transition_transition() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	}

	function transition_end() {
	  var on0, on1, that = this, id = that._id, size = that.size();
	  return new Promise(function(resolve, reject) {
	    var cancel = {value: reject},
	        end = {value: function() { if (--size === 0) resolve(); }};

	    that.each(function() {
	      var schedule = set(this, id),
	          on = schedule.on;

	      // If this node shared a dispatch with the previous node,
	      // just assign the updated shared dispatch and we’re done!
	      // Otherwise, copy-on-write.
	      if (on !== on0) {
	        on1 = (on0 = on).copy();
	        on1._.cancel.push(cancel);
	        on1._.interrupt.push(cancel);
	        on1._.end.push(end);
	      }

	      schedule.on = on1;
	    });
	  });
	}

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function transition(name) {
	  return d3Selection.selection().transition(name);
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = d3Selection.selection.prototype;

	Transition.prototype = transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  textTween: transition_textTween,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease,
	  end: transition_end
	};

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: d3Ease.easeCubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      return defaultTiming.time = d3Timer.now(), defaultTiming;
	    }
	  }
	  return timing;
	}

	function selection_transition(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	}

	d3Selection.selection.prototype.interrupt = selection_interrupt;
	d3Selection.selection.prototype.transition = selection_transition;

	var root = [null];

	function active(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      i;

	  if (schedules) {
	    name = name == null ? null : name + "";
	    for (i in schedules) {
	      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
	        return new Transition([[node]], root, name, +i);
	      }
	    }
	  }

	  return null;
	}

	exports.active = active;
	exports.interrupt = interrupt;
	exports.transition = transition;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-timer/ v1.0.10 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var frame = 0, // is an animation frame pending?
	    timeout = 0, // is a timeout pending?
	    interval = 0, // are any timers active?
	    pokeDelay = 1000, // how frequently we check for clock skew
	    taskHead,
	    taskTail,
	    clockLast = 0,
	    clockNow = 0,
	    clockSkew = 0,
	    clock = typeof performance === "object" && performance.now ? performance : Date,
	    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now(); // Get the current time, if not already set.
	  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout) timeout = clearTimeout(timeout);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	function timeout$1(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(function(elapsed) {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	}

	function interval$1(callback, delay, time) {
	  var t = new Timer, total = delay;
	  if (delay == null) return t.restart(callback, delay, time), t;
	  delay = +delay, time = time == null ? now() : +time;
	  t.restart(function tick(elapsed) {
	    elapsed += total;
	    t.restart(tick, total += delay, time);
	    callback(elapsed);
	  }, delay, time);
	  return t;
	}

	exports.interval = interval$1;
	exports.now = now;
	exports.timeout = timeout$1;
	exports.timer = timer;
	exports.timerFlush = timerFlush;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-ease/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function linear(t) {
	  return +t;
	}

	function quadIn(t) {
	  return t * t;
	}

	function quadOut(t) {
	  return t * (2 - t);
	}

	function quadInOut(t) {
	  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
	}

	function cubicIn(t) {
	  return t * t * t;
	}

	function cubicOut(t) {
	  return --t * t * t + 1;
	}

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var exponent = 3;

	var polyIn = (function custom(e) {
	  e = +e;

	  function polyIn(t) {
	    return Math.pow(t, e);
	  }

	  polyIn.exponent = custom;

	  return polyIn;
	})(exponent);

	var polyOut = (function custom(e) {
	  e = +e;

	  function polyOut(t) {
	    return 1 - Math.pow(1 - t, e);
	  }

	  polyOut.exponent = custom;

	  return polyOut;
	})(exponent);

	var polyInOut = (function custom(e) {
	  e = +e;

	  function polyInOut(t) {
	    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
	  }

	  polyInOut.exponent = custom;

	  return polyInOut;
	})(exponent);

	var pi = Math.PI,
	    halfPi = pi / 2;

	function sinIn(t) {
	  return 1 - Math.cos(t * halfPi);
	}

	function sinOut(t) {
	  return Math.sin(t * halfPi);
	}

	function sinInOut(t) {
	  return (1 - Math.cos(pi * t)) / 2;
	}

	function expIn(t) {
	  return Math.pow(2, 10 * t - 10);
	}

	function expOut(t) {
	  return 1 - Math.pow(2, -10 * t);
	}

	function expInOut(t) {
	  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
	}

	function circleIn(t) {
	  return 1 - Math.sqrt(1 - t * t);
	}

	function circleOut(t) {
	  return Math.sqrt(1 - --t * t);
	}

	function circleInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
	}

	var b1 = 4 / 11,
	    b2 = 6 / 11,
	    b3 = 8 / 11,
	    b4 = 3 / 4,
	    b5 = 9 / 11,
	    b6 = 10 / 11,
	    b7 = 15 / 16,
	    b8 = 21 / 22,
	    b9 = 63 / 64,
	    b0 = 1 / b1 / b1;

	function bounceIn(t) {
	  return 1 - bounceOut(1 - t);
	}

	function bounceOut(t) {
	  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
	}

	function bounceInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
	}

	var overshoot = 1.70158;

	var backIn = (function custom(s) {
	  s = +s;

	  function backIn(t) {
	    return t * t * ((s + 1) * t - s);
	  }

	  backIn.overshoot = custom;

	  return backIn;
	})(overshoot);

	var backOut = (function custom(s) {
	  s = +s;

	  function backOut(t) {
	    return --t * t * ((s + 1) * t + s) + 1;
	  }

	  backOut.overshoot = custom;

	  return backOut;
	})(overshoot);

	var backInOut = (function custom(s) {
	  s = +s;

	  function backInOut(t) {
	    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
	  }

	  backInOut.overshoot = custom;

	  return backInOut;
	})(overshoot);

	var tau = 2 * Math.PI,
	    amplitude = 1,
	    period = 0.3;

	var elasticIn = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticIn(t) {
	    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
	  }

	  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
	  elasticIn.period = function(p) { return custom(a, p); };

	  return elasticIn;
	})(amplitude, period);

	var elasticOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticOut(t) {
	    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
	  }

	  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticOut.period = function(p) { return custom(a, p); };

	  return elasticOut;
	})(amplitude, period);

	var elasticInOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticInOut(t) {
	    return ((t = t * 2 - 1) < 0
	        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
	        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
	  }

	  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticInOut.period = function(p) { return custom(a, p); };

	  return elasticInOut;
	})(amplitude, period);

	exports.easeBack = backInOut;
	exports.easeBackIn = backIn;
	exports.easeBackInOut = backInOut;
	exports.easeBackOut = backOut;
	exports.easeBounce = bounceOut;
	exports.easeBounceIn = bounceIn;
	exports.easeBounceInOut = bounceInOut;
	exports.easeBounceOut = bounceOut;
	exports.easeCircle = circleInOut;
	exports.easeCircleIn = circleIn;
	exports.easeCircleInOut = circleInOut;
	exports.easeCircleOut = circleOut;
	exports.easeCubic = cubicInOut;
	exports.easeCubicIn = cubicIn;
	exports.easeCubicInOut = cubicInOut;
	exports.easeCubicOut = cubicOut;
	exports.easeElastic = elasticOut;
	exports.easeElasticIn = elasticIn;
	exports.easeElasticInOut = elasticInOut;
	exports.easeElasticOut = elasticOut;
	exports.easeExp = expInOut;
	exports.easeExpIn = expIn;
	exports.easeExpInOut = expInOut;
	exports.easeExpOut = expOut;
	exports.easeLinear = linear;
	exports.easePoly = polyInOut;
	exports.easePolyIn = polyIn;
	exports.easePolyInOut = polyInOut;
	exports.easePolyOut = polyOut;
	exports.easeQuad = quadInOut;
	exports.easeQuadIn = quadIn;
	exports.easeQuadInOut = quadInOut;
	exports.easeQuadOut = quadOut;
	exports.easeSin = sinInOut;
	exports.easeSinIn = sinIn;
	exports.easeSinInOut = sinInOut;
	exports.easeSinOut = sinOut;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-chord/ v1.0.6 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(18), __webpack_require__(19)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
	}(this, (function (exports,d3Array,d3Path) { 'use strict';

	var cos = Math.cos;
	var sin = Math.sin;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = pi * 2;
	var max = Math.max;

	function compareValue(compare) {
	  return function(a, b) {
	    return compare(
	      a.source.value + a.target.value,
	      b.source.value + b.target.value
	    );
	  };
	}

	function chord() {
	  var padAngle = 0,
	      sortGroups = null,
	      sortSubgroups = null,
	      sortChords = null;

	  function chord(matrix) {
	    var n = matrix.length,
	        groupSums = [],
	        groupIndex = d3Array.range(n),
	        subgroupIndex = [],
	        chords = [],
	        groups = chords.groups = new Array(n),
	        subgroups = new Array(n * n),
	        k,
	        x,
	        x0,
	        dx,
	        i,
	        j;

	    // Compute the sum.
	    k = 0, i = -1; while (++i < n) {
	      x = 0, j = -1; while (++j < n) {
	        x += matrix[i][j];
	      }
	      groupSums.push(x);
	      subgroupIndex.push(d3Array.range(n));
	      k += x;
	    }

	    // Sort groups…
	    if (sortGroups) groupIndex.sort(function(a, b) {
	      return sortGroups(groupSums[a], groupSums[b]);
	    });

	    // Sort subgroups…
	    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
	      d.sort(function(a, b) {
	        return sortSubgroups(matrix[i][a], matrix[i][b]);
	      });
	    });

	    // Convert the sum to scaling factor for [0, 2pi].
	    // TODO Allow start and end angle to be specified?
	    // TODO Allow padding to be specified as percentage?
	    k = max(0, tau - padAngle * n) / k;
	    dx = k ? padAngle : tau / n;

	    // Compute the start and end angle for each group and subgroup.
	    // Note: Opera has a bug reordering object literal properties!
	    x = 0, i = -1; while (++i < n) {
	      x0 = x, j = -1; while (++j < n) {
	        var di = groupIndex[i],
	            dj = subgroupIndex[di][j],
	            v = matrix[di][dj],
	            a0 = x,
	            a1 = x += v * k;
	        subgroups[dj * n + di] = {
	          index: di,
	          subindex: dj,
	          startAngle: a0,
	          endAngle: a1,
	          value: v
	        };
	      }
	      groups[di] = {
	        index: di,
	        startAngle: x0,
	        endAngle: x,
	        value: groupSums[di]
	      };
	      x += dx;
	    }

	    // Generate chords for each (non-empty) subgroup-subgroup link.
	    i = -1; while (++i < n) {
	      j = i - 1; while (++j < n) {
	        var source = subgroups[j * n + i],
	            target = subgroups[i * n + j];
	        if (source.value || target.value) {
	          chords.push(source.value < target.value
	              ? {source: target, target: source}
	              : {source: source, target: target});
	        }
	      }
	    }

	    return sortChords ? chords.sort(sortChords) : chords;
	  }

	  chord.padAngle = function(_) {
	    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
	  };

	  chord.sortGroups = function(_) {
	    return arguments.length ? (sortGroups = _, chord) : sortGroups;
	  };

	  chord.sortSubgroups = function(_) {
	    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
	  };

	  chord.sortChords = function(_) {
	    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
	  };

	  return chord;
	}

	var slice = Array.prototype.slice;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function defaultSource(d) {
	  return d.source;
	}

	function defaultTarget(d) {
	  return d.target;
	}

	function defaultRadius(d) {
	  return d.radius;
	}

	function defaultStartAngle(d) {
	  return d.startAngle;
	}

	function defaultEndAngle(d) {
	  return d.endAngle;
	}

	function ribbon() {
	  var source = defaultSource,
	      target = defaultTarget,
	      radius = defaultRadius,
	      startAngle = defaultStartAngle,
	      endAngle = defaultEndAngle,
	      context = null;

	  function ribbon() {
	    var buffer,
	        argv = slice.call(arguments),
	        s = source.apply(this, argv),
	        t = target.apply(this, argv),
	        sr = +radius.apply(this, (argv[0] = s, argv)),
	        sa0 = startAngle.apply(this, argv) - halfPi,
	        sa1 = endAngle.apply(this, argv) - halfPi,
	        sx0 = sr * cos(sa0),
	        sy0 = sr * sin(sa0),
	        tr = +radius.apply(this, (argv[0] = t, argv)),
	        ta0 = startAngle.apply(this, argv) - halfPi,
	        ta1 = endAngle.apply(this, argv) - halfPi;

	    if (!context) context = buffer = d3Path.path();

	    context.moveTo(sx0, sy0);
	    context.arc(0, 0, sr, sa0, sa1);
	    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
	      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
	      context.arc(0, 0, tr, ta0, ta1);
	    }
	    context.quadraticCurveTo(0, 0, sx0, sy0);
	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  ribbon.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
	  };

	  ribbon.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
	  };

	  ribbon.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
	  };

	  ribbon.source = function(_) {
	    return arguments.length ? (source = _, ribbon) : source;
	  };

	  ribbon.target = function(_) {
	    return arguments.length ? (target = _, ribbon) : target;
	  };

	  ribbon.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
	  };

	  return ribbon;
	}

	exports.chord = chord;
	exports.ribbon = ribbon;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function pairs(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function cross(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function deviation(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	}

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function identity(x) {
	  return x;
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	}

	function histogram() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	}

	function max(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function mean(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	}

	function median(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	}

	function merge(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function permute(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	}

	function scan(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	}

	function shuffle(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var pi = Math.PI,
	    tau = 2 * pi,
	    epsilon = 1e-6,
	    tauEpsilon = tau - epsilon;

	function Path() {
	  this._x0 = this._y0 = // start of current subpath
	  this._x1 = this._y1 = null; // end of current subpath
	  this._ = "";
	}

	function path() {
	  return new Path;
	}

	Path.prototype = path.prototype = {
	  constructor: Path,
	  moveTo: function(x, y) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
	  },
	  closePath: function() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  },
	  lineTo: function(x, y) {
	    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  quadraticCurveTo: function(x1, y1, x, y) {
	    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  arcTo: function(x1, y1, x2, y2, r) {
	    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	    var x0 = this._x1,
	        y0 = this._y1,
	        x21 = x2 - x1,
	        y21 = y2 - y1,
	        x01 = x0 - x1,
	        y01 = y0 - y1,
	        l01_2 = x01 * x01 + y01 * y01;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x1,y1).
	    if (this._x1 === null) {
	      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	    else if (!(l01_2 > epsilon));

	    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	    // Equivalently, is (x1,y1) coincident with (x2,y2)?
	    // Or, is the radius zero? Line to (x1,y1).
	    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
	      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Otherwise, draw an arc!
	    else {
	      var x20 = x2 - x0,
	          y20 = y2 - y0,
	          l21_2 = x21 * x21 + y21 * y21,
	          l20_2 = x20 * x20 + y20 * y20,
	          l21 = Math.sqrt(l21_2),
	          l01 = Math.sqrt(l01_2),
	          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
	          t01 = l / l01,
	          t21 = l / l21;

	      // If the start tangent is not coincident with (x0,y0), line to.
	      if (Math.abs(t01 - 1) > epsilon) {
	        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	      }

	      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	    }
	  },
	  arc: function(x, y, r, a0, a1, ccw) {
	    x = +x, y = +y, r = +r, ccw = !!ccw;
	    var dx = r * Math.cos(a0),
	        dy = r * Math.sin(a0),
	        x0 = x + dx,
	        y0 = y + dy,
	        cw = 1 ^ ccw,
	        da = ccw ? a0 - a1 : a1 - a0;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x0,y0).
	    if (this._x1 === null) {
	      this._ += "M" + x0 + "," + y0;
	    }

	    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
	      this._ += "L" + x0 + "," + y0;
	    }

	    // Is this arc empty? We’re done.
	    if (!r) return;

	    // Does the angle go the wrong way? Flip the direction.
	    if (da < 0) da = da % tau + tau;

	    // Is this a complete circle? Draw two arcs to complete the circle.
	    if (da > tauEpsilon) {
	      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	    }

	    // Is this arc non-empty? Draw an arc!
	    else if (da > epsilon) {
	      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	    }
	  },
	  rect: function(x, y, w, h) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
	  },
	  toString: function() {
	    return this._;
	  }
	};

	exports.path = path;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var prefix = "$";

	function Map() {}

	Map.prototype = map.prototype = {
	  constructor: Map,
	  has: function(key) {
	    return (prefix + key) in this;
	  },
	  get: function(key) {
	    return this[prefix + key];
	  },
	  set: function(key, value) {
	    this[prefix + key] = value;
	    return this;
	  },
	  remove: function(key) {
	    var property = prefix + key;
	    return property in this && delete this[property];
	  },
	  clear: function() {
	    for (var property in this) if (property[0] === prefix) delete this[property];
	  },
	  keys: function() {
	    var keys = [];
	    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	    return keys;
	  },
	  values: function() {
	    var values = [];
	    for (var property in this) if (property[0] === prefix) values.push(this[property]);
	    return values;
	  },
	  entries: function() {
	    var entries = [];
	    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	    return entries;
	  },
	  size: function() {
	    var size = 0;
	    for (var property in this) if (property[0] === prefix) ++size;
	    return size;
	  },
	  empty: function() {
	    for (var property in this) if (property[0] === prefix) return false;
	    return true;
	  },
	  each: function(f) {
	    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	  }
	};

	function map(object, f) {
	  var map = new Map;

	  // Copy constructor.
	  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

	  // Index array by numeric index or specified key function.
	  else if (Array.isArray(object)) {
	    var i = -1,
	        n = object.length,
	        o;

	    if (f == null) while (++i < n) map.set(i, object[i]);
	    else while (++i < n) map.set(f(o = object[i], i, object), o);
	  }

	  // Convert object to map.
	  else if (object) for (var key in object) map.set(key, object[key]);

	  return map;
	}

	function nest() {
	  var keys = [],
	      sortKeys = [],
	      sortValues,
	      rollup,
	      nest;

	  function apply(array, depth, createResult, setResult) {
	    if (depth >= keys.length) {
	      if (sortValues != null) array.sort(sortValues);
	      return rollup != null ? rollup(array) : array;
	    }

	    var i = -1,
	        n = array.length,
	        key = keys[depth++],
	        keyValue,
	        value,
	        valuesByKey = map(),
	        values,
	        result = createResult();

	    while (++i < n) {
	      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
	        values.push(value);
	      } else {
	        valuesByKey.set(keyValue, [value]);
	      }
	    }

	    valuesByKey.each(function(values, key) {
	      setResult(result, key, apply(values, depth, createResult, setResult));
	    });

	    return result;
	  }

	  function entries(map$$1, depth) {
	    if (++depth > keys.length) return map$$1;
	    var array, sortKey = sortKeys[depth - 1];
	    if (rollup != null && depth >= keys.length) array = map$$1.entries();
	    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
	    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
	  }

	  return nest = {
	    object: function(array) { return apply(array, 0, createObject, setObject); },
	    map: function(array) { return apply(array, 0, createMap, setMap); },
	    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
	    key: function(d) { keys.push(d); return nest; },
	    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
	    sortValues: function(order) { sortValues = order; return nest; },
	    rollup: function(f) { rollup = f; return nest; }
	  };
	}

	function createObject() {
	  return {};
	}

	function setObject(object, key, value) {
	  object[key] = value;
	}

	function createMap() {
	  return map();
	}

	function setMap(map$$1, key, value) {
	  map$$1.set(key, value);
	}

	function Set() {}

	var proto = map.prototype;

	Set.prototype = set.prototype = {
	  constructor: Set,
	  has: proto.has,
	  add: function(value) {
	    value += "";
	    this[prefix + value] = value;
	    return this;
	  },
	  remove: proto.remove,
	  clear: proto.clear,
	  values: proto.keys,
	  size: proto.size,
	  empty: proto.empty,
	  each: proto.each
	};

	function set(object, f) {
	  var set = new Set;

	  // Copy constructor.
	  if (object instanceof Set) object.each(function(value) { set.add(value); });

	  // Otherwise, assume it’s an array.
	  else if (object) {
	    var i = -1, n = object.length;
	    if (f == null) while (++i < n) set.add(object[i]);
	    else while (++i < n) set.add(f(object[i], i, object));
	  }

	  return set;
	}

	function keys(map) {
	  var keys = [];
	  for (var key in map) keys.push(key);
	  return keys;
	}

	function values(map) {
	  var values = [];
	  for (var key in map) values.push(map[key]);
	  return values;
	}

	function entries(map) {
	  var entries = [];
	  for (var key in map) entries.push({key: key, value: map[key]});
	  return entries;
	}

	exports.nest = nest;
	exports.set = set;
	exports.map = map;
	exports.keys = keys;
	exports.values = values;
	exports.entries = entries;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-contour/ v1.3.2 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(22)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Array) { 'use strict';

	var array = Array.prototype;

	var slice = array.slice;

	function ascending(a, b) {
	  return a - b;
	}

	function area(ring) {
	  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
	  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
	  return area;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function contains(ring, hole) {
	  var i = -1, n = hole.length, c;
	  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
	  return 0;
	}

	function ringContains(ring, point) {
	  var x = point[0], y = point[1], contains = -1;
	  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
	    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
	    if (segmentContains(pi, pj, point)) return 0;
	    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
	  }
	  return contains;
	}

	function segmentContains(a, b, c) {
	  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
	}

	function collinear(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
	}

	function within(p, q, r) {
	  return p <= q && q <= r || r <= q && q <= p;
	}

	function noop() {}

	var cases = [
	  [],
	  [[[1.0, 1.5], [0.5, 1.0]]],
	  [[[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [0.5, 1.0]]],
	  [[[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 0.5], [1.0, 1.5]]],
	  [[[1.0, 0.5], [0.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 0.5]]],
	  [[[1.0, 1.5], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.5, 1.0]]],
	  [[[1.0, 1.5], [1.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 1.5]]],
	  []
	];

	function contours() {
	  var dx = 1,
	      dy = 1,
	      threshold = d3Array.thresholdSturges,
	      smooth = smoothLinear;

	  function contours(values) {
	    var tz = threshold(values);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
	      tz = d3Array.tickStep(start, stop, tz);
	      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
	    } else {
	      tz = tz.slice().sort(ascending);
	    }

	    return tz.map(function(value) {
	      return contour(values, value);
	    });
	  }

	  // Accumulate, smooth contour rings, assign holes to exterior rings.
	  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
	  function contour(values, value) {
	    var polygons = [],
	        holes = [];

	    isorings(values, value, function(ring) {
	      smooth(ring, values, value);
	      if (area(ring) > 0) polygons.push([ring]);
	      else holes.push(ring);
	    });

	    holes.forEach(function(hole) {
	      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
	        if (contains((polygon = polygons[i])[0], hole) !== -1) {
	          polygon.push(hole);
	          return;
	        }
	      }
	    });

	    return {
	      type: "MultiPolygon",
	      value: value,
	      coordinates: polygons
	    };
	  }

	  // Marching squares with isolines stitched into rings.
	  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
	  function isorings(values, value, callback) {
	    var fragmentByStart = new Array,
	        fragmentByEnd = new Array,
	        x, y, t0, t1, t2, t3;

	    // Special case for the first row (y = -1, t2 = t3 = 0).
	    x = y = -1;
	    t1 = values[0] >= value;
	    cases[t1 << 1].forEach(stitch);
	    while (++x < dx - 1) {
	      t0 = t1, t1 = values[x + 1] >= value;
	      cases[t0 | t1 << 1].forEach(stitch);
	    }
	    cases[t1 << 0].forEach(stitch);

	    // General case for the intermediate rows.
	    while (++y < dy - 1) {
	      x = -1;
	      t1 = values[y * dx + dx] >= value;
	      t2 = values[y * dx] >= value;
	      cases[t1 << 1 | t2 << 2].forEach(stitch);
	      while (++x < dx - 1) {
	        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
	        t3 = t2, t2 = values[y * dx + x + 1] >= value;
	        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
	      }
	      cases[t1 | t2 << 3].forEach(stitch);
	    }

	    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
	    x = -1;
	    t2 = values[y * dx] >= value;
	    cases[t2 << 2].forEach(stitch);
	    while (++x < dx - 1) {
	      t3 = t2, t2 = values[y * dx + x + 1] >= value;
	      cases[t2 << 2 | t3 << 3].forEach(stitch);
	    }
	    cases[t2 << 3].forEach(stitch);

	    function stitch(line) {
	      var start = [line[0][0] + x, line[0][1] + y],
	          end = [line[1][0] + x, line[1][1] + y],
	          startIndex = index(start),
	          endIndex = index(end),
	          f, g;
	      if (f = fragmentByEnd[startIndex]) {
	        if (g = fragmentByStart[endIndex]) {
	          delete fragmentByEnd[f.end];
	          delete fragmentByStart[g.start];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
	          }
	        } else {
	          delete fragmentByEnd[f.end];
	          f.ring.push(end);
	          fragmentByEnd[f.end = endIndex] = f;
	        }
	      } else if (f = fragmentByStart[endIndex]) {
	        if (g = fragmentByEnd[startIndex]) {
	          delete fragmentByStart[f.start];
	          delete fragmentByEnd[g.end];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
	          }
	        } else {
	          delete fragmentByStart[f.start];
	          f.ring.unshift(start);
	          fragmentByStart[f.start = startIndex] = f;
	        }
	      } else {
	        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
	      }
	    }
	  }

	  function index(point) {
	    return point[0] * 2 + point[1] * (dx + 1) * 4;
	  }

	  function smoothLinear(ring, values, value) {
	    ring.forEach(function(point) {
	      var x = point[0],
	          y = point[1],
	          xt = x | 0,
	          yt = y | 0,
	          v0,
	          v1 = values[yt * dx + xt];
	      if (x > 0 && x < dx && xt === x) {
	        v0 = values[yt * dx + xt - 1];
	        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
	      }
	      if (y > 0 && y < dy && yt === y) {
	        v0 = values[(yt - 1) * dx + xt];
	        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
	      }
	    });
	  }

	  contours.contour = contour;

	  contours.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, contours;
	  };

	  contours.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
	  };

	  contours.smooth = function(_) {
	    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
	  };

	  return contours;
	}

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurX(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var j = 0; j < m; ++j) {
	    for (var i = 0, sr = 0; i < n + r; ++i) {
	      if (i < n) {
	        sr += source.data[i + j * n];
	      }
	      if (i >= r) {
	        if (i >= w) {
	          sr -= source.data[i - w + j * n];
	        }
	        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
	      }
	    }
	  }
	}

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurY(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var i = 0; i < n; ++i) {
	    for (var j = 0, sr = 0; j < m + r; ++j) {
	      if (j < m) {
	        sr += source.data[i + j * n];
	      }
	      if (j >= r) {
	        if (j >= w) {
	          sr -= source.data[i + (j - w) * n];
	        }
	        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
	      }
	    }
	  }
	}

	function defaultX(d) {
	  return d[0];
	}

	function defaultY(d) {
	  return d[1];
	}

	function defaultWeight() {
	  return 1;
	}

	function density() {
	  var x = defaultX,
	      y = defaultY,
	      weight = defaultWeight,
	      dx = 960,
	      dy = 500,
	      r = 20, // blur radius
	      k = 2, // log2(grid cell size)
	      o = r * 3, // grid offset, to pad for blur
	      n = (dx + o * 2) >> k, // grid width
	      m = (dy + o * 2) >> k, // grid height
	      threshold = constant(20);

	  function density(data) {
	    var values0 = new Float32Array(n * m),
	        values1 = new Float32Array(n * m);

	    data.forEach(function(d, i, data) {
	      var xi = (+x(d, i, data) + o) >> k,
	          yi = (+y(d, i, data) + o) >> k,
	          wi = +weight(d, i, data);
	      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
	        values0[xi + yi * n] += wi;
	      }
	    });

	    // TODO Optimize.
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

	    var tz = threshold(values0);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var stop = d3Array.max(values0);
	      tz = d3Array.tickStep(0, stop, tz);
	      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
	      tz.shift();
	    }

	    return contours()
	        .thresholds(tz)
	        .size([n, m])
	      (values0)
	        .map(transform);
	  }

	  function transform(geometry) {
	    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
	    geometry.coordinates.forEach(transformPolygon);
	    return geometry;
	  }

	  function transformPolygon(coordinates) {
	    coordinates.forEach(transformRing);
	  }

	  function transformRing(coordinates) {
	    coordinates.forEach(transformPoint);
	  }

	  // TODO Optimize.
	  function transformPoint(coordinates) {
	    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
	    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
	  }

	  function resize() {
	    o = r * 3;
	    n = (dx + o * 2) >> k;
	    m = (dy + o * 2) >> k;
	    return density;
	  }

	  density.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
	  };

	  density.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
	  };

	  density.weight = function(_) {
	    return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density) : weight;
	  };

	  density.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, resize();
	  };

	  density.cellSize = function(_) {
	    if (!arguments.length) return 1 << k;
	    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
	    return k = Math.floor(Math.log(_) / Math.LN2), resize();
	  };

	  density.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
	  };

	  density.bandwidth = function(_) {
	    if (!arguments.length) return Math.sqrt(r * (r + 1));
	    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
	    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
	  };

	  return density;
	}

	exports.contours = contours;
	exports.contourDensity = density;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function pairs(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function cross(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function deviation(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	}

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function identity(x) {
	  return x;
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	}

	function histogram() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	}

	function max(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function mean(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	}

	function median(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	}

	function merge(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function permute(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	}

	function scan(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	}

	function shuffle(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var EOL = {},
	    EOF = {},
	    QUOTE = 34,
	    NEWLINE = 10,
	    RETURN = 13;

	function objectConverter(columns) {
	  return new Function("d", "return {" + columns.map(function(name, i) {
	    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
	  }).join(",") + "}");
	}

	function customConverter(columns, f) {
	  var object = objectConverter(columns);
	  return function(row, i) {
	    return f(object(row), i, columns);
	  };
	}

	// Compute unique columns in order of discovery.
	function inferColumns(rows) {
	  var columnSet = Object.create(null),
	      columns = [];

	  rows.forEach(function(row) {
	    for (var column in row) {
	      if (!(column in columnSet)) {
	        columns.push(columnSet[column] = column);
	      }
	    }
	  });

	  return columns;
	}

	function pad(value, width) {
	  var s = value + "", length = s.length;
	  return length < width ? new Array(width - length + 1).join(0) + s : s;
	}

	function formatYear(year) {
	  return year < 0 ? "-" + pad(-year, 6)
	    : year > 9999 ? "+" + pad(year, 6)
	    : pad(year, 4);
	}

	function formatDate(date) {
	  var hours = date.getUTCHours(),
	      minutes = date.getUTCMinutes(),
	      seconds = date.getUTCSeconds(),
	      milliseconds = date.getUTCMilliseconds();
	  return isNaN(date) ? "Invalid Date"
	      : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
	      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
	      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
	      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
	      : "");
	}

	function dsv(delimiter) {
	  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
	      DELIMITER = delimiter.charCodeAt(0);

	  function parse(text, f) {
	    var convert, columns, rows = parseRows(text, function(row, i) {
	      if (convert) return convert(row, i - 1);
	      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	    });
	    rows.columns = columns || [];
	    return rows;
	  }

	  function parseRows(text, f) {
	    var rows = [], // output rows
	        N = text.length,
	        I = 0, // current character index
	        n = 0, // current line number
	        t, // current token
	        eof = N <= 0, // current token followed by EOF?
	        eol = false; // current token followed by EOL?

	    // Strip the trailing newline.
	    if (text.charCodeAt(N - 1) === NEWLINE) --N;
	    if (text.charCodeAt(N - 1) === RETURN) --N;

	    function token() {
	      if (eof) return EOF;
	      if (eol) return eol = false, EOL;

	      // Unescape quotes.
	      var i, j = I, c;
	      if (text.charCodeAt(j) === QUOTE) {
	        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
	        if ((i = I) >= N) eof = true;
	        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
	      }

	      // Find next delimiter or newline.
	      while (I < N) {
	        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        else if (c !== DELIMITER) continue;
	        return text.slice(j, i);
	      }

	      // Return last token before EOF.
	      return eof = true, text.slice(j, N);
	    }

	    while ((t = token()) !== EOF) {
	      var row = [];
	      while (t !== EOL && t !== EOF) row.push(t), t = token();
	      if (f && (row = f(row, n++)) == null) continue;
	      rows.push(row);
	    }

	    return rows;
	  }

	  function preformatBody(rows, columns) {
	    return rows.map(function(row) {
	      return columns.map(function(column) {
	        return formatValue(row[column]);
	      }).join(delimiter);
	    });
	  }

	  function format(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
	  }

	  function formatBody(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return preformatBody(rows, columns).join("\n");
	  }

	  function formatRows(rows) {
	    return rows.map(formatRow).join("\n");
	  }

	  function formatRow(row) {
	    return row.map(formatValue).join(delimiter);
	  }

	  function formatValue(value) {
	    return value == null ? ""
	        : value instanceof Date ? formatDate(value)
	        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
	        : value;
	  }

	  return {
	    parse: parse,
	    parseRows: parseRows,
	    format: format,
	    formatBody: formatBody,
	    formatRows: formatRows,
	    formatRow: formatRow,
	    formatValue: formatValue
	  };
	}

	var csv = dsv(",");

	var csvParse = csv.parse;
	var csvParseRows = csv.parseRows;
	var csvFormat = csv.format;
	var csvFormatBody = csv.formatBody;
	var csvFormatRows = csv.formatRows;
	var csvFormatRow = csv.formatRow;
	var csvFormatValue = csv.formatValue;

	var tsv = dsv("\t");

	var tsvParse = tsv.parse;
	var tsvParseRows = tsv.parseRows;
	var tsvFormat = tsv.format;
	var tsvFormatBody = tsv.formatBody;
	var tsvFormatRows = tsv.formatRows;
	var tsvFormatRow = tsv.formatRow;
	var tsvFormatValue = tsv.formatValue;

	function autoType(object) {
	  for (var key in object) {
	    var value = object[key].trim(), number, m;
	    if (!value) value = null;
	    else if (value === "true") value = true;
	    else if (value === "false") value = false;
	    else if (value === "NaN") value = NaN;
	    else if (!isNaN(number = +value)) value = number;
	    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
	      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
	      value = new Date(value);
	    }
	    else continue;
	    object[key] = value;
	  }
	  return object;
	}

	// https://github.com/d3/d3-dsv/issues/45
	var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

	exports.autoType = autoType;
	exports.csvFormat = csvFormat;
	exports.csvFormatBody = csvFormatBody;
	exports.csvFormatRow = csvFormatRow;
	exports.csvFormatRows = csvFormatRows;
	exports.csvFormatValue = csvFormatValue;
	exports.csvParse = csvParse;
	exports.csvParseRows = csvParseRows;
	exports.dsvFormat = dsv;
	exports.tsvFormat = tsvFormat;
	exports.tsvFormatBody = tsvFormatBody;
	exports.tsvFormatRow = tsvFormatRow;
	exports.tsvFormatRows = tsvFormatRows;
	exports.tsvFormatValue = tsvFormatValue;
	exports.tsvParse = tsvParse;
	exports.tsvParseRows = tsvParseRows;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-fetch/ v1.1.2 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(23)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Dsv) { 'use strict';

	function responseBlob(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.blob();
	}

	function blob(input, init) {
	  return fetch(input, init).then(responseBlob);
	}

	function responseArrayBuffer(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.arrayBuffer();
	}

	function buffer(input, init) {
	  return fetch(input, init).then(responseArrayBuffer);
	}

	function responseText(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.text();
	}

	function text(input, init) {
	  return fetch(input, init).then(responseText);
	}

	function dsvParse(parse) {
	  return function(input, init, row) {
	    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
	    return text(input, init).then(function(response) {
	      return parse(response, row);
	    });
	  };
	}

	function dsv(delimiter, input, init, row) {
	  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
	  var format = d3Dsv.dsvFormat(delimiter);
	  return text(input, init).then(function(response) {
	    return format.parse(response, row);
	  });
	}

	var csv = dsvParse(d3Dsv.csvParse);
	var tsv = dsvParse(d3Dsv.tsvParse);

	function image(input, init) {
	  return new Promise(function(resolve, reject) {
	    var image = new Image;
	    for (var key in init) image[key] = init[key];
	    image.onerror = reject;
	    image.onload = function() { resolve(image); };
	    image.src = input;
	  });
	}

	function responseJson(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.json();
	}

	function json(input, init) {
	  return fetch(input, init).then(responseJson);
	}

	function parser(type) {
	  return function(input, init)  {
	    return text(input, init).then(function(text$$1) {
	      return (new DOMParser).parseFromString(text$$1, type);
	    });
	  };
	}

	var xml = parser("application/xml");

	var html = parser("text/html");

	var svg = parser("image/svg+xml");

	exports.blob = blob;
	exports.buffer = buffer;
	exports.dsv = dsv;
	exports.csv = csv;
	exports.tsv = tsv;
	exports.image = image;
	exports.json = json;
	exports.text = text;
	exports.xml = xml;
	exports.html = html;
	exports.svg = svg;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-force/ v1.2.1 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(26), __webpack_require__(20), __webpack_require__(9), __webpack_require__(15)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

	function center(x, y) {
	  var nodes;

	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force() {
	    var i,
	        n = nodes.length,
	        node,
	        sx = 0,
	        sy = 0;

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], sx += node.x, sy += node.y;
	    }

	    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
	      node = nodes[i], node.x -= sx, node.y -= sy;
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function jiggle() {
	  return (Math.random() - 0.5) * 1e-6;
	}

	function x(d) {
	  return d.x + d.vx;
	}

	function y(d) {
	  return d.y + d.vy;
	}

	function collide(radius) {
	  var nodes,
	      radii,
	      strength = 1,
	      iterations = 1;

	  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

	  function force() {
	    var i, n = nodes.length,
	        tree,
	        node,
	        xi,
	        yi,
	        ri,
	        ri2;

	    for (var k = 0; k < iterations; ++k) {
	      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        ri = radii[node.index], ri2 = ri * ri;
	        xi = node.x + node.vx;
	        yi = node.y + node.vy;
	        tree.visit(apply);
	      }
	    }

	    function apply(quad, x0, y0, x1, y1) {
	      var data = quad.data, rj = quad.r, r = ri + rj;
	      if (data) {
	        if (data.index > node.index) {
	          var x = xi - data.x - data.vx,
	              y = yi - data.y - data.vy,
	              l = x * x + y * y;
	          if (l < r * r) {
	            if (x === 0) x = jiggle(), l += x * x;
	            if (y === 0) y = jiggle(), l += y * y;
	            l = (r - (l = Math.sqrt(l))) / l * strength;
	            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
	            node.vy += (y *= l) * r;
	            data.vx -= x * (r = 1 - r);
	            data.vy -= y * r;
	          }
	        }
	        return;
	      }
	      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
	    }
	  }

	  function prepare(quad) {
	    if (quad.data) return quad.r = radii[quad.data.index];
	    for (var i = quad.r = 0; i < 4; ++i) {
	      if (quad[i] && quad[i].r > quad.r) {
	        quad.r = quad[i].r;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    radii = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = +_, force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  return force;
	}

	function index(d) {
	  return d.index;
	}

	function find(nodeById, nodeId) {
	  var node = nodeById.get(nodeId);
	  if (!node) throw new Error("missing: " + nodeId);
	  return node;
	}

	function link(links) {
	  var id = index,
	      strength = defaultStrength,
	      strengths,
	      distance = constant(30),
	      distances,
	      nodes,
	      count,
	      bias,
	      iterations = 1;

	  if (links == null) links = [];

	  function defaultStrength(link) {
	    return 1 / Math.min(count[link.source.index], count[link.target.index]);
	  }

	  function force(alpha) {
	    for (var k = 0, n = links.length; k < iterations; ++k) {
	      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
	        link = links[i], source = link.source, target = link.target;
	        x = target.x + target.vx - source.x - source.vx || jiggle();
	        y = target.y + target.vy - source.y - source.vy || jiggle();
	        l = Math.sqrt(x * x + y * y);
	        l = (l - distances[i]) / l * alpha * strengths[i];
	        x *= l, y *= l;
	        target.vx -= x * (b = bias[i]);
	        target.vy -= y * b;
	        source.vx += x * (b = 1 - b);
	        source.vy += y * b;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;

	    var i,
	        n = nodes.length,
	        m = links.length,
	        nodeById = d3Collection.map(nodes, id),
	        link;

	    for (i = 0, count = new Array(n); i < m; ++i) {
	      link = links[i], link.index = i;
	      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
	      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
	      count[link.source.index] = (count[link.source.index] || 0) + 1;
	      count[link.target.index] = (count[link.target.index] || 0) + 1;
	    }

	    for (i = 0, bias = new Array(m); i < m; ++i) {
	      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
	    }

	    strengths = new Array(m), initializeStrength();
	    distances = new Array(m), initializeDistance();
	  }

	  function initializeStrength() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      strengths[i] = +strength(links[i], i, links);
	    }
	  }

	  function initializeDistance() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      distances[i] = +distance(links[i], i, links);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.links = function(_) {
	    return arguments.length ? (links = _, initialize(), force) : links;
	  };

	  force.id = function(_) {
	    return arguments.length ? (id = _, force) : id;
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
	  };

	  force.distance = function(_) {
	    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
	  };

	  return force;
	}

	function x$1(d) {
	  return d.x;
	}

	function y$1(d) {
	  return d.y;
	}

	var initialRadius = 10,
	    initialAngle = Math.PI * (3 - Math.sqrt(5));

	function simulation(nodes) {
	  var simulation,
	      alpha = 1,
	      alphaMin = 0.001,
	      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
	      alphaTarget = 0,
	      velocityDecay = 0.6,
	      forces = d3Collection.map(),
	      stepper = d3Timer.timer(step),
	      event = d3Dispatch.dispatch("tick", "end");

	  if (nodes == null) nodes = [];

	  function step() {
	    tick();
	    event.call("tick", simulation);
	    if (alpha < alphaMin) {
	      stepper.stop();
	      event.call("end", simulation);
	    }
	  }

	  function tick(iterations) {
	    var i, n = nodes.length, node;

	    if (iterations === undefined) iterations = 1;

	    for (var k = 0; k < iterations; ++k) {
	      alpha += (alphaTarget - alpha) * alphaDecay;

	      forces.each(function (force) {
	        force(alpha);
	      });

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        if (node.fx == null) node.x += node.vx *= velocityDecay;
	        else node.x = node.fx, node.vx = 0;
	        if (node.fy == null) node.y += node.vy *= velocityDecay;
	        else node.y = node.fy, node.vy = 0;
	      }
	    }

	    return simulation;
	  }

	  function initializeNodes() {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.index = i;
	      if (node.fx != null) node.x = node.fx;
	      if (node.fy != null) node.y = node.fy;
	      if (isNaN(node.x) || isNaN(node.y)) {
	        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
	        node.x = radius * Math.cos(angle);
	        node.y = radius * Math.sin(angle);
	      }
	      if (isNaN(node.vx) || isNaN(node.vy)) {
	        node.vx = node.vy = 0;
	      }
	    }
	  }

	  function initializeForce(force) {
	    if (force.initialize) force.initialize(nodes);
	    return force;
	  }

	  initializeNodes();

	  return simulation = {
	    tick: tick,

	    restart: function() {
	      return stepper.restart(step), simulation;
	    },

	    stop: function() {
	      return stepper.stop(), simulation;
	    },

	    nodes: function(_) {
	      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
	    },

	    alpha: function(_) {
	      return arguments.length ? (alpha = +_, simulation) : alpha;
	    },

	    alphaMin: function(_) {
	      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
	    },

	    alphaDecay: function(_) {
	      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
	    },

	    alphaTarget: function(_) {
	      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
	    },

	    velocityDecay: function(_) {
	      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
	    },

	    force: function(name, _) {
	      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
	    },

	    find: function(x, y, radius) {
	      var i = 0,
	          n = nodes.length,
	          dx,
	          dy,
	          d2,
	          node,
	          closest;

	      if (radius == null) radius = Infinity;
	      else radius *= radius;

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        dx = x - node.x;
	        dy = y - node.y;
	        d2 = dx * dx + dy * dy;
	        if (d2 < radius) closest = node, radius = d2;
	      }

	      return closest;
	    },

	    on: function(name, _) {
	      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
	    }
	  };
	}

	function manyBody() {
	  var nodes,
	      node,
	      alpha,
	      strength = constant(-30),
	      strengths,
	      distanceMin2 = 1,
	      distanceMax2 = Infinity,
	      theta2 = 0.81;

	  function force(_) {
	    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
	    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    strengths = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
	  }

	  function accumulate(quad) {
	    var strength = 0, q, c, weight = 0, x, y, i;

	    // For internal nodes, accumulate forces from child quadrants.
	    if (quad.length) {
	      for (x = y = i = 0; i < 4; ++i) {
	        if ((q = quad[i]) && (c = Math.abs(q.value))) {
	          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
	        }
	      }
	      quad.x = x / weight;
	      quad.y = y / weight;
	    }

	    // For leaf nodes, accumulate forces from coincident quadrants.
	    else {
	      q = quad;
	      q.x = q.data.x;
	      q.y = q.data.y;
	      do strength += strengths[q.data.index];
	      while (q = q.next);
	    }

	    quad.value = strength;
	  }

	  function apply(quad, x1, _, x2) {
	    if (!quad.value) return true;

	    var x = quad.x - node.x,
	        y = quad.y - node.y,
	        w = x2 - x1,
	        l = x * x + y * y;

	    // Apply the Barnes-Hut approximation if possible.
	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (w * w / theta2 < l) {
	      if (l < distanceMax2) {
	        if (x === 0) x = jiggle(), l += x * x;
	        if (y === 0) y = jiggle(), l += y * y;
	        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	        node.vx += x * quad.value * alpha / l;
	        node.vy += y * quad.value * alpha / l;
	      }
	      return true;
	    }

	    // Otherwise, process points directly.
	    else if (quad.length || l >= distanceMax2) return;

	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (quad.data !== node || quad.next) {
	      if (x === 0) x = jiggle(), l += x * x;
	      if (y === 0) y = jiggle(), l += y * y;
	      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	    }

	    do if (quad.data !== node) {
	      w = strengths[quad.data.index] * alpha / l;
	      node.vx += x * w;
	      node.vy += y * w;
	    } while (quad = quad.next);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.distanceMin = function(_) {
	    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
	  };

	  force.distanceMax = function(_) {
	    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
	  };

	  force.theta = function(_) {
	    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
	  };

	  return force;
	}

	function radial(radius, x, y) {
	  var nodes,
	      strength = constant(0.1),
	      strengths,
	      radiuses;

	  if (typeof radius !== "function") radius = constant(+radius);
	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force(alpha) {
	    for (var i = 0, n = nodes.length; i < n; ++i) {
	      var node = nodes[i],
	          dx = node.x - x || 1e-6,
	          dy = node.y - y || 1e-6,
	          r = Math.sqrt(dx * dx + dy * dy),
	          k = (radiuses[i] - r) * strengths[i] * alpha / r;
	      node.vx += dx * k;
	      node.vy += dy * k;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    radiuses = new Array(n);
	    for (i = 0; i < n; ++i) {
	      radiuses[i] = +radius(nodes[i], i, nodes);
	      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _, initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	}

	function x$2(x) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      xz;

	  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    xz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
	  };

	  return force;
	}

	function y$2(y) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      yz;

	  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    yz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
	  };

	  return force;
	}

	exports.forceCenter = center;
	exports.forceCollide = collide;
	exports.forceLink = link;
	exports.forceManyBody = manyBody;
	exports.forceRadial = radial;
	exports.forceSimulation = simulation;
	exports.forceX = x$2;
	exports.forceY = y$2;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function tree_add(d) {
	  var x = +this._x.call(null, d),
	      y = +this._y.call(null, d);
	  return add(this.cover(x, y), x, y, d);
	}

	function add(tree, x, y, d) {
	  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      y0 = tree._y0,
	      x1 = tree._x1,
	      y1 = tree._y1,
	      xm,
	      ym,
	      xp,
	      yp,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  yp = +tree._y.call(null, node.data);
	  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var d, i, n = data.length,
	      x,
	      y,
	      xz = new Array(n),
	      yz = new Array(n),
	      x0 = Infinity,
	      y0 = Infinity,
	      x1 = -Infinity,
	      y1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
	    xz[i] = x;
	    yz[i] = y;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	    if (y < y0) y0 = y;
	    if (y > y1) y1 = y;
	  }

	  // If there were no (valid) points, abort.
	  if (x0 > x1 || y0 > y1) return this;

	  // Expand the tree to cover the new points.
	  this.cover(x0, y0).cover(x1, y1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], yz[i], data[i]);
	  }

	  return this;
	}

	function tree_cover(x, y) {
	  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

	  var x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1;

	  // If the quadtree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing quadrant boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	    y1 = (y0 = Math.floor(y)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else {
	    var z = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
	      i = (y < y0) << 1 | (x < x0);
	      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
	      switch (i) {
	        case 0: x1 = x0 + z, y1 = y0 + z; break;
	        case 1: x0 = x1 - z, y1 = y0 + z; break;
	        case 2: x1 = x0 + z, y0 = y1 - z; break;
	        case 3: x0 = x1 - z, y0 = y1 - z; break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  return this;
	}

	function tree_data() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	}

	function tree_extent(_) {
	  return arguments.length
	      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
	      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
	}

	function Quad(node, x0, y0, x1, y1) {
	  this.node = node;
	  this.x0 = x0;
	  this.y0 = y0;
	  this.x1 = x1;
	  this.y1 = y1;
	}

	function tree_find(x, y, radius) {
	  var data,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1,
	      y1,
	      x2,
	      y2,
	      x3 = this._x1,
	      y3 = this._y1,
	      quads = [],
	      node = this._root,
	      q,
	      i;

	  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius, y0 = y - radius;
	    x3 = x + radius, y3 = y + radius;
	    radius *= radius;
	  }

	  while (q = quads.pop()) {

	    // Stop searching if this quadrant can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (y1 = q.y0) > y3
	        || (x2 = q.x1) < x0
	        || (y2 = q.y1) < y0) continue;

	    // Bisect the current quadrant.
	    if (node.length) {
	      var xm = (x1 + x2) / 2,
	          ym = (y1 + y2) / 2;

	      quads.push(
	        new Quad(node[3], xm, ym, x2, y2),
	        new Quad(node[2], x1, ym, xm, y2),
	        new Quad(node[1], xm, y1, x2, ym),
	        new Quad(node[0], x1, y1, xm, ym)
	      );

	      // Visit the closest quadrant first.
	      if (i = (y >= ym) << 1 | (x >= xm)) {
	        q = quads[quads.length - 1];
	        quads[quads.length - 1] = quads[quads.length - 1 - i];
	        quads[quads.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var dx = x - +this._x.call(null, node.data),
	          dy = y - +this._y.call(null, node.data),
	          d2 = dx * dx + dy * dy;
	      if (d2 < radius) {
	        var d = Math.sqrt(radius = d2);
	        x0 = x - d, y0 = y - d;
	        x3 = x + d, y3 = y + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	}

	function tree_remove(d) {
	  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1,
	      x,
	      y,
	      xm,
	      ym,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
	      && node === (parent[3] || parent[2] || parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	}

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	function tree_root() {
	  return this._root;
	}

	function tree_size() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	}

	function tree_visit(callback) {
	  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
	  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
	      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	    }
	  }
	  return this;
	}

	function tree_visitAfter(callback) {
	  var quads = [], next = [], q;
	  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.y0, q.x1, q.y1);
	  }
	  return this;
	}

	function defaultX(d) {
	  return d[0];
	}

	function tree_x(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	}

	function defaultY(d) {
	  return d[1];
	}

	function tree_y(_) {
	  return arguments.length ? (this._y = _, this) : this._y;
	}

	function quadtree(nodes, x, y) {
	  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Quadtree(x, y, x0, y0, x1, y1) {
	  this._x = x;
	  this._y = y;
	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = quadtree.prototype = Quadtree.prototype;

	treeProto.copy = function() {
	  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(4)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 4; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;
	treeProto.y = tree_y;

	exports.quadtree = quadtree;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-format/ v1.4.4 Copyright 2020 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimal(1.23) returns ["123", 0].
	function formatDecimal(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	}

	function exponent(x) {
	  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	}

	function formatGroup(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	}

	function formatNumerals(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	}

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  return new FormatSpecifier({
	    fill: match[1],
	    align: match[2],
	    sign: match[3],
	    symbol: match[4],
	    zero: match[5],
	    width: match[6],
	    comma: match[7],
	    precision: match[8] && match[8].slice(1),
	    trim: match[9],
	    type: match[10]
	  });
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
	  this.align = specifier.align === undefined ? ">" : specifier.align + "";
	  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
	  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
	  this.zero = !!specifier.zero;
	  this.width = specifier.width === undefined ? undefined : +specifier.width;
	  this.comma = !!specifier.comma;
	  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
	  this.trim = !!specifier.trim;
	  this.type = specifier.type === undefined ? "" : specifier.type + "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	function formatTrim(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	}

	var prefixExponent;

	function formatPrefixAuto(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	}

	function formatRounded(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	}

	var formatTypes = {
	  "%": function(x, p) { return (x * 100).toFixed(p); },
	  "b": function(x) { return Math.round(x).toString(2); },
	  "c": function(x) { return x + ""; },
	  "d": function(x) { return Math.round(x).toString(10); },
	  "e": function(x, p) { return x.toExponential(p); },
	  "f": function(x, p) { return x.toFixed(p); },
	  "g": function(x, p) { return x.toPrecision(p); },
	  "o": function(x) { return Math.round(x).toString(8); },
	  "p": function(x, p) { return formatRounded(x * 100, p); },
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	  "x": function(x) { return Math.round(x).toString(16); }
	};

	function identity(x) {
	  return x;
	}

	var map = Array.prototype.map,
	    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

	function formatLocale(locale) {
	  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
	      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
	      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
	      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
	      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
	      percent = locale.percent === undefined ? "%" : locale.percent + "",
	      minus = locale.minus === undefined ? "-" : locale.minus + "",
	      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision === undefined ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
	        var valueNegative = value < 0 || 1 / value < 0;

	        // Perform the initial formatting.
	        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
	        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer “value” part that can be
	        // grouped, and fractional or exponential “suffix” part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	}

	var locale;

	defaultLocale({
	  decimal: ".",
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""],
	  minus: "-"
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.format = locale.format;
	  exports.formatPrefix = locale.formatPrefix;
	  return locale;
	}

	function precisionFixed(step) {
	  return Math.max(0, -exponent(Math.abs(step)));
	}

	function precisionPrefix(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	}

	function precisionRound(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent(max) - exponent(step)) + 1;
	}

	exports.FormatSpecifier = FormatSpecifier;
	exports.formatDefaultLocale = defaultLocale;
	exports.formatLocale = formatLocale;
	exports.formatSpecifier = formatSpecifier;
	exports.precisionFixed = precisionFixed;
	exports.precisionPrefix = precisionPrefix;
	exports.precisionRound = precisionRound;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-geo/ v1.11.9 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(29)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Array) { 'use strict';

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305–363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
	  return new Adder;
	}

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add(temp, y, this.t);
	    add(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var quarterPi = pi / 4;
	var tau = pi * 2;

	var degrees = 180 / pi;
	var radians = pi / 180;

	var abs = Math.abs;
	var atan = Math.atan;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var ceil = Math.ceil;
	var exp = Math.exp;
	var log = Math.log;
	var pow = Math.pow;
	var sin = Math.sin;
	var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
	var sqrt = Math.sqrt;
	var tan = Math.tan;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
	}

	function haversin(x) {
	  return (x = sin(x / 2)) * x;
	}

	function noop() {}

	function streamGeometry(geometry, stream) {
	  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
	    streamGeometryType[geometry.type](geometry, stream);
	  }
	}

	var streamObjectType = {
	  Feature: function(object, stream) {
	    streamGeometry(object.geometry, stream);
	  },
	  FeatureCollection: function(object, stream) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) streamGeometry(features[i].geometry, stream);
	  }
	};

	var streamGeometryType = {
	  Sphere: function(object, stream) {
	    stream.sphere();
	  },
	  Point: function(object, stream) {
	    object = object.coordinates;
	    stream.point(object[0], object[1], object[2]);
	  },
	  MultiPoint: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
	  },
	  LineString: function(object, stream) {
	    streamLine(object.coordinates, stream, 0);
	  },
	  MultiLineString: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamLine(coordinates[i], stream, 0);
	  },
	  Polygon: function(object, stream) {
	    streamPolygon(object.coordinates, stream);
	  },
	  MultiPolygon: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamPolygon(coordinates[i], stream);
	  },
	  GeometryCollection: function(object, stream) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) streamGeometry(geometries[i], stream);
	  }
	};

	function streamLine(coordinates, stream, closed) {
	  var i = -1, n = coordinates.length - closed, coordinate;
	  stream.lineStart();
	  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
	  stream.lineEnd();
	}

	function streamPolygon(coordinates, stream) {
	  var i = -1, n = coordinates.length;
	  stream.polygonStart();
	  while (++i < n) streamLine(coordinates[i], stream, 1);
	  stream.polygonEnd();
	}

	function geoStream(object, stream) {
	  if (object && streamObjectType.hasOwnProperty(object.type)) {
	    streamObjectType[object.type](object, stream);
	  } else {
	    streamGeometry(object, stream);
	  }
	}

	var areaRingSum = adder();

	var areaSum = adder(),
	    lambda00,
	    phi00,
	    lambda0,
	    cosPhi0,
	    sinPhi0;

	var areaStream = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaRingSum.reset();
	    areaStream.lineStart = areaRingStart;
	    areaStream.lineEnd = areaRingEnd;
	  },
	  polygonEnd: function() {
	    var areaRing = +areaRingSum;
	    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
	    this.lineStart = this.lineEnd = this.point = noop;
	  },
	  sphere: function() {
	    areaSum.add(tau);
	  }
	};

	function areaRingStart() {
	  areaStream.point = areaPointFirst;
	}

	function areaRingEnd() {
	  areaPoint(lambda00, phi00);
	}

	function areaPointFirst(lambda, phi) {
	  areaStream.point = areaPoint;
	  lambda00 = lambda, phi00 = phi;
	  lambda *= radians, phi *= radians;
	  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
	}

	function areaPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  phi = phi / 2 + quarterPi; // half the angular distance from south pole

	  // Spherical excess E for a spherical triangle with vertices: south pole,
	  // previous point, current point.  Uses a formula derived from Cagnoli’s
	  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
	  var dLambda = lambda - lambda0,
	      sdLambda = dLambda >= 0 ? 1 : -1,
	      adLambda = sdLambda * dLambda,
	      cosPhi = cos(phi),
	      sinPhi = sin(phi),
	      k = sinPhi0 * sinPhi,
	      u = cosPhi0 * cosPhi + k * cos(adLambda),
	      v = k * sdLambda * sin(adLambda);
	  areaRingSum.add(atan2(v, u));

	  // Advance the previous points.
	  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
	}

	function area(object) {
	  areaSum.reset();
	  geoStream(object, areaStream);
	  return areaSum * 2;
	}

	function spherical(cartesian) {
	  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
	}

	function cartesian(spherical) {
	  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
	  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
	}

	function cartesianDot(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	function cartesianCross(a, b) {
	  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	}

	// TODO return a
	function cartesianAddInPlace(a, b) {
	  a[0] += b[0], a[1] += b[1], a[2] += b[2];
	}

	function cartesianScale(vector, k) {
	  return [vector[0] * k, vector[1] * k, vector[2] * k];
	}

	// TODO return d
	function cartesianNormalizeInPlace(d) {
	  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	  d[0] /= l, d[1] /= l, d[2] /= l;
	}

	var lambda0$1, phi0, lambda1, phi1, // bounds
	    lambda2, // previous lambda-coordinate
	    lambda00$1, phi00$1, // first point
	    p0, // previous 3D point
	    deltaSum = adder(),
	    ranges,
	    range;

	var boundsStream = {
	  point: boundsPoint,
	  lineStart: boundsLineStart,
	  lineEnd: boundsLineEnd,
	  polygonStart: function() {
	    boundsStream.point = boundsRingPoint;
	    boundsStream.lineStart = boundsRingStart;
	    boundsStream.lineEnd = boundsRingEnd;
	    deltaSum.reset();
	    areaStream.polygonStart();
	  },
	  polygonEnd: function() {
	    areaStream.polygonEnd();
	    boundsStream.point = boundsPoint;
	    boundsStream.lineStart = boundsLineStart;
	    boundsStream.lineEnd = boundsLineEnd;
	    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	    else if (deltaSum > epsilon) phi1 = 90;
	    else if (deltaSum < -epsilon) phi0 = -90;
	    range[0] = lambda0$1, range[1] = lambda1;
	  },
	  sphere: function() {
	    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	  }
	};

	function boundsPoint(lambda, phi) {
	  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	}

	function linePoint(lambda, phi) {
	  var p = cartesian([lambda * radians, phi * radians]);
	  if (p0) {
	    var normal = cartesianCross(p0, p),
	        equatorial = [normal[1], -normal[0], 0],
	        inflection = cartesianCross(equatorial, normal);
	    cartesianNormalizeInPlace(inflection);
	    inflection = spherical(inflection);
	    var delta = lambda - lambda2,
	        sign = delta > 0 ? 1 : -1,
	        lambdai = inflection[0] * degrees * sign,
	        phii,
	        antimeridian = abs(delta) > 180;
	    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = inflection[1] * degrees;
	      if (phii > phi1) phi1 = phii;
	    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = -inflection[1] * degrees;
	      if (phii < phi0) phi0 = phii;
	    } else {
	      if (phi < phi0) phi0 = phi;
	      if (phi > phi1) phi1 = phi;
	    }
	    if (antimeridian) {
	      if (lambda < lambda2) {
	        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	      } else {
	        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	      }
	    } else {
	      if (lambda1 >= lambda0$1) {
	        if (lambda < lambda0$1) lambda0$1 = lambda;
	        if (lambda > lambda1) lambda1 = lambda;
	      } else {
	        if (lambda > lambda2) {
	          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	        } else {
	          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	        }
	      }
	    }
	  } else {
	    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
	  }
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	  p0 = p, lambda2 = lambda;
	}

	function boundsLineStart() {
	  boundsStream.point = linePoint;
	}

	function boundsLineEnd() {
	  range[0] = lambda0$1, range[1] = lambda1;
	  boundsStream.point = boundsPoint;
	  p0 = null;
	}

	function boundsRingPoint(lambda, phi) {
	  if (p0) {
	    var delta = lambda - lambda2;
	    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
	  } else {
	    lambda00$1 = lambda, phi00$1 = phi;
	  }
	  areaStream.point(lambda, phi);
	  linePoint(lambda, phi);
	}

	function boundsRingStart() {
	  areaStream.lineStart();
	}

	function boundsRingEnd() {
	  boundsRingPoint(lambda00$1, phi00$1);
	  areaStream.lineEnd();
	  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
	  range[0] = lambda0$1, range[1] = lambda1;
	  p0 = null;
	}

	// Finds the left-right distance between two longitudes.
	// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
	// the distance between ±180° to be 360°.
	function angle(lambda0, lambda1) {
	  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
	}

	function rangeCompare(a, b) {
	  return a[0] - b[0];
	}

	function rangeContains(range, x) {
	  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	}

	function bounds(feature) {
	  var i, n, a, b, merged, deltaMax, delta;

	  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
	  ranges = [];
	  geoStream(feature, boundsStream);

	  // First, sort ranges by their minimum longitudes.
	  if (n = ranges.length) {
	    ranges.sort(rangeCompare);

	    // Then, merge any ranges that overlap.
	    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
	      b = ranges[i];
	      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
	        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	      } else {
	        merged.push(a = b);
	      }
	    }

	    // Finally, find the largest gap between the merged ranges.
	    // The final bounding box will be the inverse of this gap.
	    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
	      b = merged[i];
	      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
	    }
	  }

	  ranges = range = null;

	  return lambda0$1 === Infinity || phi0 === Infinity
	      ? [[NaN, NaN], [NaN, NaN]]
	      : [[lambda0$1, phi0], [lambda1, phi1]];
	}

	var W0, W1,
	    X0, Y0, Z0,
	    X1, Y1, Z1,
	    X2, Y2, Z2,
	    lambda00$2, phi00$2, // first point
	    x0, y0, z0; // previous point

	var centroidStream = {
	  sphere: noop,
	  point: centroidPoint,
	  lineStart: centroidLineStart,
	  lineEnd: centroidLineEnd,
	  polygonStart: function() {
	    centroidStream.lineStart = centroidRingStart;
	    centroidStream.lineEnd = centroidRingEnd;
	  },
	  polygonEnd: function() {
	    centroidStream.lineStart = centroidLineStart;
	    centroidStream.lineEnd = centroidLineEnd;
	  }
	};

	// Arithmetic mean of Cartesian vectors.
	function centroidPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
	}

	function centroidPointCartesian(x, y, z) {
	  ++W0;
	  X0 += (x - X0) / W0;
	  Y0 += (y - Y0) / W0;
	  Z0 += (z - Z0) / W0;
	}

	function centroidLineStart() {
	  centroidStream.point = centroidLinePointFirst;
	}

	function centroidLinePointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidStream.point = centroidLinePoint;
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLinePoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLineEnd() {
	  centroidStream.point = centroidPoint;
	}

	// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
	// J. Applied Mechanics 42, 239 (1975).
	function centroidRingStart() {
	  centroidStream.point = centroidRingPointFirst;
	}

	function centroidRingEnd() {
	  centroidRingPoint(lambda00$2, phi00$2);
	  centroidStream.point = centroidPoint;
	}

	function centroidRingPointFirst(lambda, phi) {
	  lambda00$2 = lambda, phi00$2 = phi;
	  lambda *= radians, phi *= radians;
	  centroidStream.point = centroidRingPoint;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidRingPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      cx = y0 * z - z0 * y,
	      cy = z0 * x - x0 * z,
	      cz = x0 * y - y0 * x,
	      m = sqrt(cx * cx + cy * cy + cz * cz),
	      w = asin(m), // line weight = angle
	      v = m && -w / m; // area weight multiplier
	  X2 += v * cx;
	  Y2 += v * cy;
	  Z2 += v * cz;
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroid(object) {
	  W0 = W1 =
	  X0 = Y0 = Z0 =
	  X1 = Y1 = Z1 =
	  X2 = Y2 = Z2 = 0;
	  geoStream(object, centroidStream);

	  var x = X2,
	      y = Y2,
	      z = Z2,
	      m = x * x + y * y + z * z;

	  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
	  if (m < epsilon2) {
	    x = X1, y = Y1, z = Z1;
	    // If the feature has zero length, fall back to arithmetic mean of point vectors.
	    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
	    m = x * x + y * y + z * z;
	    // If the feature still has an undefined ccentroid, then return.
	    if (m < epsilon2) return [NaN, NaN];
	  }

	  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function compose(a, b) {

	  function compose(x, y) {
	    return x = a(x, y), b(x[0], x[1]);
	  }

	  if (a.invert && b.invert) compose.invert = function(x, y) {
	    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	  };

	  return compose;
	}

	function rotationIdentity(lambda, phi) {
	  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
	  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
	    : rotationLambda(deltaLambda))
	    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
	    : rotationIdentity);
	}

	function forwardRotationLambda(deltaLambda) {
	  return function(lambda, phi) {
	    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	  };
	}

	function rotationLambda(deltaLambda) {
	  var rotation = forwardRotationLambda(deltaLambda);
	  rotation.invert = forwardRotationLambda(-deltaLambda);
	  return rotation;
	}

	function rotationPhiGamma(deltaPhi, deltaGamma) {
	  var cosDeltaPhi = cos(deltaPhi),
	      sinDeltaPhi = sin(deltaPhi),
	      cosDeltaGamma = cos(deltaGamma),
	      sinDeltaGamma = sin(deltaGamma);

	  function rotation(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaPhi + x * sinDeltaPhi;
	    return [
	      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
	      asin(k * cosDeltaGamma + y * sinDeltaGamma)
	    ];
	  }

	  rotation.invert = function(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaGamma - y * sinDeltaGamma;
	    return [
	      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
	      asin(k * cosDeltaPhi - x * sinDeltaPhi)
	    ];
	  };

	  return rotation;
	}

	function rotation(rotate) {
	  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

	  function forward(coordinates) {
	    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  }

	  forward.invert = function(coordinates) {
	    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  };

	  return forward;
	}

	// Generates a circle centered at [0°, 0°], with a given radius and precision.
	function circleStream(stream, radius, delta, direction, t0, t1) {
	  if (!delta) return;
	  var cosRadius = cos(radius),
	      sinRadius = sin(radius),
	      step = direction * delta;
	  if (t0 == null) {
	    t0 = radius + direction * tau;
	    t1 = radius - step / 2;
	  } else {
	    t0 = circleRadius(cosRadius, t0);
	    t1 = circleRadius(cosRadius, t1);
	    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
	  }
	  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
	    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
	    stream.point(point[0], point[1]);
	  }
	}

	// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
	function circleRadius(cosRadius, point) {
	  point = cartesian(point), point[0] -= cosRadius;
	  cartesianNormalizeInPlace(point);
	  var radius = acos(-point[1]);
	  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
	}

	function circle() {
	  var center = constant([0, 0]),
	      radius = constant(90),
	      precision = constant(6),
	      ring,
	      rotate,
	      stream = {point: point};

	  function point(x, y) {
	    ring.push(x = rotate(x, y));
	    x[0] *= degrees, x[1] *= degrees;
	  }

	  function circle() {
	    var c = center.apply(this, arguments),
	        r = radius.apply(this, arguments) * radians,
	        p = precision.apply(this, arguments) * radians;
	    ring = [];
	    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
	    circleStream(stream, r, p, 1);
	    c = {type: "Polygon", coordinates: [ring]};
	    ring = rotate = null;
	    return c;
	  }

	  circle.center = function(_) {
	    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
	  };

	  circle.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
	  };

	  circle.precision = function(_) {
	    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
	  };

	  return circle;
	}

	function clipBuffer() {
	  var lines = [],
	      line;
	  return {
	    point: function(x, y) {
	      line.push([x, y]);
	    },
	    lineStart: function() {
	      lines.push(line = []);
	    },
	    lineEnd: noop,
	    rejoin: function() {
	      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	    },
	    result: function() {
	      var result = lines;
	      lines = [];
	      line = null;
	      return result;
	    }
	  };
	}

	function pointEqual(a, b) {
	  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
	}

	function Intersection(point, points, other, entry) {
	  this.x = point;
	  this.z = points;
	  this.o = other; // another intersection
	  this.e = entry; // is an entry?
	  this.v = false; // visited
	  this.n = this.p = null; // next & previous
	}

	// A generalized polygon clipping algorithm: given a polygon that has been cut
	// into its visible line segments, and rejoins the segments by interpolating
	// along the clip edge.
	function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
	  var subject = [],
	      clip = [],
	      i,
	      n;

	  segments.forEach(function(segment) {
	    if ((n = segment.length - 1) <= 0) return;
	    var n, p0 = segment[0], p1 = segment[n], x;

	    // If the first and last points of a segment are coincident, then treat as a
	    // closed ring. TODO if all rings are closed, then the winding order of the
	    // exterior ring should be checked.
	    if (pointEqual(p0, p1)) {
	      stream.lineStart();
	      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
	      stream.lineEnd();
	      return;
	    }

	    subject.push(x = new Intersection(p0, segment, null, true));
	    clip.push(x.o = new Intersection(p0, null, x, false));
	    subject.push(x = new Intersection(p1, segment, null, false));
	    clip.push(x.o = new Intersection(p1, null, x, true));
	  });

	  if (!subject.length) return;

	  clip.sort(compareIntersection);
	  link(subject);
	  link(clip);

	  for (i = 0, n = clip.length; i < n; ++i) {
	    clip[i].e = startInside = !startInside;
	  }

	  var start = subject[0],
	      points,
	      point;

	  while (1) {
	    // Find first unvisited intersection.
	    var current = start,
	        isSubject = true;
	    while (current.v) if ((current = current.n) === start) return;
	    points = current.z;
	    stream.lineStart();
	    do {
	      current.v = current.o.v = true;
	      if (current.e) {
	        if (isSubject) {
	          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.n.x, 1, stream);
	        }
	        current = current.n;
	      } else {
	        if (isSubject) {
	          points = current.p.z;
	          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.p.x, -1, stream);
	        }
	        current = current.p;
	      }
	      current = current.o;
	      points = current.z;
	      isSubject = !isSubject;
	    } while (!current.v);
	    stream.lineEnd();
	  }
	}

	function link(array) {
	  if (!(n = array.length)) return;
	  var n,
	      i = 0,
	      a = array[0],
	      b;
	  while (++i < n) {
	    a.n = b = array[i];
	    b.p = a;
	    a = b;
	  }
	  a.n = b = array[0];
	  b.p = a;
	}

	var sum = adder();

	function longitude(point) {
	  if (abs(point[0]) <= pi)
	    return point[0];
	  else
	    return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
	}

	function polygonContains(polygon, point) {
	  var lambda = longitude(point),
	      phi = point[1],
	      sinPhi = sin(phi),
	      normal = [sin(lambda), -cos(lambda), 0],
	      angle = 0,
	      winding = 0;

	  sum.reset();

	  if (sinPhi === 1) phi = halfPi + epsilon;
	  else if (sinPhi === -1) phi = -halfPi - epsilon;

	  for (var i = 0, n = polygon.length; i < n; ++i) {
	    if (!(m = (ring = polygon[i]).length)) continue;
	    var ring,
	        m,
	        point0 = ring[m - 1],
	        lambda0 = longitude(point0),
	        phi0 = point0[1] / 2 + quarterPi,
	        sinPhi0 = sin(phi0),
	        cosPhi0 = cos(phi0);

	    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
	      var point1 = ring[j],
	          lambda1 = longitude(point1),
	          phi1 = point1[1] / 2 + quarterPi,
	          sinPhi1 = sin(phi1),
	          cosPhi1 = cos(phi1),
	          delta = lambda1 - lambda0,
	          sign = delta >= 0 ? 1 : -1,
	          absDelta = sign * delta,
	          antimeridian = absDelta > pi,
	          k = sinPhi0 * sinPhi1;

	      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
	      angle += antimeridian ? delta + sign * tau : delta;

	      // Are the longitudes either side of the point’s meridian (lambda),
	      // and are the latitudes smaller than the parallel (phi)?
	      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
	        var arc = cartesianCross(cartesian(point0), cartesian(point1));
	        cartesianNormalizeInPlace(arc);
	        var intersection = cartesianCross(normal, arc);
	        cartesianNormalizeInPlace(intersection);
	        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
	        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
	          winding += antimeridian ^ delta >= 0 ? 1 : -1;
	        }
	      }
	    }
	  }

	  // First, determine whether the South pole is inside or outside:
	  //
	  // It is inside if:
	  // * the polygon winds around it in a clockwise direction.
	  // * the polygon does not (cumulatively) wind around it, but has a negative
	  //   (counter-clockwise) area.
	  //
	  // Second, count the (signed) number of times a segment crosses a lambda
	  // from the point to the South pole.  If it is zero, then the point is the
	  // same side as the South pole.

	  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
	}

	function clip(pointVisible, clipLine, interpolate, start) {
	  return function(sink) {
	    var line = clipLine(sink),
	        ringBuffer = clipBuffer(),
	        ringSink = clipLine(ringBuffer),
	        polygonStarted = false,
	        polygon,
	        segments,
	        ring;

	    var clip = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        clip.point = pointRing;
	        clip.lineStart = ringStart;
	        clip.lineEnd = ringEnd;
	        segments = [];
	        polygon = [];
	      },
	      polygonEnd: function() {
	        clip.point = point;
	        clip.lineStart = lineStart;
	        clip.lineEnd = lineEnd;
	        segments = d3Array.merge(segments);
	        var startInside = polygonContains(polygon, start);
	        if (segments.length) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
	        } else if (startInside) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          interpolate(null, null, 1, sink);
	          sink.lineEnd();
	        }
	        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
	        segments = polygon = null;
	      },
	      sphere: function() {
	        sink.polygonStart();
	        sink.lineStart();
	        interpolate(null, null, 1, sink);
	        sink.lineEnd();
	        sink.polygonEnd();
	      }
	    };

	    function point(lambda, phi) {
	      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
	    }

	    function pointLine(lambda, phi) {
	      line.point(lambda, phi);
	    }

	    function lineStart() {
	      clip.point = pointLine;
	      line.lineStart();
	    }

	    function lineEnd() {
	      clip.point = point;
	      line.lineEnd();
	    }

	    function pointRing(lambda, phi) {
	      ring.push([lambda, phi]);
	      ringSink.point(lambda, phi);
	    }

	    function ringStart() {
	      ringSink.lineStart();
	      ring = [];
	    }

	    function ringEnd() {
	      pointRing(ring[0][0], ring[0][1]);
	      ringSink.lineEnd();

	      var clean = ringSink.clean(),
	          ringSegments = ringBuffer.result(),
	          i, n = ringSegments.length, m,
	          segment,
	          point;

	      ring.pop();
	      polygon.push(ring);
	      ring = null;

	      if (!n) return;

	      // No intersections.
	      if (clean & 1) {
	        segment = ringSegments[0];
	        if ((m = segment.length - 1) > 0) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
	          sink.lineEnd();
	        }
	        return;
	      }

	      // Rejoin connected segments.
	      // TODO reuse ringBuffer.rejoin()?
	      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

	      segments.push(ringSegments.filter(validSegment));
	    }

	    return clip;
	  };
	}

	function validSegment(segment) {
	  return segment.length > 1;
	}

	// Intersections are sorted along the clip edge. For both antimeridian cutting
	// and circle clipping, the same comparison is used.
	function compareIntersection(a, b) {
	  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
	       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
	}

	var clipAntimeridian = clip(
	  function() { return true; },
	  clipAntimeridianLine,
	  clipAntimeridianInterpolate,
	  [-pi, -halfPi]
	);

	// Takes a line and cuts into visible segments. Return values: 0 - there were
	// intersections or the line was empty; 1 - no intersections; 2 - there were
	// intersections, and the first and last segments should be rejoined.
	function clipAntimeridianLine(stream) {
	  var lambda0 = NaN,
	      phi0 = NaN,
	      sign0 = NaN,
	      clean; // no intersections

	  return {
	    lineStart: function() {
	      stream.lineStart();
	      clean = 1;
	    },
	    point: function(lambda1, phi1) {
	      var sign1 = lambda1 > 0 ? pi : -pi,
	          delta = abs(lambda1 - lambda0);
	      if (abs(delta - pi) < epsilon) { // line crosses a pole
	        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        stream.point(lambda1, phi0);
	        clean = 0;
	      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
	        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
	        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
	        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        clean = 0;
	      }
	      stream.point(lambda0 = lambda1, phi0 = phi1);
	      sign0 = sign1;
	    },
	    lineEnd: function() {
	      stream.lineEnd();
	      lambda0 = phi0 = NaN;
	    },
	    clean: function() {
	      return 2 - clean; // if intersections, rejoin first and last segments
	    }
	  };
	}

	function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
	  var cosPhi0,
	      cosPhi1,
	      sinLambda0Lambda1 = sin(lambda0 - lambda1);
	  return abs(sinLambda0Lambda1) > epsilon
	      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
	          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
	          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
	      : (phi0 + phi1) / 2;
	}

	function clipAntimeridianInterpolate(from, to, direction, stream) {
	  var phi;
	  if (from == null) {
	    phi = direction * halfPi;
	    stream.point(-pi, phi);
	    stream.point(0, phi);
	    stream.point(pi, phi);
	    stream.point(pi, 0);
	    stream.point(pi, -phi);
	    stream.point(0, -phi);
	    stream.point(-pi, -phi);
	    stream.point(-pi, 0);
	    stream.point(-pi, phi);
	  } else if (abs(from[0] - to[0]) > epsilon) {
	    var lambda = from[0] < to[0] ? pi : -pi;
	    phi = direction * lambda / 2;
	    stream.point(-lambda, phi);
	    stream.point(0, phi);
	    stream.point(lambda, phi);
	  } else {
	    stream.point(to[0], to[1]);
	  }
	}

	function clipCircle(radius) {
	  var cr = cos(radius),
	      delta = 6 * radians,
	      smallRadius = cr > 0,
	      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

	  function interpolate(from, to, direction, stream) {
	    circleStream(stream, radius, delta, direction, from, to);
	  }

	  function visible(lambda, phi) {
	    return cos(lambda) * cos(phi) > cr;
	  }

	  // Takes a line and cuts into visible segments. Return values used for polygon
	  // clipping: 0 - there were intersections or the line was empty; 1 - no
	  // intersections 2 - there were intersections, and the first and last segments
	  // should be rejoined.
	  function clipLine(stream) {
	    var point0, // previous point
	        c0, // code for previous point
	        v0, // visibility of previous point
	        v00, // visibility of first point
	        clean; // no intersections
	    return {
	      lineStart: function() {
	        v00 = v0 = false;
	        clean = 1;
	      },
	      point: function(lambda, phi) {
	        var point1 = [lambda, phi],
	            point2,
	            v = visible(lambda, phi),
	            c = smallRadius
	              ? v ? 0 : code(lambda, phi)
	              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
	        if (!point0 && (v00 = v0 = v)) stream.lineStart();
	        // Handle degeneracies.
	        // TODO ignore if not clipping polygons.
	        if (v !== v0) {
	          point2 = intersect(point0, point1);
	          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
	            point1[0] += epsilon;
	            point1[1] += epsilon;
	            v = visible(point1[0], point1[1]);
	          }
	        }
	        if (v !== v0) {
	          clean = 0;
	          if (v) {
	            // outside going in
	            stream.lineStart();
	            point2 = intersect(point1, point0);
	            stream.point(point2[0], point2[1]);
	          } else {
	            // inside going out
	            point2 = intersect(point0, point1);
	            stream.point(point2[0], point2[1]);
	            stream.lineEnd();
	          }
	          point0 = point2;
	        } else if (notHemisphere && point0 && smallRadius ^ v) {
	          var t;
	          // If the codes for two points are different, or are both zero,
	          // and there this segment intersects with the small circle.
	          if (!(c & c0) && (t = intersect(point1, point0, true))) {
	            clean = 0;
	            if (smallRadius) {
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	            } else {
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	            }
	          }
	        }
	        if (v && (!point0 || !pointEqual(point0, point1))) {
	          stream.point(point1[0], point1[1]);
	        }
	        point0 = point1, v0 = v, c0 = c;
	      },
	      lineEnd: function() {
	        if (v0) stream.lineEnd();
	        point0 = null;
	      },
	      // Rejoin first and last segments if there were intersections and the first
	      // and last points were visible.
	      clean: function() {
	        return clean | ((v00 && v0) << 1);
	      }
	    };
	  }

	  // Intersects the great circle between a and b with the clip circle.
	  function intersect(a, b, two) {
	    var pa = cartesian(a),
	        pb = cartesian(b);

	    // We have two planes, n1.p = d1 and n2.p = d2.
	    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
	    var n1 = [1, 0, 0], // normal
	        n2 = cartesianCross(pa, pb),
	        n2n2 = cartesianDot(n2, n2),
	        n1n2 = n2[0], // cartesianDot(n1, n2),
	        determinant = n2n2 - n1n2 * n1n2;

	    // Two polar points.
	    if (!determinant) return !two && a;

	    var c1 =  cr * n2n2 / determinant,
	        c2 = -cr * n1n2 / determinant,
	        n1xn2 = cartesianCross(n1, n2),
	        A = cartesianScale(n1, c1),
	        B = cartesianScale(n2, c2);
	    cartesianAddInPlace(A, B);

	    // Solve |p(t)|^2 = 1.
	    var u = n1xn2,
	        w = cartesianDot(A, u),
	        uu = cartesianDot(u, u),
	        t2 = w * w - uu * (cartesianDot(A, A) - 1);

	    if (t2 < 0) return;

	    var t = sqrt(t2),
	        q = cartesianScale(u, (-w - t) / uu);
	    cartesianAddInPlace(q, A);
	    q = spherical(q);

	    if (!two) return q;

	    // Two intersection points.
	    var lambda0 = a[0],
	        lambda1 = b[0],
	        phi0 = a[1],
	        phi1 = b[1],
	        z;

	    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

	    var delta = lambda1 - lambda0,
	        polar = abs(delta - pi) < epsilon,
	        meridian = polar || delta < epsilon;

	    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

	    // Check that the first point is between a and b.
	    if (meridian
	        ? polar
	          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
	          : phi0 <= q[1] && q[1] <= phi1
	        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
	      var q1 = cartesianScale(u, (-w + t) / uu);
	      cartesianAddInPlace(q1, A);
	      return [q, spherical(q1)];
	    }
	  }

	  // Generates a 4-bit vector representing the location of a point relative to
	  // the small circle's bounding box.
	  function code(lambda, phi) {
	    var r = smallRadius ? radius : pi - radius,
	        code = 0;
	    if (lambda < -r) code |= 1; // left
	    else if (lambda > r) code |= 2; // right
	    if (phi < -r) code |= 4; // below
	    else if (phi > r) code |= 8; // above
	    return code;
	  }

	  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
	}

	function clipLine(a, b, x0, y0, x1, y1) {
	  var ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
	  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
	  return true;
	}

	var clipMax = 1e9, clipMin = -clipMax;

	// TODO Use d3-polygon’s polygonContains here for the ring check?
	// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

	function clipRectangle(x0, y0, x1, y1) {

	  function visible(x, y) {
	    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	  }

	  function interpolate(from, to, direction, stream) {
	    var a = 0, a1 = 0;
	    if (from == null
	        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
	        || comparePoint(from, to) < 0 ^ direction > 0) {
	      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	      while ((a = (a + direction + 4) % 4) !== a1);
	    } else {
	      stream.point(to[0], to[1]);
	    }
	  }

	  function corner(p, direction) {
	    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
	        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
	        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
	        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
	  }

	  function compareIntersection(a, b) {
	    return comparePoint(a.x, b.x);
	  }

	  function comparePoint(a, b) {
	    var ca = corner(a, 1),
	        cb = corner(b, 1);
	    return ca !== cb ? ca - cb
	        : ca === 0 ? b[1] - a[1]
	        : ca === 1 ? a[0] - b[0]
	        : ca === 2 ? a[1] - b[1]
	        : b[0] - a[0];
	  }

	  return function(stream) {
	    var activeStream = stream,
	        bufferStream = clipBuffer(),
	        segments,
	        polygon,
	        ring,
	        x__, y__, v__, // first point
	        x_, y_, v_, // previous point
	        first,
	        clean;

	    var clipStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: polygonStart,
	      polygonEnd: polygonEnd
	    };

	    function point(x, y) {
	      if (visible(x, y)) activeStream.point(x, y);
	    }

	    function polygonInside() {
	      var winding = 0;

	      for (var i = 0, n = polygon.length; i < n; ++i) {
	        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
	          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
	          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
	          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
	        }
	      }

	      return winding;
	    }

	    // Buffer geometry within a polygon and then clip it en masse.
	    function polygonStart() {
	      activeStream = bufferStream, segments = [], polygon = [], clean = true;
	    }

	    function polygonEnd() {
	      var startInside = polygonInside(),
	          cleanInside = clean && startInside,
	          visible = (segments = d3Array.merge(segments)).length;
	      if (cleanInside || visible) {
	        stream.polygonStart();
	        if (cleanInside) {
	          stream.lineStart();
	          interpolate(null, null, 1, stream);
	          stream.lineEnd();
	        }
	        if (visible) {
	          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
	        }
	        stream.polygonEnd();
	      }
	      activeStream = stream, segments = polygon = ring = null;
	    }

	    function lineStart() {
	      clipStream.point = linePoint;
	      if (polygon) polygon.push(ring = []);
	      first = true;
	      v_ = false;
	      x_ = y_ = NaN;
	    }

	    // TODO rather than special-case polygons, simply handle them separately.
	    // Ideally, coincident intersection points should be jittered to avoid
	    // clipping issues.
	    function lineEnd() {
	      if (segments) {
	        linePoint(x__, y__);
	        if (v__ && v_) bufferStream.rejoin();
	        segments.push(bufferStream.result());
	      }
	      clipStream.point = point;
	      if (v_) activeStream.lineEnd();
	    }

	    function linePoint(x, y) {
	      var v = visible(x, y);
	      if (polygon) ring.push([x, y]);
	      if (first) {
	        x__ = x, y__ = y, v__ = v;
	        first = false;
	        if (v) {
	          activeStream.lineStart();
	          activeStream.point(x, y);
	        }
	      } else {
	        if (v && v_) activeStream.point(x, y);
	        else {
	          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
	              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
	          if (clipLine(a, b, x0, y0, x1, y1)) {
	            if (!v_) {
	              activeStream.lineStart();
	              activeStream.point(a[0], a[1]);
	            }
	            activeStream.point(b[0], b[1]);
	            if (!v) activeStream.lineEnd();
	            clean = false;
	          } else if (v) {
	            activeStream.lineStart();
	            activeStream.point(x, y);
	            clean = false;
	          }
	        }
	      }
	      x_ = x, y_ = y, v_ = v;
	    }

	    return clipStream;
	  };
	}

	function extent() {
	  var x0 = 0,
	      y0 = 0,
	      x1 = 960,
	      y1 = 500,
	      cache,
	      cacheStream,
	      clip;

	  return clip = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
	    },
	    extent: function(_) {
	      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
	    }
	  };
	}

	var lengthSum = adder(),
	    lambda0$2,
	    sinPhi0$1,
	    cosPhi0$1;

	var lengthStream = {
	  sphere: noop,
	  point: noop,
	  lineStart: lengthLineStart,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop
	};

	function lengthLineStart() {
	  lengthStream.point = lengthPointFirst;
	  lengthStream.lineEnd = lengthLineEnd;
	}

	function lengthLineEnd() {
	  lengthStream.point = lengthStream.lineEnd = noop;
	}

	function lengthPointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
	  lengthStream.point = lengthPoint;
	}

	function lengthPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var sinPhi = sin(phi),
	      cosPhi = cos(phi),
	      delta = abs(lambda - lambda0$2),
	      cosDelta = cos(delta),
	      sinDelta = sin(delta),
	      x = cosPhi * sinDelta,
	      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
	      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
	  lengthSum.add(atan2(sqrt(x * x + y * y), z));
	  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
	}

	function length(object) {
	  lengthSum.reset();
	  geoStream(object, lengthStream);
	  return +lengthSum;
	}

	var coordinates = [null, null],
	    object = {type: "LineString", coordinates: coordinates};

	function distance(a, b) {
	  coordinates[0] = a;
	  coordinates[1] = b;
	  return length(object);
	}

	var containsObjectType = {
	  Feature: function(object, point) {
	    return containsGeometry(object.geometry, point);
	  },
	  FeatureCollection: function(object, point) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
	    return false;
	  }
	};

	var containsGeometryType = {
	  Sphere: function() {
	    return true;
	  },
	  Point: function(object, point) {
	    return containsPoint(object.coordinates, point);
	  },
	  MultiPoint: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
	    return false;
	  },
	  LineString: function(object, point) {
	    return containsLine(object.coordinates, point);
	  },
	  MultiLineString: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsLine(coordinates[i], point)) return true;
	    return false;
	  },
	  Polygon: function(object, point) {
	    return containsPolygon(object.coordinates, point);
	  },
	  MultiPolygon: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
	    return false;
	  },
	  GeometryCollection: function(object, point) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
	    return false;
	  }
	};

	function containsGeometry(geometry, point) {
	  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
	      ? containsGeometryType[geometry.type](geometry, point)
	      : false;
	}

	function containsPoint(coordinates, point) {
	  return distance(coordinates, point) === 0;
	}

	function containsLine(coordinates, point) {
	  var ao, bo, ab;
	  for (var i = 0, n = coordinates.length; i < n; i++) {
	    bo = distance(coordinates[i], point);
	    if (bo === 0) return true;
	    if (i > 0) {
	      ab = distance(coordinates[i], coordinates[i - 1]);
	      if (
	        ab > 0 &&
	        ao <= ab &&
	        bo <= ab &&
	        (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
	      )
	        return true;
	    }
	    ao = bo;
	  }
	  return false;
	}

	function containsPolygon(coordinates, point) {
	  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
	}

	function ringRadians(ring) {
	  return ring = ring.map(pointRadians), ring.pop(), ring;
	}

	function pointRadians(point) {
	  return [point[0] * radians, point[1] * radians];
	}

	function contains(object, point) {
	  return (object && containsObjectType.hasOwnProperty(object.type)
	      ? containsObjectType[object.type]
	      : containsGeometry)(object, point);
	}

	function graticuleX(y0, y1, dy) {
	  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
	  return function(x) { return y.map(function(y) { return [x, y]; }); };
	}

	function graticuleY(x0, x1, dx) {
	  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
	  return function(y) { return x.map(function(x) { return [x, y]; }); };
	}

	function graticule() {
	  var x1, x0, X1, X0,
	      y1, y0, Y1, Y0,
	      dx = 10, dy = dx, DX = 90, DY = 360,
	      x, y, X, Y,
	      precision = 2.5;

	  function graticule() {
	    return {type: "MultiLineString", coordinates: lines()};
	  }

	  function lines() {
	    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
	        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
	        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
	        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
	  }

	  graticule.lines = function() {
	    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
	  };

	  graticule.outline = function() {
	    return {
	      type: "Polygon",
	      coordinates: [
	        X(X0).concat(
	        Y(Y1).slice(1),
	        X(X1).reverse().slice(1),
	        Y(Y0).reverse().slice(1))
	      ]
	    };
	  };

	  graticule.extent = function(_) {
	    if (!arguments.length) return graticule.extentMinor();
	    return graticule.extentMajor(_).extentMinor(_);
	  };

	  graticule.extentMajor = function(_) {
	    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
	    X0 = +_[0][0], X1 = +_[1][0];
	    Y0 = +_[0][1], Y1 = +_[1][1];
	    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.extentMinor = function(_) {
	    if (!arguments.length) return [[x0, y0], [x1, y1]];
	    x0 = +_[0][0], x1 = +_[1][0];
	    y0 = +_[0][1], y1 = +_[1][1];
	    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.step = function(_) {
	    if (!arguments.length) return graticule.stepMinor();
	    return graticule.stepMajor(_).stepMinor(_);
	  };

	  graticule.stepMajor = function(_) {
	    if (!arguments.length) return [DX, DY];
	    DX = +_[0], DY = +_[1];
	    return graticule;
	  };

	  graticule.stepMinor = function(_) {
	    if (!arguments.length) return [dx, dy];
	    dx = +_[0], dy = +_[1];
	    return graticule;
	  };

	  graticule.precision = function(_) {
	    if (!arguments.length) return precision;
	    precision = +_;
	    x = graticuleX(y0, y1, 90);
	    y = graticuleY(x0, x1, precision);
	    X = graticuleX(Y0, Y1, 90);
	    Y = graticuleY(X0, X1, precision);
	    return graticule;
	  };

	  return graticule
	      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
	      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
	}

	function graticule10() {
	  return graticule()();
	}

	function interpolate(a, b) {
	  var x0 = a[0] * radians,
	      y0 = a[1] * radians,
	      x1 = b[0] * radians,
	      y1 = b[1] * radians,
	      cy0 = cos(y0),
	      sy0 = sin(y0),
	      cy1 = cos(y1),
	      sy1 = sin(y1),
	      kx0 = cy0 * cos(x0),
	      ky0 = cy0 * sin(x0),
	      kx1 = cy1 * cos(x1),
	      ky1 = cy1 * sin(x1),
	      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
	      k = sin(d);

	  var interpolate = d ? function(t) {
	    var B = sin(t *= d) / k,
	        A = sin(d - t) / k,
	        x = A * kx0 + B * kx1,
	        y = A * ky0 + B * ky1,
	        z = A * sy0 + B * sy1;
	    return [
	      atan2(y, x) * degrees,
	      atan2(z, sqrt(x * x + y * y)) * degrees
	    ];
	  } : function() {
	    return [x0 * degrees, y0 * degrees];
	  };

	  interpolate.distance = d;

	  return interpolate;
	}

	function identity(x) {
	  return x;
	}

	var areaSum$1 = adder(),
	    areaRingSum$1 = adder(),
	    x00,
	    y00,
	    x0$1,
	    y0$1;

	var areaStream$1 = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaStream$1.lineStart = areaRingStart$1;
	    areaStream$1.lineEnd = areaRingEnd$1;
	  },
	  polygonEnd: function() {
	    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
	    areaSum$1.add(abs(areaRingSum$1));
	    areaRingSum$1.reset();
	  },
	  result: function() {
	    var area = areaSum$1 / 2;
	    areaSum$1.reset();
	    return area;
	  }
	};

	function areaRingStart$1() {
	  areaStream$1.point = areaPointFirst$1;
	}

	function areaPointFirst$1(x, y) {
	  areaStream$1.point = areaPoint$1;
	  x00 = x0$1 = x, y00 = y0$1 = y;
	}

	function areaPoint$1(x, y) {
	  areaRingSum$1.add(y0$1 * x - x0$1 * y);
	  x0$1 = x, y0$1 = y;
	}

	function areaRingEnd$1() {
	  areaPoint$1(x00, y00);
	}

	var x0$2 = Infinity,
	    y0$2 = x0$2,
	    x1 = -x0$2,
	    y1 = x1;

	var boundsStream$1 = {
	  point: boundsPoint$1,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop,
	  result: function() {
	    var bounds = [[x0$2, y0$2], [x1, y1]];
	    x1 = y1 = -(y0$2 = x0$2 = Infinity);
	    return bounds;
	  }
	};

	function boundsPoint$1(x, y) {
	  if (x < x0$2) x0$2 = x;
	  if (x > x1) x1 = x;
	  if (y < y0$2) y0$2 = y;
	  if (y > y1) y1 = y;
	}

	// TODO Enforce positive area for exterior, negative area for interior?

	var X0$1 = 0,
	    Y0$1 = 0,
	    Z0$1 = 0,
	    X1$1 = 0,
	    Y1$1 = 0,
	    Z1$1 = 0,
	    X2$1 = 0,
	    Y2$1 = 0,
	    Z2$1 = 0,
	    x00$1,
	    y00$1,
	    x0$3,
	    y0$3;

	var centroidStream$1 = {
	  point: centroidPoint$1,
	  lineStart: centroidLineStart$1,
	  lineEnd: centroidLineEnd$1,
	  polygonStart: function() {
	    centroidStream$1.lineStart = centroidRingStart$1;
	    centroidStream$1.lineEnd = centroidRingEnd$1;
	  },
	  polygonEnd: function() {
	    centroidStream$1.point = centroidPoint$1;
	    centroidStream$1.lineStart = centroidLineStart$1;
	    centroidStream$1.lineEnd = centroidLineEnd$1;
	  },
	  result: function() {
	    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
	        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
	        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
	        : [NaN, NaN];
	    X0$1 = Y0$1 = Z0$1 =
	    X1$1 = Y1$1 = Z1$1 =
	    X2$1 = Y2$1 = Z2$1 = 0;
	    return centroid;
	  }
	};

	function centroidPoint$1(x, y) {
	  X0$1 += x;
	  Y0$1 += y;
	  ++Z0$1;
	}

	function centroidLineStart$1() {
	  centroidStream$1.point = centroidPointFirstLine;
	}

	function centroidPointFirstLine(x, y) {
	  centroidStream$1.point = centroidPointLine;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidPointLine(x, y) {
	  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidLineEnd$1() {
	  centroidStream$1.point = centroidPoint$1;
	}

	function centroidRingStart$1() {
	  centroidStream$1.point = centroidPointFirstRing;
	}

	function centroidRingEnd$1() {
	  centroidPointRing(x00$1, y00$1);
	}

	function centroidPointFirstRing(x, y) {
	  centroidStream$1.point = centroidPointRing;
	  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
	}

	function centroidPointRing(x, y) {
	  var dx = x - x0$3,
	      dy = y - y0$3,
	      z = sqrt(dx * dx + dy * dy);

	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;

	  z = y0$3 * x - x0$3 * y;
	  X2$1 += z * (x0$3 + x);
	  Y2$1 += z * (y0$3 + y);
	  Z2$1 += z * 3;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function PathContext(context) {
	  this._context = context;
	}

	PathContext.prototype = {
	  _radius: 4.5,
	  pointRadius: function(_) {
	    return this._radius = _, this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._context.closePath();
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._context.moveTo(x, y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._context.lineTo(x, y);
	        break;
	      }
	      default: {
	        this._context.moveTo(x + this._radius, y);
	        this._context.arc(x, y, this._radius, 0, tau);
	        break;
	      }
	    }
	  },
	  result: noop
	};

	var lengthSum$1 = adder(),
	    lengthRing,
	    x00$2,
	    y00$2,
	    x0$4,
	    y0$4;

	var lengthStream$1 = {
	  point: noop,
	  lineStart: function() {
	    lengthStream$1.point = lengthPointFirst$1;
	  },
	  lineEnd: function() {
	    if (lengthRing) lengthPoint$1(x00$2, y00$2);
	    lengthStream$1.point = noop;
	  },
	  polygonStart: function() {
	    lengthRing = true;
	  },
	  polygonEnd: function() {
	    lengthRing = null;
	  },
	  result: function() {
	    var length = +lengthSum$1;
	    lengthSum$1.reset();
	    return length;
	  }
	};

	function lengthPointFirst$1(x, y) {
	  lengthStream$1.point = lengthPoint$1;
	  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
	}

	function lengthPoint$1(x, y) {
	  x0$4 -= x, y0$4 -= y;
	  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
	  x0$4 = x, y0$4 = y;
	}

	function PathString() {
	  this._string = [];
	}

	PathString.prototype = {
	  _radius: 4.5,
	  _circle: circle$1(4.5),
	  pointRadius: function(_) {
	    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
	    return this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._string.push("Z");
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._string.push("M", x, ",", y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._string.push("L", x, ",", y);
	        break;
	      }
	      default: {
	        if (this._circle == null) this._circle = circle$1(this._radius);
	        this._string.push("M", x, ",", y, this._circle);
	        break;
	      }
	    }
	  },
	  result: function() {
	    if (this._string.length) {
	      var result = this._string.join("");
	      this._string = [];
	      return result;
	    } else {
	      return null;
	    }
	  }
	};

	function circle$1(radius) {
	  return "m0," + radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
	      + "z";
	}

	function index(projection, context) {
	  var pointRadius = 4.5,
	      projectionStream,
	      contextStream;

	  function path(object) {
	    if (object) {
	      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	      geoStream(object, projectionStream(contextStream));
	    }
	    return contextStream.result();
	  }

	  path.area = function(object) {
	    geoStream(object, projectionStream(areaStream$1));
	    return areaStream$1.result();
	  };

	  path.measure = function(object) {
	    geoStream(object, projectionStream(lengthStream$1));
	    return lengthStream$1.result();
	  };

	  path.bounds = function(object) {
	    geoStream(object, projectionStream(boundsStream$1));
	    return boundsStream$1.result();
	  };

	  path.centroid = function(object) {
	    geoStream(object, projectionStream(centroidStream$1));
	    return centroidStream$1.result();
	  };

	  path.projection = function(_) {
	    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
	  };

	  path.context = function(_) {
	    if (!arguments.length) return context;
	    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
	    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	    return path;
	  };

	  path.pointRadius = function(_) {
	    if (!arguments.length) return pointRadius;
	    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	    return path;
	  };

	  return path.projection(projection).context(context);
	}

	function transform(methods) {
	  return {
	    stream: transformer(methods)
	  };
	}

	function transformer(methods) {
	  return function(stream) {
	    var s = new TransformStream;
	    for (var key in methods) s[key] = methods[key];
	    s.stream = stream;
	    return s;
	  };
	}

	function TransformStream() {}

	TransformStream.prototype = {
	  constructor: TransformStream,
	  point: function(x, y) { this.stream.point(x, y); },
	  sphere: function() { this.stream.sphere(); },
	  lineStart: function() { this.stream.lineStart(); },
	  lineEnd: function() { this.stream.lineEnd(); },
	  polygonStart: function() { this.stream.polygonStart(); },
	  polygonEnd: function() { this.stream.polygonEnd(); }
	};

	function fit(projection, fitBounds, object) {
	  var clip = projection.clipExtent && projection.clipExtent();
	  projection.scale(150).translate([0, 0]);
	  if (clip != null) projection.clipExtent(null);
	  geoStream(object, projection.stream(boundsStream$1));
	  fitBounds(boundsStream$1.result());
	  if (clip != null) projection.clipExtent(clip);
	  return projection;
	}

	function fitExtent(projection, extent, object) {
	  return fit(projection, function(b) {
	    var w = extent[1][0] - extent[0][0],
	        h = extent[1][1] - extent[0][1],
	        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
	        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
	        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitSize(projection, size, object) {
	  return fitExtent(projection, [[0, 0], size], object);
	}

	function fitWidth(projection, width, object) {
	  return fit(projection, function(b) {
	    var w = +width,
	        k = w / (b[1][0] - b[0][0]),
	        x = (w - k * (b[1][0] + b[0][0])) / 2,
	        y = -k * b[0][1];
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitHeight(projection, height, object) {
	  return fit(projection, function(b) {
	    var h = +height,
	        k = h / (b[1][1] - b[0][1]),
	        x = -k * b[0][0],
	        y = (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	var maxDepth = 16, // maximum depth of subdivision
	    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

	function resample(project, delta2) {
	  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
	}

	function resampleNone(project) {
	  return transformer({
	    point: function(x, y) {
	      x = project(x, y);
	      this.stream.point(x[0], x[1]);
	    }
	  });
	}

	function resample$1(project, delta2) {

	  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
	    var dx = x1 - x0,
	        dy = y1 - y0,
	        d2 = dx * dx + dy * dy;
	    if (d2 > 4 * delta2 && depth--) {
	      var a = a0 + a1,
	          b = b0 + b1,
	          c = c0 + c1,
	          m = sqrt(a * a + b * b + c * c),
	          phi2 = asin(c /= m),
	          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
	          p = project(lambda2, phi2),
	          x2 = p[0],
	          y2 = p[1],
	          dx2 = x2 - x0,
	          dy2 = y2 - y0,
	          dz = dy * dx2 - dx * dy2;
	      if (dz * dz / d2 > delta2 // perpendicular projected distance
	          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
	          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
	        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
	        stream.point(x2, y2);
	        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
	      }
	    }
	  }
	  return function(stream) {
	    var lambda00, x00, y00, a00, b00, c00, // first point
	        lambda0, x0, y0, a0, b0, c0; // previous point

	    var resampleStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
	      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
	    };

	    function point(x, y) {
	      x = project(x, y);
	      stream.point(x[0], x[1]);
	    }

	    function lineStart() {
	      x0 = NaN;
	      resampleStream.point = linePoint;
	      stream.lineStart();
	    }

	    function linePoint(lambda, phi) {
	      var c = cartesian([lambda, phi]), p = project(lambda, phi);
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	      stream.point(x0, y0);
	    }

	    function lineEnd() {
	      resampleStream.point = point;
	      stream.lineEnd();
	    }

	    function ringStart() {
	      lineStart();
	      resampleStream.point = ringPoint;
	      resampleStream.lineEnd = ringEnd;
	    }

	    function ringPoint(lambda, phi) {
	      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	      resampleStream.point = linePoint;
	    }

	    function ringEnd() {
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
	      resampleStream.lineEnd = lineEnd;
	      lineEnd();
	    }

	    return resampleStream;
	  };
	}

	var transformRadians = transformer({
	  point: function(x, y) {
	    this.stream.point(x * radians, y * radians);
	  }
	});

	function transformRotate(rotate) {
	  return transformer({
	    point: function(x, y) {
	      var r = rotate(x, y);
	      return this.stream.point(r[0], r[1]);
	    }
	  });
	}

	function scaleTranslate(k, dx, dy) {
	  function transform(x, y) {
	    return [dx + k * x, dy - k * y];
	  }
	  transform.invert = function(x, y) {
	    return [(x - dx) / k, (dy - y) / k];
	  };
	  return transform;
	}

	function scaleTranslateRotate(k, dx, dy, alpha) {
	  var cosAlpha = cos(alpha),
	      sinAlpha = sin(alpha),
	      a = cosAlpha * k,
	      b = sinAlpha * k,
	      ai = cosAlpha / k,
	      bi = sinAlpha / k,
	      ci = (sinAlpha * dy - cosAlpha * dx) / k,
	      fi = (sinAlpha * dx + cosAlpha * dy) / k;
	  function transform(x, y) {
	    return [a * x - b * y + dx, dy - b * x - a * y];
	  }
	  transform.invert = function(x, y) {
	    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
	  };
	  return transform;
	}

	function projection(project) {
	  return projectionMutator(function() { return project; })();
	}

	function projectionMutator(projectAt) {
	  var project,
	      k = 150, // scale
	      x = 480, y = 250, // translate
	      lambda = 0, phi = 0, // center
	      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
	      alpha = 0, // post-rotate
	      theta = null, preclip = clipAntimeridian, // pre-clip angle
	      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
	      delta2 = 0.5, // precision
	      projectResample,
	      projectTransform,
	      projectRotateTransform,
	      cache,
	      cacheStream;

	  function projection(point) {
	    return projectRotateTransform(point[0] * radians, point[1] * radians);
	  }

	  function invert(point) {
	    point = projectRotateTransform.invert(point[0], point[1]);
	    return point && [point[0] * degrees, point[1] * degrees];
	  }

	  projection.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
	  };

	  projection.preclip = function(_) {
	    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
	  };

	  projection.postclip = function(_) {
	    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	  };

	  projection.clipAngle = function(_) {
	    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
	  };

	  projection.clipExtent = function(_) {
	    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  projection.scale = function(_) {
	    return arguments.length ? (k = +_, recenter()) : k;
	  };

	  projection.translate = function(_) {
	    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
	  };

	  projection.center = function(_) {
	    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
	  };

	  projection.rotate = function(_) {
	    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
	  };

	  projection.angle = function(_) {
	    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
	  };

	  projection.precision = function(_) {
	    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
	  };

	  projection.fitExtent = function(extent, object) {
	    return fitExtent(projection, extent, object);
	  };

	  projection.fitSize = function(size, object) {
	    return fitSize(projection, size, object);
	  };

	  projection.fitWidth = function(width, object) {
	    return fitWidth(projection, width, object);
	  };

	  projection.fitHeight = function(height, object) {
	    return fitHeight(projection, height, object);
	  };

	  function recenter() {
	    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
	        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
	    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
	    projectTransform = compose(project, transform);
	    projectRotateTransform = compose(rotate, projectTransform);
	    projectResample = resample(projectTransform, delta2);
	    return reset();
	  }

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return function() {
	    project = projectAt.apply(this, arguments);
	    projection.invert = project.invert && invert;
	    return recenter();
	  };
	}

	function conicProjection(projectAt) {
	  var phi0 = 0,
	      phi1 = pi / 3,
	      m = projectionMutator(projectAt),
	      p = m(phi0, phi1);

	  p.parallels = function(_) {
	    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
	  };

	  return p;
	}

	function cylindricalEqualAreaRaw(phi0) {
	  var cosPhi0 = cos(phi0);

	  function forward(lambda, phi) {
	    return [lambda * cosPhi0, sin(phi) / cosPhi0];
	  }

	  forward.invert = function(x, y) {
	    return [x / cosPhi0, asin(y * cosPhi0)];
	  };

	  return forward;
	}

	function conicEqualAreaRaw(y0, y1) {
	  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

	  // Are the parallels symmetrical around the Equator?
	  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

	  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

	  function project(x, y) {
	    var r = sqrt(c - 2 * n * sin(y)) / n;
	    return [r * sin(x *= n), r0 - r * cos(x)];
	  }

	  project.invert = function(x, y) {
	    var r0y = r0 - y;
	    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
	  };

	  return project;
	}

	function conicEqualArea() {
	  return conicProjection(conicEqualAreaRaw)
	      .scale(155.424)
	      .center([0, 33.6442]);
	}

	function albers() {
	  return conicEqualArea()
	      .parallels([29.5, 45.5])
	      .scale(1070)
	      .translate([480, 250])
	      .rotate([96, 0])
	      .center([-0.6, 38.7]);
	}

	// The projections must have mutually exclusive clip regions on the sphere,
	// as this will avoid emitting interleaving lines and polygons.
	function multiplex(streams) {
	  var n = streams.length;
	  return {
	    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
	    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
	    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
	    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
	    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
	    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
	  };
	}

	// A composite projection for the United States, configured by default for
	// 960×500. The projection also works quite well at 960×600 if you change the
	// scale to 1285 and adjust the translate accordingly. The set of standard
	// parallels for each region comes from USGS, which is published here:
	// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
	function albersUsa() {
	  var cache,
	      cacheStream,
	      lower48 = albers(), lower48Point,
	      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
	      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
	      point, pointStream = {point: function(x, y) { point = [x, y]; }};

	  function albersUsa(coordinates) {
	    var x = coordinates[0], y = coordinates[1];
	    return point = null,
	        (lower48Point.point(x, y), point)
	        || (alaskaPoint.point(x, y), point)
	        || (hawaiiPoint.point(x, y), point);
	  }

	  albersUsa.invert = function(coordinates) {
	    var k = lower48.scale(),
	        t = lower48.translate(),
	        x = (coordinates[0] - t[0]) / k,
	        y = (coordinates[1] - t[1]) / k;
	    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
	        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
	        : lower48).invert(coordinates);
	  };

	  albersUsa.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
	  };

	  albersUsa.precision = function(_) {
	    if (!arguments.length) return lower48.precision();
	    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
	    return reset();
	  };

	  albersUsa.scale = function(_) {
	    if (!arguments.length) return lower48.scale();
	    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
	    return albersUsa.translate(lower48.translate());
	  };

	  albersUsa.translate = function(_) {
	    if (!arguments.length) return lower48.translate();
	    var k = lower48.scale(), x = +_[0], y = +_[1];

	    lower48Point = lower48
	        .translate(_)
	        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
	        .stream(pointStream);

	    alaskaPoint = alaska
	        .translate([x - 0.307 * k, y + 0.201 * k])
	        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    hawaiiPoint = hawaii
	        .translate([x - 0.205 * k, y + 0.212 * k])
	        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    return reset();
	  };

	  albersUsa.fitExtent = function(extent, object) {
	    return fitExtent(albersUsa, extent, object);
	  };

	  albersUsa.fitSize = function(size, object) {
	    return fitSize(albersUsa, size, object);
	  };

	  albersUsa.fitWidth = function(width, object) {
	    return fitWidth(albersUsa, width, object);
	  };

	  albersUsa.fitHeight = function(height, object) {
	    return fitHeight(albersUsa, height, object);
	  };

	  function reset() {
	    cache = cacheStream = null;
	    return albersUsa;
	  }

	  return albersUsa.scale(1070);
	}

	function azimuthalRaw(scale) {
	  return function(x, y) {
	    var cx = cos(x),
	        cy = cos(y),
	        k = scale(cx * cy);
	    return [
	      k * cy * sin(x),
	      k * sin(y)
	    ];
	  }
	}

	function azimuthalInvert(angle) {
	  return function(x, y) {
	    var z = sqrt(x * x + y * y),
	        c = angle(z),
	        sc = sin(c),
	        cc = cos(c);
	    return [
	      atan2(x * sc, z * cc),
	      asin(z && y * sc / z)
	    ];
	  }
	}

	var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
	  return sqrt(2 / (1 + cxcy));
	});

	azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
	  return 2 * asin(z / 2);
	});

	function azimuthalEqualArea() {
	  return projection(azimuthalEqualAreaRaw)
	      .scale(124.75)
	      .clipAngle(180 - 1e-3);
	}

	var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
	  return (c = acos(c)) && c / sin(c);
	});

	azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
	  return z;
	});

	function azimuthalEquidistant() {
	  return projection(azimuthalEquidistantRaw)
	      .scale(79.4188)
	      .clipAngle(180 - 1e-3);
	}

	function mercatorRaw(lambda, phi) {
	  return [lambda, log(tan((halfPi + phi) / 2))];
	}

	mercatorRaw.invert = function(x, y) {
	  return [x, 2 * atan(exp(y)) - halfPi];
	};

	function mercator() {
	  return mercatorProjection(mercatorRaw)
	      .scale(961 / tau);
	}

	function mercatorProjection(project) {
	  var m = projection(project),
	      center = m.center,
	      scale = m.scale,
	      translate = m.translate,
	      clipExtent = m.clipExtent,
	      x0 = null, y0, x1, y1; // clip extent

	  m.scale = function(_) {
	    return arguments.length ? (scale(_), reclip()) : scale();
	  };

	  m.translate = function(_) {
	    return arguments.length ? (translate(_), reclip()) : translate();
	  };

	  m.center = function(_) {
	    return arguments.length ? (center(_), reclip()) : center();
	  };

	  m.clipExtent = function(_) {
	    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  function reclip() {
	    var k = pi * scale(),
	        t = m(rotation(m.rotate()).invert([0, 0]));
	    return clipExtent(x0 == null
	        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
	        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
	        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
	  }

	  return reclip();
	}

	function tany(y) {
	  return tan((halfPi + y) / 2);
	}

	function conicConformalRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
	      f = cy0 * pow(tany(y0), n) / n;

	  if (!n) return mercatorRaw;

	  function project(x, y) {
	    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
	    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
	    var r = f / pow(tany(y), n);
	    return [r * sin(n * x), f - r * cos(n * x)];
	  }

	  project.invert = function(x, y) {
	    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
	    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
	  };

	  return project;
	}

	function conicConformal() {
	  return conicProjection(conicConformalRaw)
	      .scale(109.5)
	      .parallels([30, 30]);
	}

	function equirectangularRaw(lambda, phi) {
	  return [lambda, phi];
	}

	equirectangularRaw.invert = equirectangularRaw;

	function equirectangular() {
	  return projection(equirectangularRaw)
	      .scale(152.63);
	}

	function conicEquidistantRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
	      g = cy0 / n + y0;

	  if (abs(n) < epsilon) return equirectangularRaw;

	  function project(x, y) {
	    var gy = g - y, nx = n * x;
	    return [gy * sin(nx), g - gy * cos(nx)];
	  }

	  project.invert = function(x, y) {
	    var gy = g - y;
	    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
	  };

	  return project;
	}

	function conicEquidistant() {
	  return conicProjection(conicEquidistantRaw)
	      .scale(131.154)
	      .center([0, 13.9389]);
	}

	var A1 = 1.340264,
	    A2 = -0.081106,
	    A3 = 0.000893,
	    A4 = 0.003796,
	    M = sqrt(3) / 2,
	    iterations = 12;

	function equalEarthRaw(lambda, phi) {
	  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
	  return [
	    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
	    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
	  ];
	}

	equalEarthRaw.invert = function(x, y) {
	  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
	  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
	    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
	    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
	    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
	    if (abs(delta) < epsilon2) break;
	  }
	  return [
	    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
	    asin(sin(l) / M)
	  ];
	};

	function equalEarth() {
	  return projection(equalEarthRaw)
	      .scale(177.158);
	}

	function gnomonicRaw(x, y) {
	  var cy = cos(y), k = cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	gnomonicRaw.invert = azimuthalInvert(atan);

	function gnomonic() {
	  return projection(gnomonicRaw)
	      .scale(144.049)
	      .clipAngle(60);
	}

	function scaleTranslate$1(kx, ky, tx, ty) {
	  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
	    point: function(x, y) {
	      this.stream.point(x * kx + tx, y * ky + ty);
	    }
	  });
	}

	function identity$1() {
	  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect
	      x0 = null, y0, x1, y1, // clip extent
	      postclip = identity,
	      cache,
	      cacheStream,
	      projection;

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return projection = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
	    },
	    postclip: function(_) {
	      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	    },
	    clipExtent: function(_) {
	      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	    },
	    scale: function(_) {
	      return arguments.length ? (transform = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
	    },
	    translate: function(_) {
	      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
	    },
	    reflectX: function(_) {
	      return arguments.length ? (transform = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
	    },
	    reflectY: function(_) {
	      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
	    },
	    fitExtent: function(extent, object) {
	      return fitExtent(projection, extent, object);
	    },
	    fitSize: function(size, object) {
	      return fitSize(projection, size, object);
	    },
	    fitWidth: function(width, object) {
	      return fitWidth(projection, width, object);
	    },
	    fitHeight: function(height, object) {
	      return fitHeight(projection, height, object);
	    }
	  };
	}

	function naturalEarth1Raw(lambda, phi) {
	  var phi2 = phi * phi, phi4 = phi2 * phi2;
	  return [
	    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
	    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
	  ];
	}

	naturalEarth1Raw.invert = function(x, y) {
	  var phi = y, i = 25, delta;
	  do {
	    var phi2 = phi * phi, phi4 = phi2 * phi2;
	    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
	        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
	  } while (abs(delta) > epsilon && --i > 0);
	  return [
	    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
	    phi
	  ];
	};

	function naturalEarth1() {
	  return projection(naturalEarth1Raw)
	      .scale(175.295);
	}

	function orthographicRaw(x, y) {
	  return [cos(y) * sin(x), sin(y)];
	}

	orthographicRaw.invert = azimuthalInvert(asin);

	function orthographic() {
	  return projection(orthographicRaw)
	      .scale(249.5)
	      .clipAngle(90 + epsilon);
	}

	function stereographicRaw(x, y) {
	  var cy = cos(y), k = 1 + cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	stereographicRaw.invert = azimuthalInvert(function(z) {
	  return 2 * atan(z);
	});

	function stereographic() {
	  return projection(stereographicRaw)
	      .scale(250)
	      .clipAngle(142);
	}

	function transverseMercatorRaw(lambda, phi) {
	  return [log(tan((halfPi + phi) / 2)), -lambda];
	}

	transverseMercatorRaw.invert = function(x, y) {
	  return [-y, 2 * atan(exp(x)) - halfPi];
	};

	function transverseMercator() {
	  var m = mercatorProjection(transverseMercatorRaw),
	      center = m.center,
	      rotate = m.rotate;

	  m.center = function(_) {
	    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
	  };

	  m.rotate = function(_) {
	    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
	  };

	  return rotate([0, 0, 90])
	      .scale(159.155);
	}

	exports.geoAlbers = albers;
	exports.geoAlbersUsa = albersUsa;
	exports.geoArea = area;
	exports.geoAzimuthalEqualArea = azimuthalEqualArea;
	exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
	exports.geoAzimuthalEquidistant = azimuthalEquidistant;
	exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
	exports.geoBounds = bounds;
	exports.geoCentroid = centroid;
	exports.geoCircle = circle;
	exports.geoClipAntimeridian = clipAntimeridian;
	exports.geoClipCircle = clipCircle;
	exports.geoClipExtent = extent;
	exports.geoClipRectangle = clipRectangle;
	exports.geoConicConformal = conicConformal;
	exports.geoConicConformalRaw = conicConformalRaw;
	exports.geoConicEqualArea = conicEqualArea;
	exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
	exports.geoConicEquidistant = conicEquidistant;
	exports.geoConicEquidistantRaw = conicEquidistantRaw;
	exports.geoContains = contains;
	exports.geoDistance = distance;
	exports.geoEqualEarth = equalEarth;
	exports.geoEqualEarthRaw = equalEarthRaw;
	exports.geoEquirectangular = equirectangular;
	exports.geoEquirectangularRaw = equirectangularRaw;
	exports.geoGnomonic = gnomonic;
	exports.geoGnomonicRaw = gnomonicRaw;
	exports.geoGraticule = graticule;
	exports.geoGraticule10 = graticule10;
	exports.geoIdentity = identity$1;
	exports.geoInterpolate = interpolate;
	exports.geoLength = length;
	exports.geoMercator = mercator;
	exports.geoMercatorRaw = mercatorRaw;
	exports.geoNaturalEarth1 = naturalEarth1;
	exports.geoNaturalEarth1Raw = naturalEarth1Raw;
	exports.geoOrthographic = orthographic;
	exports.geoOrthographicRaw = orthographicRaw;
	exports.geoPath = index;
	exports.geoProjection = projection;
	exports.geoProjectionMutator = projectionMutator;
	exports.geoRotation = rotation;
	exports.geoStereographic = stereographic;
	exports.geoStereographicRaw = stereographicRaw;
	exports.geoStream = geoStream;
	exports.geoTransform = transform;
	exports.geoTransverseMercator = transverseMercator;
	exports.geoTransverseMercatorRaw = transverseMercatorRaw;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function pairs(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function cross(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function deviation(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	}

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function identity(x) {
	  return x;
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	}

	function histogram() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	}

	function max(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function mean(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	}

	function median(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	}

	function merge(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function permute(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	}

	function scan(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	}

	function shuffle(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function defaultSeparation(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	function meanX(children) {
	  return children.reduce(meanXReduce, 0) / children.length;
	}

	function meanXReduce(x, c) {
	  return x + c.x;
	}

	function maxY(children) {
	  return 1 + children.reduce(maxYReduce, 0);
	}

	function maxYReduce(y, c) {
	  return Math.max(y, c.y);
	}

	function leafLeft(node) {
	  var children;
	  while (children = node.children) node = children[0];
	  return node;
	}

	function leafRight(node) {
	  var children;
	  while (children = node.children) node = children[children.length - 1];
	  return node;
	}

	function cluster() {
	  var separation = defaultSeparation,
	      dx = 1,
	      dy = 1,
	      nodeSize = false;

	  function cluster(root) {
	    var previousNode,
	        x = 0;

	    // First walk, computing the initial x & y values.
	    root.eachAfter(function(node) {
	      var children = node.children;
	      if (children) {
	        node.x = meanX(children);
	        node.y = maxY(children);
	      } else {
	        node.x = previousNode ? x += separation(node, previousNode) : 0;
	        node.y = 0;
	        previousNode = node;
	      }
	    });

	    var left = leafLeft(root),
	        right = leafRight(root),
	        x0 = left.x - separation(left, right) / 2,
	        x1 = right.x + separation(right, left) / 2;

	    // Second walk, normalizing x & y to the desired size.
	    return root.eachAfter(nodeSize ? function(node) {
	      node.x = (node.x - root.x) * dx;
	      node.y = (root.y - node.y) * dy;
	    } : function(node) {
	      node.x = (node.x - x0) / (x1 - x0) * dx;
	      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
	    });
	  }

	  cluster.separation = function(x) {
	    return arguments.length ? (separation = x, cluster) : separation;
	  };

	  cluster.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
	  };

	  cluster.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
	  };

	  return cluster;
	}

	function count(node) {
	  var sum = 0,
	      children = node.children,
	      i = children && children.length;
	  if (!i) sum = 1;
	  else while (--i >= 0) sum += children[i].value;
	  node.value = sum;
	}

	function node_count() {
	  return this.eachAfter(count);
	}

	function node_each(callback) {
	  var node = this, current, next = [node], children, i, n;
	  do {
	    current = next.reverse(), next = [];
	    while (node = current.pop()) {
	      callback(node), children = node.children;
	      if (children) for (i = 0, n = children.length; i < n; ++i) {
	        next.push(children[i]);
	      }
	    }
	  } while (next.length);
	  return this;
	}

	function node_eachBefore(callback) {
	  var node = this, nodes = [node], children, i;
	  while (node = nodes.pop()) {
	    callback(node), children = node.children;
	    if (children) for (i = children.length - 1; i >= 0; --i) {
	      nodes.push(children[i]);
	    }
	  }
	  return this;
	}

	function node_eachAfter(callback) {
	  var node = this, nodes = [node], next = [], children, i, n;
	  while (node = nodes.pop()) {
	    next.push(node), children = node.children;
	    if (children) for (i = 0, n = children.length; i < n; ++i) {
	      nodes.push(children[i]);
	    }
	  }
	  while (node = next.pop()) {
	    callback(node);
	  }
	  return this;
	}

	function node_sum(value) {
	  return this.eachAfter(function(node) {
	    var sum = +value(node.data) || 0,
	        children = node.children,
	        i = children && children.length;
	    while (--i >= 0) sum += children[i].value;
	    node.value = sum;
	  });
	}

	function node_sort(compare) {
	  return this.eachBefore(function(node) {
	    if (node.children) {
	      node.children.sort(compare);
	    }
	  });
	}

	function node_path(end) {
	  var start = this,
	      ancestor = leastCommonAncestor(start, end),
	      nodes = [start];
	  while (start !== ancestor) {
	    start = start.parent;
	    nodes.push(start);
	  }
	  var k = nodes.length;
	  while (end !== ancestor) {
	    nodes.splice(k, 0, end);
	    end = end.parent;
	  }
	  return nodes;
	}

	function leastCommonAncestor(a, b) {
	  if (a === b) return a;
	  var aNodes = a.ancestors(),
	      bNodes = b.ancestors(),
	      c = null;
	  a = aNodes.pop();
	  b = bNodes.pop();
	  while (a === b) {
	    c = a;
	    a = aNodes.pop();
	    b = bNodes.pop();
	  }
	  return c;
	}

	function node_ancestors() {
	  var node = this, nodes = [node];
	  while (node = node.parent) {
	    nodes.push(node);
	  }
	  return nodes;
	}

	function node_descendants() {
	  var nodes = [];
	  this.each(function(node) {
	    nodes.push(node);
	  });
	  return nodes;
	}

	function node_leaves() {
	  var leaves = [];
	  this.eachBefore(function(node) {
	    if (!node.children) {
	      leaves.push(node);
	    }
	  });
	  return leaves;
	}

	function node_links() {
	  var root = this, links = [];
	  root.each(function(node) {
	    if (node !== root) { // Don’t include the root’s parent, if any.
	      links.push({source: node.parent, target: node});
	    }
	  });
	  return links;
	}

	function hierarchy(data, children) {
	  var root = new Node(data),
	      valued = +data.value && (root.value = data.value),
	      node,
	      nodes = [root],
	      child,
	      childs,
	      i,
	      n;

	  if (children == null) children = defaultChildren;

	  while (node = nodes.pop()) {
	    if (valued) node.value = +node.data.value;
	    if ((childs = children(node.data)) && (n = childs.length)) {
	      node.children = new Array(n);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new Node(childs[i]));
	        child.parent = node;
	        child.depth = node.depth + 1;
	      }
	    }
	  }

	  return root.eachBefore(computeHeight);
	}

	function node_copy() {
	  return hierarchy(this).eachBefore(copyData);
	}

	function defaultChildren(d) {
	  return d.children;
	}

	function copyData(node) {
	  node.data = node.data.data;
	}

	function computeHeight(node) {
	  var height = 0;
	  do node.height = height;
	  while ((node = node.parent) && (node.height < ++height));
	}

	function Node(data) {
	  this.data = data;
	  this.depth =
	  this.height = 0;
	  this.parent = null;
	}

	Node.prototype = hierarchy.prototype = {
	  constructor: Node,
	  count: node_count,
	  each: node_each,
	  eachAfter: node_eachAfter,
	  eachBefore: node_eachBefore,
	  sum: node_sum,
	  sort: node_sort,
	  path: node_path,
	  ancestors: node_ancestors,
	  descendants: node_descendants,
	  leaves: node_leaves,
	  links: node_links,
	  copy: node_copy
	};

	var slice = Array.prototype.slice;

	function shuffle(array) {
	  var m = array.length,
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m];
	    array[m] = array[i];
	    array[i] = t;
	  }

	  return array;
	}

	function enclose(circles) {
	  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

	  while (i < n) {
	    p = circles[i];
	    if (e && enclosesWeak(e, p)) ++i;
	    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
	  }

	  return e;
	}

	function extendBasis(B, p) {
	  var i, j;

	  if (enclosesWeakAll(p, B)) return [p];

	  // If we get here then B must have at least one element.
	  for (i = 0; i < B.length; ++i) {
	    if (enclosesNot(p, B[i])
	        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
	      return [B[i], p];
	    }
	  }

	  // If we get here then B must have at least two elements.
	  for (i = 0; i < B.length - 1; ++i) {
	    for (j = i + 1; j < B.length; ++j) {
	      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
	          && enclosesNot(encloseBasis2(B[i], p), B[j])
	          && enclosesNot(encloseBasis2(B[j], p), B[i])
	          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
	        return [B[i], B[j], p];
	      }
	    }
	  }

	  // If we get here then something is very wrong.
	  throw new Error;
	}

	function enclosesNot(a, b) {
	  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
	  return dr < 0 || dr * dr < dx * dx + dy * dy;
	}

	function enclosesWeak(a, b) {
	  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function enclosesWeakAll(a, B) {
	  for (var i = 0; i < B.length; ++i) {
	    if (!enclosesWeak(a, B[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	function encloseBasis(B) {
	  switch (B.length) {
	    case 1: return encloseBasis1(B[0]);
	    case 2: return encloseBasis2(B[0], B[1]);
	    case 3: return encloseBasis3(B[0], B[1], B[2]);
	  }
	}

	function encloseBasis1(a) {
	  return {
	    x: a.x,
	    y: a.y,
	    r: a.r
	  };
	}

	function encloseBasis2(a, b) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
	      l = Math.sqrt(x21 * x21 + y21 * y21);
	  return {
	    x: (x1 + x2 + x21 / l * r21) / 2,
	    y: (y1 + y2 + y21 / l * r21) / 2,
	    r: (l + r1 + r2) / 2
	  };
	}

	function encloseBasis3(a, b, c) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x3 = c.x, y3 = c.y, r3 = c.r,
	      a2 = x1 - x2,
	      a3 = x1 - x3,
	      b2 = y1 - y2,
	      b3 = y1 - y3,
	      c2 = r2 - r1,
	      c3 = r3 - r1,
	      d1 = x1 * x1 + y1 * y1 - r1 * r1,
	      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
	      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
	      ab = a3 * b2 - a2 * b3,
	      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
	      xb = (b3 * c2 - b2 * c3) / ab,
	      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
	      yb = (a2 * c3 - a3 * c2) / ab,
	      A = xb * xb + yb * yb - 1,
	      B = 2 * (r1 + xa * xb + ya * yb),
	      C = xa * xa + ya * ya - r1 * r1,
	      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
	  return {
	    x: x1 + xa + xb * r,
	    y: y1 + ya + yb * r,
	    r: r
	  };
	}

	function place(b, a, c) {
	  var dx = b.x - a.x, x, a2,
	      dy = b.y - a.y, y, b2,
	      d2 = dx * dx + dy * dy;
	  if (d2) {
	    a2 = a.r + c.r, a2 *= a2;
	    b2 = b.r + c.r, b2 *= b2;
	    if (a2 > b2) {
	      x = (d2 + b2 - a2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
	      c.x = b.x - x * dx - y * dy;
	      c.y = b.y - x * dy + y * dx;
	    } else {
	      x = (d2 + a2 - b2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
	      c.x = a.x + x * dx - y * dy;
	      c.y = a.y + x * dy + y * dx;
	    }
	  } else {
	    c.x = a.x + c.r;
	    c.y = a.y;
	  }
	}

	function intersects(a, b) {
	  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function score(node) {
	  var a = node._,
	      b = node.next._,
	      ab = a.r + b.r,
	      dx = (a.x * b.r + b.x * a.r) / ab,
	      dy = (a.y * b.r + b.y * a.r) / ab;
	  return dx * dx + dy * dy;
	}

	function Node$1(circle) {
	  this._ = circle;
	  this.next = null;
	  this.previous = null;
	}

	function packEnclose(circles) {
	  if (!(n = circles.length)) return 0;

	  var a, b, c, n, aa, ca, i, j, k, sj, sk;

	  // Place the first circle.
	  a = circles[0], a.x = 0, a.y = 0;
	  if (!(n > 1)) return a.r;

	  // Place the second circle.
	  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
	  if (!(n > 2)) return a.r + b.r;

	  // Place the third circle.
	  place(b, a, c = circles[2]);

	  // Initialize the front-chain using the first three circles a, b and c.
	  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
	  a.next = c.previous = b;
	  b.next = a.previous = c;
	  c.next = b.previous = a;

	  // Attempt to place each remaining circle…
	  pack: for (i = 3; i < n; ++i) {
	    place(a._, b._, c = circles[i]), c = new Node$1(c);

	    // Find the closest intersecting circle on the front-chain, if any.
	    // “Closeness” is determined by linear distance along the front-chain.
	    // “Ahead” or “behind” is likewise determined by linear distance.
	    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
	    do {
	      if (sj <= sk) {
	        if (intersects(j._, c._)) {
	          b = j, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sj += j._.r, j = j.next;
	      } else {
	        if (intersects(k._, c._)) {
	          a = k, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sk += k._.r, k = k.previous;
	      }
	    } while (j !== k.next);

	    // Success! Insert the new circle c between a and b.
	    c.previous = a, c.next = b, a.next = b.previous = b = c;

	    // Compute the new closest circle pair to the centroid.
	    aa = score(a);
	    while ((c = c.next) !== b) {
	      if ((ca = score(c)) < aa) {
	        a = c, aa = ca;
	      }
	    }
	    b = a.next;
	  }

	  // Compute the enclosing circle of the front chain.
	  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

	  // Translate the circles to put the enclosing circle around the origin.
	  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

	  return c.r;
	}

	function siblings(circles) {
	  packEnclose(circles);
	  return circles;
	}

	function optional(f) {
	  return f == null ? null : required(f);
	}

	function required(f) {
	  if (typeof f !== "function") throw new Error;
	  return f;
	}

	function constantZero() {
	  return 0;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function defaultRadius(d) {
	  return Math.sqrt(d.value);
	}

	function index() {
	  var radius = null,
	      dx = 1,
	      dy = 1,
	      padding = constantZero;

	  function pack(root) {
	    root.x = dx / 2, root.y = dy / 2;
	    if (radius) {
	      root.eachBefore(radiusLeaf(radius))
	          .eachAfter(packChildren(padding, 0.5))
	          .eachBefore(translateChild(1));
	    } else {
	      root.eachBefore(radiusLeaf(defaultRadius))
	          .eachAfter(packChildren(constantZero, 1))
	          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
	          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
	    }
	    return root;
	  }

	  pack.radius = function(x) {
	    return arguments.length ? (radius = optional(x), pack) : radius;
	  };

	  pack.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
	  };

	  pack.padding = function(x) {
	    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
	  };

	  return pack;
	}

	function radiusLeaf(radius) {
	  return function(node) {
	    if (!node.children) {
	      node.r = Math.max(0, +radius(node) || 0);
	    }
	  };
	}

	function packChildren(padding, k) {
	  return function(node) {
	    if (children = node.children) {
	      var children,
	          i,
	          n = children.length,
	          r = padding(node) * k || 0,
	          e;

	      if (r) for (i = 0; i < n; ++i) children[i].r += r;
	      e = packEnclose(children);
	      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
	      node.r = e + r;
	    }
	  };
	}

	function translateChild(k) {
	  return function(node) {
	    var parent = node.parent;
	    node.r *= k;
	    if (parent) {
	      node.x = parent.x + k * node.x;
	      node.y = parent.y + k * node.y;
	    }
	  };
	}

	function roundNode(node) {
	  node.x0 = Math.round(node.x0);
	  node.y0 = Math.round(node.y0);
	  node.x1 = Math.round(node.x1);
	  node.y1 = Math.round(node.y1);
	}

	function treemapDice(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (x1 - x0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.y0 = y0, node.y1 = y1;
	    node.x0 = x0, node.x1 = x0 += node.value * k;
	  }
	}

	function partition() {
	  var dx = 1,
	      dy = 1,
	      padding = 0,
	      round = false;

	  function partition(root) {
	    var n = root.height + 1;
	    root.x0 =
	    root.y0 = padding;
	    root.x1 = dx;
	    root.y1 = dy / n;
	    root.eachBefore(positionNode(dy, n));
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(dy, n) {
	    return function(node) {
	      if (node.children) {
	        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
	      }
	      var x0 = node.x0,
	          y0 = node.y0,
	          x1 = node.x1 - padding,
	          y1 = node.y1 - padding;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      node.x0 = x0;
	      node.y0 = y0;
	      node.x1 = x1;
	      node.y1 = y1;
	    };
	  }

	  partition.round = function(x) {
	    return arguments.length ? (round = !!x, partition) : round;
	  };

	  partition.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
	  };

	  partition.padding = function(x) {
	    return arguments.length ? (padding = +x, partition) : padding;
	  };

	  return partition;
	}

	var keyPrefix = "$", // Protect against keys like “__proto__”.
	    preroot = {depth: -1},
	    ambiguous = {};

	function defaultId(d) {
	  return d.id;
	}

	function defaultParentId(d) {
	  return d.parentId;
	}

	function stratify() {
	  var id = defaultId,
	      parentId = defaultParentId;

	  function stratify(data) {
	    var d,
	        i,
	        n = data.length,
	        root,
	        parent,
	        node,
	        nodes = new Array(n),
	        nodeId,
	        nodeKey,
	        nodeByKey = {};

	    for (i = 0; i < n; ++i) {
	      d = data[i], node = nodes[i] = new Node(d);
	      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
	        nodeKey = keyPrefix + (node.id = nodeId);
	        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
	      }
	    }

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], nodeId = parentId(data[i], i, data);
	      if (nodeId == null || !(nodeId += "")) {
	        if (root) throw new Error("multiple roots");
	        root = node;
	      } else {
	        parent = nodeByKey[keyPrefix + nodeId];
	        if (!parent) throw new Error("missing: " + nodeId);
	        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
	        if (parent.children) parent.children.push(node);
	        else parent.children = [node];
	        node.parent = parent;
	      }
	    }

	    if (!root) throw new Error("no root");
	    root.parent = preroot;
	    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
	    root.parent = null;
	    if (n > 0) throw new Error("cycle");

	    return root;
	  }

	  stratify.id = function(x) {
	    return arguments.length ? (id = required(x), stratify) : id;
	  };

	  stratify.parentId = function(x) {
	    return arguments.length ? (parentId = required(x), stratify) : parentId;
	  };

	  return stratify;
	}

	function defaultSeparation$1(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	// function radialSeparation(a, b) {
	//   return (a.parent === b.parent ? 1 : 2) / a.depth;
	// }

	// This function is used to traverse the left contour of a subtree (or
	// subforest). It returns the successor of v on this contour. This successor is
	// either given by the leftmost child of v or by the thread of v. The function
	// returns null if and only if v is on the highest level of its subtree.
	function nextLeft(v) {
	  var children = v.children;
	  return children ? children[0] : v.t;
	}

	// This function works analogously to nextLeft.
	function nextRight(v) {
	  var children = v.children;
	  return children ? children[children.length - 1] : v.t;
	}

	// Shifts the current subtree rooted at w+. This is done by increasing
	// prelim(w+) and mod(w+) by shift.
	function moveSubtree(wm, wp, shift) {
	  var change = shift / (wp.i - wm.i);
	  wp.c -= change;
	  wp.s += shift;
	  wm.c += change;
	  wp.z += shift;
	  wp.m += shift;
	}

	// All other shifts, applied to the smaller subtrees between w- and w+, are
	// performed by this function. To prepare the shifts, we have to adjust
	// change(w+), shift(w+), and change(w-).
	function executeShifts(v) {
	  var shift = 0,
	      change = 0,
	      children = v.children,
	      i = children.length,
	      w;
	  while (--i >= 0) {
	    w = children[i];
	    w.z += shift;
	    w.m += shift;
	    shift += w.s + (change += w.c);
	  }
	}

	// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
	// returns the specified (default) ancestor.
	function nextAncestor(vim, v, ancestor) {
	  return vim.a.parent === v.parent ? vim.a : ancestor;
	}

	function TreeNode(node, i) {
	  this._ = node;
	  this.parent = null;
	  this.children = null;
	  this.A = null; // default ancestor
	  this.a = this; // ancestor
	  this.z = 0; // prelim
	  this.m = 0; // mod
	  this.c = 0; // change
	  this.s = 0; // shift
	  this.t = null; // thread
	  this.i = i; // number
	}

	TreeNode.prototype = Object.create(Node.prototype);

	function treeRoot(root) {
	  var tree = new TreeNode(root, 0),
	      node,
	      nodes = [tree],
	      child,
	      children,
	      i,
	      n;

	  while (node = nodes.pop()) {
	    if (children = node._.children) {
	      node.children = new Array(n = children.length);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
	        child.parent = node;
	      }
	    }
	  }

	  (tree.parent = new TreeNode(null, 0)).children = [tree];
	  return tree;
	}

	// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
	function tree() {
	  var separation = defaultSeparation$1,
	      dx = 1,
	      dy = 1,
	      nodeSize = null;

	  function tree(root) {
	    var t = treeRoot(root);

	    // Compute the layout using Buchheim et al.’s algorithm.
	    t.eachAfter(firstWalk), t.parent.m = -t.z;
	    t.eachBefore(secondWalk);

	    // If a fixed node size is specified, scale x and y.
	    if (nodeSize) root.eachBefore(sizeNode);

	    // If a fixed tree size is specified, scale x and y based on the extent.
	    // Compute the left-most, right-most, and depth-most nodes for extents.
	    else {
	      var left = root,
	          right = root,
	          bottom = root;
	      root.eachBefore(function(node) {
	        if (node.x < left.x) left = node;
	        if (node.x > right.x) right = node;
	        if (node.depth > bottom.depth) bottom = node;
	      });
	      var s = left === right ? 1 : separation(left, right) / 2,
	          tx = s - left.x,
	          kx = dx / (right.x + s + tx),
	          ky = dy / (bottom.depth || 1);
	      root.eachBefore(function(node) {
	        node.x = (node.x + tx) * kx;
	        node.y = node.depth * ky;
	      });
	    }

	    return root;
	  }

	  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
	  // applied recursively to the children of v, as well as the function
	  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
	  // node v is placed to the midpoint of its outermost children.
	  function firstWalk(v) {
	    var children = v.children,
	        siblings = v.parent.children,
	        w = v.i ? siblings[v.i - 1] : null;
	    if (children) {
	      executeShifts(v);
	      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	      if (w) {
	        v.z = w.z + separation(v._, w._);
	        v.m = v.z - midpoint;
	      } else {
	        v.z = midpoint;
	      }
	    } else if (w) {
	      v.z = w.z + separation(v._, w._);
	    }
	    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	  }

	  // Computes all real x-coordinates by summing up the modifiers recursively.
	  function secondWalk(v) {
	    v._.x = v.z + v.parent.m;
	    v.m += v.parent.m;
	  }

	  // The core of the algorithm. Here, a new subtree is combined with the
	  // previous subtrees. Threads are used to traverse the inside and outside
	  // contours of the left and right subtree up to the highest common level. The
	  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
	  // superscript o means outside and i means inside, the subscript - means left
	  // subtree and + means right subtree. For summing up the modifiers along the
	  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
	  // nodes of the inside contours conflict, we compute the left one of the
	  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
	  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
	  // Finally, we add a new thread (if necessary).
	  function apportion(v, w, ancestor) {
	    if (w) {
	      var vip = v,
	          vop = v,
	          vim = w,
	          vom = vip.parent.children[0],
	          sip = vip.m,
	          sop = vop.m,
	          sim = vim.m,
	          som = vom.m,
	          shift;
	      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
	        vom = nextLeft(vom);
	        vop = nextRight(vop);
	        vop.a = v;
	        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	        if (shift > 0) {
	          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
	          sip += shift;
	          sop += shift;
	        }
	        sim += vim.m;
	        sip += vip.m;
	        som += vom.m;
	        sop += vop.m;
	      }
	      if (vim && !nextRight(vop)) {
	        vop.t = vim;
	        vop.m += sim - sop;
	      }
	      if (vip && !nextLeft(vom)) {
	        vom.t = vip;
	        vom.m += sip - som;
	        ancestor = v;
	      }
	    }
	    return ancestor;
	  }

	  function sizeNode(node) {
	    node.x *= dx;
	    node.y = node.depth * dy;
	  }

	  tree.separation = function(x) {
	    return arguments.length ? (separation = x, tree) : separation;
	  };

	  tree.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
	  };

	  tree.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
	  };

	  return tree;
	}

	function treemapSlice(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (y1 - y0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.x0 = x0, node.x1 = x1;
	    node.y0 = y0, node.y1 = y0 += node.value * k;
	  }
	}

	var phi = (1 + Math.sqrt(5)) / 2;

	function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
	  var rows = [],
	      nodes = parent.children,
	      row,
	      nodeValue,
	      i0 = 0,
	      i1 = 0,
	      n = nodes.length,
	      dx, dy,
	      value = parent.value,
	      sumValue,
	      minValue,
	      maxValue,
	      newRatio,
	      minRatio,
	      alpha,
	      beta;

	  while (i0 < n) {
	    dx = x1 - x0, dy = y1 - y0;

	    // Find the next non-empty node.
	    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
	    minValue = maxValue = sumValue;
	    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
	    beta = sumValue * sumValue * alpha;
	    minRatio = Math.max(maxValue / beta, beta / minValue);

	    // Keep adding nodes while the aspect ratio maintains or improves.
	    for (; i1 < n; ++i1) {
	      sumValue += nodeValue = nodes[i1].value;
	      if (nodeValue < minValue) minValue = nodeValue;
	      if (nodeValue > maxValue) maxValue = nodeValue;
	      beta = sumValue * sumValue * alpha;
	      newRatio = Math.max(maxValue / beta, beta / minValue);
	      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
	      minRatio = newRatio;
	    }

	    // Position and record the row orientation.
	    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
	    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
	    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
	    value -= sumValue, i0 = i1;
	  }

	  return rows;
	}

	var squarify = (function custom(ratio) {

	  function squarify(parent, x0, y0, x1, y1) {
	    squarifyRatio(ratio, parent, x0, y0, x1, y1);
	  }

	  squarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return squarify;
	})(phi);

	function index$1() {
	  var tile = squarify,
	      round = false,
	      dx = 1,
	      dy = 1,
	      paddingStack = [0],
	      paddingInner = constantZero,
	      paddingTop = constantZero,
	      paddingRight = constantZero,
	      paddingBottom = constantZero,
	      paddingLeft = constantZero;

	  function treemap(root) {
	    root.x0 =
	    root.y0 = 0;
	    root.x1 = dx;
	    root.y1 = dy;
	    root.eachBefore(positionNode);
	    paddingStack = [0];
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(node) {
	    var p = paddingStack[node.depth],
	        x0 = node.x0 + p,
	        y0 = node.y0 + p,
	        x1 = node.x1 - p,
	        y1 = node.y1 - p;
	    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	    node.x0 = x0;
	    node.y0 = y0;
	    node.x1 = x1;
	    node.y1 = y1;
	    if (node.children) {
	      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
	      x0 += paddingLeft(node) - p;
	      y0 += paddingTop(node) - p;
	      x1 -= paddingRight(node) - p;
	      y1 -= paddingBottom(node) - p;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      tile(node, x0, y0, x1, y1);
	    }
	  }

	  treemap.round = function(x) {
	    return arguments.length ? (round = !!x, treemap) : round;
	  };

	  treemap.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
	  };

	  treemap.tile = function(x) {
	    return arguments.length ? (tile = required(x), treemap) : tile;
	  };

	  treemap.padding = function(x) {
	    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
	  };

	  treemap.paddingInner = function(x) {
	    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
	  };

	  treemap.paddingOuter = function(x) {
	    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
	  };

	  treemap.paddingTop = function(x) {
	    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
	  };

	  treemap.paddingRight = function(x) {
	    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
	  };

	  treemap.paddingBottom = function(x) {
	    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
	  };

	  treemap.paddingLeft = function(x) {
	    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
	  };

	  return treemap;
	}

	function binary(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      i, n = nodes.length,
	      sum, sums = new Array(n + 1);

	  for (sums[0] = sum = i = 0; i < n; ++i) {
	    sums[i + 1] = sum += nodes[i].value;
	  }

	  partition(0, n, parent.value, x0, y0, x1, y1);

	  function partition(i, j, value, x0, y0, x1, y1) {
	    if (i >= j - 1) {
	      var node = nodes[i];
	      node.x0 = x0, node.y0 = y0;
	      node.x1 = x1, node.y1 = y1;
	      return;
	    }

	    var valueOffset = sums[i],
	        valueTarget = (value / 2) + valueOffset,
	        k = i + 1,
	        hi = j - 1;

	    while (k < hi) {
	      var mid = k + hi >>> 1;
	      if (sums[mid] < valueTarget) k = mid + 1;
	      else hi = mid;
	    }

	    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

	    var valueLeft = sums[k] - valueOffset,
	        valueRight = value - valueLeft;

	    if ((x1 - x0) > (y1 - y0)) {
	      var xk = (x0 * valueRight + x1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, xk, y1);
	      partition(k, j, valueRight, xk, y0, x1, y1);
	    } else {
	      var yk = (y0 * valueRight + y1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, x1, yk);
	      partition(k, j, valueRight, x0, yk, x1, y1);
	    }
	  }
	}

	function sliceDice(parent, x0, y0, x1, y1) {
	  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
	}

	var resquarify = (function custom(ratio) {

	  function resquarify(parent, x0, y0, x1, y1) {
	    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
	      var rows,
	          row,
	          nodes,
	          i,
	          j = -1,
	          n,
	          m = rows.length,
	          value = parent.value;

	      while (++j < m) {
	        row = rows[j], nodes = row.children;
	        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
	        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
	        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
	        value -= row.value;
	      }
	    } else {
	      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
	      rows.ratio = ratio;
	    }
	  }

	  resquarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return resquarify;
	})(phi);

	exports.cluster = cluster;
	exports.hierarchy = hierarchy;
	exports.pack = index;
	exports.packEnclose = enclose;
	exports.packSiblings = siblings;
	exports.partition = partition;
	exports.stratify = stratify;
	exports.tree = tree;
	exports.treemap = index$1;
	exports.treemapBinary = binary;
	exports.treemapDice = treemapDice;
	exports.treemapResquarify = resquarify;
	exports.treemapSlice = treemapSlice;
	exports.treemapSliceDice = sliceDice;
	exports.treemapSquarify = squarify;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-polygon/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function area(polygon) {
	  var i = -1,
	      n = polygon.length,
	      a,
	      b = polygon[n - 1],
	      area = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    area += a[1] * b[0] - a[0] * b[1];
	  }

	  return area / 2;
	}

	function centroid(polygon) {
	  var i = -1,
	      n = polygon.length,
	      x = 0,
	      y = 0,
	      a,
	      b = polygon[n - 1],
	      c,
	      k = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    k += c = a[0] * b[1] - b[0] * a[1];
	    x += (a[0] + b[0]) * c;
	    y += (a[1] + b[1]) * c;
	  }

	  return k *= 3, [x / k, y / k];
	}

	// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
	// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
	// right, +y is up). Returns a positive value if ABC is counter-clockwise,
	// negative if clockwise, and zero if the points are collinear.
	function cross(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	}

	function lexicographicOrder(a, b) {
	  return a[0] - b[0] || a[1] - b[1];
	}

	// Computes the upper convex hull per the monotone chain algorithm.
	// Assumes points.length >= 3, is sorted by x, unique in y.
	// Returns an array of indices into points in left-to-right order.
	function computeUpperHullIndexes(points) {
	  var n = points.length,
	      indexes = [0, 1],
	      size = 2;

	  for (var i = 2; i < n; ++i) {
	    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
	    indexes[size++] = i;
	  }

	  return indexes.slice(0, size); // remove popped points
	}

	function hull(points) {
	  if ((n = points.length) < 3) return null;

	  var i,
	      n,
	      sortedPoints = new Array(n),
	      flippedPoints = new Array(n);

	  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
	  sortedPoints.sort(lexicographicOrder);
	  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

	  var upperIndexes = computeUpperHullIndexes(sortedPoints),
	      lowerIndexes = computeUpperHullIndexes(flippedPoints);

	  // Construct the hull polygon, removing possible duplicate endpoints.
	  var skipLeft = lowerIndexes[0] === upperIndexes[0],
	      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
	      hull = [];

	  // Add upper hull in right-to-l order.
	  // Then add lower hull in left-to-right order.
	  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
	  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

	  return hull;
	}

	function contains(polygon, point) {
	  var n = polygon.length,
	      p = polygon[n - 1],
	      x = point[0], y = point[1],
	      x0 = p[0], y0 = p[1],
	      x1, y1,
	      inside = false;

	  for (var i = 0; i < n; ++i) {
	    p = polygon[i], x1 = p[0], y1 = p[1];
	    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
	    x0 = x1, y0 = y1;
	  }

	  return inside;
	}

	function length(polygon) {
	  var i = -1,
	      n = polygon.length,
	      b = polygon[n - 1],
	      xa,
	      ya,
	      xb = b[0],
	      yb = b[1],
	      perimeter = 0;

	  while (++i < n) {
	    xa = xb;
	    ya = yb;
	    b = polygon[i];
	    xb = b[0];
	    yb = b[1];
	    xa -= xb;
	    ya -= yb;
	    perimeter += Math.sqrt(xa * xa + ya * ya);
	  }

	  return perimeter;
	}

	exports.polygonArea = area;
	exports.polygonCentroid = centroid;
	exports.polygonContains = contains;
	exports.polygonHull = hull;
	exports.polygonLength = length;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-random/ v1.1.2 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function defaultSource() {
	  return Math.random();
	}

	var uniform = (function sourceRandomUniform(source) {
	  function randomUniform(min, max) {
	    min = min == null ? 0 : +min;
	    max = max == null ? 1 : +max;
	    if (arguments.length === 1) max = min, min = 0;
	    else max -= min;
	    return function() {
	      return source() * max + min;
	    };
	  }

	  randomUniform.source = sourceRandomUniform;

	  return randomUniform;
	})(defaultSource);

	var normal = (function sourceRandomNormal(source) {
	  function randomNormal(mu, sigma) {
	    var x, r;
	    mu = mu == null ? 0 : +mu;
	    sigma = sigma == null ? 1 : +sigma;
	    return function() {
	      var y;

	      // If available, use the second previously-generated uniform random.
	      if (x != null) y = x, x = null;

	      // Otherwise, generate a new x and y.
	      else do {
	        x = source() * 2 - 1;
	        y = source() * 2 - 1;
	        r = x * x + y * y;
	      } while (!r || r > 1);

	      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	    };
	  }

	  randomNormal.source = sourceRandomNormal;

	  return randomNormal;
	})(defaultSource);

	var logNormal = (function sourceRandomLogNormal(source) {
	  function randomLogNormal() {
	    var randomNormal = normal.source(source).apply(this, arguments);
	    return function() {
	      return Math.exp(randomNormal());
	    };
	  }

	  randomLogNormal.source = sourceRandomLogNormal;

	  return randomLogNormal;
	})(defaultSource);

	var irwinHall = (function sourceRandomIrwinHall(source) {
	  function randomIrwinHall(n) {
	    return function() {
	      for (var sum = 0, i = 0; i < n; ++i) sum += source();
	      return sum;
	    };
	  }

	  randomIrwinHall.source = sourceRandomIrwinHall;

	  return randomIrwinHall;
	})(defaultSource);

	var bates = (function sourceRandomBates(source) {
	  function randomBates(n) {
	    var randomIrwinHall = irwinHall.source(source)(n);
	    return function() {
	      return randomIrwinHall() / n;
	    };
	  }

	  randomBates.source = sourceRandomBates;

	  return randomBates;
	})(defaultSource);

	var exponential = (function sourceRandomExponential(source) {
	  function randomExponential(lambda) {
	    return function() {
	      return -Math.log(1 - source()) / lambda;
	    };
	  }

	  randomExponential.source = sourceRandomExponential;

	  return randomExponential;
	})(defaultSource);

	exports.randomUniform = uniform;
	exports.randomNormal = normal;
	exports.randomLogNormal = logNormal;
	exports.randomBates = bates;
	exports.randomIrwinHall = irwinHall;
	exports.randomExponential = exponential;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale/ v2.2.2 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(20), __webpack_require__(6), __webpack_require__(12), __webpack_require__(27), __webpack_require__(34), __webpack_require__(35)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-collection', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

	function initRange(domain, range) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.range(domain); break;
	    default: this.range(range).domain(domain); break;
	  }
	  return this;
	}

	function initInterpolator(domain, interpolator) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.interpolator(domain); break;
	    default: this.interpolator(interpolator).domain(domain); break;
	  }
	  return this;
	}

	var array = Array.prototype;

	var map = array.map;
	var slice = array.slice;

	var implicit = {name: "implicit"};

	function ordinal() {
	  var index = d3Collection.map(),
	      domain = [],
	      range = [],
	      unknown = implicit;

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range[(i - 1) % range.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = d3Collection.map();
	    var i = -1, n = _.length, d, key;
	    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), scale) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal(domain, range).unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      range = [0, 1],
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = range[1] < range[0],
	        start = range[reverse - 0],
	        stop = range[1 - reverse];
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = d3Array.range(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = [+_[0], +_[1]], round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band(domain(), range)
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return initRange.apply(rescale(), arguments);
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point() {
	  return pointish(band.apply(null, arguments).paddingInner(1));
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function number(x) {
	  return +x;
	}

	var unit = [0, 1];

	function identity(x) {
	  return x;
	}

	function normalize(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant(isNaN(b) ? NaN : 0.5);
	}

	function clamper(domain) {
	  var a = domain[0], b = domain[domain.length - 1], t;
	  if (a > b) t = a, a = b, b = t;
	  return function(x) { return Math.max(a, Math.min(b, x)); };
	}

	// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
	function bimap(domain, range, interpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, interpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = normalize(domain[i], domain[i + 1]);
	    r[i] = interpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = d3Array.bisect(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function transformer() {
	  var domain = unit,
	      range = unit,
	      interpolate = d3Interpolate.interpolate,
	      transform,
	      untransform,
	      unknown,
	      clamp = identity,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
	  }

	  scale.invert = function(y) {
	    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, rescale()) : interpolate;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t, u) {
	    transform = t, untransform = u;
	    return rescale();
	  };
	}

	function continuous(transform, untransform) {
	  return transformer()(transform, untransform);
	}

	function tickFormat(start, stop, count, specifier) {
	  var step = d3Array.tickStep(start, stop, count),
	      precision;
	  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
	      return d3Format.formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return d3Format.format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    var d = domain();
	    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = d3Array.tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = d3Array.tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = d3Array.tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear() {
	  var scale = continuous(identity, identity);

	  scale.copy = function() {
	    return copy(scale, linear());
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function identity$1(domain) {
	  var unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : x;
	  }

	  scale.invert = scale;

	  scale.domain = scale.range = function(_) {
	    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return identity$1(domain).unknown(unknown);
	  };

	  domain = arguments.length ? map.call(domain, number) : [0, 1];

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function transformLog(x) {
	  return Math.log(x);
	}

	function transformExp(x) {
	  return Math.exp(x);
	}

	function transformLogn(x) {
	  return -Math.log(-x);
	}

	function transformExpn(x) {
	  return -Math.exp(-x);
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function loggish(transform) {
	  var scale = transform(transformLog, transformExp),
	      domain = scale.domain,
	      base = 10,
	      logs,
	      pows;

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) {
	      logs = reflect(logs), pows = reflect(pows);
	      transform(transformLogn, transformExpn);
	    } else {
	      transform(transformLog, transformExp);
	    }
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.round(i) - 1, j = Math.round(j) + 1;
	      if (u > 0) for (; i < j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i < j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	    } else {
	      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  return scale;
	}

	function log() {
	  var scale = loggish(transformer()).domain([1, 10]);

	  scale.copy = function() {
	    return copy(scale, log()).base(scale.base());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function transformSymlog(c) {
	  return function(x) {
	    return Math.sign(x) * Math.log1p(Math.abs(x / c));
	  };
	}

	function transformSymexp(c) {
	  return function(x) {
	    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
	  };
	}

	function symlogish(transform) {
	  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

	  scale.constant = function(_) {
	    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
	  };

	  return linearish(scale);
	}

	function symlog() {
	  var scale = symlogish(transformer());

	  scale.copy = function() {
	    return copy(scale, symlog()).constant(scale.constant());
	  };

	  return initRange.apply(scale, arguments);
	}

	function transformPow(exponent) {
	  return function(x) {
	    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	  };
	}

	function transformSqrt(x) {
	  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
	}

	function transformSquare(x) {
	  return x < 0 ? -x * x : x * x;
	}

	function powish(transform) {
	  var scale = transform(identity, identity),
	      exponent = 1;

	  function rescale() {
	    return exponent === 1 ? transform(identity, identity)
	        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
	        : transform(transformPow(exponent), transformPow(1 / exponent));
	  }

	  scale.exponent = function(_) {
	    return arguments.length ? (exponent = +_, rescale()) : exponent;
	  };

	  return linearish(scale);
	}

	function pow() {
	  var scale = powish(transformer());

	  scale.copy = function() {
	    return copy(scale, pow()).exponent(scale.exponent());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function sqrt() {
	  return pow.apply(null, arguments).exponent(0.5);
	}

	function quantile() {
	  var domain = [],
	      range = [],
	      thresholds = [],
	      unknown;

	  function rescale() {
	    var i = 0, n = Math.max(1, range.length);
	    thresholds = new Array(n - 1);
	    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
	  }

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN] : [
	      i > 0 ? thresholds[i - 1] : domain[0],
	      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	    ];
	  };

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return rescale();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.quantiles = function() {
	    return thresholds.slice();
	  };

	  scale.copy = function() {
	    return quantile()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	function quantize() {
	  var x0 = 0,
	      x1 = 1,
	      n = 1,
	      domain = [0.5],
	      range = [0, 1],
	      unknown;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  function rescale() {
	    var i = -1;
	    domain = new Array(n);
	    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	    return scale;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
	  };

	  scale.range = function(_) {
	    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN]
	        : i < 1 ? [x0, domain[0]]
	        : i >= n ? [domain[n - 1], x1]
	        : [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : scale;
	  };

	  scale.thresholds = function() {
	    return domain.slice();
	  };

	  scale.copy = function() {
	    return quantize()
	        .domain([x0, x1])
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(linearish(scale), arguments);
	}

	function threshold() {
	  var domain = [0.5],
	      range = [0, 1],
	      unknown,
	      n = 1;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return threshold()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	var durationSecond = 1000,
	    durationMinute = durationSecond * 60,
	    durationHour = durationMinute * 60,
	    durationDay = durationHour * 24,
	    durationWeek = durationDay * 7,
	    durationMonth = durationDay * 30,
	    durationYear = durationDay * 365;

	function date(t) {
	  return new Date(t);
	}

	function number$1(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	  var scale = continuous(identity, identity),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format(".%L"),
	      formatSecond = format(":%S"),
	      formatMinute = format("%I:%M"),
	      formatHour = format("%I %p"),
	      formatDay = format("%a %d"),
	      formatWeek = format("%b %d"),
	      formatMonth = format("%B"),
	      formatYear = format("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond],
	    [second,  5,  5 * durationSecond],
	    [second, 15, 15 * durationSecond],
	    [second, 30, 30 * durationSecond],
	    [minute,  1,      durationMinute],
	    [minute,  5,  5 * durationMinute],
	    [minute, 15, 15 * durationMinute],
	    [minute, 30, 30 * durationMinute],
	    [  hour,  1,      durationHour  ],
	    [  hour,  3,  3 * durationHour  ],
	    [  hour,  6,  6 * durationHour  ],
	    [  hour, 12, 12 * durationHour  ],
	    [   day,  1,      durationDay   ],
	    [   day,  2,  2 * durationDay   ],
	    [  week,  1,      durationWeek  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop, step) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	      if (i === tickIntervals.length) {
	        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	    }

	    return step == null ? interval : interval.every(step);
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
	  };

	  scale.ticks = function(interval, step) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1, step);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format(specifier);
	  };

	  scale.nice = function(interval, step) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	  };

	  return scale;
	}

	function time() {
	  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
	}

	function utcTime() {
	  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
	}

	function transformer$1() {
	  var x0 = 0,
	      x1 = 1,
	      t0,
	      t1,
	      k10,
	      transform,
	      interpolator = identity,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
	    return scale;
	  };
	}

	function copy$1(source, target) {
	  return target
	      .domain(source.domain())
	      .interpolator(source.interpolator())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function sequential() {
	  var scale = linearish(transformer$1()(identity));

	  scale.copy = function() {
	    return copy$1(scale, sequential());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialLog() {
	  var scale = loggish(transformer$1()).domain([1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, sequentialLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSymlog() {
	  var scale = symlogish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialPow() {
	  var scale = powish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSqrt() {
	  return sequentialPow.apply(null, arguments).exponent(0.5);
	}

	function sequentialQuantile() {
	  var domain = [],
	      interpolator = identity;

	  function scale(x) {
	    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return scale;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.copy = function() {
	    return sequentialQuantile(interpolator).domain(domain);
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function transformer$2() {
	  var x0 = 0,
	      x1 = 0.5,
	      x2 = 1,
	      t0,
	      t1,
	      t2,
	      k10,
	      k21,
	      interpolator = identity,
	      transform,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
	    return scale;
	  };
	}

	function diverging() {
	  var scale = linearish(transformer$2()(identity));

	  scale.copy = function() {
	    return copy$1(scale, diverging());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingLog() {
	  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, divergingLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSymlog() {
	  var scale = symlogish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingPow() {
	  var scale = powish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSqrt() {
	  return divergingPow.apply(null, arguments).exponent(0.5);
	}

	exports.scaleBand = band;
	exports.scalePoint = point;
	exports.scaleIdentity = identity$1;
	exports.scaleLinear = linear;
	exports.scaleLog = log;
	exports.scaleSymlog = symlog;
	exports.scaleOrdinal = ordinal;
	exports.scaleImplicit = implicit;
	exports.scalePow = pow;
	exports.scaleSqrt = sqrt;
	exports.scaleQuantile = quantile;
	exports.scaleQuantize = quantize;
	exports.scaleThreshold = threshold;
	exports.scaleTime = time;
	exports.scaleUtc = utcTime;
	exports.scaleSequential = sequential;
	exports.scaleSequentialLog = sequentialLog;
	exports.scaleSequentialPow = sequentialPow;
	exports.scaleSequentialSqrt = sequentialSqrt;
	exports.scaleSequentialSymlog = sequentialSymlog;
	exports.scaleSequentialQuantile = sequentialQuantile;
	exports.scaleDiverging = diverging;
	exports.scaleDivergingLog = divergingLog;
	exports.scaleDivergingPow = divergingPow;
	exports.scaleDivergingSqrt = divergingSqrt;
	exports.scaleDivergingSymlog = divergingSymlog;
	exports.tickFormat = tickFormat;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time/ v1.1.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var t0 = new Date,
	    t1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
	  }

	  interval.floor = function(date) {
	    return floori(date = new Date(+date)), date;
	  };

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0.setTime(+start), t1.setTime(+end);
	      floori(t0), floori(t1);
	      return Math.floor(count(t0, t1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};
	var milliseconds = millisecond.range;

	var durationSecond = 1e3;
	var durationMinute = 6e4;
	var durationHour = 36e5;
	var durationDay = 864e5;
	var durationWeek = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds());
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond);
	}, function(start, end) {
	  return (end - start) / durationSecond;
	}, function(date) {
	  return date.getUTCSeconds();
	});
	var seconds = second.range;

	var minute = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getMinutes();
	});
	var minutes = minute.range;

	var hour = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getHours();
	});
	var hours = hour.range;

	var day = newInterval(function(date) {
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setDate(date.getDate() + step);
	}, function(start, end) {
	  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
	}, function(date) {
	  return date.getDate() - 1;
	});
	var days = day.range;

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	var sundays = sunday.range;
	var mondays = monday.range;
	var tuesdays = tuesday.range;
	var wednesdays = wednesday.range;
	var thursdays = thursday.range;
	var fridays = friday.range;
	var saturdays = saturday.range;

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});
	var months = month.range;

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};
	var years = year.range;

	var utcMinute = newInterval(function(date) {
	  date.setUTCSeconds(0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getUTCMinutes();
	});
	var utcMinutes = utcMinute.range;

	var utcHour = newInterval(function(date) {
	  date.setUTCMinutes(0, 0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getUTCHours();
	});
	var utcHours = utcHour.range;

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});
	var utcDays = utcDay.range;

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	var utcSundays = utcSunday.range;
	var utcMondays = utcMonday.range;
	var utcTuesdays = utcTuesday.range;
	var utcWednesdays = utcWednesday.range;
	var utcThursdays = utcThursday.range;
	var utcFridays = utcFriday.range;
	var utcSaturdays = utcSaturday.range;

	var utcMonth = newInterval(function(date) {
	  date.setUTCDate(1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCMonth(date.getUTCMonth() + step);
	}, function(start, end) {
	  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	}, function(date) {
	  return date.getUTCMonth();
	});
	var utcMonths = utcMonth.range;

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};
	var utcYears = utcYear.range;

	exports.timeDay = day;
	exports.timeDays = days;
	exports.timeFriday = friday;
	exports.timeFridays = fridays;
	exports.timeHour = hour;
	exports.timeHours = hours;
	exports.timeInterval = newInterval;
	exports.timeMillisecond = millisecond;
	exports.timeMilliseconds = milliseconds;
	exports.timeMinute = minute;
	exports.timeMinutes = minutes;
	exports.timeMonday = monday;
	exports.timeMondays = mondays;
	exports.timeMonth = month;
	exports.timeMonths = months;
	exports.timeSaturday = saturday;
	exports.timeSaturdays = saturdays;
	exports.timeSecond = second;
	exports.timeSeconds = seconds;
	exports.timeSunday = sunday;
	exports.timeSundays = sundays;
	exports.timeThursday = thursday;
	exports.timeThursdays = thursdays;
	exports.timeTuesday = tuesday;
	exports.timeTuesdays = tuesdays;
	exports.timeWednesday = wednesday;
	exports.timeWednesdays = wednesdays;
	exports.timeWeek = sunday;
	exports.timeWeeks = sundays;
	exports.timeYear = year;
	exports.timeYears = years;
	exports.utcDay = utcDay;
	exports.utcDays = utcDays;
	exports.utcFriday = utcFriday;
	exports.utcFridays = utcFridays;
	exports.utcHour = utcHour;
	exports.utcHours = utcHours;
	exports.utcMillisecond = millisecond;
	exports.utcMilliseconds = milliseconds;
	exports.utcMinute = utcMinute;
	exports.utcMinutes = utcMinutes;
	exports.utcMonday = utcMonday;
	exports.utcMondays = utcMondays;
	exports.utcMonth = utcMonth;
	exports.utcMonths = utcMonths;
	exports.utcSaturday = utcSaturday;
	exports.utcSaturdays = utcSaturdays;
	exports.utcSecond = second;
	exports.utcSeconds = seconds;
	exports.utcSunday = utcSunday;
	exports.utcSundays = utcSundays;
	exports.utcThursday = utcThursday;
	exports.utcThursdays = utcThursdays;
	exports.utcTuesday = utcTuesday;
	exports.utcTuesdays = utcTuesdays;
	exports.utcWednesday = utcWednesday;
	exports.utcWednesdays = utcWednesdays;
	exports.utcWeek = utcSunday;
	exports.utcWeeks = utcSundays;
	exports.utcYear = utcYear;
	exports.utcYears = utcYears;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time-format/ v2.2.3 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(34)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Time) { 'use strict';

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newDate(y, m, d) {
	  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "q": formatQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "q": formatUTCQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "q": parseQuarter,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, Z) {
	    return function(string) {
	      var d = newDate(1900, undefined, 1),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);
	      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

	      // If this is utcParse, never use the local timezone.
	      if (Z && !("Z" in d)) d.Z = 0;

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // If the month was not specified, inherit from the quarter.
	      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
	          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
	          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
	          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
	          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return localDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatQuarter(d) {
	    return 1 + ~~(d.getMonth() / 3);
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  function formatUTCQuarter(d) {
	    return 1 + ~~(d.getUTCMonth() / 3);
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", false);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier += "", true);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"},
	    numberRe = /^\s*\d+/, // note: ignores next directive
	    percentRe = /^%/,
	    requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  var map = {}, i = -1, n = names.length;
	  while (++i < n) map[names[i].toLowerCase()] = i;
	  return map;
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseQuarter(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.s = +n[0], i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day = d.getDay();
	  return day === 0 ? 7 : day;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
	}

	function formatWeekNumberISO(d, p) {
	  var day = d.getDay();
	  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
	  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
	}

	function formatUTCWeekNumberISO(d, p) {
	  var day = d.getUTCDay();
	  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
	  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale;

	defaultLocale({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.timeFormat = locale.format;
	  exports.timeParse = locale.parse;
	  exports.utcFormat = locale.utcFormat;
	  exports.utcParse = locale.utcParse;
	  return locale;
	}

	var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

	function formatIsoNative(date) {
	  return date.toISOString();
	}

	var formatIso = Date.prototype.toISOString
	    ? formatIsoNative
	    : exports.utcFormat(isoSpecifier);

	function parseIsoNative(string) {
	  var date = new Date(string);
	  return isNaN(date) ? null : date;
	}

	var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	    ? parseIsoNative
	    : exports.utcParse(isoSpecifier);

	exports.isoFormat = formatIso;
	exports.isoParse = parseIso;
	exports.timeFormatDefaultLocale = defaultLocale;
	exports.timeFormatLocale = formatLocale;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale-chromatic/ v1.5.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(12), __webpack_require__(13)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
	}(this, function (exports, d3Interpolate, d3Color) { 'use strict';

	function colors(specifier) {
	  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
	  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
	  return colors;
	}

	var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

	var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

	var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

	var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

	var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

	var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

	var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

	var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

	var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

	var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

	function ramp(scheme) {
	  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
	}

	var scheme = new Array(3).concat(
	  "d8b365f5f5f55ab4ac",
	  "a6611adfc27d80cdc1018571",
	  "a6611adfc27df5f5f580cdc1018571",
	  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
	  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
	  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
	  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
	  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
	  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
	).map(colors);

	var BrBG = ramp(scheme);

	var scheme$1 = new Array(3).concat(
	  "af8dc3f7f7f77fbf7b",
	  "7b3294c2a5cfa6dba0008837",
	  "7b3294c2a5cff7f7f7a6dba0008837",
	  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
	  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
	  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
	  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
	  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
	  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
	).map(colors);

	var PRGn = ramp(scheme$1);

	var scheme$2 = new Array(3).concat(
	  "e9a3c9f7f7f7a1d76a",
	  "d01c8bf1b6dab8e1864dac26",
	  "d01c8bf1b6daf7f7f7b8e1864dac26",
	  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
	  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
	  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
	  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
	  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
	  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
	).map(colors);

	var PiYG = ramp(scheme$2);

	var scheme$3 = new Array(3).concat(
	  "998ec3f7f7f7f1a340",
	  "5e3c99b2abd2fdb863e66101",
	  "5e3c99b2abd2f7f7f7fdb863e66101",
	  "542788998ec3d8daebfee0b6f1a340b35806",
	  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
	  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
	  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
	  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
	  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
	).map(colors);

	var PuOr = ramp(scheme$3);

	var scheme$4 = new Array(3).concat(
	  "ef8a62f7f7f767a9cf",
	  "ca0020f4a58292c5de0571b0",
	  "ca0020f4a582f7f7f792c5de0571b0",
	  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
	  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
	  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
	  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
	  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
	  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
	).map(colors);

	var RdBu = ramp(scheme$4);

	var scheme$5 = new Array(3).concat(
	  "ef8a62ffffff999999",
	  "ca0020f4a582bababa404040",
	  "ca0020f4a582ffffffbababa404040",
	  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
	  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
	  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
	  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
	  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
	  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
	).map(colors);

	var RdGy = ramp(scheme$5);

	var scheme$6 = new Array(3).concat(
	  "fc8d59ffffbf91bfdb",
	  "d7191cfdae61abd9e92c7bb6",
	  "d7191cfdae61ffffbfabd9e92c7bb6",
	  "d73027fc8d59fee090e0f3f891bfdb4575b4",
	  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
	  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
	  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
	  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
	  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
	).map(colors);

	var RdYlBu = ramp(scheme$6);

	var scheme$7 = new Array(3).concat(
	  "fc8d59ffffbf91cf60",
	  "d7191cfdae61a6d96a1a9641",
	  "d7191cfdae61ffffbfa6d96a1a9641",
	  "d73027fc8d59fee08bd9ef8b91cf601a9850",
	  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
	  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
	  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
	  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
	  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
	).map(colors);

	var RdYlGn = ramp(scheme$7);

	var scheme$8 = new Array(3).concat(
	  "fc8d59ffffbf99d594",
	  "d7191cfdae61abdda42b83ba",
	  "d7191cfdae61ffffbfabdda42b83ba",
	  "d53e4ffc8d59fee08be6f59899d5943288bd",
	  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
	  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
	  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
	  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
	  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
	).map(colors);

	var Spectral = ramp(scheme$8);

	var scheme$9 = new Array(3).concat(
	  "e5f5f999d8c92ca25f",
	  "edf8fbb2e2e266c2a4238b45",
	  "edf8fbb2e2e266c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
	).map(colors);

	var BuGn = ramp(scheme$9);

	var scheme$a = new Array(3).concat(
	  "e0ecf49ebcda8856a7",
	  "edf8fbb3cde38c96c688419d",
	  "edf8fbb3cde38c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
	).map(colors);

	var BuPu = ramp(scheme$a);

	var scheme$b = new Array(3).concat(
	  "e0f3dba8ddb543a2ca",
	  "f0f9e8bae4bc7bccc42b8cbe",
	  "f0f9e8bae4bc7bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
	).map(colors);

	var GnBu = ramp(scheme$b);

	var scheme$c = new Array(3).concat(
	  "fee8c8fdbb84e34a33",
	  "fef0d9fdcc8afc8d59d7301f",
	  "fef0d9fdcc8afc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
	).map(colors);

	var OrRd = ramp(scheme$c);

	var scheme$d = new Array(3).concat(
	  "ece2f0a6bddb1c9099",
	  "f6eff7bdc9e167a9cf02818a",
	  "f6eff7bdc9e167a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
	).map(colors);

	var PuBuGn = ramp(scheme$d);

	var scheme$e = new Array(3).concat(
	  "ece7f2a6bddb2b8cbe",
	  "f1eef6bdc9e174a9cf0570b0",
	  "f1eef6bdc9e174a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
	).map(colors);

	var PuBu = ramp(scheme$e);

	var scheme$f = new Array(3).concat(
	  "e7e1efc994c7dd1c77",
	  "f1eef6d7b5d8df65b0ce1256",
	  "f1eef6d7b5d8df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
	).map(colors);

	var PuRd = ramp(scheme$f);

	var scheme$g = new Array(3).concat(
	  "fde0ddfa9fb5c51b8a",
	  "feebe2fbb4b9f768a1ae017e",
	  "feebe2fbb4b9f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
	).map(colors);

	var RdPu = ramp(scheme$g);

	var scheme$h = new Array(3).concat(
	  "edf8b17fcdbb2c7fb8",
	  "ffffcca1dab441b6c4225ea8",
	  "ffffcca1dab441b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
	).map(colors);

	var YlGnBu = ramp(scheme$h);

	var scheme$i = new Array(3).concat(
	  "f7fcb9addd8e31a354",
	  "ffffccc2e69978c679238443",
	  "ffffccc2e69978c67931a354006837",
	  "ffffccd9f0a3addd8e78c67931a354006837",
	  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
	).map(colors);

	var YlGn = ramp(scheme$i);

	var scheme$j = new Array(3).concat(
	  "fff7bcfec44fd95f0e",
	  "ffffd4fed98efe9929cc4c02",
	  "ffffd4fed98efe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
	).map(colors);

	var YlOrBr = ramp(scheme$j);

	var scheme$k = new Array(3).concat(
	  "ffeda0feb24cf03b20",
	  "ffffb2fecc5cfd8d3ce31a1c",
	  "ffffb2fecc5cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
	).map(colors);

	var YlOrRd = ramp(scheme$k);

	var scheme$l = new Array(3).concat(
	  "deebf79ecae13182bd",
	  "eff3ffbdd7e76baed62171b5",
	  "eff3ffbdd7e76baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
	).map(colors);

	var Blues = ramp(scheme$l);

	var scheme$m = new Array(3).concat(
	  "e5f5e0a1d99b31a354",
	  "edf8e9bae4b374c476238b45",
	  "edf8e9bae4b374c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
	).map(colors);

	var Greens = ramp(scheme$m);

	var scheme$n = new Array(3).concat(
	  "f0f0f0bdbdbd636363",
	  "f7f7f7cccccc969696525252",
	  "f7f7f7cccccc969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
	).map(colors);

	var Greys = ramp(scheme$n);

	var scheme$o = new Array(3).concat(
	  "efedf5bcbddc756bb1",
	  "f2f0f7cbc9e29e9ac86a51a3",
	  "f2f0f7cbc9e29e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
	).map(colors);

	var Purples = ramp(scheme$o);

	var scheme$p = new Array(3).concat(
	  "fee0d2fc9272de2d26",
	  "fee5d9fcae91fb6a4acb181d",
	  "fee5d9fcae91fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
	).map(colors);

	var Reds = ramp(scheme$p);

	var scheme$q = new Array(3).concat(
	  "fee6cefdae6be6550d",
	  "feeddefdbe85fd8d3cd94701",
	  "feeddefdbe85fd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
	).map(colors);

	var Oranges = ramp(scheme$q);

	function cividis(t) {
	  t = Math.max(0, Math.min(1, t));
	  return "rgb("
	      + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
	      + ")";
	}

	var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

	var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var c = d3Color.cubehelix();

	function rainbow(t) {
	  if (t < 0 || t > 1) t -= Math.floor(t);
	  var ts = Math.abs(t - 0.5);
	  c.h = 360 * t - 100;
	  c.s = 1.5 - 1.5 * ts;
	  c.l = 0.8 - 0.9 * ts;
	  return c + "";
	}

	var c$1 = d3Color.rgb(),
	    pi_1_3 = Math.PI / 3,
	    pi_2_3 = Math.PI * 2 / 3;

	function sinebow(t) {
	  var x;
	  t = (0.5 - t) * Math.PI;
	  c$1.r = 255 * (x = Math.sin(t)) * x;
	  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
	  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
	  return c$1 + "";
	}

	function turbo(t) {
	  t = Math.max(0, Math.min(1, t));
	  return "rgb("
	      + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
	      + ")";
	}

	function ramp$1(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

	var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

	var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

	var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

	exports.interpolateBlues = Blues;
	exports.interpolateBrBG = BrBG;
	exports.interpolateBuGn = BuGn;
	exports.interpolateBuPu = BuPu;
	exports.interpolateCividis = cividis;
	exports.interpolateCool = cool;
	exports.interpolateCubehelixDefault = cubehelix;
	exports.interpolateGnBu = GnBu;
	exports.interpolateGreens = Greens;
	exports.interpolateGreys = Greys;
	exports.interpolateInferno = inferno;
	exports.interpolateMagma = magma;
	exports.interpolateOrRd = OrRd;
	exports.interpolateOranges = Oranges;
	exports.interpolatePRGn = PRGn;
	exports.interpolatePiYG = PiYG;
	exports.interpolatePlasma = plasma;
	exports.interpolatePuBu = PuBu;
	exports.interpolatePuBuGn = PuBuGn;
	exports.interpolatePuOr = PuOr;
	exports.interpolatePuRd = PuRd;
	exports.interpolatePurples = Purples;
	exports.interpolateRainbow = rainbow;
	exports.interpolateRdBu = RdBu;
	exports.interpolateRdGy = RdGy;
	exports.interpolateRdPu = RdPu;
	exports.interpolateRdYlBu = RdYlBu;
	exports.interpolateRdYlGn = RdYlGn;
	exports.interpolateReds = Reds;
	exports.interpolateSinebow = sinebow;
	exports.interpolateSpectral = Spectral;
	exports.interpolateTurbo = turbo;
	exports.interpolateViridis = viridis;
	exports.interpolateWarm = warm;
	exports.interpolateYlGn = YlGn;
	exports.interpolateYlGnBu = YlGnBu;
	exports.interpolateYlOrBr = YlOrBr;
	exports.interpolateYlOrRd = YlOrRd;
	exports.schemeAccent = Accent;
	exports.schemeBlues = scheme$l;
	exports.schemeBrBG = scheme;
	exports.schemeBuGn = scheme$9;
	exports.schemeBuPu = scheme$a;
	exports.schemeCategory10 = category10;
	exports.schemeDark2 = Dark2;
	exports.schemeGnBu = scheme$b;
	exports.schemeGreens = scheme$m;
	exports.schemeGreys = scheme$n;
	exports.schemeOrRd = scheme$c;
	exports.schemeOranges = scheme$q;
	exports.schemePRGn = scheme$1;
	exports.schemePaired = Paired;
	exports.schemePastel1 = Pastel1;
	exports.schemePastel2 = Pastel2;
	exports.schemePiYG = scheme$2;
	exports.schemePuBu = scheme$e;
	exports.schemePuBuGn = scheme$d;
	exports.schemePuOr = scheme$3;
	exports.schemePuRd = scheme$f;
	exports.schemePurples = scheme$o;
	exports.schemeRdBu = scheme$4;
	exports.schemeRdGy = scheme$5;
	exports.schemeRdPu = scheme$g;
	exports.schemeRdYlBu = scheme$6;
	exports.schemeRdYlGn = scheme$7;
	exports.schemeReds = scheme$p;
	exports.schemeSet1 = Set1;
	exports.schemeSet2 = Set2;
	exports.schemeSet3 = Set3;
	exports.schemeSpectral = scheme$8;
	exports.schemeTableau10 = Tableau10;
	exports.schemeYlGn = scheme$i;
	exports.schemeYlGnBu = scheme$h;
	exports.schemeYlOrBr = scheme$j;
	exports.schemeYlOrRd = scheme$k;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(19)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Path) { 'use strict';

	function constant(x) {
	  return function constant() {
	    return x;
	  };
	}

	var abs = Math.abs;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var max = Math.max;
	var min = Math.min;
	var sin = Math.sin;
	var sqrt = Math.sqrt;

	var epsilon = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = 2 * pi;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
	}

	function arcInnerRadius(d) {
	  return d.innerRadius;
	}

	function arcOuterRadius(d) {
	  return d.outerRadius;
	}

	function arcStartAngle(d) {
	  return d.startAngle;
	}

	function arcEndAngle(d) {
	  return d.endAngle;
	}

	function arcPadAngle(d) {
	  return d && d.padAngle; // Note: optional!
	}

	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  var x10 = x1 - x0, y10 = y1 - y0,
	      x32 = x3 - x2, y32 = y3 - y2,
	      t = y32 * x10 - x32 * y10;
	  if (t * t < epsilon) return;
	  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
	  return [x0 + t * x10, y0 + t * y10];
	}

	// Compute perpendicular offset line of length rc.
	// http://mathworld.wolfram.com/Circle-LineIntersection.html
	function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
	  var x01 = x0 - x1,
	      y01 = y0 - y1,
	      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
	      ox = lo * y01,
	      oy = -lo * x01,
	      x11 = x0 + ox,
	      y11 = y0 + oy,
	      x10 = x1 + ox,
	      y10 = y1 + oy,
	      x00 = (x11 + x10) / 2,
	      y00 = (y11 + y10) / 2,
	      dx = x10 - x11,
	      dy = y10 - y11,
	      d2 = dx * dx + dy * dy,
	      r = r1 - rc,
	      D = x11 * y10 - x10 * y11,
	      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
	      cx0 = (D * dy - dx * d) / d2,
	      cy0 = (-D * dx - dy * d) / d2,
	      cx1 = (D * dy + dx * d) / d2,
	      cy1 = (-D * dx + dy * d) / d2,
	      dx0 = cx0 - x00,
	      dy0 = cy0 - y00,
	      dx1 = cx1 - x00,
	      dy1 = cy1 - y00;

	  // Pick the closer of the two intersection points.
	  // TODO Is there a faster way to determine which intersection to use?
	  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

	  return {
	    cx: cx0,
	    cy: cy0,
	    x01: -ox,
	    y01: -oy,
	    x11: cx0 * (r1 / r - 1),
	    y11: cy0 * (r1 / r - 1)
	  };
	}

	function arc() {
	  var innerRadius = arcInnerRadius,
	      outerRadius = arcOuterRadius,
	      cornerRadius = constant(0),
	      padRadius = null,
	      startAngle = arcStartAngle,
	      endAngle = arcEndAngle,
	      padAngle = arcPadAngle,
	      context = null;

	  function arc() {
	    var buffer,
	        r,
	        r0 = +innerRadius.apply(this, arguments),
	        r1 = +outerRadius.apply(this, arguments),
	        a0 = startAngle.apply(this, arguments) - halfPi,
	        a1 = endAngle.apply(this, arguments) - halfPi,
	        da = abs(a1 - a0),
	        cw = a1 > a0;

	    if (!context) context = buffer = d3Path.path();

	    // Ensure that the outer radius is always larger than the inner radius.
	    if (r1 < r0) r = r1, r1 = r0, r0 = r;

	    // Is it a point?
	    if (!(r1 > epsilon)) context.moveTo(0, 0);

	    // Or is it a circle or annulus?
	    else if (da > tau - epsilon) {
	      context.moveTo(r1 * cos(a0), r1 * sin(a0));
	      context.arc(0, 0, r1, a0, a1, !cw);
	      if (r0 > epsilon) {
	        context.moveTo(r0 * cos(a1), r0 * sin(a1));
	        context.arc(0, 0, r0, a1, a0, cw);
	      }
	    }

	    // Or is it a circular or annular sector?
	    else {
	      var a01 = a0,
	          a11 = a1,
	          a00 = a0,
	          a10 = a1,
	          da0 = da,
	          da1 = da,
	          ap = padAngle.apply(this, arguments) / 2,
	          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
	          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
	          rc0 = rc,
	          rc1 = rc,
	          t0,
	          t1;

	      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
	      if (rp > epsilon) {
	        var p0 = asin(rp / r0 * sin(ap)),
	            p1 = asin(rp / r1 * sin(ap));
	        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
	        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
	        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
	        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
	      }

	      var x01 = r1 * cos(a01),
	          y01 = r1 * sin(a01),
	          x10 = r0 * cos(a10),
	          y10 = r0 * sin(a10);

	      // Apply rounded corners?
	      if (rc > epsilon) {
	        var x11 = r1 * cos(a11),
	            y11 = r1 * sin(a11),
	            x00 = r0 * cos(a00),
	            y00 = r0 * sin(a00),
	            oc;

	        // Restrict the corner radius according to the sector angle.
	        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
	          var ax = x01 - oc[0],
	              ay = y01 - oc[1],
	              bx = x11 - oc[0],
	              by = y11 - oc[1],
	              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
	              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = min(rc, (r0 - lc) / (kc - 1));
	          rc1 = min(rc, (r1 - lc) / (kc + 1));
	        }
	      }

	      // Is the sector collapsed to a line?
	      if (!(da1 > epsilon)) context.moveTo(x01, y01);

	      // Does the sector’s outer ring have rounded corners?
	      else if (rc1 > epsilon) {
	        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
	        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

	        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
	          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the outer ring just a circular arc?
	      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

	      // Is there no inner ring, and it’s a circular sector?
	      // Or perhaps it’s an annular sector collapsed due to padding?
	      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

	      // Does the sector’s inner ring (or point) have rounded corners?
	      else if (rc0 > epsilon) {
	        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
	        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

	        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
	          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the inner ring just a circular arc?
	      else context.arc(0, 0, r0, a10, a00, cw);
	    }

	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  arc.centroid = function() {
	    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
	        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
	    return [cos(a) * r, sin(a) * r];
	  };

	  arc.innerRadius = function(_) {
	    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
	  };

	  arc.outerRadius = function(_) {
	    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
	  };

	  arc.cornerRadius = function(_) {
	    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
	  };

	  arc.padRadius = function(_) {
	    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
	  };

	  arc.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
	  };

	  arc.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
	  };

	  arc.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
	  };

	  arc.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
	  };

	  return arc;
	}

	function Linear(context) {
	  this._context = context;
	}

	Linear.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: this._context.lineTo(x, y); break;
	    }
	  }
	};

	function curveLinear(context) {
	  return new Linear(context);
	}

	function x(p) {
	  return p[0];
	}

	function y(p) {
	  return p[1];
	}

	function line() {
	  var x$1 = x,
	      y$1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function line(data) {
	    var i,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer;

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) output.lineStart();
	        else output.lineEnd();
	      }
	      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  line.x = function(_) {
	    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
	  };

	  line.y = function(_) {
	    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
	  };

	  line.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
	  };

	  line.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	  };

	  line.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	  };

	  return line;
	}

	function area() {
	  var x0 = x,
	      x1 = null,
	      y0 = constant(0),
	      y1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function area(data) {
	    var i,
	        j,
	        k,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer,
	        x0z = new Array(n),
	        y0z = new Array(n);

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) {
	          j = i;
	          output.areaStart();
	          output.lineStart();
	        } else {
	          output.lineEnd();
	          output.lineStart();
	          for (k = i - 1; k >= j; --k) {
	            output.point(x0z[k], y0z[k]);
	          }
	          output.lineEnd();
	          output.areaEnd();
	        }
	      }
	      if (defined0) {
	        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
	        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	      }
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  function arealine() {
	    return line().defined(defined).curve(curve).context(context);
	  }

	  area.x = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
	  };

	  area.x0 = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
	  };

	  area.x1 = function(_) {
	    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
	  };

	  area.y = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
	  };

	  area.y0 = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
	  };

	  area.y1 = function(_) {
	    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
	  };

	  area.lineX0 =
	  area.lineY0 = function() {
	    return arealine().x(x0).y(y0);
	  };

	  area.lineY1 = function() {
	    return arealine().x(x0).y(y1);
	  };

	  area.lineX1 = function() {
	    return arealine().x(x1).y(y0);
	  };

	  area.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
	  };

	  area.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	  };

	  area.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	  };

	  return area;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function identity(d) {
	  return d;
	}

	function pie() {
	  var value = identity,
	      sortValues = descending,
	      sort = null,
	      startAngle = constant(0),
	      endAngle = constant(tau),
	      padAngle = constant(0);

	  function pie(data) {
	    var i,
	        n = data.length,
	        j,
	        k,
	        sum = 0,
	        index = new Array(n),
	        arcs = new Array(n),
	        a0 = +startAngle.apply(this, arguments),
	        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
	        a1,
	        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
	        pa = p * (da < 0 ? -1 : 1),
	        v;

	    for (i = 0; i < n; ++i) {
	      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
	        sum += v;
	      }
	    }

	    // Optionally sort the arcs by previously-computed values or by data.
	    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
	    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

	    // Compute the arcs! They are stored in the original data's order.
	    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
	      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
	        data: data[j],
	        index: i,
	        value: v,
	        startAngle: a0,
	        endAngle: a1,
	        padAngle: p
	      };
	    }

	    return arcs;
	  }

	  pie.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
	  };

	  pie.sortValues = function(_) {
	    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
	  };

	  pie.sort = function(_) {
	    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
	  };

	  pie.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
	  };

	  pie.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
	  };

	  pie.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
	  };

	  return pie;
	}

	var curveRadialLinear = curveRadial(curveLinear);

	function Radial(curve) {
	  this._curve = curve;
	}

	Radial.prototype = {
	  areaStart: function() {
	    this._curve.areaStart();
	  },
	  areaEnd: function() {
	    this._curve.areaEnd();
	  },
	  lineStart: function() {
	    this._curve.lineStart();
	  },
	  lineEnd: function() {
	    this._curve.lineEnd();
	  },
	  point: function(a, r) {
	    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
	  }
	};

	function curveRadial(curve) {

	  function radial(context) {
	    return new Radial(curve(context));
	  }

	  radial._curve = curve;

	  return radial;
	}

	function lineRadial(l) {
	  var c = l.curve;

	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;

	  l.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return l;
	}

	function lineRadial$1() {
	  return lineRadial(line().curve(curveRadialLinear));
	}

	function areaRadial() {
	  var a = area().curve(curveRadialLinear),
	      c = a.curve,
	      x0 = a.lineX0,
	      x1 = a.lineX1,
	      y0 = a.lineY0,
	      y1 = a.lineY1;

	  a.angle = a.x, delete a.x;
	  a.startAngle = a.x0, delete a.x0;
	  a.endAngle = a.x1, delete a.x1;
	  a.radius = a.y, delete a.y;
	  a.innerRadius = a.y0, delete a.y0;
	  a.outerRadius = a.y1, delete a.y1;
	  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
	  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
	  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
	  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

	  a.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return a;
	}

	function pointRadial(x, y) {
	  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
	}

	var slice = Array.prototype.slice;

	function linkSource(d) {
	  return d.source;
	}

	function linkTarget(d) {
	  return d.target;
	}

	function link(curve) {
	  var source = linkSource,
	      target = linkTarget,
	      x$1 = x,
	      y$1 = y,
	      context = null;

	  function link() {
	    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
	    if (!context) context = buffer = d3Path.path();
	    curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  link.source = function(_) {
	    return arguments.length ? (source = _, link) : source;
	  };

	  link.target = function(_) {
	    return arguments.length ? (target = _, link) : target;
	  };

	  link.x = function(_) {
	    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link) : x$1;
	  };

	  link.y = function(_) {
	    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link) : y$1;
	  };

	  link.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), link) : context;
	  };

	  return link;
	}

	function curveHorizontal(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
	}

	function curveVertical(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
	}

	function curveRadial$1(context, x0, y0, x1, y1) {
	  var p0 = pointRadial(x0, y0),
	      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
	      p2 = pointRadial(x1, y0),
	      p3 = pointRadial(x1, y1);
	  context.moveTo(p0[0], p0[1]);
	  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
	}

	function linkHorizontal() {
	  return link(curveHorizontal);
	}

	function linkVertical() {
	  return link(curveVertical);
	}

	function linkRadial() {
	  var l = link(curveRadial$1);
	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;
	  return l;
	}

	var circle = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / pi);
	    context.moveTo(r, 0);
	    context.arc(0, 0, r, 0, tau);
	  }
	};

	var cross = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / 5) / 2;
	    context.moveTo(-3 * r, -r);
	    context.lineTo(-r, -r);
	    context.lineTo(-r, -3 * r);
	    context.lineTo(r, -3 * r);
	    context.lineTo(r, -r);
	    context.lineTo(3 * r, -r);
	    context.lineTo(3 * r, r);
	    context.lineTo(r, r);
	    context.lineTo(r, 3 * r);
	    context.lineTo(-r, 3 * r);
	    context.lineTo(-r, r);
	    context.lineTo(-3 * r, r);
	    context.closePath();
	  }
	};

	var tan30 = Math.sqrt(1 / 3),
	    tan30_2 = tan30 * 2;

	var diamond = {
	  draw: function(context, size) {
	    var y = Math.sqrt(size / tan30_2),
	        x = y * tan30;
	    context.moveTo(0, -y);
	    context.lineTo(x, 0);
	    context.lineTo(0, y);
	    context.lineTo(-x, 0);
	    context.closePath();
	  }
	};

	var ka = 0.89081309152928522810,
	    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
	    kx = Math.sin(tau / 10) * kr,
	    ky = -Math.cos(tau / 10) * kr;

	var star = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size * ka),
	        x = kx * r,
	        y = ky * r;
	    context.moveTo(0, -r);
	    context.lineTo(x, y);
	    for (var i = 1; i < 5; ++i) {
	      var a = tau * i / 5,
	          c = Math.cos(a),
	          s = Math.sin(a);
	      context.lineTo(s * r, -c * r);
	      context.lineTo(c * x - s * y, s * x + c * y);
	    }
	    context.closePath();
	  }
	};

	var square = {
	  draw: function(context, size) {
	    var w = Math.sqrt(size),
	        x = -w / 2;
	    context.rect(x, x, w, w);
	  }
	};

	var sqrt3 = Math.sqrt(3);

	var triangle = {
	  draw: function(context, size) {
	    var y = -Math.sqrt(size / (sqrt3 * 3));
	    context.moveTo(0, y * 2);
	    context.lineTo(-sqrt3 * y, -y);
	    context.lineTo(sqrt3 * y, -y);
	    context.closePath();
	  }
	};

	var c = -0.5,
	    s = Math.sqrt(3) / 2,
	    k = 1 / Math.sqrt(12),
	    a = (k / 2 + 1) * 3;

	var wye = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / a),
	        x0 = r / 2,
	        y0 = r * k,
	        x1 = x0,
	        y1 = r * k + r,
	        x2 = -x1,
	        y2 = y1;
	    context.moveTo(x0, y0);
	    context.lineTo(x1, y1);
	    context.lineTo(x2, y2);
	    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	    context.closePath();
	  }
	};

	var symbols = [
	  circle,
	  cross,
	  diamond,
	  square,
	  star,
	  triangle,
	  wye
	];

	function symbol() {
	  var type = constant(circle),
	      size = constant(64),
	      context = null;

	  function symbol() {
	    var buffer;
	    if (!context) context = buffer = d3Path.path();
	    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  symbol.type = function(_) {
	    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
	  };

	  symbol.size = function(_) {
	    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
	  };

	  symbol.context = function(_) {
	    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	  };

	  return symbol;
	}

	function noop() {}

	function point(that, x, y) {
	  that._context.bezierCurveTo(
	    (2 * that._x0 + that._x1) / 3,
	    (2 * that._y0 + that._y1) / 3,
	    (that._x0 + 2 * that._x1) / 3,
	    (that._y0 + 2 * that._y1) / 3,
	    (that._x0 + 4 * that._x1 + x) / 6,
	    (that._y0 + 4 * that._y1 + y) / 6
	  );
	}

	function Basis(context) {
	  this._context = context;
	}

	Basis.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 3: point(this, this._x1, this._y1); // proceed
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basis(context) {
	  return new Basis(context);
	}

	function BasisClosed(context) {
	  this._context = context;
	}

	BasisClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x2, this._y2);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
	        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x2, this._y2);
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
	      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
	      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basisClosed(context) {
	  return new BasisClosed(context);
	}

	function BasisOpen(context) {
	  this._context = context;
	}

	BasisOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
	      case 3: this._point = 4; // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basisOpen(context) {
	  return new BasisOpen(context);
	}

	function Bundle(context, beta) {
	  this._basis = new Basis(context);
	  this._beta = beta;
	}

	Bundle.prototype = {
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	    this._basis.lineStart();
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        j = x.length - 1;

	    if (j > 0) {
	      var x0 = x[0],
	          y0 = y[0],
	          dx = x[j] - x0,
	          dy = y[j] - y0,
	          i = -1,
	          t;

	      while (++i <= j) {
	        t = i / j;
	        this._basis.point(
	          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
	          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
	        );
	      }
	    }

	    this._x = this._y = null;
	    this._basis.lineEnd();
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	var bundle = (function custom(beta) {

	  function bundle(context) {
	    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
	  }

	  bundle.beta = function(beta) {
	    return custom(+beta);
	  };

	  return bundle;
	})(0.85);

	function point$1(that, x, y) {
	  that._context.bezierCurveTo(
	    that._x1 + that._k * (that._x2 - that._x0),
	    that._y1 + that._k * (that._y2 - that._y0),
	    that._x2 + that._k * (that._x1 - x),
	    that._y2 + that._k * (that._y1 - y),
	    that._x2,
	    that._y2
	  );
	}

	function Cardinal(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	Cardinal.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: point$1(this, this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
	      case 2: this._point = 3; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinal = (function custom(tension) {

	  function cardinal(context) {
	    return new Cardinal(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function CardinalClosed(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalClosed = (function custom(tension) {

	  function cardinal(context) {
	    return new CardinalClosed(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function CardinalOpen(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalOpen = (function custom(tension) {

	  function cardinal(context) {
	    return new CardinalOpen(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function point$2(that, x, y) {
	  var x1 = that._x1,
	      y1 = that._y1,
	      x2 = that._x2,
	      y2 = that._y2;

	  if (that._l01_a > epsilon) {
	    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
	        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
	    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
	    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
	  }

	  if (that._l23_a > epsilon) {
	    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
	        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
	    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
	    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
	  }

	  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
	}

	function CatmullRom(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRom.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: this.point(this._x2, this._y2); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRom = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function CatmullRomClosed(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomClosed = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function CatmullRomOpen(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomOpen = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function LinearClosed(context) {
	  this._context = context;
	}

	LinearClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._point) this._context.closePath();
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    if (this._point) this._context.lineTo(x, y);
	    else this._point = 1, this._context.moveTo(x, y);
	  }
	};

	function linearClosed(context) {
	  return new LinearClosed(context);
	}

	function sign(x) {
	  return x < 0 ? -1 : 1;
	}

	// Calculate the slopes of the tangents (Hermite-type interpolation) based on
	// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
	// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
	// NOV(II), P. 443, 1990.
	function slope3(that, x2, y2) {
	  var h0 = that._x1 - that._x0,
	      h1 = x2 - that._x1,
	      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
	      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
	      p = (s0 * h1 + s1 * h0) / (h0 + h1);
	  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
	}

	// Calculate a one-sided slope.
	function slope2(that, t) {
	  var h = that._x1 - that._x0;
	  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
	}

	// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
	// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
	// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
	function point$3(that, t0, t1) {
	  var x0 = that._x0,
	      y0 = that._y0,
	      x1 = that._x1,
	      y1 = that._y1,
	      dx = (x1 - x0) / 3;
	  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
	}

	function MonotoneX(context) {
	  this._context = context;
	}

	MonotoneX.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 =
	    this._t0 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    var t1 = NaN;

	    x = +x, y = +y;
	    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
	      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
	    }

	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	    this._t0 = t1;
	  }
	};

	function MonotoneY(context) {
	  this._context = new ReflectContext(context);
	}

	(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
	  MonotoneX.prototype.point.call(this, y, x);
	};

	function ReflectContext(context) {
	  this._context = context;
	}

	ReflectContext.prototype = {
	  moveTo: function(x, y) { this._context.moveTo(y, x); },
	  closePath: function() { this._context.closePath(); },
	  lineTo: function(x, y) { this._context.lineTo(y, x); },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
	};

	function monotoneX(context) {
	  return new MonotoneX(context);
	}

	function monotoneY(context) {
	  return new MonotoneY(context);
	}

	function Natural(context) {
	  this._context = context;
	}

	Natural.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        n = x.length;

	    if (n) {
	      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
	      if (n === 2) {
	        this._context.lineTo(x[1], y[1]);
	      } else {
	        var px = controlPoints(x),
	            py = controlPoints(y);
	        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
	          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
	        }
	      }
	    }

	    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	    this._x = this._y = null;
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
	function controlPoints(x) {
	  var i,
	      n = x.length - 1,
	      m,
	      a = new Array(n),
	      b = new Array(n),
	      r = new Array(n);
	  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
	  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
	  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
	  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
	  a[n - 1] = r[n - 1] / b[n - 1];
	  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
	  b[n - 1] = (x[n] + a[n - 1]) / 2;
	  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
	  return [a, b];
	}

	function natural(context) {
	  return new Natural(context);
	}

	function Step(context, t) {
	  this._context = context;
	  this._t = t;
	}

	Step.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = this._y = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: {
	        if (this._t <= 0) {
	          this._context.lineTo(this._x, y);
	          this._context.lineTo(x, y);
	        } else {
	          var x1 = this._x * (1 - this._t) + x * this._t;
	          this._context.lineTo(x1, this._y);
	          this._context.lineTo(x1, y);
	        }
	        break;
	      }
	    }
	    this._x = x, this._y = y;
	  }
	};

	function step(context) {
	  return new Step(context, 0.5);
	}

	function stepBefore(context) {
	  return new Step(context, 0);
	}

	function stepAfter(context) {
	  return new Step(context, 1);
	}

	function none(series, order) {
	  if (!((n = series.length) > 1)) return;
	  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
	    s0 = s1, s1 = series[order[i]];
	    for (j = 0; j < m; ++j) {
	      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	    }
	  }
	}

	function none$1(series) {
	  var n = series.length, o = new Array(n);
	  while (--n >= 0) o[n] = n;
	  return o;
	}

	function stackValue(d, key) {
	  return d[key];
	}

	function stack() {
	  var keys = constant([]),
	      order = none$1,
	      offset = none,
	      value = stackValue;

	  function stack(data) {
	    var kz = keys.apply(this, arguments),
	        i,
	        m = data.length,
	        n = kz.length,
	        sz = new Array(n),
	        oz;

	    for (i = 0; i < n; ++i) {
	      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
	        si[j] = sij = [0, +value(data[j], ki, j, data)];
	        sij.data = data[j];
	      }
	      si.key = ki;
	    }

	    for (i = 0, oz = order(sz); i < n; ++i) {
	      sz[oz[i]].index = i;
	    }

	    offset(sz, oz);
	    return sz;
	  }

	  stack.keys = function(_) {
	    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
	  };

	  stack.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
	  };

	  stack.order = function(_) {
	    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
	  };

	  stack.offset = function(_) {
	    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
	  };

	  return stack;
	}

	function expand(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
	    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
	    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
	  }
	  none(series, order);
	}

	function diverging(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
	    for (yp = yn = 0, i = 0; i < n; ++i) {
	      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
	        d[0] = yp, d[1] = yp += dy;
	      } else if (dy < 0) {
	        d[1] = yn, d[0] = yn += dy;
	      } else {
	        d[0] = 0, d[1] = dy;
	      }
	    }
	  }
	}

	function silhouette(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
	    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
	    s0[j][1] += s0[j][0] = -y / 2;
	  }
	  none(series, order);
	}

	function wiggle(series, order) {
	  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
	    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
	      var si = series[order[i]],
	          sij0 = si[j][1] || 0,
	          sij1 = si[j - 1][1] || 0,
	          s3 = (sij0 - sij1) / 2;
	      for (var k = 0; k < i; ++k) {
	        var sk = series[order[k]],
	            skj0 = sk[j][1] || 0,
	            skj1 = sk[j - 1][1] || 0;
	        s3 += skj0 - skj1;
	      }
	      s1 += sij0, s2 += s3 * sij0;
	    }
	    s0[j - 1][1] += s0[j - 1][0] = y;
	    if (s1) y -= s2 / s1;
	  }
	  s0[j - 1][1] += s0[j - 1][0] = y;
	  none(series, order);
	}

	function appearance(series) {
	  var peaks = series.map(peak);
	  return none$1(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
	}

	function peak(series) {
	  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
	  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
	  return j;
	}

	function ascending(series) {
	  var sums = series.map(sum);
	  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
	}

	function sum(series) {
	  var s = 0, i = -1, n = series.length, v;
	  while (++i < n) if (v = +series[i][1]) s += v;
	  return s;
	}

	function descending$1(series) {
	  return ascending(series).reverse();
	}

	function insideOut(series) {
	  var n = series.length,
	      i,
	      j,
	      sums = series.map(sum),
	      order = appearance(series),
	      top = 0,
	      bottom = 0,
	      tops = [],
	      bottoms = [];

	  for (i = 0; i < n; ++i) {
	    j = order[i];
	    if (top < bottom) {
	      top += sums[j];
	      tops.push(j);
	    } else {
	      bottom += sums[j];
	      bottoms.push(j);
	    }
	  }

	  return bottoms.reverse().concat(tops);
	}

	function reverse(series) {
	  return none$1(series).reverse();
	}

	exports.arc = arc;
	exports.area = area;
	exports.areaRadial = areaRadial;
	exports.curveBasis = basis;
	exports.curveBasisClosed = basisClosed;
	exports.curveBasisOpen = basisOpen;
	exports.curveBundle = bundle;
	exports.curveCardinal = cardinal;
	exports.curveCardinalClosed = cardinalClosed;
	exports.curveCardinalOpen = cardinalOpen;
	exports.curveCatmullRom = catmullRom;
	exports.curveCatmullRomClosed = catmullRomClosed;
	exports.curveCatmullRomOpen = catmullRomOpen;
	exports.curveLinear = curveLinear;
	exports.curveLinearClosed = linearClosed;
	exports.curveMonotoneX = monotoneX;
	exports.curveMonotoneY = monotoneY;
	exports.curveNatural = natural;
	exports.curveStep = step;
	exports.curveStepAfter = stepAfter;
	exports.curveStepBefore = stepBefore;
	exports.line = line;
	exports.lineRadial = lineRadial$1;
	exports.linkHorizontal = linkHorizontal;
	exports.linkRadial = linkRadial;
	exports.linkVertical = linkVertical;
	exports.pie = pie;
	exports.pointRadial = pointRadial;
	exports.radialArea = areaRadial;
	exports.radialLine = lineRadial$1;
	exports.stack = stack;
	exports.stackOffsetDiverging = diverging;
	exports.stackOffsetExpand = expand;
	exports.stackOffsetNone = none;
	exports.stackOffsetSilhouette = silhouette;
	exports.stackOffsetWiggle = wiggle;
	exports.stackOrderAppearance = appearance;
	exports.stackOrderAscending = ascending;
	exports.stackOrderDescending = descending$1;
	exports.stackOrderInsideOut = insideOut;
	exports.stackOrderNone = none$1;
	exports.stackOrderReverse = reverse;
	exports.symbol = symbol;
	exports.symbolCircle = circle;
	exports.symbolCross = cross;
	exports.symbolDiamond = diamond;
	exports.symbolSquare = square;
	exports.symbolStar = star;
	exports.symbolTriangle = triangle;
	exports.symbolWye = wye;
	exports.symbols = symbols;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function x(d) {
	  return d[0];
	}

	function y(d) {
	  return d[1];
	}

	function RedBlackTree() {
	  this._ = null; // root node
	}

	function RedBlackNode(node) {
	  node.U = // parent node
	  node.C = // color - true for red, false for black
	  node.L = // left node
	  node.R = // right node
	  node.P = // previous node
	  node.N = null; // next node
	}

	RedBlackTree.prototype = {
	  constructor: RedBlackTree,

	  insert: function(after, node) {
	    var parent, grandpa, uncle;

	    if (after) {
	      node.P = after;
	      node.N = after.N;
	      if (after.N) after.N.P = node;
	      after.N = node;
	      if (after.R) {
	        after = after.R;
	        while (after.L) after = after.L;
	        after.L = node;
	      } else {
	        after.R = node;
	      }
	      parent = after;
	    } else if (this._) {
	      after = RedBlackFirst(this._);
	      node.P = null;
	      node.N = after;
	      after.P = after.L = node;
	      parent = after;
	    } else {
	      node.P = node.N = null;
	      this._ = node;
	      parent = null;
	    }
	    node.L = node.R = null;
	    node.U = parent;
	    node.C = true;

	    after = node;
	    while (parent && parent.C) {
	      grandpa = parent.U;
	      if (parent === grandpa.L) {
	        uncle = grandpa.R;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.R) {
	            RedBlackRotateLeft(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateRight(this, grandpa);
	        }
	      } else {
	        uncle = grandpa.L;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.L) {
	            RedBlackRotateRight(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateLeft(this, grandpa);
	        }
	      }
	      parent = after.U;
	    }
	    this._.C = false;
	  },

	  remove: function(node) {
	    if (node.N) node.N.P = node.P;
	    if (node.P) node.P.N = node.N;
	    node.N = node.P = null;

	    var parent = node.U,
	        sibling,
	        left = node.L,
	        right = node.R,
	        next,
	        red;

	    if (!left) next = right;
	    else if (!right) next = left;
	    else next = RedBlackFirst(right);

	    if (parent) {
	      if (parent.L === node) parent.L = next;
	      else parent.R = next;
	    } else {
	      this._ = next;
	    }

	    if (left && right) {
	      red = next.C;
	      next.C = node.C;
	      next.L = left;
	      left.U = next;
	      if (next !== right) {
	        parent = next.U;
	        next.U = node.U;
	        node = next.R;
	        parent.L = node;
	        next.R = right;
	        right.U = next;
	      } else {
	        next.U = parent;
	        parent = next;
	        node = next.R;
	      }
	    } else {
	      red = node.C;
	      node = next;
	    }

	    if (node) node.U = parent;
	    if (red) return;
	    if (node && node.C) { node.C = false; return; }

	    do {
	      if (node === this._) break;
	      if (node === parent.L) {
	        sibling = parent.R;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateLeft(this, parent);
	          sibling = parent.R;
	        }
	        if ((sibling.L && sibling.L.C)
	            || (sibling.R && sibling.R.C)) {
	          if (!sibling.R || !sibling.R.C) {
	            sibling.L.C = false;
	            sibling.C = true;
	            RedBlackRotateRight(this, sibling);
	            sibling = parent.R;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.R.C = false;
	          RedBlackRotateLeft(this, parent);
	          node = this._;
	          break;
	        }
	      } else {
	        sibling = parent.L;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateRight(this, parent);
	          sibling = parent.L;
	        }
	        if ((sibling.L && sibling.L.C)
	          || (sibling.R && sibling.R.C)) {
	          if (!sibling.L || !sibling.L.C) {
	            sibling.R.C = false;
	            sibling.C = true;
	            RedBlackRotateLeft(this, sibling);
	            sibling = parent.L;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.L.C = false;
	          RedBlackRotateRight(this, parent);
	          node = this._;
	          break;
	        }
	      }
	      sibling.C = true;
	      node = parent;
	      parent = parent.U;
	    } while (!node.C);

	    if (node) node.C = false;
	  }
	};

	function RedBlackRotateLeft(tree, node) {
	  var p = node,
	      q = node.R,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.R = q.L;
	  if (p.R) p.R.U = p;
	  q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
	  var p = node,
	      q = node.L,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.L = q.R;
	  if (p.L) p.L.U = p;
	  q.R = p;
	}

	function RedBlackFirst(node) {
	  while (node.L) node = node.L;
	  return node;
	}

	function createEdge(left, right, v0, v1) {
	  var edge = [null, null],
	      index = edges.push(edge) - 1;
	  edge.left = left;
	  edge.right = right;
	  if (v0) setEdgeEnd(edge, left, right, v0);
	  if (v1) setEdgeEnd(edge, right, left, v1);
	  cells[left.index].halfedges.push(index);
	  cells[right.index].halfedges.push(index);
	  return edge;
	}

	function createBorderEdge(left, v0, v1) {
	  var edge = [v0, v1];
	  edge.left = left;
	  return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
	  if (!edge[0] && !edge[1]) {
	    edge[0] = vertex;
	    edge.left = left;
	    edge.right = right;
	  } else if (edge.left === right) {
	    edge[1] = vertex;
	  } else {
	    edge[0] = vertex;
	  }
	}

	// Liang–Barsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
	  var a = edge[0],
	      b = edge[1],
	      ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

	  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
	  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
	  return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
	  var v1 = edge[1];
	  if (v1) return true;

	  var v0 = edge[0],
	      left = edge.left,
	      right = edge.right,
	      lx = left[0],
	      ly = left[1],
	      rx = right[0],
	      ry = right[1],
	      fx = (lx + rx) / 2,
	      fy = (ly + ry) / 2,
	      fm,
	      fb;

	  if (ry === ly) {
	    if (fx < x0 || fx >= x1) return;
	    if (lx > rx) {
	      if (!v0) v0 = [fx, y0];
	      else if (v0[1] >= y1) return;
	      v1 = [fx, y1];
	    } else {
	      if (!v0) v0 = [fx, y1];
	      else if (v0[1] < y0) return;
	      v1 = [fx, y0];
	    }
	  } else {
	    fm = (lx - rx) / (ry - ly);
	    fb = fy - fm * fx;
	    if (fm < -1 || fm > 1) {
	      if (lx > rx) {
	        if (!v0) v0 = [(y0 - fb) / fm, y0];
	        else if (v0[1] >= y1) return;
	        v1 = [(y1 - fb) / fm, y1];
	      } else {
	        if (!v0) v0 = [(y1 - fb) / fm, y1];
	        else if (v0[1] < y0) return;
	        v1 = [(y0 - fb) / fm, y0];
	      }
	    } else {
	      if (ly < ry) {
	        if (!v0) v0 = [x0, fm * x0 + fb];
	        else if (v0[0] >= x1) return;
	        v1 = [x1, fm * x1 + fb];
	      } else {
	        if (!v0) v0 = [x1, fm * x1 + fb];
	        else if (v0[0] < x0) return;
	        v1 = [x0, fm * x0 + fb];
	      }
	    }
	  }

	  edge[0] = v0;
	  edge[1] = v1;
	  return true;
	}

	function clipEdges(x0, y0, x1, y1) {
	  var i = edges.length,
	      edge;

	  while (i--) {
	    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
	        || !clipEdge(edge, x0, y0, x1, y1)
	        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
	            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
	      delete edges[i];
	    }
	  }
	}

	function createCell(site) {
	  return cells[site.index] = {
	    site: site,
	    halfedges: []
	  };
	}

	function cellHalfedgeAngle(cell, edge) {
	  var site = cell.site,
	      va = edge.left,
	      vb = edge.right;
	  if (site === vb) vb = va, va = site;
	  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
	  if (site === va) va = edge[1], vb = edge[0];
	  else va = edge[0], vb = edge[1];
	  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
	  return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
	  return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
	  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
	    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
	      var index = new Array(m),
	          array = new Array(m);
	      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
	      index.sort(function(i, j) { return array[j] - array[i]; });
	      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	      for (j = 0; j < m; ++j) halfedges[j] = array[j];
	    }
	  }
	}

	function clipCells(x0, y0, x1, y1) {
	  var nCells = cells.length,
	      iCell,
	      cell,
	      site,
	      iHalfedge,
	      halfedges,
	      nHalfedges,
	      start,
	      startX,
	      startY,
	      end,
	      endX,
	      endY,
	      cover = true;

	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      site = cell.site;
	      halfedges = cell.halfedges;
	      iHalfedge = halfedges.length;

	      // Remove any dangling clipped edges.
	      while (iHalfedge--) {
	        if (!edges[halfedges[iHalfedge]]) {
	          halfedges.splice(iHalfedge, 1);
	        }
	      }

	      // Insert any border edges as necessary.
	      iHalfedge = 0, nHalfedges = halfedges.length;
	      while (iHalfedge < nHalfedges) {
	        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
	        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
	        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
	          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
	              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
	              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
	              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
	              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
	              : null)) - 1);
	          ++nHalfedges;
	        }
	      }

	      if (nHalfedges) cover = false;
	    }
	  }

	  // If there weren’t any edges, have the closest site cover the extent.
	  // It doesn’t matter which corner of the extent we measure!
	  if (cover) {
	    var dx, dy, d2, dc = Infinity;

	    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	      if (cell = cells[iCell]) {
	        site = cell.site;
	        dx = site[0] - x0;
	        dy = site[1] - y0;
	        d2 = dx * dx + dy * dy;
	        if (d2 < dc) dc = d2, cover = cell;
	      }
	    }

	    if (cover) {
	      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	      cover.halfedges.push(
	        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
	        edges.push(createBorderEdge(site, v01, v11)) - 1,
	        edges.push(createBorderEdge(site, v11, v10)) - 1,
	        edges.push(createBorderEdge(site, v10, v00)) - 1
	      );
	    }
	  }

	  // Lastly delete any cells with no edges; these were entirely clipped.
	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      if (!cell.halfedges.length) {
	        delete cells[iCell];
	      }
	    }
	  }
	}

	var circlePool = [];

	var firstCircle;

	function Circle() {
	  RedBlackNode(this);
	  this.x =
	  this.y =
	  this.arc =
	  this.site =
	  this.cy = null;
	}

	function attachCircle(arc) {
	  var lArc = arc.P,
	      rArc = arc.N;

	  if (!lArc || !rArc) return;

	  var lSite = lArc.site,
	      cSite = arc.site,
	      rSite = rArc.site;

	  if (lSite === rSite) return;

	  var bx = cSite[0],
	      by = cSite[1],
	      ax = lSite[0] - bx,
	      ay = lSite[1] - by,
	      cx = rSite[0] - bx,
	      cy = rSite[1] - by;

	  var d = 2 * (ax * cy - ay * cx);
	  if (d >= -epsilon2) return;

	  var ha = ax * ax + ay * ay,
	      hc = cx * cx + cy * cy,
	      x = (cy * ha - ay * hc) / d,
	      y = (ax * hc - cx * ha) / d;

	  var circle = circlePool.pop() || new Circle;
	  circle.arc = arc;
	  circle.site = cSite;
	  circle.x = x + bx;
	  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

	  arc.circle = circle;

	  var before = null,
	      node = circles._;

	  while (node) {
	    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	      if (node.L) node = node.L;
	      else { before = node.P; break; }
	    } else {
	      if (node.R) node = node.R;
	      else { before = node; break; }
	    }
	  }

	  circles.insert(before, circle);
	  if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
	  var circle = arc.circle;
	  if (circle) {
	    if (!circle.P) firstCircle = circle.N;
	    circles.remove(circle);
	    circlePool.push(circle);
	    RedBlackNode(circle);
	    arc.circle = null;
	  }
	}

	var beachPool = [];

	function Beach() {
	  RedBlackNode(this);
	  this.edge =
	  this.site =
	  this.circle = null;
	}

	function createBeach(site) {
	  var beach = beachPool.pop() || new Beach;
	  beach.site = site;
	  return beach;
	}

	function detachBeach(beach) {
	  detachCircle(beach);
	  beaches.remove(beach);
	  beachPool.push(beach);
	  RedBlackNode(beach);
	}

	function removeBeach(beach) {
	  var circle = beach.circle,
	      x = circle.x,
	      y = circle.cy,
	      vertex = [x, y],
	      previous = beach.P,
	      next = beach.N,
	      disappearing = [beach];

	  detachBeach(beach);

	  var lArc = previous;
	  while (lArc.circle
	      && Math.abs(x - lArc.circle.x) < epsilon
	      && Math.abs(y - lArc.circle.cy) < epsilon) {
	    previous = lArc.P;
	    disappearing.unshift(lArc);
	    detachBeach(lArc);
	    lArc = previous;
	  }

	  disappearing.unshift(lArc);
	  detachCircle(lArc);

	  var rArc = next;
	  while (rArc.circle
	      && Math.abs(x - rArc.circle.x) < epsilon
	      && Math.abs(y - rArc.circle.cy) < epsilon) {
	    next = rArc.N;
	    disappearing.push(rArc);
	    detachBeach(rArc);
	    rArc = next;
	  }

	  disappearing.push(rArc);
	  detachCircle(rArc);

	  var nArcs = disappearing.length,
	      iArc;
	  for (iArc = 1; iArc < nArcs; ++iArc) {
	    rArc = disappearing[iArc];
	    lArc = disappearing[iArc - 1];
	    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	  }

	  lArc = disappearing[0];
	  rArc = disappearing[nArcs - 1];
	  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function addBeach(site) {
	  var x = site[0],
	      directrix = site[1],
	      lArc,
	      rArc,
	      dxl,
	      dxr,
	      node = beaches._;

	  while (node) {
	    dxl = leftBreakPoint(node, directrix) - x;
	    if (dxl > epsilon) node = node.L; else {
	      dxr = x - rightBreakPoint(node, directrix);
	      if (dxr > epsilon) {
	        if (!node.R) {
	          lArc = node;
	          break;
	        }
	        node = node.R;
	      } else {
	        if (dxl > -epsilon) {
	          lArc = node.P;
	          rArc = node;
	        } else if (dxr > -epsilon) {
	          lArc = node;
	          rArc = node.N;
	        } else {
	          lArc = rArc = node;
	        }
	        break;
	      }
	    }
	  }

	  createCell(site);
	  var newArc = createBeach(site);
	  beaches.insert(lArc, newArc);

	  if (!lArc && !rArc) return;

	  if (lArc === rArc) {
	    detachCircle(lArc);
	    rArc = createBeach(lArc.site);
	    beaches.insert(newArc, rArc);
	    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	    attachCircle(lArc);
	    attachCircle(rArc);
	    return;
	  }

	  if (!rArc) { // && lArc
	    newArc.edge = createEdge(lArc.site, newArc.site);
	    return;
	  }

	  // else lArc !== rArc
	  detachCircle(lArc);
	  detachCircle(rArc);

	  var lSite = lArc.site,
	      ax = lSite[0],
	      ay = lSite[1],
	      bx = site[0] - ax,
	      by = site[1] - ay,
	      rSite = rArc.site,
	      cx = rSite[0] - ax,
	      cy = rSite[1] - ay,
	      d = 2 * (bx * cy - by * cx),
	      hb = bx * bx + by * by,
	      hc = cx * cx + cy * cy,
	      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

	  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
	  newArc.edge = createEdge(lSite, site, null, vertex);
	  rArc.edge = createEdge(site, rSite, null, vertex);
	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
	  var site = arc.site,
	      rfocx = site[0],
	      rfocy = site[1],
	      pby2 = rfocy - directrix;

	  if (!pby2) return rfocx;

	  var lArc = arc.P;
	  if (!lArc) return -Infinity;

	  site = lArc.site;
	  var lfocx = site[0],
	      lfocy = site[1],
	      plby2 = lfocy - directrix;

	  if (!plby2) return lfocx;

	  var hl = lfocx - rfocx,
	      aby2 = 1 / pby2 - 1 / plby2,
	      b = hl / plby2;

	  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

	  return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
	  var rArc = arc.N;
	  if (rArc) return leftBreakPoint(rArc, directrix);
	  var site = arc.site;
	  return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
	  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
	  return b[1] - a[1]
	      || b[0] - a[0];
	}

	function Diagram(sites, extent) {
	  var site = sites.sort(lexicographic).pop(),
	      x,
	      y,
	      circle;

	  edges = [];
	  cells = new Array(sites.length);
	  beaches = new RedBlackTree;
	  circles = new RedBlackTree;

	  while (true) {
	    circle = firstCircle;
	    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	      if (site[0] !== x || site[1] !== y) {
	        addBeach(site);
	        x = site[0], y = site[1];
	      }
	      site = sites.pop();
	    } else if (circle) {
	      removeBeach(circle.arc);
	    } else {
	      break;
	    }
	  }

	  sortCellHalfedges();

	  if (extent) {
	    var x0 = +extent[0][0],
	        y0 = +extent[0][1],
	        x1 = +extent[1][0],
	        y1 = +extent[1][1];
	    clipEdges(x0, y0, x1, y1);
	    clipCells(x0, y0, x1, y1);
	  }

	  this.edges = edges;
	  this.cells = cells;

	  beaches =
	  circles =
	  edges =
	  cells = null;
	}

	Diagram.prototype = {
	  constructor: Diagram,

	  polygons: function() {
	    var edges = this.edges;

	    return this.cells.map(function(cell) {
	      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	      polygon.data = cell.site.data;
	      return polygon;
	    });
	  },

	  triangles: function() {
	    var triangles = [],
	        edges = this.edges;

	    this.cells.forEach(function(cell, i) {
	      if (!(m = (halfedges = cell.halfedges).length)) return;
	      var site = cell.site,
	          halfedges,
	          j = -1,
	          m,
	          s0,
	          e1 = edges[halfedges[m - 1]],
	          s1 = e1.left === site ? e1.right : e1.left;

	      while (++j < m) {
	        s0 = s1;
	        e1 = edges[halfedges[j]];
	        s1 = e1.left === site ? e1.right : e1.left;
	        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
	          triangles.push([site.data, s0.data, s1.data]);
	        }
	      }
	    });

	    return triangles;
	  },

	  links: function() {
	    return this.edges.filter(function(edge) {
	      return edge.right;
	    }).map(function(edge) {
	      return {
	        source: edge.left.data,
	        target: edge.right.data
	      };
	    });
	  },

	  find: function(x, y, radius) {
	    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	    // Use the previously-found cell, or start with an arbitrary one.
	    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	    // Traverse the half-edges to find a closer cell, if any.
	    do {
	      cell = that.cells[i0 = i1], i1 = null;
	      cell.halfedges.forEach(function(e) {
	        var edge = that.edges[e], v = edge.left;
	        if ((v === cell.site || !v) && !(v = edge.right)) return;
	        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
	        if (v2 < d2) d2 = v2, i1 = v.index;
	      });
	    } while (i1 !== null);

	    that._found = i0;

	    return radius == null || d2 <= radius * radius ? cell.site : null;
	  }
	};

	function voronoi() {
	  var x$$1 = x,
	      y$$1 = y,
	      extent = null;

	  function voronoi(data) {
	    return new Diagram(data.map(function(d, i) {
	      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
	      s.index = i;
	      s.data = d;
	      return s;
	    }), extent);
	  }

	  voronoi.polygons = function(data) {
	    return voronoi(data).polygons();
	  };

	  voronoi.links = function(data) {
	    return voronoi(data).links();
	  };

	  voronoi.triangles = function(data) {
	    return voronoi(data).triangles();
	  };

	  voronoi.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
	  };

	  voronoi.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
	  };

	  voronoi.extent = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
	  };

	  voronoi.size = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
	  };

	  return voronoi;
	}

	exports.voronoi = voronoi;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-zoom/ v1.8.3 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(10), __webpack_require__(12), __webpack_require__(11), __webpack_require__(14)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function ZoomEvent(target, type, transform) {
	  this.target = target;
	  this.type = type;
	  this.transform = transform;
	}

	function Transform(k, x, y) {
	  this.k = k;
	  this.x = x;
	  this.y = y;
	}

	Transform.prototype = {
	  constructor: Transform,
	  scale: function(k) {
	    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
	  },
	  translate: function(x, y) {
	    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
	  },
	  apply: function(point) {
	    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
	  },
	  applyX: function(x) {
	    return x * this.k + this.x;
	  },
	  applyY: function(y) {
	    return y * this.k + this.y;
	  },
	  invert: function(location) {
	    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
	  },
	  invertX: function(x) {
	    return (x - this.x) / this.k;
	  },
	  invertY: function(y) {
	    return (y - this.y) / this.k;
	  },
	  rescaleX: function(x) {
	    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
	  },
	  rescaleY: function(y) {
	    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
	  },
	  toString: function() {
	    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	  }
	};

	var identity = new Transform(1, 0, 0);

	transform.prototype = Transform.prototype;

	function transform(node) {
	  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
	  return node.__zoom;
	}

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultExtent() {
	  var e = this;
	  if (e instanceof SVGElement) {
	    e = e.ownerSVGElement || e;
	    if (e.hasAttribute("viewBox")) {
	      e = e.viewBox.baseVal;
	      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
	    }
	    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
	  }
	  return [[0, 0], [e.clientWidth, e.clientHeight]];
	}

	function defaultTransform() {
	  return this.__zoom || identity;
	}

	function defaultWheelDelta() {
	  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 0.002);
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	function defaultConstrain(transform, extent, translateExtent) {
	  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
	      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
	      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
	      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
	  return transform.translate(
	    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
	    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
	  );
	}

	function zoom() {
	  var filter = defaultFilter,
	      extent = defaultExtent,
	      constrain = defaultConstrain,
	      wheelDelta = defaultWheelDelta,
	      touchable = defaultTouchable,
	      scaleExtent = [0, Infinity],
	      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
	      duration = 250,
	      interpolate = d3Interpolate.interpolateZoom,
	      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
	      touchstarting,
	      touchending,
	      touchDelay = 500,
	      wheelDelay = 150,
	      clickDistance2 = 0;

	  function zoom(selection) {
	    selection
	        .property("__zoom", defaultTransform)
	        .on("wheel.zoom", wheeled)
	        .on("mousedown.zoom", mousedowned)
	        .on("dblclick.zoom", dblclicked)
	      .filter(touchable)
	        .on("touchstart.zoom", touchstarted)
	        .on("touchmove.zoom", touchmoved)
	        .on("touchend.zoom touchcancel.zoom", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  zoom.transform = function(collection, transform, point) {
	    var selection = collection.selection ? collection.selection() : collection;
	    selection.property("__zoom", defaultTransform);
	    if (collection !== selection) {
	      schedule(collection, transform, point);
	    } else {
	      selection.interrupt().each(function() {
	        gesture(this, arguments)
	            .start()
	            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
	            .end();
	      });
	    }
	  };

	  zoom.scaleBy = function(selection, k, p) {
	    zoom.scaleTo(selection, function() {
	      var k0 = this.__zoom.k,
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return k0 * k1;
	    }, p);
	  };

	  zoom.scaleTo = function(selection, k, p) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t0 = this.__zoom,
	          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
	          p1 = t0.invert(p0),
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
	    }, p);
	  };

	  zoom.translateBy = function(selection, x, y) {
	    zoom.transform(selection, function() {
	      return constrain(this.__zoom.translate(
	        typeof x === "function" ? x.apply(this, arguments) : x,
	        typeof y === "function" ? y.apply(this, arguments) : y
	      ), extent.apply(this, arguments), translateExtent);
	    });
	  };

	  zoom.translateTo = function(selection, x, y, p) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t = this.__zoom,
	          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
	      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
	        typeof x === "function" ? -x.apply(this, arguments) : -x,
	        typeof y === "function" ? -y.apply(this, arguments) : -y
	      ), e, translateExtent);
	    }, p);
	  };

	  function scale(transform, k) {
	    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
	    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
	  }

	  function translate(transform, p0, p1) {
	    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
	    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
	  }

	  function centroid(extent) {
	    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
	  }

	  function schedule(transition, transform, point) {
	    transition
	        .on("start.zoom", function() { gesture(this, arguments).start(); })
	        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
	        .tween("zoom", function() {
	          var that = this,
	              args = arguments,
	              g = gesture(that, args),
	              e = extent.apply(that, args),
	              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
	              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
	              a = that.__zoom,
	              b = typeof transform === "function" ? transform.apply(that, args) : transform,
	              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
	          return function(t) {
	            if (t === 1) t = b; // Avoid rounding error on end.
	            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
	            g.zoom(null, t);
	          };
	        });
	  }

	  function gesture(that, args, clean) {
	    return (!clean && that.__zooming) || new Gesture(that, args);
	  }

	  function Gesture(that, args) {
	    this.that = that;
	    this.args = args;
	    this.active = 0;
	    this.extent = extent.apply(that, args);
	    this.taps = 0;
	  }

	  Gesture.prototype = {
	    start: function() {
	      if (++this.active === 1) {
	        this.that.__zooming = this;
	        this.emit("start");
	      }
	      return this;
	    },
	    zoom: function(key, transform) {
	      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
	      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
	      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
	      this.that.__zoom = transform;
	      this.emit("zoom");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) {
	        delete this.that.__zooming;
	        this.emit("end");
	      }
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function wheeled() {
	    if (!filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments),
	        t = this.__zoom,
	        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
	        p = d3Selection.mouse(this);

	    // If the mouse is in the same location as before, reuse it.
	    // If there were recent wheel events, reset the wheel idle timeout.
	    if (g.wheel) {
	      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
	        g.mouse[1] = t.invert(g.mouse[0] = p);
	      }
	      clearTimeout(g.wheel);
	    }

	    // If this wheel event won’t trigger a transform change, ignore it.
	    else if (t.k === k) return;

	    // Otherwise, capture the mouse point and location at the start.
	    else {
	      g.mouse = [p, t.invert(p)];
	      d3Transition.interrupt(this);
	      g.start();
	    }

	    noevent();
	    g.wheel = setTimeout(wheelidled, wheelDelay);
	    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

	    function wheelidled() {
	      g.wheel = null;
	      g.end();
	    }
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments, true),
	        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
	        p = d3Selection.mouse(this),
	        x0 = d3Selection.event.clientX,
	        y0 = d3Selection.event.clientY;

	    d3Drag.dragDisable(d3Selection.event.view);
	    nopropagation();
	    g.mouse = [p, this.__zoom.invert(p)];
	    d3Transition.interrupt(this);
	    g.start();

	    function mousemoved() {
	      noevent();
	      if (!g.moved) {
	        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
	        g.moved = dx * dx + dy * dy > clickDistance2;
	      }
	      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
	    }

	    function mouseupped() {
	      v.on("mousemove.zoom mouseup.zoom", null);
	      d3Drag.dragEnable(d3Selection.event.view, g.moved);
	      noevent();
	      g.end();
	    }
	  }

	  function dblclicked() {
	    if (!filter.apply(this, arguments)) return;
	    var t0 = this.__zoom,
	        p0 = d3Selection.mouse(this),
	        p1 = t0.invert(p0),
	        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
	        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

	    noevent();
	    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
	    else d3Selection.select(this).call(zoom.transform, t1);
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches = d3Selection.event.touches,
	        n = touches.length,
	        g = gesture(this, arguments, d3Selection.event.changedTouches.length === n),
	        started, i, t, p;

	    nopropagation();
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      p = [p, this.__zoom.invert(p), t.identifier];
	      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
	      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
	    }

	    if (touchstarting) touchstarting = clearTimeout(touchstarting);

	    if (started) {
	      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
	      d3Transition.interrupt(this);
	      g.start();
	    }
	  }

	  function touchmoved() {
	    if (!this.__zooming) return;
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t, p, l;

	    noevent();
	    if (touchstarting) touchstarting = clearTimeout(touchstarting);
	    g.taps = 0;
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
	      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
	    }
	    t = g.that.__zoom;
	    if (g.touch1) {
	      var p0 = g.touch0[0], l0 = g.touch0[1],
	          p1 = g.touch1[0], l1 = g.touch1[1],
	          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
	          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
	      t = scale(t, Math.sqrt(dp / dl));
	      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
	      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
	    }
	    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
	    else return;
	    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
	  }

	  function touchended() {
	    if (!this.__zooming) return;
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t;

	    nopropagation();
	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, touchDelay);
	    for (i = 0; i < n; ++i) {
	      t = touches[i];
	      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
	      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
	    }
	    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
	    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
	    else {
	      g.end();
	      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
	      if (g.taps === 2) {
	        var p = d3Selection.select(this).on("dblclick.zoom");
	        if (p) p.apply(this, arguments);
	      }
	    }
	  }

	  zoom.wheelDelta = function(_) {
	    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
	  };

	  zoom.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
	  };

	  zoom.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
	  };

	  zoom.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
	  };

	  zoom.scaleExtent = function(_) {
	    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
	  };

	  zoom.translateExtent = function(_) {
	    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
	  };

	  zoom.constrain = function(_) {
	    return arguments.length ? (constrain = _, zoom) : constrain;
	  };

	  zoom.duration = function(_) {
	    return arguments.length ? (duration = +_, zoom) : duration;
	  };

	  zoom.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, zoom) : interpolate;
	  };

	  zoom.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? zoom : value;
	  };

	  zoom.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
	  };

	  return zoom;
	}

	exports.zoom = zoom;
	exports.zoomIdentity = identity;
	exports.zoomTransform = transform;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var three$1 = __webpack_require__(41);
	var ThreeDragControls = _interopDefault(__webpack_require__(42));
	var ThreeForceGraph = _interopDefault(__webpack_require__(43));
	var ThreeRenderObjects = _interopDefault(__webpack_require__(84));
	var accessorFn = _interopDefault(__webpack_require__(78));
	var Kapsule = _interopDefault(__webpack_require__(76));

	function styleInject(css, ref) {
	  if (ref === void 0) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') {
	    return;
	  }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = ".graph-info-msg {\n  top: 50%;\n  width: 100%;\n  text-align: center;\n  color: lavender;\n  opacity: 0.7;\n  font-size: 22px;\n  position: absolute;\n  font-family: Sans-serif;\n}\n\n.grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}";
	styleInject(css_248z);

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(n);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function linkKapsule (kapsulePropName, kapsuleType) {
	  var dummyK = new kapsuleType(); // To extract defaults

	  return {
	    linkProp: function linkProp(prop) {
	      // link property config
	      return {
	        "default": dummyK[prop](),
	        onChange: function onChange(v, state) {
	          state[kapsulePropName][prop](v);
	        },
	        triggerUpdate: false
	      };
	    },
	    linkMethod: function linkMethod(method) {
	      // link method pass-through
	      return function (state) {
	        var kapsuleInstance = state[kapsulePropName];

	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }

	        var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
	        return returnVal === kapsuleInstance ? this // chain based on the parent object, not the inner kapsule
	        : returnVal;
	      };
	    }
	  };
	}

	var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
	: {
	  AmbientLight: three$1.AmbientLight,
	  DirectionalLight: three$1.DirectionalLight,
	  Vector3: three$1.Vector3
	};

	var CAMERA_DISTANCE2NODES_FACTOR = 170; //
	// Expose config from forceGraph

	var bindFG = linkKapsule('forceGraph', ThreeForceGraph);
	var linkedFGProps = Object.assign.apply(Object, _toConsumableArray(['jsonUrl', 'graphData', 'numDimensions', 'dagMode', 'dagLevelDistance', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeVisibility', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'forceEngine', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {
	  return _defineProperty({}, p, bindFG.linkProp(p));
	})));
	var linkedFGMethods = Object.assign.apply(Object, _toConsumableArray(['refresh', 'd3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {
	  return _defineProperty({}, p, bindFG.linkMethod(p));
	}))); // Expose config from renderObjs

	var bindRenderObjs = linkKapsule('renderObjs', ThreeRenderObjects);
	var linkedRenderObjsProps = Object.assign.apply(Object, _toConsumableArray(['width', 'height', 'backgroundColor', 'showNavInfo', 'enablePointerInteraction', 'postProcessingComposer'].map(function (p) {
	  return _defineProperty({}, p, bindRenderObjs.linkProp(p));
	})));
	var linkedRenderObjsMethods = Object.assign.apply(Object, _toConsumableArray(['cameraPosition'].map(function (p) {
	  return _defineProperty({}, p, bindRenderObjs.linkMethod(p));
	}))); //

	var _3dForceGraph = Kapsule({
	  props: _objectSpread2({
	    nodeLabel: {
	      "default": 'name',
	      triggerUpdate: false
	    },
	    linkLabel: {
	      "default": 'name',
	      triggerUpdate: false
	    },
	    linkHoverPrecision: {
	      "default": 1,
	      onChange: function onChange(p, state) {
	        return state.renderObjs.lineHoverPrecision(p);
	      },
	      triggerUpdate: false
	    },
	    enableNavigationControls: {
	      "default": true,
	      onChange: function onChange(enable, state) {
	        var controls = state.renderObjs.controls();

	        if (controls) {
	          controls.enabled = enable;
	        }
	      },
	      triggerUpdate: false
	    },
	    enableNodeDrag: {
	      "default": true,
	      triggerUpdate: false
	    },
	    onNodeDrag: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeDragEnd: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeRightClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeHover: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onLinkClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onLinkRightClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onLinkHover: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onBackgroundClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onBackgroundRightClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    }
	  }, linkedFGProps, {}, linkedRenderObjsProps),
	  methods: _objectSpread2({
	    graph2ScreenCoords: function graph2ScreenCoords(state, x, y, z) {
	      var vec = new three.Vector3(x, y, z);
	      vec.project(this.camera()); // project to the camera plane

	      return {
	        // align relative pos to canvas dimensions
	        x: (vec.x + 1) * state.width / 2,
	        y: -(vec.y - 1) * state.height / 2
	      };
	    },
	    pauseAnimation: function pauseAnimation(state) {
	      if (state.animationFrameRequestId !== null) {
	        cancelAnimationFrame(state.animationFrameRequestId);
	        state.animationFrameRequestId = null;
	      }

	      return this;
	    },
	    resumeAnimation: function resumeAnimation(state) {
	      if (state.animationFrameRequestId === null) {
	        this._animationCycle();
	      }

	      return this;
	    },
	    _animationCycle: function _animationCycle(state) {
	      if (state.enablePointerInteraction) {
	        // reset canvas cursor (override dragControls cursor)
	        this.renderer().domElement.style.cursor = null;
	      } // Frame cycle


	      state.forceGraph.tickFrame();
	      state.renderObjs.tick();
	      state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
	    },
	    scene: function scene(state) {
	      return state.renderObjs.scene();
	    },
	    // Expose scene
	    camera: function camera(state) {
	      return state.renderObjs.camera();
	    },
	    // Expose camera
	    renderer: function renderer(state) {
	      return state.renderObjs.renderer();
	    },
	    // Expose renderer
	    controls: function controls(state) {
	      return state.renderObjs.controls();
	    },
	    // Expose controls
	    tbControls: function tbControls(state) {
	      return state.renderObjs.tbControls();
	    },
	    // To be deprecated
	    _destructor: function _destructor() {
	      this.pauseAnimation();
	      this.graphData({
	        nodes: [],
	        links: []
	      });
	    }
	  }, linkedFGMethods, {}, linkedRenderObjsMethods),
	  stateInit: function stateInit(_ref5) {
	    var controlType = _ref5.controlType,
	        rendererConfig = _ref5.rendererConfig;
	    return {
	      forceGraph: new ThreeForceGraph(),
	      renderObjs: ThreeRenderObjects({
	        controlType: controlType,
	        rendererConfig: rendererConfig
	      })
	    };
	  },
	  init: function init(domNode, state) {
	    // Wipe DOM
	    domNode.innerHTML = ''; // Add relative container

	    domNode.appendChild(state.container = document.createElement('div'));
	    state.container.style.position = 'relative'; // Add renderObjs

	    var roDomNode = document.createElement('div');
	    state.container.appendChild(roDomNode);
	    state.renderObjs(roDomNode);
	    var camera = state.renderObjs.camera();
	    var renderer = state.renderObjs.renderer();
	    var controls = state.renderObjs.controls();
	    controls.enabled = !!state.enableNavigationControls;
	    state.lastSetCameraZ = camera.position.z; // Add info space

	    var infoElem;
	    state.container.appendChild(infoElem = document.createElement('div'));
	    infoElem.className = 'graph-info-msg';
	    infoElem.textContent = ''; // config forcegraph

	    state.forceGraph.onLoading(function () {
	      infoElem.textContent = 'Loading...';
	    }).onFinishLoading(function () {
	      infoElem.textContent = '';
	    }).onUpdate(function () {
	      // sync graph data structures
	      state.graphData = state.forceGraph.graphData(); // re-aim camera, if still in default position (not user modified)

	      if (camera.position.x === 0 && camera.position.y === 0 && camera.position.z === state.lastSetCameraZ && state.graphData.nodes.length) {
	        camera.lookAt(state.forceGraph.position);
	        state.lastSetCameraZ = camera.position.z = Math.cbrt(state.graphData.nodes.length) * CAMERA_DISTANCE2NODES_FACTOR;
	      }
	    }).onFinishUpdate(function () {
	      // Setup node drag interaction
	      if (state._dragControls) {
	        var curNodeDrag = state.graphData.nodes.find(function (node) {
	          return node.__initialFixedPos && !node.__disposeControlsAfterDrag;
	        }); // detect if there's a node being dragged using the existing drag controls

	        if (curNodeDrag) {
	          curNodeDrag.__disposeControlsAfterDrag = true; // postpone previous controls disposal until drag ends
	        } else {
	          state._dragControls.dispose(); // cancel previous drag controls

	        }

	        state._dragControls = undefined;
	      }

	      if (state.enableNodeDrag && state.enablePointerInteraction && state.forceEngine === 'd3') {
	        // Can't access node positions programatically in ngraph
	        var dragControls = state._dragControls = new ThreeDragControls(state.graphData.nodes.map(function (node) {
	          return node.__threeObj;
	        }).filter(function (obj) {
	          return obj;
	        }), camera, renderer.domElement);
	        dragControls.addEventListener('dragstart', function (event) {
	          controls.enabled = false; // Disable controls while dragging

	          var node = event.object.__data;
	          !node.__initialFixedPos && (node.__initialFixedPos = {
	            fx: node.fx,
	            fy: node.fy,
	            fz: node.fz
	          });
	          !node.__initialPos && (node.__initialPos = {
	            x: node.x,
	            y: node.y,
	            z: node.z
	          }); // lock node

	          ['x', 'y', 'z'].forEach(function (c) {
	            return node["f".concat(c)] = node[c];
	          }); // drag cursor

	          renderer.domElement.classList.add('grabbable');
	        });
	        dragControls.addEventListener('drag', function (event) {
	          state.ignoreOneClick = true; // Don't click the node if it's being dragged

	          var node = event.object.__data;
	          var newPos = event.object.position;
	          var translate = {
	            x: newPos.x - node.x,
	            y: newPos.y - node.y,
	            z: newPos.z - node.z
	          }; // Move fx/fy/fz (and x/y/z) of nodes based on object new position

	          ['x', 'y', 'z'].forEach(function (c) {
	            return node["f".concat(c)] = node[c] = newPos[c];
	          });
	          state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag
	          .resetCountdown(); // prevent freeze while dragging

	          node.__dragged = true;
	          state.onNodeDrag(node, translate);
	        });
	        dragControls.addEventListener('dragend', function (event) {
	          var node = event.object.__data; // dispose previous controls if needed

	          if (node.__disposeControlsAfterDrag) {
	            dragControls.dispose();
	            delete node.__disposeControlsAfterDrag;
	          }

	          var initFixedPos = node.__initialFixedPos;
	          var initPos = node.__initialPos;
	          var translate = {
	            x: initPos.x - node.x,
	            y: initPos.y - node.y,
	            z: initPos.z - node.z
	          };

	          if (initFixedPos) {
	            ['x', 'y', 'z'].forEach(function (c) {
	              var fc = "f".concat(c);

	              if (initFixedPos[fc] === undefined) {
	                delete node[fc];
	              }
	            });
	            delete node.__initialFixedPos;
	            delete node.__initialPos;

	            if (node.__dragged) {
	              delete node.__dragged;
	              state.onNodeDragEnd(node, translate);
	            }
	          }

	          state.forceGraph.d3AlphaTarget(0) // release engine low intensity
	          .resetCountdown(); // let the engine readjust after releasing fixed nodes

	          if (state.enableNavigationControls) {
	            controls.enabled = true; // Re-enable controls
	          } // clear cursor


	          renderer.domElement.classList.remove('grabbable');
	        });
	      }
	    }); // config renderObjs

	    var getGraphObj = function getGraphObj(object) {
	      var obj = object; // recurse up object chain until finding the graph object

	      while (obj && !obj.hasOwnProperty('__graphObjType')) {
	        obj = obj.parent;
	      }

	      return obj;
	    };

	    state.renderObjs.objects([// Populate scene
	    new three.AmbientLight(0xbbbbbb), new three.DirectionalLight(0xffffff, 0.6), state.forceGraph]).hoverOrderComparator(function (a, b) {
	      // Prioritize graph objects
	      var aObj = getGraphObj(a);
	      if (!aObj) return 1;
	      var bObj = getGraphObj(b);
	      if (!bObj) return -1; // Prioritize nodes over links

	      var isNode = function isNode(o) {
	        return o.__graphObjType === 'node';
	      };

	      return isNode(bObj) - isNode(aObj);
	    }).tooltipContent(function (obj) {
	      var graphObj = getGraphObj(obj);
	      return graphObj ? accessorFn(state["".concat(graphObj.__graphObjType, "Label")])(graphObj.__data) || '' : '';
	    }).onHover(function (obj) {
	      // Update tooltip and trigger onHover events
	      var hoverObj = getGraphObj(obj);

	      if (hoverObj !== state.hoverObj) {
	        var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;
	        var prevObjData = state.hoverObj ? state.hoverObj.__data : null;
	        var objType = hoverObj ? hoverObj.__graphObjType : null;
	        var objData = hoverObj ? hoverObj.__data : null;

	        if (prevObjType && prevObjType !== objType) {
	          // Hover out
	          state["on".concat(prevObjType === 'node' ? 'Node' : 'Link', "Hover")](null, prevObjData);
	        }

	        if (objType) {
	          // Hover in
	          state["on".concat(objType === 'node' ? 'Node' : 'Link', "Hover")](objData, prevObjType === objType ? prevObjData : null);
	        }

	        state.hoverObj = hoverObj;
	      }
	    }).onClick(function (obj, ev) {
	      // Handle click events on objects
	      if (state.ignoreOneClick) {
	        // f.e. because of dragend event
	        state.ignoreOneClick = false;
	        return;
	      }

	      var graphObj = getGraphObj(obj);

	      if (graphObj) {
	        state["on".concat(graphObj.__graphObjType === 'node' ? 'Node' : 'Link', "Click")](graphObj.__data, ev);
	      } else {
	        state.onBackgroundClick(ev);
	      }
	    }).onRightClick(function (obj, ev) {
	      // Handle right-click events
	      var graphObj = getGraphObj(obj);

	      if (graphObj) {
	        state["on".concat(graphObj.__graphObjType === 'node' ? 'Node' : 'Link', "RightClick")](graphObj.__data, ev);
	      } else {
	        state.onBackgroundRightClick(ev);
	      }
	    }); //
	    // Kick-off renderer

	    this._animationCycle();
	  }
	});

	module.exports = _3dForceGraph;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(global = global || self, factory(global.THREE = {}));
	}(this, (function (exports) { 'use strict';

		// Polyfills

		if ( Number.EPSILON === undefined ) {

			Number.EPSILON = Math.pow( 2, - 52 );

		}

		if ( Number.isInteger === undefined ) {

			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

			Number.isInteger = function ( value ) {

				return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

			};

		}

		//

		if ( Math.sign === undefined ) {

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

			Math.sign = function ( x ) {

				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

			};

		}

		if ( 'name' in Function.prototype === false ) {

			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

			Object.defineProperty( Function.prototype, 'name', {

				get: function () {

					return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

				}

			} );

		}

		if ( Object.assign === undefined ) {

			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		}

		var REVISION = '115';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
		var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var VSMShadowMap = 3;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var ACESFilmicToneMapping = 5;

		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var NearestFilter = 1003;
		var NearestMipmapNearestFilter = 1004;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipmapLinearFilter = 1005;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipmapNearestFilter = 1007;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipmapLinearFilter = 1008;
		var LinearMipMapLinearFilter = 1008;
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RedFormat = 1028;
		var RedIntegerFormat = 1029;
		var RGFormat = 1030;
		var RGIntegerFormat = 1031;
		var RGBIntegerFormat = 1032;
		var RGBAIntegerFormat = 1033;

		var RGB_S3TC_DXT1_Format = 33776;
		var RGBA_S3TC_DXT1_Format = 33777;
		var RGBA_S3TC_DXT3_Format = 33778;
		var RGBA_S3TC_DXT5_Format = 33779;
		var RGB_PVRTC_4BPPV1_Format = 35840;
		var RGB_PVRTC_2BPPV1_Format = 35841;
		var RGBA_PVRTC_4BPPV1_Format = 35842;
		var RGBA_PVRTC_2BPPV1_Format = 35843;
		var RGB_ETC1_Format = 36196;
		var RGB_ETC2_Format = 37492;
		var RGBA_ETC2_EAC_Format = 37496;
		var RGBA_ASTC_4x4_Format = 37808;
		var RGBA_ASTC_5x4_Format = 37809;
		var RGBA_ASTC_5x5_Format = 37810;
		var RGBA_ASTC_6x5_Format = 37811;
		var RGBA_ASTC_6x6_Format = 37812;
		var RGBA_ASTC_8x5_Format = 37813;
		var RGBA_ASTC_8x6_Format = 37814;
		var RGBA_ASTC_8x8_Format = 37815;
		var RGBA_ASTC_10x5_Format = 37816;
		var RGBA_ASTC_10x6_Format = 37817;
		var RGBA_ASTC_10x8_Format = 37818;
		var RGBA_ASTC_10x10_Format = 37819;
		var RGBA_ASTC_12x10_Format = 37820;
		var RGBA_ASTC_12x12_Format = 37821;
		var RGBA_BPTC_Format = 36492;
		var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
		var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
		var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
		var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
		var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
		var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
		var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
		var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
		var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
		var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
		var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
		var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
		var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
		var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;
		var TangentSpaceNormalMap = 0;
		var ObjectSpaceNormalMap = 1;

		var ZeroStencilOp = 0;
		var KeepStencilOp = 7680;
		var ReplaceStencilOp = 7681;
		var IncrementStencilOp = 7682;
		var DecrementStencilOp = 7683;
		var IncrementWrapStencilOp = 34055;
		var DecrementWrapStencilOp = 34056;
		var InvertStencilOp = 5386;

		var NeverStencilFunc = 512;
		var LessStencilFunc = 513;
		var EqualStencilFunc = 514;
		var LessEqualStencilFunc = 515;
		var GreaterStencilFunc = 516;
		var NotEqualStencilFunc = 517;
		var GreaterEqualStencilFunc = 518;
		var AlwaysStencilFunc = 519;

		var StaticDrawUsage = 35044;
		var DynamicDrawUsage = 35048;
		var StreamDrawUsage = 35040;
		var StaticReadUsage = 35045;
		var DynamicReadUsage = 35049;
		var StreamReadUsage = 35041;
		var StaticCopyUsage = 35046;
		var DynamicCopyUsage = 35050;
		var StreamCopyUsage = 35042;

		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */

		function EventDispatcher() {}

		Object.assign( EventDispatcher.prototype, {

			addEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) { this._listeners = {}; }

				var listeners = this._listeners;

				if ( listeners[ type ] === undefined ) {

					listeners[ type ] = [];

				}

				if ( listeners[ type ].indexOf( listener ) === - 1 ) {

					listeners[ type ].push( listener );

				}

			},

			hasEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) { return false; }

				var listeners = this._listeners;

				return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

			},

			removeEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) { return; }

				var listeners = this._listeners;
				var listenerArray = listeners[ type ];

				if ( listenerArray !== undefined ) {

					var index = listenerArray.indexOf( listener );

					if ( index !== - 1 ) {

						listenerArray.splice( index, 1 );

					}

				}

			},

			dispatchEvent: function ( event ) {

				if ( this._listeners === undefined ) { return; }

				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];

				if ( listenerArray !== undefined ) {

					event.target = this;

					// Make a copy, in case listeners are removed while iterating.
					var array = listenerArray.slice( 0 );

					for ( var i = 0, l = array.length; i < l; i ++ ) {

						array[ i ].call( this, event );

					}

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author thezwap
		 */

		var _lut = [];

		for ( var i = 0; i < 256; i ++ ) {

			_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

		}

		var MathUtils = {

			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,

			generateUUID: function () {

				// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
					_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
					_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
					_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();

			},

			clamp: function ( value, min, max ) {

				return Math.max( min, Math.min( max, value ) );

			},

			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation

			euclideanModulo: function ( n, m ) {

				return ( ( n % m ) + m ) % m;

			},

			// Linear mapping from range <a1, a2> to range <b1, b2>

			mapLinear: function ( x, a1, a2, b1, b2 ) {

				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

			},

			// https://en.wikipedia.org/wiki/Linear_interpolation

			lerp: function ( x, y, t ) {

				return ( 1 - t ) * x + t * y;

			},

			// http://en.wikipedia.org/wiki/Smoothstep

			smoothstep: function ( x, min, max ) {

				if ( x <= min ) { return 0; }
				if ( x >= max ) { return 1; }

				x = ( x - min ) / ( max - min );

				return x * x * ( 3 - 2 * x );

			},

			smootherstep: function ( x, min, max ) {

				if ( x <= min ) { return 0; }
				if ( x >= max ) { return 1; }

				x = ( x - min ) / ( max - min );

				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

			},

			// Random integer from <low, high> interval

			randInt: function ( low, high ) {

				return low + Math.floor( Math.random() * ( high - low + 1 ) );

			},

			// Random float from <low, high> interval

			randFloat: function ( low, high ) {

				return low + Math.random() * ( high - low );

			},

			// Random float from <-range/2, range/2> interval

			randFloatSpread: function ( range ) {

				return range * ( 0.5 - Math.random() );

			},

			degToRad: function ( degrees ) {

				return degrees * MathUtils.DEG2RAD;

			},

			radToDeg: function ( radians ) {

				return radians * MathUtils.RAD2DEG;

			},

			isPowerOfTwo: function ( value ) {

				return ( value & ( value - 1 ) ) === 0 && value !== 0;

			},

			ceilPowerOfTwo: function ( value ) {

				return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

			},

			floorPowerOfTwo: function ( value ) {

				return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

			},

			setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

				// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

				// rotations are applied to the axes in the order specified by 'order'
				// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
				// angles are in radians

				var cos = Math.cos;
				var sin = Math.sin;

				var c2 = cos( b / 2 );
				var s2 = sin( b / 2 );

				var c13 = cos( ( a + c ) / 2 );
				var s13 = sin( ( a + c ) / 2 );

				var c1_3 = cos( ( a - c ) / 2 );
				var s1_3 = sin( ( a - c ) / 2 );

				var c3_1 = cos( ( c - a ) / 2 );
				var s3_1 = sin( ( c - a ) / 2 );

				if ( order === 'XYX' ) {

					q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

				} else if ( order === 'YZY' ) {

					q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

				} else if ( order === 'ZXZ' ) {

					q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

				} else if ( order === 'XZX' ) {

					q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

				} else if ( order === 'YXY' ) {

					q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

				} else if ( order === 'ZYZ' ) {

					q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

				} else {

					console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

				}

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		function Vector2( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}

		Object.defineProperties( Vector2.prototype, {

			"width": {

				get: function () {

					return this.x;

				},

				set: function ( value ) {

					this.x = value;

				}

			},

			"height": {

				get: function () {

					return this.y;

				},

				set: function ( value ) {

					this.y = value;

				}

			}

		} );

		Object.assign( Vector2.prototype, {

			isVector2: true,

			set: function ( x, y ) {

				this.x = x;
				this.y = y;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;

				return this;

			},

			multiply: function ( v ) {

				this.x *= v.x;
				this.y *= v.y;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				this.x *= scalar;
				this.y *= scalar;

				return this;

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			applyMatrix3: function ( m ) {

				var x = this.x, y = this.y;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

				return this;

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );

				return this;

			},

			clamp: function ( min, max ) {

				// assumes min < max, componentwise

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );

				return this;

			},

			clampScalar: function ( minVal, maxVal ) {

				this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
				this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

				return this;

			},

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y;

			},

			cross: function ( v ) {

				return this.x * v.y - this.y * v.x;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y );

			},

			manhattanLength: function () {

				return Math.abs( this.x ) + Math.abs( this.y );

			},

			normalize: function () {

				return this.divideScalar( this.length() || 1 );

			},

			angle: function () {

				// computes the angle in radians with respect to the positive x-axis

				var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

				return angle;

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;

			},

			manhattanDistanceTo: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

			},

			setLength: function ( length ) {

				return this.normalize().multiplyScalar( length );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );

				return this;

			},

			rotateAround: function ( center, angle ) {

				var c = Math.cos( angle ), s = Math.sin( angle );

				var x = this.x - center.x;
				var y = this.y - center.y;

				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;

				return this;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */

		function Matrix3() {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Object.assign( Matrix3.prototype, {

			isMatrix3: true,

			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0,
					0, 1, 0,
					0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new this.constructor().fromArray( this.elements );

			},

			copy: function ( m ) {

				var te = this.elements;
				var me = m.elements;

				te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
				te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
				te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

				return this;

			},

			extractBasis: function ( xAxis, yAxis, zAxis ) {

				xAxis.setFromMatrix3Column( this, 0 );
				yAxis.setFromMatrix3Column( this, 1 );
				zAxis.setFromMatrix3Column( this, 2 );

				return this;

			},

			setFromMatrix4: function ( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 4 ], me[ 8 ],
					me[ 1 ], me[ 5 ], me[ 9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]

				);

				return this;

			},

			multiply: function ( m ) {

				return this.multiplyMatrices( this, m );

			},

			premultiply: function ( m ) {

				return this.multiplyMatrices( m, this );

			},

			multiplyMatrices: function ( a, b ) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
				var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
				var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

				var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
				var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
				var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
				te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
				te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
				te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
				te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
				te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
				te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

				return this;

			},

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

				return this;

			},

			determinant: function () {

				var te = this.elements;

				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

			},

			getInverse: function ( matrix, throwOnDegenerate ) {

				if ( throwOnDegenerate !== undefined ) {

					console.warn( "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate." );

				}

				var me = matrix.elements,
					te = this.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,

					det = n11 * t11 + n21 * t12 + n31 * t13;

				if ( det === 0 ) { return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); }

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

				return this;

			},

			transpose: function () {

				var tmp, m = this.elements;

				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

				return this;

			},

			getNormalMatrix: function ( matrix4 ) {

				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

			},

			transposeIntoArray: function ( r ) {

				var m = this.elements;

				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];

				return this;

			},

			setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

				var c = Math.cos( rotation );
				var s = Math.sin( rotation );

				this.set(
					sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
					- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
					0, 0, 1
				);

			},

			scale: function ( sx, sy ) {

				var te = this.elements;

				te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
				te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

				return this;

			},

			rotate: function ( theta ) {

				var c = Math.cos( theta );
				var s = Math.sin( theta );

				var te = this.elements;

				var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
				var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

				te[ 0 ] = c * a11 + s * a21;
				te[ 3 ] = c * a12 + s * a22;
				te[ 6 ] = c * a13 + s * a23;

				te[ 1 ] = - s * a11 + c * a21;
				te[ 4 ] = - s * a12 + c * a22;
				te[ 7 ] = - s * a13 + c * a23;

				return this;

			},

			translate: function ( tx, ty ) {

				var te = this.elements;

				te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
				te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

				return this;

			},

			equals: function ( matrix ) {

				var te = this.elements;
				var me = matrix.elements;

				for ( var i = 0; i < 9; i ++ ) {

					if ( te[ i ] !== me[ i ] ) { return false; }

				}

				return true;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				for ( var i = 0; i < 9; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];

				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];

				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ] = te[ 8 ];

				return array;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */

		var _canvas;

		var ImageUtils = {

			getDataURL: function ( image ) {

				var canvas;

				if ( typeof HTMLCanvasElement == 'undefined' ) {

					return image.src;

				} else if ( image instanceof HTMLCanvasElement ) {

					canvas = image;

				} else {

					if ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }

					_canvas.width = image.width;
					_canvas.height = image.height;

					var context = _canvas.getContext( '2d' );

					if ( image instanceof ImageData ) {

						context.putImageData( image, 0, 0 );

					} else {

						context.drawImage( image, 0, 0, image.width, image.height );

					}

					canvas = _canvas;

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */

		var textureId = 0;

		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';

			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];

			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;

			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

			this.format = format !== undefined ? format : RGBAFormat;
			this.internalFormat = null;
			this.type = type !== undefined ? type : UnsignedByteType;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding : LinearEncoding;

			this.version = 0;
			this.onUpdate = null;

		}

		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;

		Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: Texture,

			isTexture: true,

			updateMatrix: function () {

				this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.name = source.name;

				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );

				this.mapping = source.mapping;

				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;

				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;

				this.anisotropy = source.anisotropy;

				this.format = source.format;
				this.internalFormat = source.internalFormat;
				this.type = source.type;

				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );
				this.center.copy( source.center );
				this.rotation = source.rotation;

				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrix.copy( source.matrix );

				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;

				return this;

			},

			toJSON: function ( meta ) {

				var isRootObject = ( meta === undefined || typeof meta === 'string' );

				if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

					return meta.textures[ this.uuid ];

				}

				var output = {

					metadata: {
						version: 4.5,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},

					uuid: this.uuid,
					name: this.name,

					mapping: this.mapping,

					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					center: [ this.center.x, this.center.y ],
					rotation: this.rotation,

					wrap: [ this.wrapS, this.wrapT ],

					format: this.format,
					type: this.type,
					encoding: this.encoding,

					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,

					flipY: this.flipY,

					premultiplyAlpha: this.premultiplyAlpha,
					unpackAlignment: this.unpackAlignment

				};

				if ( this.image !== undefined ) {

					// TODO: Move to THREE.Image

					var image = this.image;

					if ( image.uuid === undefined ) {

						image.uuid = MathUtils.generateUUID(); // UGH

					}

					if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

						var url;

						if ( Array.isArray( image ) ) {

							// process array of images e.g. CubeTexture

							url = [];

							for ( var i = 0, l = image.length; i < l; i ++ ) {

								url.push( ImageUtils.getDataURL( image[ i ] ) );

							}

						} else {

							// process single image

							url = ImageUtils.getDataURL( image );

						}

						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: url
						};

					}

					output.image = image.uuid;

				}

				if ( ! isRootObject ) {

					meta.textures[ this.uuid ] = output;

				}

				return output;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			},

			transformUv: function ( uv ) {

				if ( this.mapping !== UVMapping ) { return uv; }

				uv.applyMatrix3( this.matrix );

				if ( uv.x < 0 || uv.x > 1 ) {

					switch ( this.wrapS ) {

						case RepeatWrapping:

							uv.x = uv.x - Math.floor( uv.x );
							break;

						case ClampToEdgeWrapping:

							uv.x = uv.x < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

								uv.x = Math.ceil( uv.x ) - uv.x;

							} else {

								uv.x = uv.x - Math.floor( uv.x );

							}
							break;

					}

				}

				if ( uv.y < 0 || uv.y > 1 ) {

					switch ( this.wrapT ) {

						case RepeatWrapping:

							uv.y = uv.y - Math.floor( uv.y );
							break;

						case ClampToEdgeWrapping:

							uv.y = uv.y < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

								uv.y = Math.ceil( uv.y ) - uv.y;

							} else {

								uv.y = uv.y - Math.floor( uv.y );

							}
							break;

					}

				}

				if ( this.flipY ) {

					uv.y = 1 - uv.y;

				}

				return uv;

			}

		} );

		Object.defineProperty( Texture.prototype, "needsUpdate", {

			set: function ( value ) {

				if ( value === true ) { this.version ++; }

			}

		} );

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector4( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

		Object.defineProperties( Vector4.prototype, {

			"width": {

				get: function () {

					return this.z;

				},

				set: function ( value ) {

					this.z = value;

				}

			},

			"height": {

				get: function () {

					return this.w;

				},

				set: function ( value ) {

					this.w = value;

				}

			}

		} );

		Object.assign( Vector4.prototype, {

			isVector4: true,

			set: function ( x, y, z, w ) {

				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setW: function ( w ) {

				this.w = w;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z, this.w );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;

				return this;

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			setAxisAngleFromQuaternion: function ( q ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

				// q is assumed to be normalized

				this.w = 2 * Math.acos( q.w );

				var s = Math.sqrt( 1 - q.w * q.w );

				if ( s < 0.0001 ) {

					this.x = 1;
					this.y = 0;
					this.z = 0;

				} else {

					this.x = q.x / s;
					this.y = q.y / s;
					this.z = q.z / s;

				}

				return this;

			},

			setAxisAngleFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

					te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {

					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms

					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

						// this singularity is identity matrix so angle = 0

						this.set( 1, 0, 0, 0 );

						return this; // zero angle, arbitrary axis

					}

					// otherwise this singularity is angle = 180

					angle = Math.PI;

					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;

					if ( ( xx > yy ) && ( xx > zz ) ) {

						// m11 is the largest diagonal term

						if ( xx < epsilon ) {

							x = 0;
							y = 0.707106781;
							z = 0.707106781;

						} else {

							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;

						}

					} else if ( yy > zz ) {

						// m22 is the largest diagonal term

						if ( yy < epsilon ) {

							x = 0.707106781;
							y = 0;
							z = 0.707106781;

						} else {

							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;

						}

					} else {

						// m33 is the largest diagonal term so base result on this

						if ( zz < epsilon ) {

							x = 0.707106781;
							y = 0.707106781;
							z = 0;

						} else {

							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;

						}

					}

					this.set( x, y, z, angle );

					return this; // return 180 deg rotation

				}

				// as we have reached here there are no singularities so we can handle normally

				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

				if ( Math.abs( s ) < 0.001 ) { s = 1; }

				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case

				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

				return this;

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );

				return this;

			},

			clamp: function ( min, max ) {

				// assumes min < max, componentwise

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );

				return this;

			},

			clampScalar: function ( minVal, maxVal ) {

				this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
				this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
				this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
				this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

				return this;

			},

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

			},

			manhattanLength: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

			},

			normalize: function () {

				return this.divideScalar( this.length() || 1 );

			},

			setLength: function ( length ) {

				return this.normalize().multiplyScalar( length );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
				this.w = attribute.getW( index );

				return this;

			}

		} );

		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */

		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {

			this.width = width;
			this.height = height;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.texture.image = {};
			this.texture.image.width = width;
			this.texture.image.height = height;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		}

		WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: WebGLRenderTarget,

			isWebGLRenderTarget: true,

			setSize: function ( width, height ) {

				if ( this.width !== width || this.height !== height ) {

					this.width = width;
					this.height = height;

					this.texture.image.width = width;
					this.texture.image.height = height;

					this.dispose();

				}

				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.width = source.width;
				this.height = source.height;

				this.viewport.copy( source.viewport );

				this.texture = source.texture.clone();

				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 * @author Matt DesLauriers / @mattdesl
		 */

		function WebGLMultisampleRenderTarget( width, height, options ) {

			WebGLRenderTarget.call( this, width, height, options );

			this.samples = 4;

		}

		WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

			constructor: WebGLMultisampleRenderTarget,

			isWebGLMultisampleRenderTarget: true,

			copy: function ( source ) {

				WebGLRenderTarget.prototype.copy.call( this, source );

				this.samples = source.samples;

				return this;

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Quaternion( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}

		Object.assign( Quaternion, {

			slerp: function ( qa, qb, qm, t ) {

				return qm.copy( qa ).slerp( qb, t );

			},

			slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

				// fuzz-free, array-based Quaternion SLERP operation

				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],

					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];

				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

					var s = 1 - t,

						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;

					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {

						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );

						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;

					}

					var tDir = t * dir;

					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;

					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {

						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;

					}

				}

				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;

			}

		} );

		Object.defineProperties( Quaternion.prototype, {

			x: {

				get: function () {

					return this._x;

				},

				set: function ( value ) {

					this._x = value;
					this._onChangeCallback();

				}

			},

			y: {

				get: function () {

					return this._y;

				},

				set: function ( value ) {

					this._y = value;
					this._onChangeCallback();

				}

			},

			z: {

				get: function () {

					return this._z;

				},

				set: function ( value ) {

					this._z = value;
					this._onChangeCallback();

				}

			},

			w: {

				get: function () {

					return this._w;

				},

				set: function ( value ) {

					this._w = value;
					this._onChangeCallback();

				}

			}

		} );

		Object.assign( Quaternion.prototype, {

			isQuaternion: true,

			set: function ( x, y, z, w ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;

				this._onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._w );

			},

			copy: function ( quaternion ) {

				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;

				this._onChangeCallback();

				return this;

			},

			setFromEuler: function ( euler, update ) {

				if ( ! ( euler && euler.isEuler ) ) {

					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m

				var cos = Math.cos;
				var sin = Math.sin;

				var c1 = cos( x / 2 );
				var c2 = cos( y / 2 );
				var c3 = cos( z / 2 );

				var s1 = sin( x / 2 );
				var s2 = sin( y / 2 );
				var s3 = sin( z / 2 );

				if ( order === 'XYZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'YXZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'ZXY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'ZYX' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'YZX' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'XZY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				}

				if ( update !== false ) { this._onChangeCallback(); }

				return this;

			},

			setFromAxisAngle: function ( axis, angle ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

				// assumes axis is normalized

				var halfAngle = angle / 2, s = Math.sin( halfAngle );

				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );

				this._onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

					trace = m11 + m22 + m33,
					s;

				if ( trace > 0 ) {

					s = 0.5 / Math.sqrt( trace + 1.0 );

					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;

				} else if ( m11 > m22 && m11 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;

				} else if ( m22 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;

				} else {

					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;

				}

				this._onChangeCallback();

				return this;

			},

			setFromUnitVectors: function ( vFrom, vTo ) {

				// assumes direction vectors vFrom and vTo are normalized

				var EPS = 0.000001;

				var r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						this._x = - vFrom.y;
						this._y = vFrom.x;
						this._z = 0;
						this._w = r;

					} else {

						this._x = 0;
						this._y = - vFrom.z;
						this._z = vFrom.y;
						this._w = r;

					}

				} else {

					// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

					this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
					this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
					this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
					this._w = r;

				}

				return this.normalize();

			},

			angleTo: function ( q ) {

				return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

			},

			rotateTowards: function ( q, step ) {

				var angle = this.angleTo( q );

				if ( angle === 0 ) { return this; }

				var t = Math.min( 1, step / angle );

				this.slerp( q, t );

				return this;

			},

			inverse: function () {

				// quaternion is assumed to have unit length

				return this.conjugate();

			},

			conjugate: function () {

				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;

				this._onChangeCallback();

				return this;

			},

			dot: function ( v ) {

				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

			},

			lengthSq: function () {

				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

			},

			length: function () {

				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

			},

			normalize: function () {

				var l = this.length();

				if ( l === 0 ) {

					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;

				} else {

					l = 1 / l;

					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;

				}

				this._onChangeCallback();

				return this;

			},

			multiply: function ( q, p ) {

				if ( p !== undefined ) {

					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );

				}

				return this.multiplyQuaternions( this, q );

			},

			premultiply: function ( q ) {

				return this.multiplyQuaternions( q, this );

			},

			multiplyQuaternions: function ( a, b ) {

				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

				this._onChangeCallback();

				return this;

			},

			slerp: function ( qb, t ) {

				if ( t === 0 ) { return this; }
				if ( t === 1 ) { return this.copy( qb ); }

				var x = this._x, y = this._y, z = this._z, w = this._w;

				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

				if ( cosHalfTheta < 0 ) {

					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;

					cosHalfTheta = - cosHalfTheta;

				} else {

					this.copy( qb );

				}

				if ( cosHalfTheta >= 1.0 ) {

					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;

					return this;

				}

				var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

				if ( sqrSinHalfTheta <= Number.EPSILON ) {

					var s = 1 - t;
					this._w = s * w + t * this._w;
					this._x = s * x + t * this._x;
					this._y = s * y + t * this._y;
					this._z = s * z + t * this._z;

					this.normalize();
					this._onChangeCallback();

					return this;

				}

				var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
					ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );

				this._onChangeCallback();

				return this;

			},

			equals: function ( quaternion ) {

				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];

				this._onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;

				return array;

			},

			fromBufferAttribute: function ( attribute, index ) {

				this._x = attribute.getX( index );
				this._y = attribute.getY( index );
				this._z = attribute.getZ( index );
				this._w = attribute.getW( index );

				return this;

			},

			_onChange: function ( callback ) {

				this._onChangeCallback = callback;

				return this;

			},

			_onChangeCallback: function () {}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		var _vector = new Vector3();
		var _quaternion = new Quaternion();

		function Vector3( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

		Object.assign( Vector3.prototype, {

			isVector3: true,

			set: function ( x, y, z ) {

				this.x = x;
				this.y = y;
				this.z = z;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}

				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;

				return this;

			},

			multiply: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );

				}

				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;

				return this;

			},

			multiplyVectors: function ( a, b ) {

				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;

				return this;

			},

			applyEuler: function ( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

			},

			applyAxisAngle: function ( axis, angle ) {

				return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

			},

			applyMatrix3: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

				return this;

			},

			applyNormalMatrix: function ( m ) {

				return this.applyMatrix3( m ).normalize();

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

				this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
				this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
				this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

				return this;

			},

			applyQuaternion: function ( q ) {

				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

				// calculate quat * vector

				var ix = qw * x + qy * z - qz * y;
				var iy = qw * y + qz * x - qx * z;
				var iz = qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;

				// calculate result * inverse quat

				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

				return this;

			},

			project: function ( camera ) {

				return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

			},

			unproject: function ( camera ) {

				return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

			},

			transformDirection: function ( m ) {

				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

				return this.normalize();

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );

				return this;

			},

			clamp: function ( min, max ) {

				// assumes min < max, componentwise

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );

				return this;

			},

			clampScalar: function ( minVal, maxVal ) {

				this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
				this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
				this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

				return this;

			},

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z;

			},

			// TODO lengthSquared?

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

			},

			manhattanLength: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

			},

			normalize: function () {

				return this.divideScalar( this.length() || 1 );

			},

			setLength: function ( length ) {

				return this.normalize().multiplyScalar( length );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			cross: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );

				}

				return this.crossVectors( this, v );

			},

			crossVectors: function ( a, b ) {

				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;

				return this;

			},

			projectOnVector: function ( v ) {

				var denominator = v.lengthSq();

				if ( denominator === 0 ) { return this.set( 0, 0, 0 ); }

				var scalar = v.dot( this ) / denominator;

				return this.copy( v ).multiplyScalar( scalar );

			},

			projectOnPlane: function ( planeNormal ) {

				_vector.copy( this ).projectOnVector( planeNormal );

				return this.sub( _vector );

			},

			reflect: function ( normal ) {

				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length

				return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			},

			angleTo: function ( v ) {

				var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

				if ( denominator === 0 ) { return Math.PI / 2; }

				var theta = this.dot( v ) / denominator;

				// clamp, to handle numerical problems

				return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

				return dx * dx + dy * dy + dz * dz;

			},

			manhattanDistanceTo: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

			},

			setFromSpherical: function ( s ) {

				return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

			},

			setFromSphericalCoords: function ( radius, phi, theta ) {

				var sinPhiRadius = Math.sin( phi ) * radius;

				this.x = sinPhiRadius * Math.sin( theta );
				this.y = Math.cos( phi ) * radius;
				this.z = sinPhiRadius * Math.cos( theta );

				return this;

			},

			setFromCylindrical: function ( c ) {

				return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

			},

			setFromCylindricalCoords: function ( radius, theta, y ) {

				this.x = radius * Math.sin( theta );
				this.y = y;
				this.z = radius * Math.cos( theta );

				return this;

			},

			setFromMatrixPosition: function ( m ) {

				var e = m.elements;

				this.x = e[ 12 ];
				this.y = e[ 13 ];
				this.z = e[ 14 ];

				return this;

			},

			setFromMatrixScale: function ( m ) {

				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();

				this.x = sx;
				this.y = sy;
				this.z = sz;

				return this;

			},

			setFromMatrixColumn: function ( m, index ) {

				return this.fromArray( m.elements, index * 4 );

			},

			setFromMatrix3Column: function ( m, index ) {

				return this.fromArray( m.elements, index * 3 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;

				return array;

			},

			fromBufferAttribute: function ( attribute, index, offset ) {

				if ( offset !== undefined ) {

					console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

				}

				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );

				return this;

			}

		} );

		var _v1 = new Vector3();
		var _m1 = new Matrix4();
		var _zero = new Vector3( 0, 0, 0 );
		var _one = new Vector3( 1, 1, 1 );
		var _x = new Vector3();
		var _y = new Vector3();
		var _z = new Vector3();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Matrix4() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Object.assign( Matrix4.prototype, {

			isMatrix4: true,

			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new Matrix4().fromArray( this.elements );

			},

			copy: function ( m ) {

				var te = this.elements;
				var me = m.elements;

				te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
				te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
				te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
				te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

				return this;

			},

			copyPosition: function ( m ) {

				var te = this.elements, me = m.elements;

				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];

				return this;

			},

			extractBasis: function ( xAxis, yAxis, zAxis ) {

				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );

				return this;

			},

			makeBasis: function ( xAxis, yAxis, zAxis ) {

				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0, 0, 0, 1
				);

				return this;

			},

			extractRotation: function ( m ) {

				// this method does not support reflection matrices

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;

				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			makeRotationFromEuler: function ( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				var te = this.elements;

				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );

				if ( euler.order === 'XYZ' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;

					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;

					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YXZ' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;

					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;

					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZXY' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;

					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;

					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZYX' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;

					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;

					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YZX' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;

					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;

					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;

				} else if ( euler.order === 'XZY' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;

					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;

					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;

				}

				// bottom row
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// last column
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			makeRotationFromQuaternion: function ( q ) {

				return this.compose( _zero, q, _one );

			},

			lookAt: function ( eye, target, up ) {

				var te = this.elements;

				_z.subVectors( eye, target );

				if ( _z.lengthSq() === 0 ) {

					// eye and target are in the same position

					_z.z = 1;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

				if ( _x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						_z.x += 0.0001;

					} else {

						_z.z += 0.0001;

					}

					_z.normalize();
					_x.crossVectors( up, _z );

				}

				_x.normalize();
				_y.crossVectors( _z, _x );

				te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
				te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
				te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

				return this;

			},

			multiply: function ( m, n ) {

				if ( n !== undefined ) {

					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );

				}

				return this.multiplyMatrices( this, m );

			},

			premultiply: function ( m ) {

				return this.multiplyMatrices( m, this );

			},

			multiplyMatrices: function ( a, b ) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

				return this;

			},

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

				return this;

			},

			determinant: function () {

				var te = this.elements;

				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)

				);

			},

			transpose: function () {

				var te = this.elements;
				var tmp;

				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

				return this;

			},

			setPosition: function ( x, y, z ) {

				var te = this.elements;

				if ( x.isVector3 ) {

					te[ 12 ] = x.x;
					te[ 13 ] = x.y;
					te[ 14 ] = x.z;

				} else {

					te[ 12 ] = x;
					te[ 13 ] = y;
					te[ 14 ] = z;

				}

				return this;

			},

			getInverse: function ( m, throwOnDegenerate ) {

				if ( throwOnDegenerate !== undefined ) {

					console.warn( "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate." );

				}

				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

				if ( det === 0 ) { return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ); }

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

				return this;

			},

			scale: function ( v ) {

				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;

				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

				return this;

			},

			getMaxScaleOnAxis: function () {

				var te = this.elements;

				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

			},

			makeTranslation: function ( x, y, z ) {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationX: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					1, 0, 0, 0,
					0, c, - s, 0,
					0, s, c, 0,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationY: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1

				);

				return this;

			},

			makeRotationZ: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					c, - s, 0, 0,
					s, c, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationAxis: function ( axis, angle ) {

				// Based on http://www.gamedev.net/reference/articles/article1199.asp

				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;

				this.set(

					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1

				);

				 return this;

			},

			makeScale: function ( x, y, z ) {

				this.set(

					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1

				);

				return this;

			},

			makeShear: function ( x, y, z ) {

				this.set(

					1, y, z, 0,
					x, 1, z, 0,
					x, y, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			compose: function ( position, quaternion, scale ) {

				var te = this.elements;

				var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
				var x2 = x + x,	y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;

				var sx = scale.x, sy = scale.y, sz = scale.z;

				te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
				te[ 1 ] = ( xy + wz ) * sx;
				te[ 2 ] = ( xz - wy ) * sx;
				te[ 3 ] = 0;

				te[ 4 ] = ( xy - wz ) * sy;
				te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
				te[ 6 ] = ( yz + wx ) * sy;
				te[ 7 ] = 0;

				te[ 8 ] = ( xz + wy ) * sz;
				te[ 9 ] = ( yz - wx ) * sz;
				te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
				te[ 11 ] = 0;

				te[ 12 ] = position.x;
				te[ 13 ] = position.y;
				te[ 14 ] = position.z;
				te[ 15 ] = 1;

				return this;

			},

			decompose: function ( position, quaternion, scale ) {

				var te = this.elements;

				var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) { sx = - sx; }

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				_m1.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				_m1.elements[ 0 ] *= invSX;
				_m1.elements[ 1 ] *= invSX;
				_m1.elements[ 2 ] *= invSX;

				_m1.elements[ 4 ] *= invSY;
				_m1.elements[ 5 ] *= invSY;
				_m1.elements[ 6 ] *= invSY;

				_m1.elements[ 8 ] *= invSZ;
				_m1.elements[ 9 ] *= invSZ;
				_m1.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( _m1 );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			},

			makePerspective: function ( left, right, top, bottom, near, far ) {

				if ( far === undefined ) {

					console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

				}

				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );

				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );

				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

				return this;

			},

			makeOrthographic: function ( left, right, top, bottom, near, far ) {

				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );

				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;

				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

				return this;

			},

			equals: function ( matrix ) {

				var te = this.elements;
				var me = matrix.elements;

				for ( var i = 0; i < 16; i ++ ) {

					if ( te[ i ] !== me[ i ] ) { return false; }

				}

				return true;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				for ( var i = 0; i < 16; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];

				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];

				array[ offset + 8 ] = te[ 8 ];
				array[ offset + 9 ] = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];

				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];

				return array;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		var _matrix = new Matrix4();
		var _quaternion$1 = new Quaternion();

		function Euler( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}

		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

		Euler.DefaultOrder = 'XYZ';

		Object.defineProperties( Euler.prototype, {

			x: {

				get: function () {

					return this._x;

				},

				set: function ( value ) {

					this._x = value;
					this._onChangeCallback();

				}

			},

			y: {

				get: function () {

					return this._y;

				},

				set: function ( value ) {

					this._y = value;
					this._onChangeCallback();

				}

			},

			z: {

				get: function () {

					return this._z;

				},

				set: function ( value ) {

					this._z = value;
					this._onChangeCallback();

				}

			},

			order: {

				get: function () {

					return this._order;

				},

				set: function ( value ) {

					this._order = value;
					this._onChangeCallback();

				}

			}

		} );

		Object.assign( Euler.prototype, {

			isEuler: true,

			set: function ( x, y, z, order ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;

				this._onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._order );

			},

			copy: function ( euler ) {

				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;

				this._onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m, order, update ) {

				var clamp = MathUtils.clamp;

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				order = order || this._order;

				if ( order === 'XYZ' ) {

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

				} else if ( order === 'YXZ' ) {

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

				} else if ( order === 'ZXY' ) {

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

				} else if ( order === 'ZYX' ) {

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

				} else if ( order === 'YZX' ) {

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

				} else if ( order === 'XZY' ) {

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

				} else {

					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

				}

				this._order = order;

				if ( update !== false ) { this._onChangeCallback(); }

				return this;

			},

			setFromQuaternion: function ( q, order, update ) {

				_matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( _matrix, order, update );

			},

			setFromVector3: function ( v, order ) {

				return this.set( v.x, v.y, v.z, order || this._order );

			},

			reorder: function ( newOrder ) {

				// WARNING: this discards revolution information -bhouston

				_quaternion$1.setFromEuler( this );

				return this.setFromQuaternion( _quaternion$1, newOrder );

			},

			equals: function ( euler ) {

				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

			},

			fromArray: function ( array ) {

				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

				this._onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;

				return array;

			},

			toVector3: function ( optionalResult ) {

				if ( optionalResult ) {

					return optionalResult.set( this._x, this._y, this._z );

				} else {

					return new Vector3( this._x, this._y, this._z );

				}

			},

			_onChange: function ( callback ) {

				this._onChangeCallback = callback;

				return this;

			},

			_onChangeCallback: function () {}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Layers() {

			this.mask = 1 | 0;

		}

		Object.assign( Layers.prototype, {

			set: function ( channel ) {

				this.mask = 1 << channel | 0;

			},

			enable: function ( channel ) {

				this.mask |= 1 << channel | 0;

			},

			enableAll: function () {

				this.mask = 0xffffffff | 0;

			},

			toggle: function ( channel ) {

				this.mask ^= 1 << channel | 0;

			},

			disable: function ( channel ) {

				this.mask &= ~ ( 1 << channel | 0 );

			},

			disableAll: function () {

				this.mask = 0;

			},

			test: function ( layers ) {

				return ( this.mask & layers.mask ) !== 0;

			}

		} );

		var _object3DId = 0;

		var _v1$1 = new Vector3();
		var _q1 = new Quaternion();
		var _m1$1 = new Matrix4();
		var _target = new Vector3();

		var _position = new Vector3();
		var _scale = new Vector3();
		var _quaternion$2 = new Quaternion();

		var _xAxis = new Vector3( 1, 0, 0 );
		var _yAxis = new Vector3( 0, 1, 0 );
		var _zAxis = new Vector3( 0, 0, 1 );

		var _addedEvent = { type: 'added' };
		var _removedEvent = { type: 'removed' };

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */

		function Object3D() {

			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.userData = {};

		}

		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;

		Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: Object3D,

			isObject3D: true,

			onBeforeRender: function () {},
			onAfterRender: function () {},

			applyMatrix4: function ( matrix ) {

				if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

				this.matrix.premultiply( matrix );

				this.matrix.decompose( this.position, this.quaternion, this.scale );

			},

			applyQuaternion: function ( q ) {

				this.quaternion.premultiply( q );

				return this;

			},

			setRotationFromAxisAngle: function ( axis, angle ) {

				// assumes axis is normalized

				this.quaternion.setFromAxisAngle( axis, angle );

			},

			setRotationFromEuler: function ( euler ) {

				this.quaternion.setFromEuler( euler, true );

			},

			setRotationFromMatrix: function ( m ) {

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				this.quaternion.setFromRotationMatrix( m );

			},

			setRotationFromQuaternion: function ( q ) {

				// assumes q is normalized

				this.quaternion.copy( q );

			},

			rotateOnAxis: function ( axis, angle ) {

				// rotate object on axis in object space
				// axis is assumed to be normalized

				_q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( _q1 );

				return this;

			},

			rotateOnWorldAxis: function ( axis, angle ) {

				// rotate object on axis in world space
				// axis is assumed to be normalized
				// method assumes no rotated parent

				_q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( _q1 );

				return this;

			},

			rotateX: function ( angle ) {

				return this.rotateOnAxis( _xAxis, angle );

			},

			rotateY: function ( angle ) {

				return this.rotateOnAxis( _yAxis, angle );

			},

			rotateZ: function ( angle ) {

				return this.rotateOnAxis( _zAxis, angle );

			},

			translateOnAxis: function ( axis, distance ) {

				// translate object by distance along axis in object space
				// axis is assumed to be normalized

				_v1$1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( _v1$1.multiplyScalar( distance ) );

				return this;

			},

			translateX: function ( distance ) {

				return this.translateOnAxis( _xAxis, distance );

			},

			translateY: function ( distance ) {

				return this.translateOnAxis( _yAxis, distance );

			},

			translateZ: function ( distance ) {

				return this.translateOnAxis( _zAxis, distance );

			},

			localToWorld: function ( vector ) {

				return vector.applyMatrix4( this.matrixWorld );

			},

			worldToLocal: function ( vector ) {

				return vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );

			},

			lookAt: function ( x, y, z ) {

				// This method does not support objects having non-uniformly-scaled parent(s)

				if ( x.isVector3 ) {

					_target.copy( x );

				} else {

					_target.set( x, y, z );

				}

				var parent = this.parent;

				this.updateWorldMatrix( true, false );

				_position.setFromMatrixPosition( this.matrixWorld );

				if ( this.isCamera || this.isLight ) {

					_m1$1.lookAt( _position, _target, this.up );

				} else {

					_m1$1.lookAt( _target, _position, this.up );

				}

				this.quaternion.setFromRotationMatrix( _m1$1 );

				if ( parent ) {

					_m1$1.extractRotation( parent.matrixWorld );
					_q1.setFromRotationMatrix( _m1$1 );
					this.quaternion.premultiply( _q1.inverse() );

				}

			},

			add: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.add( arguments[ i ] );

					}

					return this;

				}

				if ( object === this ) {

					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;

				}

				if ( ( object && object.isObject3D ) ) {

					if ( object.parent !== null ) {

						object.parent.remove( object );

					}

					object.parent = this;
					this.children.push( object );

					object.dispatchEvent( _addedEvent );

				} else {

					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

				}

				return this;

			},

			remove: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.remove( arguments[ i ] );

					}

					return this;

				}

				var index = this.children.indexOf( object );

				if ( index !== - 1 ) {

					object.parent = null;
					this.children.splice( index, 1 );

					object.dispatchEvent( _removedEvent );

				}

				return this;

			},

			attach: function ( object ) {

				// adds object as a child of this, while maintaining the object's world transform

				this.updateWorldMatrix( true, false );

				_m1$1.getInverse( this.matrixWorld );

				if ( object.parent !== null ) {

					object.parent.updateWorldMatrix( true, false );

					_m1$1.multiply( object.parent.matrixWorld );

				}

				object.applyMatrix4( _m1$1 );

				object.updateWorldMatrix( false, false );

				this.add( object );

				return this;

			},

			getObjectById: function ( id ) {

				return this.getObjectByProperty( 'id', id );

			},

			getObjectByName: function ( name ) {

				return this.getObjectByProperty( 'name', name );

			},

			getObjectByProperty: function ( name, value ) {

				if ( this[ name ] === value ) { return this; }

				for ( var i = 0, l = this.children.length; i < l; i ++ ) {

					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );

					if ( object !== undefined ) {

						return object;

					}

				}

				return undefined;

			},

			getWorldPosition: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				return target.setFromMatrixPosition( this.matrixWorld );

			},

			getWorldQuaternion: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( _position, target, _scale );

				return target;

			},

			getWorldScale: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( _position, _quaternion$2, target );

				return target;

			},

			getWorldDirection: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				var e = this.matrixWorld.elements;

				return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

			},

			raycast: function () {},

			traverse: function ( callback ) {

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverse( callback );

				}

			},

			traverseVisible: function ( callback ) {

				if ( this.visible === false ) { return; }

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverseVisible( callback );

				}

			},

			traverseAncestors: function ( callback ) {

				var parent = this.parent;

				if ( parent !== null ) {

					callback( parent );

					parent.traverseAncestors( callback );

				}

			},

			updateMatrix: function () {

				this.matrix.compose( this.position, this.quaternion, this.scale );

				this.matrixWorldNeedsUpdate = true;

			},

			updateMatrixWorld: function ( force ) {

				if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

				if ( this.matrixWorldNeedsUpdate || force ) {

					if ( this.parent === null ) {

						this.matrixWorld.copy( this.matrix );

					} else {

						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					}

					this.matrixWorldNeedsUpdate = false;

					force = true;

				}

				// update children

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( force );

				}

			},

			updateWorldMatrix: function ( updateParents, updateChildren ) {

				var parent = this.parent;

				if ( updateParents === true && parent !== null ) {

					parent.updateWorldMatrix( true, false );

				}

				if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				// update children

				if ( updateChildren === true ) {

					var children = this.children;

					for ( var i = 0, l = children.length; i < l; i ++ ) {

						children[ i ].updateWorldMatrix( false, true );

					}

				}

			},

			toJSON: function ( meta ) {

				// meta is a string when called from JSON.stringify
				var isRootObject = ( meta === undefined || typeof meta === 'string' );

				var output = {};

				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {

					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {},
						shapes: {}
					};

					output.metadata = {
						version: 4.5,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};

				}

				// standard Object3D serialization

				var object = {};

				object.uuid = this.uuid;
				object.type = this.type;

				if ( this.name !== '' ) { object.name = this.name; }
				if ( this.castShadow === true ) { object.castShadow = true; }
				if ( this.receiveShadow === true ) { object.receiveShadow = true; }
				if ( this.visible === false ) { object.visible = false; }
				if ( this.frustumCulled === false ) { object.frustumCulled = false; }
				if ( this.renderOrder !== 0 ) { object.renderOrder = this.renderOrder; }
				if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

				object.layers = this.layers.mask;
				object.matrix = this.matrix.toArray();

				if ( this.matrixAutoUpdate === false ) { object.matrixAutoUpdate = false; }

				// object specific properties

				if ( this.isInstancedMesh ) {

					object.type = 'InstancedMesh';
					object.count = this.count;
					object.instanceMatrix = this.instanceMatrix.toJSON();

				}

				//

				function serialize( library, element ) {

					if ( library[ element.uuid ] === undefined ) {

						library[ element.uuid ] = element.toJSON( meta );

					}

					return element.uuid;

				}

				if ( this.isMesh || this.isLine || this.isPoints ) {

					object.geometry = serialize( meta.geometries, this.geometry );

					var parameters = this.geometry.parameters;

					if ( parameters !== undefined && parameters.shapes !== undefined ) {

						var shapes = parameters.shapes;

						if ( Array.isArray( shapes ) ) {

							for ( var i = 0, l = shapes.length; i < l; i ++ ) {

								var shape = shapes[ i ];

								serialize( meta.shapes, shape );

							}

						} else {

							serialize( meta.shapes, shapes );

						}

					}

				}

				if ( this.material !== undefined ) {

					if ( Array.isArray( this.material ) ) {

						var uuids = [];

						for ( var i = 0, l = this.material.length; i < l; i ++ ) {

							uuids.push( serialize( meta.materials, this.material[ i ] ) );

						}

						object.material = uuids;

					} else {

						object.material = serialize( meta.materials, this.material );

					}

				}

				//

				if ( this.children.length > 0 ) {

					object.children = [];

					for ( var i = 0; i < this.children.length; i ++ ) {

						object.children.push( this.children[ i ].toJSON( meta ).object );

					}

				}

				if ( isRootObject ) {

					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
					var shapes = extractFromCache( meta.shapes );

					if ( geometries.length > 0 ) { output.geometries = geometries; }
					if ( materials.length > 0 ) { output.materials = materials; }
					if ( textures.length > 0 ) { output.textures = textures; }
					if ( images.length > 0 ) { output.images = images; }
					if ( shapes.length > 0 ) { output.shapes = shapes; }

				}

				output.object = object;

				return output;

				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {

					var values = [];
					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}
					return values;

				}

			},

			clone: function ( recursive ) {

				return new this.constructor().copy( this, recursive );

			},

			copy: function ( source, recursive ) {

				if ( recursive === undefined ) { recursive = true; }

				this.name = source.name;

				this.up.copy( source.up );

				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );

				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );

				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

				this.layers.mask = source.layers.mask;
				this.visible = source.visible;

				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;

				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;

				this.userData = JSON.parse( JSON.stringify( source.userData ) );

				if ( recursive === true ) {

					for ( var i = 0; i < source.children.length; i ++ ) {

						var child = source.children[ i ];
						this.add( child.clone() );

					}

				}

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Scene() {

			Object3D.call( this );

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

			}

		}

		Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Scene,

			isScene: true,

			copy: function ( source, recursive ) {

				Object3D.prototype.copy.call( this, source, recursive );

				if ( source.background !== null ) { this.background = source.background.clone(); }
				if ( source.environment !== null ) { this.environment = source.environment.clone(); }
				if ( source.fog !== null ) { this.fog = source.fog.clone(); }

				if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

				this.autoUpdate = source.autoUpdate;
				this.matrixAutoUpdate = source.matrixAutoUpdate;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
				if ( this.environment !== null ) { data.object.environment = this.environment.toJSON( meta ); }
				if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

				return data;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		var _points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];

		var _vector$1 = new Vector3();

		var _box = new Box3();

		// triangle centered vertices

		var _v0 = new Vector3();
		var _v1$2 = new Vector3();
		var _v2 = new Vector3();

		// triangle edge vectors

		var _f0 = new Vector3();
		var _f1 = new Vector3();
		var _f2 = new Vector3();

		var _center = new Vector3();
		var _extents = new Vector3();
		var _triangleNormal = new Vector3();
		var _testAxis = new Vector3();

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Box3( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

		}


		Object.assign( Box3.prototype, {

			isBox3: true,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromArray: function ( array ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];

					if ( x < minX ) { minX = x; }
					if ( y < minY ) { minY = y; }
					if ( z < minZ ) { minZ = z; }

					if ( x > maxX ) { maxX = x; }
					if ( y > maxY ) { maxY = y; }
					if ( z > maxZ ) { maxZ = z; }

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

				return this;

			},

			setFromBufferAttribute: function ( attribute ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					var x = attribute.getX( i );
					var y = attribute.getY( i );
					var z = attribute.getZ( i );

					if ( x < minX ) { minX = x; }
					if ( y < minY ) { minY = y; }
					if ( z < minZ ) { minZ = z; }

					if ( x > maxX ) { maxX = x; }
					if ( y > maxY ) { maxY = y; }
					if ( z > maxZ ) { maxZ = z; }

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

				return this;

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function ( center, size ) {

				var halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			},

			setFromObject: function ( object ) {

				this.makeEmpty();

				return this.expandByObject( object );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

			},

			getCenter: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .getCenter() target is now required' );
					target = new Vector3();

				}

				return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .getSize() target is now required' );
					target = new Vector3();

				}

				return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			expandByObject: function ( object ) {

				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms

				object.updateWorldMatrix( false, false );

				var geometry = object.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box.copy( geometry.boundingBox );
					_box.applyMatrix4( object.matrixWorld );

					this.union( _box );

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					this.expandByObject( children[ i ] );

				}

				return this;

			},

			containsPoint: function ( point ) {

				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ||
					point.z < this.min.z || point.z > this.max.z ? false : true;

			},

			containsBox: function ( box ) {

				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y &&
					this.min.z <= box.min.z && box.max.z <= this.max.z;

			},

			getParameter: function ( point, target ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .getParameter() target is now required' );
					target = new Vector3();

				}

				return target.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ||
					box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

			},

			intersectsSphere: function ( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, _vector$1 );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			},

			intersectsPlane: function ( plane ) {

				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.

				var min, max;

				if ( plane.normal.x > 0 ) {

					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;

				} else {

					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;

				}

				if ( plane.normal.y > 0 ) {

					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;

				} else {

					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;

				}

				if ( plane.normal.z > 0 ) {

					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;

				} else {

					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;

				}

				return ( min <= - plane.constant && max >= - plane.constant );

			},

			intersectsTriangle: function ( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( _center );
				_extents.subVectors( this.max, _center );

				// translate triangle to aabb origin
				_v0.subVectors( triangle.a, _center );
				_v1$2.subVectors( triangle.b, _center );
				_v2.subVectors( triangle.c, _center );

				// compute edge vectors for triangle
				_f0.subVectors( _v1$2, _v0 );
				_f1.subVectors( _v2, _v1$2 );
				_f2.subVectors( _v0, _v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
					_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
					- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
				];
				if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				_triangleNormal.crossVectors( _f0, _f1 );
				axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

				return satForAxes( axes, _v0, _v1$2, _v2, _extents );

			},

			clampPoint: function ( point, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .clampPoint() target is now required' );
					target = new Vector3();

				}

				return target.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function ( point ) {

				var clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

				return clampedPoint.sub( point ).length();

			},

			getBoundingSphere: function ( target ) {

				if ( target === undefined ) {

					console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
					//target = new Sphere(); // removed to avoid cyclic dependency

				}

				this.getCenter( target.center );

				target.radius = this.getSize( _vector$1 ).length() * 0.5;

				return target;

			},

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if ( this.isEmpty() ) { this.makeEmpty(); }

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			applyMatrix4: function ( matrix ) {

				// transform of empty box is an empty box.
				if ( this.isEmpty() ) { return this; }

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

				this.setFromPoints( _points );

				return this;

			},

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		} );

		function satForAxes( axes, v0, v1, v2, extents ) {

			var i, j;

			for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

				_testAxis.fromArray( axes, i );
				// project the aabb onto the seperating axis
				var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
				// project all 3 vertices of the triangle onto the seperating axis
				var p0 = v0.dot( _testAxis );
				var p1 = v1.dot( _testAxis );
				var p2 = v2.dot( _testAxis );
				// actual test, basically see if either of the most extreme of the triangle points intersects r
				if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

					// points of the projected triangle are outside the projected half-length of the aabb
					// the axis is seperating and we can exit
					return false;

				}

			}

			return true;

		}

		var _box$1 = new Box3();

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Sphere( center, radius ) {

			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;

		}

		Object.assign( Sphere.prototype, {

			set: function ( center, radius ) {

				this.center.copy( center );
				this.radius = radius;

				return this;

			},

			setFromPoints: function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					_box$1.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( sphere ) {

				this.center.copy( sphere.center );
				this.radius = sphere.radius;

				return this;

			},

			empty: function () {

				return ( this.radius <= 0 );

			},

			containsPoint: function ( point ) {

				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

			},

			distanceToPoint: function ( point ) {

				return ( point.distanceTo( this.center ) - this.radius );

			},

			intersectsSphere: function ( sphere ) {

				var radiusSum = this.radius + sphere.radius;

				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

			},

			intersectsBox: function ( box ) {

				return box.intersectsSphere( this );

			},

			intersectsPlane: function ( plane ) {

				return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

			},

			clampPoint: function ( point, target ) {

				var deltaLengthSq = this.center.distanceToSquared( point );

				if ( target === undefined ) {

					console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
					target = new Vector3();

				}

				target.copy( point );

				if ( deltaLengthSq > ( this.radius * this.radius ) ) {

					target.sub( this.center ).normalize();
					target.multiplyScalar( this.radius ).add( this.center );

				}

				return target;

			},

			getBoundingBox: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
					target = new Box3();

				}

				target.set( this.center, this.center );
				target.expandByScalar( this.radius );

				return target;

			},

			applyMatrix4: function ( matrix ) {

				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();

				return this;

			},

			translate: function ( offset ) {

				this.center.add( offset );

				return this;

			},

			equals: function ( sphere ) {

				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

			}

		} );

		var _vector$2 = new Vector3();
		var _segCenter = new Vector3();
		var _segDir = new Vector3();
		var _diff = new Vector3();

		var _edge1 = new Vector3();
		var _edge2 = new Vector3();
		var _normal = new Vector3();

		/**
		 * @author bhouston / http://clara.io
		 */

		function Ray( origin, direction ) {

			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );

		}

		Object.assign( Ray.prototype, {

			set: function ( origin, direction ) {

				this.origin.copy( origin );
				this.direction.copy( direction );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( ray ) {

				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );

				return this;

			},

			at: function ( t, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Ray: .at() target is now required' );
					target = new Vector3();

				}

				return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

			},

			lookAt: function ( v ) {

				this.direction.copy( v ).sub( this.origin ).normalize();

				return this;

			},

			recast: function ( t ) {

				this.origin.copy( this.at( t, _vector$2 ) );

				return this;

			},

			closestPointToPoint: function ( point, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				target.subVectors( point, this.origin );

				var directionDistance = target.dot( this.direction );

				if ( directionDistance < 0 ) {

					return target.copy( this.origin );

				}

				return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			},

			distanceToPoint: function ( point ) {

				return Math.sqrt( this.distanceSqToPoint( point ) );

			},

			distanceSqToPoint: function ( point ) {

				var directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return _vector$2.distanceToSquared( point );

			},

			distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				_segDir.copy( v1 ).sub( v0 ).normalize();
				_diff.copy( this.origin ).sub( _segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( _segDir );
				var b0 = _diff.dot( this.direction );
				var b1 = - _diff.dot( _segDir );
				var c = _diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

				}

				return sqrDist;

			},

			intersectSphere: function ( sphere, target ) {

				_vector$2.subVectors( sphere.center, this.origin );
				var tca = _vector$2.dot( this.direction );
				var d2 = _vector$2.dot( _vector$2 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) { return null; }

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) { return null; }

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) { return this.at( t1, target ); }

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );

			},

			intersectsSphere: function ( sphere ) {

				return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

			},

			distanceToPlane: function ( plane ) {

				var denominator = plane.normal.dot( this.direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {

						return 0;

					}

					// Null is preferable to undefined since undefined means.... it is undefined

					return null;

				}

				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

				// Return if the ray never intersects the plane

				return t >= 0 ? t : null;

			},

			intersectPlane: function ( plane, target ) {

				var t = this.distanceToPlane( plane );

				if ( t === null ) {

					return null;

				}

				return this.at( t, target );

			},

			intersectsPlane: function ( plane ) {

				// check if the ray lies on the plane first

				var distToPoint = plane.distanceToPoint( this.origin );

				if ( distToPoint === 0 ) {

					return true;

				}

				var denominator = plane.normal.dot( this.direction );

				if ( denominator * distToPoint < 0 ) {

					return true;

				}

				// ray origin is behind the plane (and is pointing behind it)

				return false;

			},

			intersectBox: function ( box, target ) {

				var tmin, tmax, tymin, tymax, tzmin, tzmax;

				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;

				var origin = this.origin;

				if ( invdirx >= 0 ) {

					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;

				} else {

					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;

				}

				if ( invdiry >= 0 ) {

					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;

				} else {

					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;

				}

				if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN

				if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

				if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

				if ( invdirz >= 0 ) {

					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;

				} else {

					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;

				}

				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

				if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

				if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

				//return point closest to the ray (positive side)

				if ( tmax < 0 ) { return null; }

				return this.at( tmin >= 0 ? tmin : tmax, target );

			},

			intersectsBox: function ( box ) {

				return this.intersectBox( box, _vector$2 ) !== null;

			},

			intersectTriangle: function ( a, b, c, backfaceCulling, target ) {

				// Compute the offset origin, edges, and normal.

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				_edge1.subVectors( b, a );
				_edge2.subVectors( c, a );
				_normal.crossVectors( _edge1, _edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( _normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) { return null; }
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				_diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * _diff.dot( _normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, target );

			},

			applyMatrix4: function ( matrix4 ) {

				this.origin.applyMatrix4( matrix4 );
				this.direction.transformDirection( matrix4 );

				return this;

			},

			equals: function ( ray ) {

				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 */

		var _vector1 = new Vector3();
		var _vector2 = new Vector3();
		var _normalMatrix = new Matrix3();

		function Plane( normal, constant ) {

			// normal is assumed to be normalized

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

		Object.assign( Plane.prototype, {

			isPlane: true,

			set: function ( normal, constant ) {

				this.normal.copy( normal );
				this.constant = constant;

				return this;

			},

			setComponents: function ( x, y, z, w ) {

				this.normal.set( x, y, z );
				this.constant = w;

				return this;

			},

			setFromNormalAndCoplanarPoint: function ( normal, point ) {

				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );

				return this;

			},

			setFromCoplanarPoints: function ( a, b, c ) {

				var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( plane ) {

				this.normal.copy( plane.normal );
				this.constant = plane.constant;

				return this;

			},

			normalize: function () {

				// Note: will lead to a divide by zero if the plane is invalid.

				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;

				return this;

			},

			negate: function () {

				this.constant *= - 1;
				this.normal.negate();

				return this;

			},

			distanceToPoint: function ( point ) {

				return this.normal.dot( point ) + this.constant;

			},

			distanceToSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) - sphere.radius;

			},

			projectPoint: function ( point, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .projectPoint() target is now required' );
					target = new Vector3();

				}

				return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

			},

			intersectLine: function ( line, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();

				}

				var direction = line.delta( _vector1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return target.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return target.copy( direction ).multiplyScalar( t ).add( line.start );

			},

			intersectsLine: function ( line ) {

				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );

				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

			},

			intersectsBox: function ( box ) {

				return box.intersectsPlane( this );

			},

			intersectsSphere: function ( sphere ) {

				return sphere.intersectsPlane( this );

			},

			coplanarPoint: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
					target = new Vector3();

				}

				return target.copy( this.normal ).multiplyScalar( - this.constant );

			},

			applyMatrix4: function ( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			},

			translate: function ( offset ) {

				this.constant -= offset.dot( this.normal );

				return this;

			},

			equals: function ( plane ) {

				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _v0$1 = new Vector3();
		var _v1$3 = new Vector3();
		var _v2$1 = new Vector3();
		var _v3 = new Vector3();

		var _vab = new Vector3();
		var _vac = new Vector3();
		var _vbc = new Vector3();
		var _vap = new Vector3();
		var _vbp = new Vector3();
		var _vcp = new Vector3();

		function Triangle( a, b, c ) {

			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();

		}

		Object.assign( Triangle, {

			getNormal: function ( a, b, c, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();

				}

				target.subVectors( c, b );
				_v0$1.subVectors( a, b );
				target.cross( _v0$1 );

				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {

					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

				}

				return target.set( 0, 0, 0 );

			},

			// static/instance method to calculate barycentric coordinates
			// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
			getBarycoord: function ( point, a, b, c, target ) {

				_v0$1.subVectors( c, a );
				_v1$3.subVectors( b, a );
				_v2$1.subVectors( point, a );

				var dot00 = _v0$1.dot( _v0$1 );
				var dot01 = _v0$1.dot( _v1$3 );
				var dot02 = _v0$1.dot( _v2$1 );
				var dot11 = _v1$3.dot( _v1$3 );
				var dot12 = _v1$3.dot( _v2$1 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();

				}

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );

			},

			containsPoint: function ( point, a, b, c ) {

				Triangle.getBarycoord( point, a, b, c, _v3 );

				return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

			},

			getUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {

				this.getBarycoord( point, p1, p2, p3, _v3 );

				target.set( 0, 0 );
				target.addScaledVector( uv1, _v3.x );
				target.addScaledVector( uv2, _v3.y );
				target.addScaledVector( uv3, _v3.z );

				return target;

			},

			isFrontFacing: function ( a, b, c, direction ) {

				_v0$1.subVectors( c, b );
				_v1$3.subVectors( a, b );

				// strictly front facing
				return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

			}

		} );

		Object.assign( Triangle.prototype, {

			set: function ( a, b, c ) {

				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );

				return this;

			},

			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( triangle ) {

				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );

				return this;

			},

			getArea: function () {

				_v0$1.subVectors( this.c, this.b );
				_v1$3.subVectors( this.a, this.b );

				return _v0$1.cross( _v1$3 ).length() * 0.5;

			},

			getMidpoint: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
					target = new Vector3();

				}

				return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

			},

			getNormal: function ( target ) {

				return Triangle.getNormal( this.a, this.b, this.c, target );

			},

			getPlane: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getPlane() target is now required' );
					target = new Plane();

				}

				return target.setFromCoplanarPoints( this.a, this.b, this.c );

			},

			getBarycoord: function ( point, target ) {

				return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

			},

			getUV: function ( point, uv1, uv2, uv3, target ) {

				return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

			},

			containsPoint: function ( point ) {

				return Triangle.containsPoint( point, this.a, this.b, this.c );

			},

			isFrontFacing: function ( direction ) {

				return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

			},

			intersectsBox: function ( box ) {

				return box.intersectsTriangle( this );

			},

			closestPointToPoint: function ( p, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				var a = this.a, b = this.b, c = this.c;
				var v, w;

				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.

				_vab.subVectors( b, a );
				_vac.subVectors( c, a );
				_vap.subVectors( p, a );
				var d1 = _vab.dot( _vap );
				var d2 = _vac.dot( _vap );
				if ( d1 <= 0 && d2 <= 0 ) {

					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );

				}

				_vbp.subVectors( p, b );
				var d3 = _vab.dot( _vbp );
				var d4 = _vac.dot( _vbp );
				if ( d3 >= 0 && d4 <= d3 ) {

					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );

				}

				var vc = d1 * d4 - d3 * d2;
				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( _vab, v );

				}

				_vcp.subVectors( p, c );
				var d5 = _vab.dot( _vcp );
				var d6 = _vac.dot( _vcp );
				if ( d6 >= 0 && d5 <= d6 ) {

					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );

				}

				var vb = d5 * d2 - d1 * d6;
				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( _vac, w );

				}

				var va = d3 * d6 - d5 * d4;
				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

					_vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

				}

				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;

				return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

			},

			equals: function ( triangle ) {

				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
			'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
			'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
			'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
			'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
			'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
			'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
			'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
			'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
			'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
			'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
			'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
			'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
			'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
			'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
			'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
			'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
			'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
			'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
			'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
			'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
			'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
			'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
			'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

		var _hslA = { h: 0, s: 0, l: 0 };
		var _hslB = { h: 0, s: 0, l: 0 };

		function Color( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) { t += 1; }
			if ( t > 1 ) { t -= 1; }
			if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
			if ( t < 1 / 2 ) { return q; }
			if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
			return p;

		}

		function SRGBToLinear( c ) {

			return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

		}

		function LinearToSRGB( c ) {

			return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

		}

		Object.assign( Color.prototype, {

			isColor: true,

			r: 1, g: 1, b: 1,

			set: function ( value ) {

				if ( value && value.isColor ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

				return this;

			},

			setScalar: function ( scalar ) {

				this.r = scalar;
				this.g = scalar;
				this.b = scalar;

				return this;

			},

			setHex: function ( hex ) {

				hex = Math.floor( hex );

				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;

				return this;

			},

			setRGB: function ( r, g, b ) {

				this.r = r;
				this.g = g;
				this.b = b;

				return this;

			},

			setHSL: function ( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = MathUtils.euclideanModulo( h, 1 );
				s = MathUtils.clamp( s, 0, 1 );
				l = MathUtils.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			},

			setStyle: function ( style ) {

				function handleAlpha( string ) {

					if ( string === undefined ) { return; }

					if ( parseFloat( string ) < 1 ) {

						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

					}

				}


				var m;

				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

					// rgb / hsl

					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];

					switch ( name ) {

						case 'rgb':
						case 'rgba':

							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

								handleAlpha( color[ 5 ] );

								return this;

							}

							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

								handleAlpha( color[ 5 ] );

								return this;

							}

							break;

						case 'hsl':
						case 'hsla':

							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;

								handleAlpha( color[ 5 ] );

								return this.setHSL( h, s, l );

							}

							break;

					}

				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

					// hex color

					var hex = m[ 1 ];
					var size = hex.length;

					if ( size === 3 ) {

						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

						return this;

					} else if ( size === 6 ) {

						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

						return this;

					}

				}

				if ( style && style.length > 0 ) {

					return this.setColorName( style );

				}

				return this;

			},

			setColorName: function ( style ) {

				// color keywords
				var hex = _colorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

				return this;

			},

			clone: function () {

				return new this.constructor( this.r, this.g, this.b );

			},

			copy: function ( color ) {

				this.r = color.r;
				this.g = color.g;
				this.b = color.b;

				return this;

			},

			copyGammaToLinear: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );

				return this;

			},

			copyLinearToGamma: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );

				return this;

			},

			convertGammaToLinear: function ( gammaFactor ) {

				this.copyGammaToLinear( this, gammaFactor );

				return this;

			},

			convertLinearToGamma: function ( gammaFactor ) {

				this.copyLinearToGamma( this, gammaFactor );

				return this;

			},

			copySRGBToLinear: function ( color ) {

				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );

				return this;

			},

			copyLinearToSRGB: function ( color ) {

				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );

				return this;

			},

			convertSRGBToLinear: function () {

				this.copySRGBToLinear( this );

				return this;

			},

			convertLinearToSRGB: function () {

				this.copyLinearToSRGB( this );

				return this;

			},

			getHex: function () {

				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

			},

			getHexString: function () {

				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

			},

			getHSL: function ( target ) {

				// h,s,l ranges are in 0.0 - 1.0

				if ( target === undefined ) {

					console.warn( 'THREE.Color: .getHSL() target is now required' );
					target = { h: 0, s: 0, l: 0 };

				}

				var r = this.r, g = this.g, b = this.b;

				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );

				var hue, saturation;
				var lightness = ( min + max ) / 2.0;

				if ( min === max ) {

					hue = 0;
					saturation = 0;

				} else {

					var delta = max - min;

					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

					switch ( max ) {

						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;

					}

					hue /= 6;

				}

				target.h = hue;
				target.s = saturation;
				target.l = lightness;

				return target;

			},

			getStyle: function () {

				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

			},

			offsetHSL: function ( h, s, l ) {

				this.getHSL( _hslA );

				_hslA.h += h; _hslA.s += s; _hslA.l += l;

				this.setHSL( _hslA.h, _hslA.s, _hslA.l );

				return this;

			},

			add: function ( color ) {

				this.r += color.r;
				this.g += color.g;
				this.b += color.b;

				return this;

			},

			addColors: function ( color1, color2 ) {

				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;

				return this;

			},

			addScalar: function ( s ) {

				this.r += s;
				this.g += s;
				this.b += s;

				return this;

			},

			sub: function ( color ) {

				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );

				return this;

			},

			multiply: function ( color ) {

				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;

				return this;

			},

			multiplyScalar: function ( s ) {

				this.r *= s;
				this.g *= s;
				this.b *= s;

				return this;

			},

			lerp: function ( color, alpha ) {

				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;

				return this;

			},

			lerpHSL: function ( color, alpha ) {

				this.getHSL( _hslA );
				color.getHSL( _hslB );

				var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
				var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
				var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

				this.setHSL( h, s, l );

				return this;

			},

			equals: function ( c ) {

				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;

				return array;

			},

			toJSON: function () {

				return this.getHex();

			}

		} );

		Color.NAMES = _colorKeywords;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Face3( a, b, c, normal, color, materialIndex ) {

			this.a = a;
			this.b = b;
			this.c = c;

			this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];

			this.color = ( color && color.isColor ) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];

			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

		}

		Object.assign( Face3.prototype, {

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.a = source.a;
				this.b = source.b;
				this.c = source.c;

				this.normal.copy( source.normal );
				this.color.copy( source.color );

				this.materialIndex = source.materialIndex;

				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

				}

				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

					this.vertexColors[ i ] = source.vertexColors[ i ].clone();

				}

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		var materialId = 0;

		function Material() {

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';
			this.type = 'Material';

			this.fog = true;

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.flatShading = false;
			this.vertexColors = false;

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.shadowSide = null;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.dithering = false;

			this.alphaTest = 0;
			this.premultipliedAlpha = false;

			this.visible = true;

			this.toneMapped = true;

			this.userData = {};

			this.version = 0;

		}

		Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: Material,

			isMaterial: true,

			onBeforeCompile: function () {},

			setValues: function ( values ) {

				if ( values === undefined ) { return; }

				for ( var key in values ) {

					var newValue = values[ key ];

					if ( newValue === undefined ) {

						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;

					}

					// for backward compatability if shading is set in the constructor
					if ( key === 'shading' ) {

						console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
						this.flatShading = ( newValue === FlatShading ) ? true : false;
						continue;

					}

					var currentValue = this[ key ];

					if ( currentValue === undefined ) {

						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;

					}

					if ( currentValue && currentValue.isColor ) {

						currentValue.set( newValue );

					} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

						currentValue.copy( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			},

			toJSON: function ( meta ) {

				var isRoot = ( meta === undefined || typeof meta === 'string' );

				if ( isRoot ) {

					meta = {
						textures: {},
						images: {}
					};

				}

				var data = {
					metadata: {
						version: 4.5,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};

				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;

				if ( this.name !== '' ) { data.name = this.name; }

				if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

				if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
				if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

				if ( this.sheen && this.sheen.isColor ) { data.sheen = this.sheen.getHex(); }
				if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
				if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) { data.emissiveIntensity = this.emissiveIntensity; }

				if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
				if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
				if ( this.clearcoat !== undefined ) { data.clearcoat = this.clearcoat; }
				if ( this.clearcoatRoughness !== undefined ) { data.clearcoatRoughness = this.clearcoatRoughness; }

				if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

					data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

				}

				if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

					data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

				}

				if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

					data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
					data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

				}

				if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
				if ( this.matcap && this.matcap.isTexture ) { data.matcap = this.matcap.toJSON( meta ).uuid; }
				if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }
				if ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }

				if ( this.aoMap && this.aoMap.isTexture ) {

					data.aoMap = this.aoMap.toJSON( meta ).uuid;
					data.aoMapIntensity = this.aoMapIntensity;

				}

				if ( this.bumpMap && this.bumpMap.isTexture ) {

					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;

				}

				if ( this.normalMap && this.normalMap.isTexture ) {

					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalMapType = this.normalMapType;
					data.normalScale = this.normalScale.toArray();

				}

				if ( this.displacementMap && this.displacementMap.isTexture ) {

					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;

				}

				if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
				if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

				if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
				if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

				if ( this.envMap && this.envMap.isTexture ) {

					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap
					data.refractionRatio = this.refractionRatio;

					if ( this.combine !== undefined ) { data.combine = this.combine; }
					if ( this.envMapIntensity !== undefined ) { data.envMapIntensity = this.envMapIntensity; }

				}

				if ( this.gradientMap && this.gradientMap.isTexture ) {

					data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

				}

				if ( this.size !== undefined ) { data.size = this.size; }
				if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

				if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
				if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
				if ( this.side !== FrontSide ) { data.side = this.side; }
				if ( this.vertexColors ) { data.vertexColors = true; }

				if ( this.opacity < 1 ) { data.opacity = this.opacity; }
				if ( this.transparent === true ) { data.transparent = this.transparent; }

				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;

				data.stencilWrite = this.stencilWrite;
				data.stencilWriteMask = this.stencilWriteMask;
				data.stencilFunc = this.stencilFunc;
				data.stencilRef = this.stencilRef;
				data.stencilFuncMask = this.stencilFuncMask;
				data.stencilFail = this.stencilFail;
				data.stencilZFail = this.stencilZFail;
				data.stencilZPass = this.stencilZPass;

				// rotation (SpriteMaterial)
				if ( this.rotation && this.rotation !== 0 ) { data.rotation = this.rotation; }

				if ( this.polygonOffset === true ) { data.polygonOffset = true; }
				if ( this.polygonOffsetFactor !== 0 ) { data.polygonOffsetFactor = this.polygonOffsetFactor; }
				if ( this.polygonOffsetUnits !== 0 ) { data.polygonOffsetUnits = this.polygonOffsetUnits; }

				if ( this.linewidth && this.linewidth !== 1 ) { data.linewidth = this.linewidth; }
				if ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }
				if ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }
				if ( this.scale !== undefined ) { data.scale = this.scale; }

				if ( this.dithering === true ) { data.dithering = true; }

				if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
				if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

				if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
				if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
				if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
				if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

				if ( this.morphTargets === true ) { data.morphTargets = true; }
				if ( this.morphNormals === true ) { data.morphNormals = true; }
				if ( this.skinning === true ) { data.skinning = true; }

				if ( this.visible === false ) { data.visible = false; }

				if ( this.toneMapped === false ) { data.toneMapped = false; }

				if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

				// TODO: Copied from Object3D.toJSON

				function extractFromCache( cache ) {

					var values = [];

					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}

					return values;

				}

				if ( isRoot ) {

					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( textures.length > 0 ) { data.textures = textures; }
					if ( images.length > 0 ) { data.images = images; }

				}

				return data;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.name = source.name;

				this.fog = source.fog;

				this.blending = source.blending;
				this.side = source.side;
				this.flatShading = source.flatShading;
				this.vertexColors = source.vertexColors;

				this.opacity = source.opacity;
				this.transparent = source.transparent;

				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;

				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;

				this.stencilWriteMask = source.stencilWriteMask;
				this.stencilFunc = source.stencilFunc;
				this.stencilRef = source.stencilRef;
				this.stencilFuncMask = source.stencilFuncMask;
				this.stencilFail = source.stencilFail;
				this.stencilZFail = source.stencilZFail;
				this.stencilZPass = source.stencilZPass;
				this.stencilWrite = source.stencilWrite;

				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;

				if ( srcPlanes !== null ) {

					var n = srcPlanes.length;
					dstPlanes = new Array( n );

					for ( var i = 0; i !== n; ++ i )
						{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }

				}

				this.clippingPlanes = dstPlanes;
				this.clipIntersection = source.clipIntersection;
				this.clipShadows = source.clipShadows;

				this.shadowSide = source.shadowSide;

				this.colorWrite = source.colorWrite;

				this.precision = source.precision;

				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;

				this.dithering = source.dithering;

				this.alphaTest = source.alphaTest;
				this.premultipliedAlpha = source.premultipliedAlpha;

				this.visible = source.visible;

				this.toneMapped = source.toneMapped;

				this.userData = JSON.parse( JSON.stringify( source.userData ) );

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		Object.defineProperty( Material.prototype, 'needsUpdate', {

			set: function ( value ) {

				if ( value === true ) { this.version ++; }

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */

		function MeshBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.setValues( parameters );

		}

		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

		MeshBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _vector$3 = new Vector3();

		function BufferAttribute( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.name = '';

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

			set: function ( value ) {

				if ( value === true ) { this.version ++; }

			}

		} );

		Object.assign( BufferAttribute.prototype, {

			isBufferAttribute: true,

			onUploadCallback: function () {},

			setUsage: function ( value ) {

				this.usage = value;

				return this;

			},

			copy: function ( source ) {

				this.name = source.name;
				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;

				this.usage = source.usage;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.itemSize;
				index2 *= attribute.itemSize;

				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			copyArray: function ( array ) {

				this.array.set( array );

				return this;

			},

			copyColorsArray: function ( colors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = colors.length; i < l; i ++ ) {

					var color = colors[ i ];

					if ( color === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();

					}

					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;

				}

				return this;

			},

			copyVector2sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;

				}

				return this;

			},

			copyVector3sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;

				}

				return this;

			},

			copyVector4sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;

				}

				return this;

			},

			applyMatrix3: function ( m ) {

				for ( var i = 0, l = this.count; i < l; i ++ ) {

					_vector$3.x = this.getX( i );
					_vector$3.y = this.getY( i );
					_vector$3.z = this.getZ( i );

					_vector$3.applyMatrix3( m );

					this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

				}

				return this;

			},

			applyMatrix4: function ( m ) {

				for ( var i = 0, l = this.count; i < l; i ++ ) {

					_vector$3.x = this.getX( i );
					_vector$3.y = this.getY( i );
					_vector$3.z = this.getZ( i );

					_vector$3.applyMatrix4( m );

					this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

				}

				return this;

			},

			applyNormalMatrix: function ( m ) {

				for ( var i = 0, l = this.count; i < l; i ++ ) {

					_vector$3.x = this.getX( i );
					_vector$3.y = this.getY( i );
					_vector$3.z = this.getZ( i );

					_vector$3.applyNormalMatrix( m );

					this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

				}

				return this;

			},

			transformDirection: function ( m ) {

				for ( var i = 0, l = this.count; i < l; i ++ ) {

					_vector$3.x = this.getX( i );
					_vector$3.y = this.getY( i );
					_vector$3.z = this.getZ( i );

					_vector$3.transformDirection( m );

					this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.array.set( value, offset );

				return this;

			},

			getX: function ( index ) {

				return this.array[ index * this.itemSize ];

			},

			setX: function ( index, x ) {

				this.array[ index * this.itemSize ] = x;

				return this;

			},

			getY: function ( index ) {

				return this.array[ index * this.itemSize + 1 ];

			},

			setY: function ( index, y ) {

				this.array[ index * this.itemSize + 1 ] = y;

				return this;

			},

			getZ: function ( index ) {

				return this.array[ index * this.itemSize + 2 ];

			},

			setZ: function ( index, z ) {

				this.array[ index * this.itemSize + 2 ] = z;

				return this;

			},

			getW: function ( index ) {

				return this.array[ index * this.itemSize + 3 ];

			},

			setW: function ( index, w ) {

				this.array[ index * this.itemSize + 3 ] = w;

				return this;

			},

			setXY: function ( index, x, y ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;

				return this;

			},

			onUpload: function ( callback ) {

				this.onUploadCallback = callback;

				return this;

			},

			clone: function () {

				return new this.constructor( this.array, this.itemSize ).copy( this );

			},

			toJSON: function () {

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: Array.prototype.slice.call( this.array ),
					normalized: this.normalized
				};

			}

		} );

		//

		function Int8BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

		}

		Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


		function Uint8BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

		}

		Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


		function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

		}

		Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


		function Int16BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

		}

		Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


		function Uint16BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

		}

		Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


		function Int32BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

		}

		Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


		function Uint32BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

		}

		Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


		function Float32BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

		}

		Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


		function Float64BufferAttribute( array, itemSize, normalized ) {

			BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

		}

		Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectGeometry() {

			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			// this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( DirectGeometry.prototype, {

			computeGroups: function ( geometry ) {

				var group;
				var groups = [];
				var materialIndex = undefined;

				var faces = geometry.faces;

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					// materials

					if ( face.materialIndex !== materialIndex ) {

						materialIndex = face.materialIndex;

						if ( group !== undefined ) {

							group.count = ( i * 3 ) - group.start;
							groups.push( group );

						}

						group = {
							start: i * 3,
							materialIndex: materialIndex
						};

					}

				}

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				this.groups = groups;

			},

			fromGeometry: function ( geometry ) {

				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;

				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

				// morphs

				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;

				var morphTargetsPosition;

				if ( morphTargetsLength > 0 ) {

					morphTargetsPosition = [];

					for ( var i = 0; i < morphTargetsLength; i ++ ) {

						morphTargetsPosition[ i ] = {
							name: morphTargets[ i ].name,
						 	data: []
						};

					}

					this.morphTargets.position = morphTargetsPosition;

				}

				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;

				var morphTargetsNormal;

				if ( morphNormalsLength > 0 ) {

					morphTargetsNormal = [];

					for ( var i = 0; i < morphNormalsLength; i ++ ) {

						morphTargetsNormal[ i ] = {
							name: morphNormals[ i ].name,
						 	data: []
						};

					}

					this.morphTargets.normal = morphTargetsNormal;

				}

				// skins

				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;

				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;

				//

				if ( vertices.length > 0 && faces.length === 0 ) {

					console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

				}

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

					} else {

						var normal = face.normal;

						this.normals.push( normal, normal, normal );

					}

					var vertexColors = face.vertexColors;

					if ( vertexColors.length === 3 ) {

						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

					} else {

						var color = face.color;

						this.colors.push( color, color, color );

					}

					if ( hasFaceVertexUv === true ) {

						var vertexUvs = faceVertexUvs[ 0 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					if ( hasFaceVertexUv2 === true ) {

						var vertexUvs = faceVertexUvs[ 1 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					// morphs

					for ( var j = 0; j < morphTargetsLength; j ++ ) {

						var morphTarget = morphTargets[ j ].vertices;

						morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

					}

					for ( var j = 0; j < morphNormalsLength; j ++ ) {

						var morphNormal = morphNormals[ j ].vertexNormals[ i ];

						morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

					}

					// skins

					if ( hasSkinIndices ) {

						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

					}

					if ( hasSkinWeights ) {

						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

					}

				}

				this.computeGroups( geometry );

				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function arrayMax( array ) {

			if ( array.length === 0 ) { return - Infinity; }

			var max = array[ 0 ];

			for ( var i = 1, l = array.length; i < l; ++ i ) {

				if ( array[ i ] > max ) { max = array[ i ]; }

			}

			return max;

		}

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

		var _m1$2 = new Matrix4();
		var _obj = new Object3D();
		var _offset = new Vector3();
		var _box$2 = new Box3();
		var _boxMorphTargets = new Box3();
		var _vector$4 = new Vector3();

		function BufferGeometry() {

			Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};
			this.morphTargetsRelative = false;

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

			this.userData = {};

		}

		BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: BufferGeometry,

			isBufferGeometry: true,

			getIndex: function () {

				return this.index;

			},

			setIndex: function ( index ) {

				if ( Array.isArray( index ) ) {

					this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

				} else {

					this.index = index;

				}

			},

			getAttribute: function ( name ) {

				return this.attributes[ name ];

			},

			setAttribute: function ( name, attribute ) {

				this.attributes[ name ] = attribute;

				return this;

			},

			deleteAttribute: function ( name ) {

				delete this.attributes[ name ];

				return this;

			},

			addGroup: function ( start, count, materialIndex ) {

				this.groups.push( {

					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0

				} );

			},

			clearGroups: function () {

				this.groups = [];

			},

			setDrawRange: function ( start, count ) {

				this.drawRange.start = start;
				this.drawRange.count = count;

			},

			applyMatrix4: function ( matrix ) {

				var position = this.attributes.position;

				if ( position !== undefined ) {

					position.applyMatrix4( matrix );

					position.needsUpdate = true;

				}

				var normal = this.attributes.normal;

				if ( normal !== undefined ) {

					var normalMatrix = new Matrix3().getNormalMatrix( matrix );

					normal.applyNormalMatrix( normalMatrix );

					normal.needsUpdate = true;

				}

				var tangent = this.attributes.tangent;

				if ( tangent !== undefined ) {

					tangent.transformDirection( matrix );

					tangent.needsUpdate = true;

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				return this;

			},

			rotateX: function ( angle ) {

				// rotate geometry around world x-axis

				_m1$2.makeRotationX( angle );

				this.applyMatrix4( _m1$2 );

				return this;

			},

			rotateY: function ( angle ) {

				// rotate geometry around world y-axis

				_m1$2.makeRotationY( angle );

				this.applyMatrix4( _m1$2 );

				return this;

			},

			rotateZ: function ( angle ) {

				// rotate geometry around world z-axis

				_m1$2.makeRotationZ( angle );

				this.applyMatrix4( _m1$2 );

				return this;

			},

			translate: function ( x, y, z ) {

				// translate geometry

				_m1$2.makeTranslation( x, y, z );

				this.applyMatrix4( _m1$2 );

				return this;

			},

			scale: function ( x, y, z ) {

				// scale geometry

				_m1$2.makeScale( x, y, z );

				this.applyMatrix4( _m1$2 );

				return this;

			},

			lookAt: function ( vector ) {

				_obj.lookAt( vector );

				_obj.updateMatrix();

				this.applyMatrix4( _obj.matrix );

				return this;

			},

			center: function () {

				this.computeBoundingBox();

				this.boundingBox.getCenter( _offset ).negate();

				this.translate( _offset.x, _offset.y, _offset.z );

				return this;

			},

			setFromObject: function ( object ) {

				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

				var geometry = object.geometry;

				if ( object.isPoints || object.isLine ) {

					var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

					this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

						var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

						this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

					}

					if ( geometry.boundingSphere !== null ) {

						this.boundingSphere = geometry.boundingSphere.clone();

					}

					if ( geometry.boundingBox !== null ) {

						this.boundingBox = geometry.boundingBox.clone();

					}

				} else if ( object.isMesh ) {

					if ( geometry && geometry.isGeometry ) {

						this.fromGeometry( geometry );

					}

				}

				return this;

			},

			setFromPoints: function ( points ) {

				var position = [];

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					position.push( point.x, point.y, point.z || 0 );

				}

				this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

				return this;

			},

			updateFromObject: function ( object ) {

				var geometry = object.geometry;

				if ( object.isMesh ) {

					var direct = geometry.__directGeometry;

					if ( geometry.elementsNeedUpdate === true ) {

						direct = undefined;
						geometry.elementsNeedUpdate = false;

					}

					if ( direct === undefined ) {

						return this.fromGeometry( geometry );

					}

					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;

					geometry = direct;

				}

				var attribute;

				if ( geometry.verticesNeedUpdate === true ) {

					attribute = this.attributes.position;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;

					}

					geometry.verticesNeedUpdate = false;

				}

				if ( geometry.normalsNeedUpdate === true ) {

					attribute = this.attributes.normal;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;

					}

					geometry.normalsNeedUpdate = false;

				}

				if ( geometry.colorsNeedUpdate === true ) {

					attribute = this.attributes.color;

					if ( attribute !== undefined ) {

						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;

					}

					geometry.colorsNeedUpdate = false;

				}

				if ( geometry.uvsNeedUpdate ) {

					attribute = this.attributes.uv;

					if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

					}

					geometry.uvsNeedUpdate = false;

				}

				if ( geometry.lineDistancesNeedUpdate ) {

					attribute = this.attributes.lineDistance;

					if ( attribute !== undefined ) {

						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;

					}

					geometry.lineDistancesNeedUpdate = false;

				}

				if ( geometry.groupsNeedUpdate ) {

					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;

					geometry.groupsNeedUpdate = false;

				}

				return this;

			},

			fromGeometry: function ( geometry ) {

				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

				return this.fromDirectGeometry( geometry.__directGeometry );

			},

			fromDirectGeometry: function ( geometry ) {

				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

				if ( geometry.normals.length > 0 ) {

					var normals = new Float32Array( geometry.normals.length * 3 );
					this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

				}

				if ( geometry.colors.length > 0 ) {

					var colors = new Float32Array( geometry.colors.length * 3 );
					this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

				}

				if ( geometry.uvs.length > 0 ) {

					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

				}

				if ( geometry.uvs2.length > 0 ) {

					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

				}

				// groups

				this.groups = geometry.groups;

				// morphs

				for ( var name in geometry.morphTargets ) {

					var array = [];
					var morphTargets = geometry.morphTargets[ name ];

					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

						var morphTarget = morphTargets[ i ];

						var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
						attribute.name = morphTarget.name;

						array.push( attribute.copyVector3sArray( morphTarget.data ) );

					}

					this.morphAttributes[ name ] = array;

				}

				// skinning

				if ( geometry.skinIndices.length > 0 ) {

					var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
					this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

				}

				if ( geometry.skinWeights.length > 0 ) {

					var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
					this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

				}

				//

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				return this;

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position !== undefined ) {

					this.boundingBox.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							_box$2.setFromBufferAttribute( morphAttribute );

							if ( this.morphTargetsRelative ) {

								_vector$4.addVectors( this.boundingBox.min, _box$2.min );
								this.boundingBox.expandByPoint( _vector$4 );

								_vector$4.addVectors( this.boundingBox.max, _box$2.max );
								this.boundingBox.expandByPoint( _vector$4 );

							} else {

								this.boundingBox.expandByPoint( _box$2.min );
								this.boundingBox.expandByPoint( _box$2.max );

							}

						}

					}

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			},

			computeBoundingSphere: function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;
				var morphAttributesPosition = this.morphAttributes.position;

				if ( position ) {

					// first, find the center of the bounding sphere

					var center = this.boundingSphere.center;

					_box$2.setFromBufferAttribute( position );

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							_boxMorphTargets.setFromBufferAttribute( morphAttribute );

							if ( this.morphTargetsRelative ) {

								_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
								_box$2.expandByPoint( _vector$4 );

								_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
								_box$2.expandByPoint( _vector$4 );

							} else {

								_box$2.expandByPoint( _boxMorphTargets.min );
								_box$2.expandByPoint( _boxMorphTargets.max );

							}

						}

					}

					_box$2.getCenter( center );

					// second, try to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						_vector$4.fromBufferAttribute( position, i );

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

					}

					// process morph attributes if present

					if ( morphAttributesPosition ) {

						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

							var morphAttribute = morphAttributesPosition[ i ];
							var morphTargetsRelative = this.morphTargetsRelative;

							for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

								_vector$4.fromBufferAttribute( morphAttribute, j );

								if ( morphTargetsRelative ) {

									_offset.fromBufferAttribute( position, j );
									_vector$4.add( _offset );

								}

								maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

							}

						}

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			},

			computeFaceNormals: function () {

				// backwards compatibility

			},

			computeVertexNormals: function () {

				var index = this.index;
				var attributes = this.attributes;

				if ( attributes.position ) {

					var positions = attributes.position.array;

					if ( attributes.normal === undefined ) {

						this.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

					} else {

						// reset existing normals to zero

						var array = attributes.normal.array;

						for ( var i = 0, il = array.length; i < il; i ++ ) {

							array[ i ] = 0;

						}

					}

					var normals = attributes.normal.array;

					var vA, vB, vC;
					var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
					var cb = new Vector3(), ab = new Vector3();

					// indexed elements

					if ( index ) {

						var indices = index.array;

						for ( var i = 0, il = index.count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					} else {

						// non-indexed elements (unconnected triangle soup)

						for ( var i = 0, il = positions.length; i < il; i += 9 ) {

							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;

							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;

							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;

						}

					}

					this.normalizeNormals();

					attributes.normal.needsUpdate = true;

				}

			},

			merge: function ( geometry, offset ) {

				if ( ! ( geometry && geometry.isBufferGeometry ) ) {

					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;

				}

				if ( offset === undefined ) {

					offset = 0;

					console.warn(
						'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
						+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
					);

				}

				var attributes = this.attributes;

				for ( var key in attributes ) {

					if ( geometry.attributes[ key ] === undefined ) { continue; }

					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;

					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;

					var attributeOffset = attribute2.itemSize * offset;
					var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

					for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

						attributeArray1[ j ] = attributeArray2[ i ];

					}

				}

				return this;

			},

			normalizeNormals: function () {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					_vector$4.x = normals.getX( i );
					_vector$4.y = normals.getY( i );
					_vector$4.z = normals.getZ( i );

					_vector$4.normalize();

					normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

				}

			},

			toNonIndexed: function () {

				function convertBufferAttribute( attribute, indices ) {

					var array = attribute.array;
					var itemSize = attribute.itemSize;

					var array2 = new array.constructor( indices.length * itemSize );

					var index = 0, index2 = 0;

					for ( var i = 0, l = indices.length; i < l; i ++ ) {

						index = indices[ i ] * itemSize;

						for ( var j = 0; j < itemSize; j ++ ) {

							array2[ index2 ++ ] = array[ index ++ ];

						}

					}

					return new BufferAttribute( array2, itemSize );

				}

				//

				if ( this.index === null ) {

					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;

				}

				var geometry2 = new BufferGeometry();

				var indices = this.index.array;
				var attributes = this.attributes;

				// attributes

				for ( var name in attributes ) {

					var attribute = attributes[ name ];

					var newAttribute = convertBufferAttribute( attribute, indices );

					geometry2.setAttribute( name, newAttribute );

				}

				// morph attributes

				var morphAttributes = this.morphAttributes;

				for ( name in morphAttributes ) {

					var morphArray = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

					for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

						var attribute = morphAttribute[ i ];

						var newAttribute = convertBufferAttribute( attribute, indices );

						morphArray.push( newAttribute );

					}

					geometry2.morphAttributes[ name ] = morphArray;

				}

				geometry2.morphTargetsRelative = this.morphTargetsRelative;

				// groups

				var groups = this.groups;

				for ( var i = 0, l = groups.length; i < l; i ++ ) {

					var group = groups[ i ];
					geometry2.addGroup( group.start, group.count, group.materialIndex );

				}

				return geometry2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.5,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};

				// standard BufferGeometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) { data.name = this.name; }
				if ( Object.keys( this.userData ).length > 0 ) { data.userData = this.userData; }

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

					}

					return data;

				}

				data.data = { attributes: {} };

				var index = this.index;

				if ( index !== null ) {

					data.data.index = {
						type: index.array.constructor.name,
						array: Array.prototype.slice.call( index.array )
					};

				}

				var attributes = this.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];

					var attributeData = attribute.toJSON();

					if ( attribute.name !== '' ) { attributeData.name = attribute.name; }

					data.data.attributes[ key ] = attributeData;

				}

				var morphAttributes = {};
				var hasMorphAttributes = false;

				for ( var key in this.morphAttributes ) {

					var attributeArray = this.morphAttributes[ key ];

					var array = [];

					for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

						var attribute = attributeArray[ i ];

						var attributeData = attribute.toJSON();

						if ( attribute.name !== '' ) { attributeData.name = attribute.name; }

						array.push( attributeData );

					}

					if ( array.length > 0 ) {

						morphAttributes[ key ] = array;

						hasMorphAttributes = true;

					}

				}

				if ( hasMorphAttributes ) {

					data.data.morphAttributes = morphAttributes;
					data.data.morphTargetsRelative = this.morphTargetsRelative;

				}

				var groups = this.groups;

				if ( groups.length > 0 ) {

					data.data.groups = JSON.parse( JSON.stringify( groups ) );

				}

				var boundingSphere = this.boundingSphere;

				if ( boundingSphere !== null ) {

					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};

				}

				return data;

			},

			clone: function () {

				/*
				 // Handle primitives

				 var parameters = this.parameters;

				 if ( parameters !== undefined ) {

				 var values = [];

				 for ( var key in parameters ) {

				 values.push( parameters[ key ] );

				 }

				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;

				 }

				 return new this.constructor().copy( this );
				 */

				return new BufferGeometry().copy( this );

			},

			copy: function ( source ) {

				var name, i, l;

				// reset

				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;

				// name

				this.name = source.name;

				// index

				var index = source.index;

				if ( index !== null ) {

					this.setIndex( index.clone() );

				}

				// attributes

				var attributes = source.attributes;

				for ( name in attributes ) {

					var attribute = attributes[ name ];
					this.setAttribute( name, attribute.clone() );

				}

				// morph attributes

				var morphAttributes = source.morphAttributes;

				for ( name in morphAttributes ) {

					var array = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

					for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

						array.push( morphAttribute[ i ].clone() );

					}

					this.morphAttributes[ name ] = array;

				}

				this.morphTargetsRelative = source.morphTargetsRelative;

				// groups

				var groups = source.groups;

				for ( i = 0, l = groups.length; i < l; i ++ ) {

					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );

				}

				// bounding box

				var boundingBox = source.boundingBox;

				if ( boundingBox !== null ) {

					this.boundingBox = boundingBox.clone();

				}

				// bounding sphere

				var boundingSphere = source.boundingSphere;

				if ( boundingSphere !== null ) {

					this.boundingSphere = boundingSphere.clone();

				}

				// draw range

				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;

				// user data

				this.userData = source.userData;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */

		var _inverseMatrix = new Matrix4();
		var _ray = new Ray();
		var _sphere = new Sphere();

		var _vA = new Vector3();
		var _vB = new Vector3();
		var _vC = new Vector3();

		var _tempA = new Vector3();
		var _tempB = new Vector3();
		var _tempC = new Vector3();

		var _morphA = new Vector3();
		var _morphB = new Vector3();
		var _morphC = new Vector3();

		var _uvA = new Vector2();
		var _uvB = new Vector2();
		var _uvC = new Vector2();

		var _intersectionPoint = new Vector3();
		var _intersectionPointWorld = new Vector3();

		function Mesh( geometry, material ) {

			Object3D.call( this );

			this.type = 'Mesh';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial();

			this.updateMorphTargets();

		}

		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Mesh,

			isMesh: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				if ( source.morphTargetInfluences !== undefined ) {

					this.morphTargetInfluences = source.morphTargetInfluences.slice();

				}

				if ( source.morphTargetDictionary !== undefined ) {

					this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

				}

				return this;

			},

			updateMorphTargets: function () {

				var geometry = this.geometry;
				var m, ml, name;

				if ( geometry.isBufferGeometry ) {

					var morphAttributes = geometry.morphAttributes;
					var keys = Object.keys( morphAttributes );

					if ( keys.length > 0 ) {

						var morphAttribute = morphAttributes[ keys[ 0 ] ];

						if ( morphAttribute !== undefined ) {

							this.morphTargetInfluences = [];
							this.morphTargetDictionary = {};

							for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

								name = morphAttribute[ m ].name || String( m );

								this.morphTargetInfluences.push( 0 );
								this.morphTargetDictionary[ name ] = m;

							}

						}

					}

				} else {

					var morphTargets = geometry.morphTargets;

					if ( morphTargets !== undefined && morphTargets.length > 0 ) {

						console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

					}

				}

			},

			raycast: function ( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) { return; }

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

				_sphere.copy( geometry.boundingSphere );
				_sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( _sphere ) === false ) { return; }

				//

				_inverseMatrix.getInverse( matrixWorld );
				_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( _ray.intersectsBox( geometry.boundingBox ) === false ) { return; }

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var morphPosition = geometry.morphAttributes.position;
					var morphTargetsRelative = geometry.morphTargetsRelative;
					var uv = geometry.attributes.uv;
					var uv2 = geometry.attributes.uv2;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;

					if ( index !== null ) {

						// indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) { continue; }

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								_uvA.copy( uvs_f[ 0 ] );
								_uvB.copy( uvs_f[ 1 ] );
								_uvC.copy( uvs_f[ 2 ] );

								intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			},

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

			var intersect;

			if ( material.side === BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

			}

			if ( intersect === null ) { return null; }

			_intersectionPointWorld.copy( point );
			_intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

			return {
				distance: distance,
				point: _intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

			_vA.fromBufferAttribute( position, a );
			_vB.fromBufferAttribute( position, b );
			_vC.fromBufferAttribute( position, c );

			var morphInfluences = object.morphTargetInfluences;

			if ( material.morphTargets && morphPosition && morphInfluences ) {

				_morphA.set( 0, 0, 0 );
				_morphB.set( 0, 0, 0 );
				_morphC.set( 0, 0, 0 );

				for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

					var influence = morphInfluences[ i ];
					var morphAttribute = morphPosition[ i ];

					if ( influence === 0 ) { continue; }

					_tempA.fromBufferAttribute( morphAttribute, a );
					_tempB.fromBufferAttribute( morphAttribute, b );
					_tempC.fromBufferAttribute( morphAttribute, c );

					if ( morphTargetsRelative ) {

						_morphA.addScaledVector( _tempA, influence );
						_morphB.addScaledVector( _tempB, influence );
						_morphC.addScaledVector( _tempC, influence );

					} else {

						_morphA.addScaledVector( _tempA.sub( _vA ), influence );
						_morphB.addScaledVector( _tempB.sub( _vB ), influence );
						_morphC.addScaledVector( _tempC.sub( _vC ), influence );

					}

				}

				_vA.add( _morphA );
				_vB.add( _morphB );
				_vC.add( _morphC );

			}

			var intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

			if ( intersection ) {

				if ( uv ) {

					_uvA.fromBufferAttribute( uv, a );
					_uvB.fromBufferAttribute( uv, b );
					_uvC.fromBufferAttribute( uv, c );

					intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

				}

				if ( uv2 ) {

					_uvA.fromBufferAttribute( uv2, a );
					_uvB.fromBufferAttribute( uv2, b );
					_uvC.fromBufferAttribute( uv2, c );

					intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

				}

				var face = new Face3( a, b, c );
				Triangle.getNormal( _vA, _vB, _vC, face.normal );

				intersection.face = face;

			}

			return intersection;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */

		var _geometryId = 0; // Geometry uses even numbers as Id
		var _m1$3 = new Matrix4();
		var _obj$1 = new Object3D();
		var _offset$1 = new Vector3();

		function Geometry() {

			Object.defineProperty( this, 'id', { value: _geometryId += 2 } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';
			this.type = 'Geometry';

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];

			this.morphTargets = [];
			this.morphNormals = [];

			this.skinWeights = [];
			this.skinIndices = [];

			this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: Geometry,

			isGeometry: true,

			applyMatrix4: function ( matrix ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );

				}

				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

					}

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;

				return this;

			},

			rotateX: function ( angle ) {

				// rotate geometry around world x-axis

				_m1$3.makeRotationX( angle );

				this.applyMatrix4( _m1$3 );

				return this;

			},

			rotateY: function ( angle ) {

				// rotate geometry around world y-axis

				_m1$3.makeRotationY( angle );

				this.applyMatrix4( _m1$3 );

				return this;

			},

			rotateZ: function ( angle ) {

				// rotate geometry around world z-axis

				_m1$3.makeRotationZ( angle );

				this.applyMatrix4( _m1$3 );

				return this;

			},

			translate: function ( x, y, z ) {

				// translate geometry

				_m1$3.makeTranslation( x, y, z );

				this.applyMatrix4( _m1$3 );

				return this;

			},

			scale: function ( x, y, z ) {

				// scale geometry

				_m1$3.makeScale( x, y, z );

				this.applyMatrix4( _m1$3 );

				return this;

			},

			lookAt: function ( vector ) {

				_obj$1.lookAt( vector );

				_obj$1.updateMatrix();

				this.applyMatrix4( _obj$1.matrix );

				return this;

			},

			fromBufferGeometry: function ( geometry ) {

				var scope = this;

				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;

				if ( attributes.position === undefined ) {

					console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
					return this;

				}

				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

				if ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }

				for ( var i = 0; i < positions.length; i += 3 ) {

					scope.vertices.push( new Vector3().fromArray( positions, i ) );

					if ( colors !== undefined ) {

						scope.colors.push( new Color().fromArray( colors, i ) );

					}

				}

				function addFace( a, b, c, materialIndex ) {

					var vertexColors = ( colors === undefined ) ? [] : [
						scope.colors[ a ].clone(),
						scope.colors[ b ].clone(),
						scope.colors[ c ].clone() ];

					var vertexNormals = ( normals === undefined ) ? [] : [
						new Vector3().fromArray( normals, a * 3 ),
						new Vector3().fromArray( normals, b * 3 ),
						new Vector3().fromArray( normals, c * 3 )
					];

					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

					scope.faces.push( face );

					if ( uvs !== undefined ) {

						scope.faceVertexUvs[ 0 ].push( [
							new Vector2().fromArray( uvs, a * 2 ),
							new Vector2().fromArray( uvs, b * 2 ),
							new Vector2().fromArray( uvs, c * 2 )
						] );

					}

					if ( uvs2 !== undefined ) {

						scope.faceVertexUvs[ 1 ].push( [
							new Vector2().fromArray( uvs2, a * 2 ),
							new Vector2().fromArray( uvs2, b * 2 ),
							new Vector2().fromArray( uvs2, c * 2 )
						] );

					}

				}

				var groups = geometry.groups;

				if ( groups.length > 0 ) {

					for ( var i = 0; i < groups.length; i ++ ) {

						var group = groups[ i ];

						var start = group.start;
						var count = group.count;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							if ( indices !== undefined ) {

								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

							} else {

								addFace( j, j + 1, j + 2, group.materialIndex );

							}

						}

					}

				} else {

					if ( indices !== undefined ) {

						for ( var i = 0; i < indices.length; i += 3 ) {

							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

						}

					} else {

						for ( var i = 0; i < positions.length / 3; i += 3 ) {

							addFace( i, i + 1, i + 2 );

						}

					}

				}

				this.computeFaceNormals();

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				return this;

			},

			center: function () {

				this.computeBoundingBox();

				this.boundingBox.getCenter( _offset$1 ).negate();

				this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

				return this;

			},

			normalize: function () {

				this.computeBoundingSphere();

				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;

				var s = radius === 0 ? 1 : 1.0 / radius;

				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);

				this.applyMatrix4( matrix );

				return this;

			},

			computeFaceNormals: function () {

				var cb = new Vector3(), ab = new Vector3();

				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

					var face = this.faces[ f ];

					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					cb.normalize();

					face.normal.copy( cb );

				}

			},

			computeVertexNormals: function ( areaWeighted ) {

				if ( areaWeighted === undefined ) { areaWeighted = true; }

				var v, vl, f, fl, face, vertices;

				vertices = new Array( this.vertices.length );

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ] = new Vector3();

				}

				if ( areaWeighted ) {

					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm

					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];

						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );

						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );

					}

				} else {

					this.computeFaceNormals();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );

					}

				}

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ].normalize();

				}

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );

					} else {

						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeFlatVertexNormals: function () {

				var f, fl, face;

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );

					} else {

						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeMorphNormals: function () {

				var i, il, f, fl, face;

				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					if ( ! face.__originalFaceNormal ) {

						face.__originalFaceNormal = face.normal.clone();

					} else {

						face.__originalFaceNormal.copy( face.normal );

					}

					if ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }

					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

						if ( ! face.__originalVertexNormals[ i ] ) {

							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

						} else {

							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

						}

					}

				}

				// use temp geometry to compute face and vertex normals for each morph

				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;

				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

					// create on first access

					if ( ! this.morphNormals[ i ] ) {

						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];

						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

						var faceNormal, vertexNormals;

						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );

						}

					}

					var morphNormals = this.morphNormals[ i ];

					// set vertices to morph target

					tmpGeo.vertices = this.morphTargets[ i ].vertices;

					// compute morph normals

					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();

					// store morph normals

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];

						faceNormal.copy( face.normal );

						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );

					}

				}

				// restore original normals

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;

				}

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				this.boundingBox.setFromPoints( this.vertices );

			},

			computeBoundingSphere: function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				this.boundingSphere.setFromPoints( this.vertices );

			},

			merge: function ( geometry, matrix, materialIndexOffset ) {

				if ( ! ( geometry && geometry.isGeometry ) ) {

					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;

				}

				var normalMatrix,
					vertexOffset = this.vertices.length,
					vertices1 = this.vertices,
					vertices2 = geometry.vertices,
					faces1 = this.faces,
					faces2 = geometry.faces,
					colors1 = this.colors,
					colors2 = geometry.colors;

				if ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }

				if ( matrix !== undefined ) {

					normalMatrix = new Matrix3().getNormalMatrix( matrix );

				}

				// vertices

				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

					var vertex = vertices2[ i ];

					var vertexCopy = vertex.clone();

					if ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }

					vertices1.push( vertexCopy );

				}

				// colors

				for ( var i = 0, il = colors2.length; i < il; i ++ ) {

					colors1.push( colors2[ i ].clone() );

				}

				// faces

				for ( i = 0, il = faces2.length; i < il; i ++ ) {

					var face = faces2[ i ], faceCopy, normal, color,
						faceVertexNormals = face.vertexNormals,
						faceVertexColors = face.vertexColors;

					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );

					if ( normalMatrix !== undefined ) {

						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

					}

					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

						normal = faceVertexNormals[ j ].clone();

						if ( normalMatrix !== undefined ) {

							normal.applyMatrix3( normalMatrix ).normalize();

						}

						faceCopy.vertexNormals.push( normal );

					}

					faceCopy.color.copy( face.color );

					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );

					}

					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

					faces1.push( faceCopy );

				}

				// uvs

				for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

					var faceVertexUvs2 = geometry.faceVertexUvs[ i ];

					if ( this.faceVertexUvs[ i ] === undefined ) { this.faceVertexUvs[ i ] = []; }

					for ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {

						var uvs2 = faceVertexUvs2[ j ], uvsCopy = [];

						for ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {

							uvsCopy.push( uvs2[ k ].clone() );

						}

						this.faceVertexUvs[ i ].push( uvsCopy );

					}

				}

			},

			mergeMesh: function ( mesh ) {

				if ( ! ( mesh && mesh.isMesh ) ) {

					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;

				}

				if ( mesh.matrixAutoUpdate ) { mesh.updateMatrix(); }

				this.merge( mesh.geometry, mesh.matrix );

			},

			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */

			mergeVertices: function () {

				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];

				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;

				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

					if ( verticesMap[ key ] === undefined ) {

						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;

					} else {

						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];

					}

				}


				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];

				for ( i = 0, il = this.faces.length; i < il; i ++ ) {

					face = this.faces[ i ];

					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];

					indices = [ face.a, face.b, face.c ];

					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {

						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

							faceIndicesToRemove.push( i );
							break;

						}

					}

				}

				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

					var idx = faceIndicesToRemove[ i ];

					this.faces.splice( idx, 1 );

					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

						this.faceVertexUvs[ j ].splice( idx, 1 );

					}

				}

				// Use unique set of vertices

				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;

			},

			setFromPoints: function ( points ) {

				this.vertices = [];

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

				}

				return this;

			},

			sortFacesByMaterialIndex: function () {

				var faces = this.faces;
				var length = faces.length;

				// tag faces

				for ( var i = 0; i < length; i ++ ) {

					faces[ i ]._id = i;

				}

				// sort faces

				function materialIndexSort( a, b ) {

					return a.materialIndex - b.materialIndex;

				}

				faces.sort( materialIndexSort );

				// sort uvs

				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];

				var newUvs1, newUvs2;

				if ( uvs1 && uvs1.length === length ) { newUvs1 = []; }
				if ( uvs2 && uvs2.length === length ) { newUvs2 = []; }

				for ( var i = 0; i < length; i ++ ) {

					var id = faces[ i ]._id;

					if ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }
					if ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }

				}

				if ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }
				if ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.5,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};

				// standard Geometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) { data.name = this.name; }

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

					}

					return data;

				}

				var vertices = [];

				for ( var i = 0; i < this.vertices.length; i ++ ) {

					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};

				for ( var i = 0; i < this.faces.length; i ++ ) {

					var face = this.faces[ i ];

					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;

					var faceType = 0;

					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );

					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );

					if ( hasFaceVertexUv ) {

						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);

					}

					if ( hasFaceNormal ) {

						faces.push( getNormalIndex( face.normal ) );

					}

					if ( hasFaceVertexNormal ) {

						var vertexNormals = face.vertexNormals;

						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);

					}

					if ( hasFaceColor ) {

						faces.push( getColorIndex( face.color ) );

					}

					if ( hasFaceVertexColor ) {

						var vertexColors = face.vertexColors;

						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);

					}

				}

				function setBit( value, position, enabled ) {

					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

				}

				function getNormalIndex( normal ) {

					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

					if ( normalsHash[ hash ] !== undefined ) {

						return normalsHash[ hash ];

					}

					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );

					return normalsHash[ hash ];

				}

				function getColorIndex( color ) {

					var hash = color.r.toString() + color.g.toString() + color.b.toString();

					if ( colorsHash[ hash ] !== undefined ) {

						return colorsHash[ hash ];

					}

					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );

					return colorsHash[ hash ];

				}

				function getUvIndex( uv ) {

					var hash = uv.x.toString() + uv.y.toString();

					if ( uvsHash[ hash ] !== undefined ) {

						return uvsHash[ hash ];

					}

					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );

					return uvsHash[ hash ];

				}

				data.data = {};

				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) { data.data.colors = colors; }
				if ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility
				data.data.faces = faces;

				return data;

			},

			clone: function () {

				/*
				 // Handle primitives

				 var parameters = this.parameters;

				 if ( parameters !== undefined ) {

				 var values = [];

				 for ( var key in parameters ) {

				 values.push( parameters[ key ] );

				 }

				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;

				 }

				 return new this.constructor().copy( this );
				 */

				return new Geometry().copy( this );

			},

			copy: function ( source ) {

				var i, il, j, jl, k, kl;

				// reset

				this.vertices = [];
				this.colors = [];
				this.faces = [];
				this.faceVertexUvs = [[]];
				this.morphTargets = [];
				this.morphNormals = [];
				this.skinWeights = [];
				this.skinIndices = [];
				this.lineDistances = [];
				this.boundingBox = null;
				this.boundingSphere = null;

				// name

				this.name = source.name;

				// vertices

				var vertices = source.vertices;

				for ( i = 0, il = vertices.length; i < il; i ++ ) {

					this.vertices.push( vertices[ i ].clone() );

				}

				// colors

				var colors = source.colors;

				for ( i = 0, il = colors.length; i < il; i ++ ) {

					this.colors.push( colors[ i ].clone() );

				}

				// faces

				var faces = source.faces;

				for ( i = 0, il = faces.length; i < il; i ++ ) {

					this.faces.push( faces[ i ].clone() );

				}

				// face vertex uvs

				for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

					var faceVertexUvs = source.faceVertexUvs[ i ];

					if ( this.faceVertexUvs[ i ] === undefined ) {

						this.faceVertexUvs[ i ] = [];

					}

					for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

						var uvs = faceVertexUvs[ j ], uvsCopy = [];

						for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

							var uv = uvs[ k ];

							uvsCopy.push( uv.clone() );

						}

						this.faceVertexUvs[ i ].push( uvsCopy );

					}

				}

				// morph targets

				var morphTargets = source.morphTargets;

				for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

					var morphTarget = {};
					morphTarget.name = morphTargets[ i ].name;

					// vertices

					if ( morphTargets[ i ].vertices !== undefined ) {

						morphTarget.vertices = [];

						for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

							morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

						}

					}

					// normals

					if ( morphTargets[ i ].normals !== undefined ) {

						morphTarget.normals = [];

						for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

							morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

						}

					}

					this.morphTargets.push( morphTarget );

				}

				// morph normals

				var morphNormals = source.morphNormals;

				for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

					var morphNormal = {};

					// vertex normals

					if ( morphNormals[ i ].vertexNormals !== undefined ) {

						morphNormal.vertexNormals = [];

						for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

							var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
							var destVertexNormal = {};

							destVertexNormal.a = srcVertexNormal.a.clone();
							destVertexNormal.b = srcVertexNormal.b.clone();
							destVertexNormal.c = srcVertexNormal.c.clone();

							morphNormal.vertexNormals.push( destVertexNormal );

						}

					}

					// face normals

					if ( morphNormals[ i ].faceNormals !== undefined ) {

						morphNormal.faceNormals = [];

						for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

							morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

						}

					}

					this.morphNormals.push( morphNormal );

				}

				// skin weights

				var skinWeights = source.skinWeights;

				for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

					this.skinWeights.push( skinWeights[ i ].clone() );

				}

				// skin indices

				var skinIndices = source.skinIndices;

				for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

					this.skinIndices.push( skinIndices[ i ].clone() );

				}

				// line distances

				var lineDistances = source.lineDistances;

				for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

					this.lineDistances.push( lineDistances[ i ] );

				}

				// bounding box

				var boundingBox = source.boundingBox;

				if ( boundingBox !== null ) {

					this.boundingBox = boundingBox.clone();

				}

				// bounding sphere

				var boundingSphere = source.boundingSphere;

				if ( boundingSphere !== null ) {

					this.boundingSphere = boundingSphere.clone();

				}

				// update flags

				this.elementsNeedUpdate = source.elementsNeedUpdate;
				this.verticesNeedUpdate = source.verticesNeedUpdate;
				this.uvsNeedUpdate = source.uvsNeedUpdate;
				this.normalsNeedUpdate = source.normalsNeedUpdate;
				this.colorsNeedUpdate = source.colorsNeedUpdate;
				this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
				this.groupsNeedUpdate = source.groupsNeedUpdate;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// BoxGeometry

		var BoxGeometry = /*@__PURE__*/(function (Geometry) {
			function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

				Geometry.call(this);

				this.type = 'BoxGeometry';

				this.parameters = {
					width: width,
					height: height,
					depth: depth,
					widthSegments: widthSegments,
					heightSegments: heightSegments,
					depthSegments: depthSegments
				};

				this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
				this.mergeVertices();

			}

			if ( Geometry ) BoxGeometry.__proto__ = Geometry;
			BoxGeometry.prototype = Object.create( Geometry && Geometry.prototype );
			BoxGeometry.prototype.constructor = BoxGeometry;

			return BoxGeometry;
		}(Geometry));

		// BoxBufferGeometry

		var BoxBufferGeometry = /*@__PURE__*/(function (BufferGeometry) {
			function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

				BufferGeometry.call(this);

				this.type = 'BoxBufferGeometry';

				this.parameters = {
					width: width,
					height: height,
					depth: depth,
					widthSegments: widthSegments,
					heightSegments: heightSegments,
					depthSegments: depthSegments
				};

				var scope = this;

				width = width || 1;
				height = height || 1;
				depth = depth || 1;

				// segments

				widthSegments = Math.floor( widthSegments ) || 1;
				heightSegments = Math.floor( heightSegments ) || 1;
				depthSegments = Math.floor( depthSegments ) || 1;

				// buffers

				var indices = [];
				var vertices = [];
				var normals = [];
				var uvs = [];

				// helper variables

				var numberOfVertices = 0;
				var groupStart = 0;

				// build each side of the box geometry

				buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
				buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
				buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
				buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
				buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
				buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

				// build geometry

				this.setIndex( indices );
				this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
				this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
				this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

				function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

					var segmentWidth = width / gridX;
					var segmentHeight = height / gridY;

					var widthHalf = width / 2;
					var heightHalf = height / 2;
					var depthHalf = depth / 2;

					var gridX1 = gridX + 1;
					var gridY1 = gridY + 1;

					var vertexCounter = 0;
					var groupCount = 0;

					var ix, iy;

					var vector = new Vector3();

					// generate vertices, normals and uvs

					for ( iy = 0; iy < gridY1; iy ++ ) {

						var y = iy * segmentHeight - heightHalf;

						for ( ix = 0; ix < gridX1; ix ++ ) {

							var x = ix * segmentWidth - widthHalf;

							// set values to correct vector component

							vector[ u ] = x * udir;
							vector[ v ] = y * vdir;
							vector[ w ] = depthHalf;

							// now apply vector to vertex buffer

							vertices.push( vector.x, vector.y, vector.z );

							// set values to correct vector component

							vector[ u ] = 0;
							vector[ v ] = 0;
							vector[ w ] = depth > 0 ? 1 : - 1;

							// now apply vector to normal buffer

							normals.push( vector.x, vector.y, vector.z );

							// uvs

							uvs.push( ix / gridX );
							uvs.push( 1 - ( iy / gridY ) );

							// counters

							vertexCounter += 1;

						}

					}

					// indices

					// 1. you need three indices to draw a single face
					// 2. a single segment consists of two faces
					// 3. so we need to generate six (2*3) indices per segment

					for ( iy = 0; iy < gridY; iy ++ ) {

						for ( ix = 0; ix < gridX; ix ++ ) {

							var a = numberOfVertices + ix + gridX1 * iy;
							var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
							var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
							var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

							// faces

							indices.push( a, b, d );
							indices.push( b, c, d );

							// increase counter

							groupCount += 6;

						}

					}

					// add a group to the geometry. this will ensure multi material support

					scope.addGroup( groupStart, groupCount, materialIndex );

					// calculate new start value for groups

					groupStart += groupCount;

					// update total number of vertices

					numberOfVertices += vertexCounter;

				}

			}

			if ( BufferGeometry ) BoxBufferGeometry.__proto__ = BufferGeometry;
			BoxBufferGeometry.prototype = Object.create( BufferGeometry && BufferGeometry.prototype );
			BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

			return BoxBufferGeometry;
		}(BufferGeometry));

		/**
		 * Uniform Utilities
		 */

		function cloneUniforms( src ) {

			var dst = {};

			for ( var u in src ) {

				dst[ u ] = {};

				for ( var p in src[ u ] ) {

					var property = src[ u ][ p ];

					if ( property && ( property.isColor ||
						property.isMatrix3 || property.isMatrix4 ||
						property.isVector2 || property.isVector3 || property.isVector4 ||
						property.isTexture ) ) {

						dst[ u ][ p ] = property.clone();

					} else if ( Array.isArray( property ) ) {

						dst[ u ][ p ] = property.slice();

					} else {

						dst[ u ][ p ] = property;

					}

				}

			}

			return dst;

		}

		function mergeUniforms( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = cloneUniforms( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		}

		// Legacy

		var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

		var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

		var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function ShaderMaterial( parameters ) {

			Material.call( this );

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};

			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;

		ShaderMaterial.prototype.isShaderMaterial = true;

		ShaderMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.lights = source.lights;
			this.clipping = source.clipping;

			this.skinning = source.skinning;

			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.extensions = source.extensions;

			return this;

		};

		ShaderMaterial.prototype.toJSON = function ( meta ) {

			var data = Material.prototype.toJSON.call( this, meta );

			data.uniforms = {};

			for ( var name in this.uniforms ) {

				var uniform = this.uniforms[ name ];
				var value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) { data.defines = this.defines; }

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			var extensions = {};

			for ( var key in this.extensions ) {

				if ( this.extensions[ key ] === true ) { extensions[ key ] = true; }

			}

			if ( Object.keys( extensions ).length > 0 ) { data.extensions = extensions; }

			return data;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function Camera() {

			Object3D.call( this );

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();

			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();

		}

		Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Camera,

			isCamera: true,

			copy: function ( source, recursive ) {

				Object3D.prototype.copy.call( this, source, recursive );

				this.matrixWorldInverse.copy( source.matrixWorldInverse );

				this.projectionMatrix.copy( source.projectionMatrix );
				this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

				return this;

			},

			getWorldDirection: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				var e = this.matrixWorld.elements;

				return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

			},

			updateMatrixWorld: function ( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				this.matrixWorldInverse.getInverse( this.matrixWorld );

			},

			updateWorldMatrix: function ( updateParents, updateChildren ) {

				Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

				this.matrixWorldInverse.getInverse( this.matrixWorld );

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */

		function PerspectiveCamera( fov, aspect, near, far ) {

			Camera.call( this );

			this.type = 'PerspectiveCamera';

			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;

			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;

			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: PerspectiveCamera,

			isPerspectiveCamera: true,

			copy: function ( source, recursive ) {

				Camera.prototype.copy.call( this, source, recursive );

				this.fov = source.fov;
				this.zoom = source.zoom;

				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;

				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;

				return this;

			},

			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {

				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

				this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();

			},

			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {

				var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

				return 0.5 * this.getFilmHeight() / vExtentSlope;

			},

			getEffectiveFOV: function () {

				return MathUtils.RAD2DEG * 2 * Math.atan(
					Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

			},

			getFilmWidth: function () {

				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );

			},

			getFilmHeight: function () {

				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );

			},

			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

				this.aspect = fullWidth / fullHeight;

				if ( this.view === null ) {

					this.view = {
						enabled: true,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					};

				}

				this.view.enabled = true;
				this.view.fullWidth = fullWidth;
				this.view.fullHeight = fullHeight;
				this.view.offsetX = x;
				this.view.offsetY = y;
				this.view.width = width;
				this.view.height = height;

				this.updateProjectionMatrix();

			},

			clearViewOffset: function () {

				if ( this.view !== null ) {

					this.view.enabled = false;

				}

				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var near = this.near,
					top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;

				if ( this.view !== null && this.view.enabled ) {

					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;

					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;

				}

				var skew = this.filmOffset;
				if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

				this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

				this.projectionMatrixInverse.getInverse( this.projectionMatrix );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.fov = this.fov;
				data.object.zoom = this.zoom;

				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;

				data.object.aspect = this.aspect;

				if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;

				return data;

			}

		} );

		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */

		var fov = 90, aspect = 1;

		function CubeCamera( near, far, cubeResolution, options ) {

			Object3D.call( this );

			this.type = 'CubeCamera';

			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

			options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

			this.renderTarget = new WebGLCubeRenderTarget( cubeResolution, options );
			this.renderTarget.texture.name = "CubeCamera";

			this.update = function ( renderer, scene ) {

				if ( this.parent === null ) { this.updateMatrixWorld(); }

				var currentRenderTarget = renderer.getRenderTarget();

				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;

				renderTarget.texture.generateMipmaps = false;

				renderer.setRenderTarget( renderTarget, 0 );
				renderer.render( scene, cameraPX );

				renderer.setRenderTarget( renderTarget, 1 );
				renderer.render( scene, cameraNX );

				renderer.setRenderTarget( renderTarget, 2 );
				renderer.render( scene, cameraPY );

				renderer.setRenderTarget( renderTarget, 3 );
				renderer.render( scene, cameraNY );

				renderer.setRenderTarget( renderTarget, 4 );
				renderer.render( scene, cameraPZ );

				renderTarget.texture.generateMipmaps = generateMipmaps;

				renderer.setRenderTarget( renderTarget, 5 );
				renderer.render( scene, cameraNZ );

				renderer.setRenderTarget( currentRenderTarget );

			};

			this.clear = function ( renderer, color, depth, stencil ) {

				var currentRenderTarget = renderer.getRenderTarget();

				var renderTarget = this.renderTarget;

				for ( var i = 0; i < 6; i ++ ) {

					renderer.setRenderTarget( renderTarget, i );

					renderer.clear( color, depth, stencil );

				}

				renderer.setRenderTarget( currentRenderTarget );

			};

		}

		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;

		/**
		 * @author alteredq / http://alteredqualia.com
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function WebGLCubeRenderTarget( size, options, dummy ) {

			if ( Number.isInteger( options ) ) {

				console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

				options = dummy;

			}

			WebGLRenderTarget.call( this, size, size, options );

		}

		WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

		WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

		WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.format = texture.format;
			this.texture.encoding = texture.encoding;

			var scene = new Scene();

			var shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: [

					"varying vec3 vWorldDirection;",

					"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",

					"	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",

					"}",

					"void main() {",

					"	vWorldDirection = transformDirection( position, modelMatrix );",

					"	#include <begin_vertex>",
					"	#include <project_vertex>",

					"}"

				].join( '\n' ),

				fragmentShader: [

					"uniform sampler2D tEquirect;",

					"varying vec3 vWorldDirection;",

					"#define RECIPROCAL_PI 0.31830988618",
					"#define RECIPROCAL_PI2 0.15915494",

					"void main() {",

					"	vec3 direction = normalize( vWorldDirection );",

					"	vec2 sampleUV;",

					"	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",

					"	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",

					"	gl_FragColor = texture2D( tEquirect, sampleUV );",

					"}"

				].join( '\n' ),
			};

			var material = new ShaderMaterial( {

				type: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			var mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );

			scene.add( mesh );

			var camera = new CubeCamera( 1, 10, 1 );

			camera.renderTarget = this;
			camera.renderTarget.texture.name = 'CubeCameraTexture';

			camera.update( renderer, scene );

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data || null, width: width || 1, height: height || 1 };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

			this.needsUpdate = true;

		}

		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;

		DataTexture.prototype.isDataTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */

		var _sphere$1 = new Sphere();
		var _vector$5 = new Vector3();

		function Frustum( p0, p1, p2, p3, p4, p5 ) {

			this.planes = [

				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()

			];

		}

		Object.assign( Frustum.prototype, {

			set: function ( p0, p1, p2, p3, p4, p5 ) {

				var planes = this.planes;

				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( frustum ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					planes[ i ].copy( frustum.planes[ i ] );

				}

				return this;

			},

			setFromProjectionMatrix: function ( m ) {

				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

				return this;

			},

			intersectsObject: function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

				_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( _sphere$1 );

			},

			intersectsSprite: function ( sprite ) {

				_sphere$1.center.set( 0, 0, 0 );
				_sphere$1.radius = 0.7071067811865476;
				_sphere$1.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( _sphere$1 );

			},

			intersectsSphere: function ( sphere ) {

				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;

				for ( var i = 0; i < 6; i ++ ) {

					var distance = planes[ i ].distanceToPoint( center );

					if ( distance < negRadius ) {

						return false;

					}

				}

				return true;

			},

			intersectsBox: function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					// corner at max distance

					_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

						return false;

					}

				}

				return true;

			},

			containsPoint: function ( point ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					if ( planes[ i ].distanceToPoint( point ) < 0 ) {

						return false;

					}

				}

				return true;

			}

		} );

		/**
		 * Uniforms library for shared webgl shaders
		 */

		var UniformsLib = {

			common: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },

				map: { value: null },
				uvTransform: { value: new Matrix3() },
				uv2Transform: { value: new Matrix3() },

				alphaMap: { value: null },

			},

			specularmap: {

				specularMap: { value: null },

			},

			envmap: {

				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 },
				maxMipLevel: { value: 0 }

			},

			aomap: {

				aoMap: { value: null },
				aoMapIntensity: { value: 1 }

			},

			lightmap: {

				lightMap: { value: null },
				lightMapIntensity: { value: 1 }

			},

			emissivemap: {

				emissiveMap: { value: null }

			},

			bumpmap: {

				bumpMap: { value: null },
				bumpScale: { value: 1 }

			},

			normalmap: {

				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }

			},

			displacementmap: {

				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }

			},

			roughnessmap: {

				roughnessMap: { value: null }

			},

			metalnessmap: {

				metalnessMap: { value: null }

			},

			gradientmap: {

				gradientMap: { value: null }

			},

			fog: {

				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }

			},

			lights: {

				ambientLightColor: { value: [] },

				lightProbe: { value: [] },

				directionalLights: { value: [], properties: {
					direction: {},
					color: {}
				} },

				directionalLightShadows: { value: [], properties: {
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },

				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				} },

				spotLightShadows: { value: [], properties: {
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },

				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				} },

				pointLightShadows: { value: [], properties: {
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				} },

				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },

				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} },

				// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
				rectAreaLights: { value: [], properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				} }

			},

			points: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new Matrix3() }

			},

			sprite: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				center: { value: new Vector2( 0.5, 0.5 ) },
				rotation: { value: 0.0 },
				map: { value: null },
				alphaMap: { value: null },
				uvTransform: { value: new Matrix3() }

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLAnimation() {

			var context = null;
			var isAnimating = false;
			var animationLoop = null;

			function onAnimationFrame( time, frame ) {

				if ( isAnimating === false ) { return; }

				animationLoop( time, frame );

				context.requestAnimationFrame( onAnimationFrame );

			}

			return {

				start: function () {

					if ( isAnimating === true ) { return; }
					if ( animationLoop === null ) { return; }

					context.requestAnimationFrame( onAnimationFrame );

					isAnimating = true;

				},

				stop: function () {

					isAnimating = false;

				},

				setAnimationLoop: function ( callback ) {

					animationLoop = callback;

				},

				setContext: function ( value ) {

					context = value;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLAttributes( gl, capabilities ) {

			var isWebGL2 = capabilities.isWebGL2;

			var buffers = new WeakMap();

			function createBuffer( attribute, bufferType ) {

				var array = attribute.array;
				var usage = attribute.usage;

				var buffer = gl.createBuffer();

				gl.bindBuffer( bufferType, buffer );
				gl.bufferData( bufferType, array, usage );

				attribute.onUploadCallback();

				var type = 5126;

				if ( array instanceof Float32Array ) {

					type = 5126;

				} else if ( array instanceof Float64Array ) {

					console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

				} else if ( array instanceof Uint16Array ) {

					type = 5123;

				} else if ( array instanceof Int16Array ) {

					type = 5122;

				} else if ( array instanceof Uint32Array ) {

					type = 5125;

				} else if ( array instanceof Int32Array ) {

					type = 5124;

				} else if ( array instanceof Int8Array ) {

					type = 5120;

				} else if ( array instanceof Uint8Array ) {

					type = 5121;

				}

				return {
					buffer: buffer,
					type: type,
					bytesPerElement: array.BYTES_PER_ELEMENT,
					version: attribute.version
				};

			}

			function updateBuffer( buffer, attribute, bufferType ) {

				var array = attribute.array;
				var updateRange = attribute.updateRange;

				gl.bindBuffer( bufferType, buffer );

				if ( updateRange.count === - 1 ) {

					// Not using update ranges

					gl.bufferSubData( bufferType, 0, array );

				} else {

					if ( isWebGL2 ) {

						gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
							array, updateRange.offset, updateRange.count );

					} else {

						gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
							array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

					}

					updateRange.count = - 1; // reset range

				}

			}

			//

			function get( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

				return buffers.get( attribute );

			}

			function remove( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

				var data = buffers.get( attribute );

				if ( data ) {

					gl.deleteBuffer( data.buffer );

					buffers.delete( attribute );

				}

			}

			function update( attribute, bufferType ) {

				if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

				var data = buffers.get( attribute );

				if ( data === undefined ) {

					buffers.set( attribute, createBuffer( attribute, bufferType ) );

				} else if ( data.version < attribute.version ) {

					updateBuffer( data.buffer, attribute, bufferType );

					data.version = attribute.version;

				}

			}

			return {

				get: get,
				remove: remove,
				update: update

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// PlaneGeometry

		function PlaneGeometry( width, height, widthSegments, heightSegments ) {

			Geometry.call( this );

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
			this.mergeVertices();

		}

		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;

		// PlaneBufferGeometry

		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

			BufferGeometry.call( this );

			this.type = 'PlaneBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			width = width || 1;
			height = height || 1;

			var width_half = width / 2;
			var height_half = height / 2;

			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var segment_width = width / gridX;
			var segment_height = height / gridY;

			var ix, iy;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segment_height - height_half;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			// indices

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

		var begin_vertex = "vec3 transformed = vec3( position );";

		var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

		var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";

		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";

		var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

		var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

		var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

		var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

		var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

		var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

		var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

		var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

		var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

		var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

		var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

		var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

		var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

		var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

		var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

		var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

		var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

		var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

		var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

		var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

		var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

		var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

		var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

		var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

		var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

		var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

		var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

		var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

		var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

		var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

		var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

		var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

		var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

		var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

		var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

		var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

		var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

		var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

		var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

		var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

		var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

		var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

		var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

		var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

		var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

		var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

		var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

		var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

		var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

		var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_common_pars_fragment: envmap_common_pars_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_physical_pars_fragment: envmap_physical_pars_fragment,
			envmap_vertex: envmap_vertex,
			fog_vertex: fog_vertex,
			fog_pars_vertex: fog_pars_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			gradientmap_pars_fragment: gradientmap_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars_begin: lights_pars_begin,
			lights_toon_fragment: lights_toon_fragment,
			lights_toon_pars_fragment: lights_toon_pars_fragment,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_fragment_begin: lights_fragment_begin,
			lights_fragment_maps: lights_fragment_maps,
			lights_fragment_end: lights_fragment_end,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_fragment_begin: normal_fragment_begin,
			normal_fragment_maps: normal_fragment_maps,
			normalmap_pars_fragment: normalmap_pars_fragment,
			clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
			clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
			clearcoat_pars_fragment: clearcoat_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			dithering_fragment: dithering_fragment,
			dithering_pars_fragment: dithering_pars_fragment,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,

			background_frag: background_frag,
			background_vert: background_vert,
			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshmatcap_frag: meshmatcap_frag,
			meshmatcap_vert: meshmatcap_vert,
			meshtoon_frag: meshtoon_frag,
			meshtoon_vert: meshtoon_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert,
			sprite_frag: sprite_frag,
			sprite_vert: sprite_vert
		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */

		var ShaderLib = {

			basic: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.specularmap,
					UniformsLib.envmap,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.fog
				] ),

				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag

			},

			lambert: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.specularmap,
					UniformsLib.envmap,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) }
					}
				] ),

				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag

			},

			phong: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.specularmap,
					UniformsLib.envmap,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),

				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag

			},

			standard: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.envmap,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0.5 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),

				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag

			},

			toon: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.specularmap,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.gradientmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),

				vertexShader: ShaderChunk.meshtoon_vert,
				fragmentShader: ShaderChunk.meshtoon_frag

			},

			matcap: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.fog,
					{
						matcap: { value: null }
					}
				] ),

				vertexShader: ShaderChunk.meshmatcap_vert,
				fragmentShader: ShaderChunk.meshmatcap_frag

			},

			points: {

				uniforms: mergeUniforms( [
					UniformsLib.points,
					UniformsLib.fog
				] ),

				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag

			},

			dashed: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 }
					}
				] ),

				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag

			},

			depth: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.displacementmap
				] ),

				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag

			},

			normal: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					{
						opacity: { value: 1.0 }
					}
				] ),

				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag

			},

			sprite: {

				uniforms: mergeUniforms( [
					UniformsLib.sprite,
					UniformsLib.fog
				] ),

				vertexShader: ShaderChunk.sprite_vert,
				fragmentShader: ShaderChunk.sprite_frag

			},

			background: {

				uniforms: {
					uvTransform: { value: new Matrix3() },
					t2D: { value: null },
				},

				vertexShader: ShaderChunk.background_vert,
				fragmentShader: ShaderChunk.background_frag

			},
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			cube: {

				uniforms: mergeUniforms( [
					UniformsLib.envmap,
					{
						opacity: { value: 1.0 }
					}
				] ),

				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag

			},

			equirect: {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag

			},

			distanceRGBA: {

				uniforms: mergeUniforms( [
					UniformsLib.common,
					UniformsLib.displacementmap,
					{
						referencePosition: { value: new Vector3() },
						nearDistance: { value: 1 },
						farDistance: { value: 1000 }
					}
				] ),

				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag

			},

			shadow: {

				uniforms: mergeUniforms( [
					UniformsLib.lights,
					UniformsLib.fog,
					{
						color: { value: new Color( 0x00000 ) },
						opacity: { value: 1.0 }
					} ] ),

				vertexShader: ShaderChunk.shadow_vert,
				fragmentShader: ShaderChunk.shadow_frag

			}

		};

		ShaderLib.physical = {

			uniforms: mergeUniforms( [
				ShaderLib.standard.uniforms,
				{
					clearcoat: { value: 0 },
					clearcoatMap: { value: null },
					clearcoatRoughness: { value: 0 },
					clearcoatRoughnessMap: { value: null },
					clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
					clearcoatNormalMap: { value: null },
					sheen: { value: new Color( 0x000000 ) },
					transparency: { value: 0 },
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

			var clearColor = new Color( 0x000000 );
			var clearAlpha = 0;

			var planeMesh;
			var boxMesh;

			var currentBackground = null;
			var currentBackgroundVersion = 0;
			var currentTonemapping = null;

			function render( renderList, scene, camera, forceClear ) {

				var background = scene.background;

				// Ignore background in AR
				// TODO: Reconsider this.

				var xr = renderer.xr;
				var session = xr.getSession && xr.getSession();

				if ( session && session.environmentBlendMode === 'additive' ) {

					background = null;

				}

				if ( background === null ) {

					setClear( clearColor, clearAlpha );

				} else if ( background && background.isColor ) {

					setClear( background, 1 );
					forceClear = true;

				}

				if ( renderer.autoClear || forceClear ) {

					renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

				}

				if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

					if ( boxMesh === undefined ) {

						boxMesh = new Mesh(
							new BoxBufferGeometry( 1, 1, 1 ),
							new ShaderMaterial( {
								type: 'BackgroundCubeMaterial',
								uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
								vertexShader: ShaderLib.cube.vertexShader,
								fragmentShader: ShaderLib.cube.fragmentShader,
								side: BackSide,
								depthTest: false,
								depthWrite: false,
								fog: false
							} )
						);

						boxMesh.geometry.deleteAttribute( 'normal' );
						boxMesh.geometry.deleteAttribute( 'uv' );

						boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

							this.matrixWorld.copyPosition( camera.matrixWorld );

						};

						// enable code injection for non-built-in material
						Object.defineProperty( boxMesh.material, 'envMap', {

							get: function () {

								return this.uniforms.envMap.value;

							}

						} );

						objects.update( boxMesh );

					}

					var texture = background.isWebGLCubeRenderTarget ? background.texture : background;

					boxMesh.material.uniforms.envMap.value = texture;
					boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;

					if ( currentBackground !== background ||
						currentBackgroundVersion !== texture.version ||
						currentTonemapping !== renderer.toneMapping ) {

						boxMesh.material.needsUpdate = true;

						currentBackground = background;
						currentBackgroundVersion = texture.version;
						currentTonemapping = renderer.toneMapping;

					}

					// push to the pre-sorted opaque render list
					renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

				} else if ( background && background.isTexture ) {

					if ( planeMesh === undefined ) {

						planeMesh = new Mesh(
							new PlaneBufferGeometry( 2, 2 ),
							new ShaderMaterial( {
								type: 'BackgroundMaterial',
								uniforms: cloneUniforms( ShaderLib.background.uniforms ),
								vertexShader: ShaderLib.background.vertexShader,
								fragmentShader: ShaderLib.background.fragmentShader,
								side: FrontSide,
								depthTest: false,
								depthWrite: false,
								fog: false
							} )
						);

						planeMesh.geometry.deleteAttribute( 'normal' );

						// enable code injection for non-built-in material
						Object.defineProperty( planeMesh.material, 'map', {

							get: function () {

								return this.uniforms.t2D.value;

							}

						} );

						objects.update( planeMesh );

					}

					planeMesh.material.uniforms.t2D.value = background;

					if ( background.matrixAutoUpdate === true ) {

						background.updateMatrix();

					}

					planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

					if ( currentBackground !== background ||
						currentBackgroundVersion !== background.version ||
						currentTonemapping !== renderer.toneMapping ) {

						planeMesh.material.needsUpdate = true;

						currentBackground = background;
						currentBackgroundVersion = background.version;
						currentTonemapping = renderer.toneMapping;

					}


					// push to the pre-sorted opaque render list
					renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

				}

			}

			function setClear( color, alpha ) {

				state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

			}

			return {

				getClearColor: function () {

					return clearColor;

				},
				setClearColor: function ( color, alpha ) {

					clearColor.set( color );
					clearAlpha = alpha !== undefined ? alpha : 1;
					setClear( clearColor, clearAlpha );

				},
				getClearAlpha: function () {

					return clearAlpha;

				},
				setClearAlpha: function ( alpha ) {

					clearAlpha = alpha;
					setClear( clearColor, clearAlpha );

				},
				render: render

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

			var isWebGL2 = capabilities.isWebGL2;

			var mode;

			function setMode( value ) {

				mode = value;

			}

			function render( start, count ) {

				gl.drawArrays( mode, start, count );

				info.update( count, mode );

			}

			function renderInstances( geometry, start, count, primcount ) {

				if ( primcount === 0 ) { return; }

				var extension, methodName;

				if ( isWebGL2 ) {

					extension = gl;
					methodName = 'drawArraysInstanced';

				} else {

					extension = extensions.get( 'ANGLE_instanced_arrays' );
					methodName = 'drawArraysInstancedANGLE';

					if ( extension === null ) {

						console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;

					}

				}

				extension[ methodName ]( mode, start, count, primcount );

				info.update( count, mode, primcount );

			}

			//

			this.setMode = setMode;
			this.render = render;
			this.renderInstances = renderInstances;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLCapabilities( gl, extensions, parameters ) {

			var maxAnisotropy;

			function getMaxAnisotropy() {

				if ( maxAnisotropy !== undefined ) { return maxAnisotropy; }

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					maxAnisotropy = 0;

				}

				return maxAnisotropy;

			}

			function getMaxPrecision( precision ) {

				if ( precision === 'highp' ) {

					if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
						gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

						return 'highp';

					}

					precision = 'mediump';

				}

				if ( precision === 'mediump' ) {

					if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
						gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

						return 'mediump';

					}

				}

				return 'lowp';

			}

			/* eslint-disable no-undef */
			var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
				( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
			/* eslint-enable no-undef */

			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );

			if ( maxPrecision !== precision ) {

				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;

			}

			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

			var maxTextures = gl.getParameter( 34930 );
			var maxVertexTextures = gl.getParameter( 35660 );
			var maxTextureSize = gl.getParameter( 3379 );
			var maxCubemapSize = gl.getParameter( 34076 );

			var maxAttributes = gl.getParameter( 34921 );
			var maxVertexUniforms = gl.getParameter( 36347 );
			var maxVaryings = gl.getParameter( 36348 );
			var maxFragmentUniforms = gl.getParameter( 36349 );

			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;

			var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

			return {

				isWebGL2: isWebGL2,

				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,

				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,

				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,

				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures,

				maxSamples: maxSamples

			};

		}

		/**
		 * @author tschw
		 */

		function WebGLClipping() {

			var scope = this,

				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,

				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),

				uniform = { value: null, needsUpdate: false };

			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;

			this.init = function ( planes, enableLocalClipping, camera ) {

				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;

				localClippingEnabled = enableLocalClipping;

				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;

				return enabled;

			};

			this.beginShadows = function () {

				renderingShadows = true;
				projectPlanes( null );

			};

			this.endShadows = function () {

				renderingShadows = false;
				resetGlobalState();

			};

			this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

				if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

					// there's no local clipping

					if ( renderingShadows ) {

						// there's no global clipping

						projectPlanes( null );

					} else {

						resetGlobalState();

					}

				} else {

					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,

						dstArray = cache.clippingState || null;

					uniform.value = dstArray; // ensure unique state

					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

					for ( var i = 0; i !== lGlobal; ++ i ) {

						dstArray[ i ] = globalState[ i ];

					}

					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;

				}


			};

			function resetGlobalState() {

				if ( uniform.value !== globalState ) {

					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;

				}

				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;

			}

			function projectPlanes( planes, camera, dstOffset, skipTransform ) {

				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;

				if ( nPlanes !== 0 ) {

					dstArray = uniform.value;

					if ( skipTransform !== true || dstArray === null ) {

						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;

						viewNormalMatrix.getNormalMatrix( viewMatrix );

						if ( dstArray === null || dstArray.length < flatSize ) {

							dstArray = new Float32Array( flatSize );

						}

						for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

							plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;

						}

					}

					uniform.value = dstArray;
					uniform.needsUpdate = true;

				}

				scope.numPlanes = nPlanes;
				scope.numIntersection = 0;

				return dstArray;

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLExtensions( gl ) {

			var extensions = {};

			return {

				get: function ( name ) {

					if ( extensions[ name ] !== undefined ) {

						return extensions[ name ];

					}

					var extension;

					switch ( name ) {

						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;

						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;

						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;

						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;

						default:
							extension = gl.getExtension( name );

					}

					if ( extension === null ) {

						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

					}

					extensions[ name ] = extension;

					return extension;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLGeometries( gl, attributes, info ) {

			var geometries = new WeakMap();
			var wireframeAttributes = new WeakMap();

			function onGeometryDispose( event ) {

				var geometry = event.target;
				var buffergeometry = geometries.get( geometry );

				if ( buffergeometry.index !== null ) {

					attributes.remove( buffergeometry.index );

				}

				for ( var name in buffergeometry.attributes ) {

					attributes.remove( buffergeometry.attributes[ name ] );

				}

				geometry.removeEventListener( 'dispose', onGeometryDispose );

				geometries.delete( geometry );

				var attribute = wireframeAttributes.get( buffergeometry );

				if ( attribute ) {

					attributes.remove( attribute );
					wireframeAttributes.delete( buffergeometry );

				}

				//

				info.memory.geometries --;

			}

			function get( object, geometry ) {

				var buffergeometry = geometries.get( geometry );

				if ( buffergeometry ) { return buffergeometry; }

				geometry.addEventListener( 'dispose', onGeometryDispose );

				if ( geometry.isBufferGeometry ) {

					buffergeometry = geometry;

				} else if ( geometry.isGeometry ) {

					if ( geometry._bufferGeometry === undefined ) {

						geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

					}

					buffergeometry = geometry._bufferGeometry;

				}

				geometries.set( geometry, buffergeometry );

				info.memory.geometries ++;

				return buffergeometry;

			}

			function update( geometry ) {

				var index = geometry.index;
				var geometryAttributes = geometry.attributes;

				if ( index !== null ) {

					attributes.update( index, 34963 );

				}

				for ( var name in geometryAttributes ) {

					attributes.update( geometryAttributes[ name ], 34962 );

				}

				// morph targets

				var morphAttributes = geometry.morphAttributes;

				for ( var name in morphAttributes ) {

					var array = morphAttributes[ name ];

					for ( var i = 0, l = array.length; i < l; i ++ ) {

						attributes.update( array[ i ], 34962 );

					}

				}

			}

			function updateWireframeAttribute( geometry ) {

				var indices = [];

				var geometryIndex = geometry.index;
				var geometryPosition = geometry.attributes.position;
				var version = 0;

				if ( geometryIndex !== null ) {

					var array = geometryIndex.array;
					version = geometryIndex.version;

					for ( var i = 0, l = array.length; i < l; i += 3 ) {

						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];

						indices.push( a, b, b, c, c, a );

					}

				} else {

					var array = geometryPosition.array;
					version = geometryPosition.version;

					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

						var a = i + 0;
						var b = i + 1;
						var c = i + 2;

						indices.push( a, b, b, c, c, a );

					}

				}

				var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
				attribute.version = version;

				attributes.update( attribute, 34963 );

				//

				var previousAttribute = wireframeAttributes.get( geometry );

				if ( previousAttribute ) { attributes.remove( previousAttribute ); }

				//

				wireframeAttributes.set( geometry, attribute );

			}

			function getWireframeAttribute( geometry ) {

				var currentAttribute = wireframeAttributes.get( geometry );

				if ( currentAttribute ) {

					var geometryIndex = geometry.index;

					if ( geometryIndex !== null ) {

						// if the attribute is obsolete, create a new one

						if ( currentAttribute.version < geometryIndex.version ) {

							updateWireframeAttribute( geometry );

						}

					}

				} else {

					updateWireframeAttribute( geometry );

				}

				return wireframeAttributes.get( geometry );

			}

			return {

				get: get,
				update: update,

				getWireframeAttribute: getWireframeAttribute

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

			var isWebGL2 = capabilities.isWebGL2;

			var mode;

			function setMode( value ) {

				mode = value;

			}

			var type, bytesPerElement;

			function setIndex( value ) {

				type = value.type;
				bytesPerElement = value.bytesPerElement;

			}

			function render( start, count ) {

				gl.drawElements( mode, count, type, start * bytesPerElement );

				info.update( count, mode );

			}

			function renderInstances( geometry, start, count, primcount ) {

				if ( primcount === 0 ) { return; }

				var extension, methodName;

				if ( isWebGL2 ) {

					extension = gl;
					methodName = 'drawElementsInstanced';

				} else {

					extension = extensions.get( 'ANGLE_instanced_arrays' );
					methodName = 'drawElementsInstancedANGLE';

					if ( extension === null ) {

						console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;

					}

				}

				extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

				info.update( count, mode, primcount );

			}

			//

			this.setMode = setMode;
			this.setIndex = setIndex;
			this.render = render;
			this.renderInstances = renderInstances;

		}

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function WebGLInfo( gl ) {

			var memory = {
				geometries: 0,
				textures: 0
			};

			var render = {
				frame: 0,
				calls: 0,
				triangles: 0,
				points: 0,
				lines: 0
			};

			function update( count, mode, instanceCount ) {

				instanceCount = instanceCount || 1;

				render.calls ++;

				switch ( mode ) {

					case 4:
						render.triangles += instanceCount * ( count / 3 );
						break;

					case 1:
						render.lines += instanceCount * ( count / 2 );
						break;

					case 3:
						render.lines += instanceCount * ( count - 1 );
						break;

					case 2:
						render.lines += instanceCount * count;
						break;

					case 0:
						render.points += instanceCount * count;
						break;

					default:
						console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
						break;

				}

			}

			function reset() {

				render.frame ++;
				render.calls = 0;
				render.triangles = 0;
				render.points = 0;
				render.lines = 0;

			}

			return {
				memory: memory,
				render: render,
				programs: null,
				autoReset: true,
				reset: reset,
				update: update
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function absNumericalSort( a, b ) {

			return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

		}

		function WebGLMorphtargets( gl ) {

			var influencesList = {};
			var morphInfluences = new Float32Array( 8 );

			function update( object, geometry, material, program ) {

				var objectInfluences = object.morphTargetInfluences;

				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

				var length = objectInfluences === undefined ? 0 : objectInfluences.length;

				var influences = influencesList[ geometry.id ];

				if ( influences === undefined ) {

					// initialise list

					influences = [];

					for ( var i = 0; i < length; i ++ ) {

						influences[ i ] = [ i, 0 ];

					}

					influencesList[ geometry.id ] = influences;

				}

				var morphTargets = material.morphTargets && geometry.morphAttributes.position;
				var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

				// Remove current morphAttributes

				for ( var i = 0; i < length; i ++ ) {

					var influence = influences[ i ];

					if ( influence[ 1 ] !== 0 ) {

						if ( morphTargets ) { geometry.deleteAttribute( 'morphTarget' + i ); }
						if ( morphNormals ) { geometry.deleteAttribute( 'morphNormal' + i ); }

					}

				}

				// Collect influences

				for ( var i = 0; i < length; i ++ ) {

					var influence = influences[ i ];

					influence[ 0 ] = i;
					influence[ 1 ] = objectInfluences[ i ];

				}

				influences.sort( absNumericalSort );

				// Add morphAttributes

				var morphInfluencesSum = 0;

				for ( var i = 0; i < 8; i ++ ) {

					var influence = influences[ i ];

					if ( influence ) {

						var index = influence[ 0 ];
						var value = influence[ 1 ];

						if ( value ) {

							if ( morphTargets ) { geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] ); }
							if ( morphNormals ) { geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] ); }

							morphInfluences[ i ] = value;
							morphInfluencesSum += value;
							continue;

						}

					}

					morphInfluences[ i ] = 0;

				}

				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

			}

			return {

				update: update

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLObjects( gl, geometries, attributes, info ) {

			var updateMap = new WeakMap();

			function update( object ) {

				var frame = info.render.frame;

				var geometry = object.geometry;
				var buffergeometry = geometries.get( object, geometry );

				// Update once per frame

				if ( updateMap.get( buffergeometry ) !== frame ) {

					if ( geometry.isGeometry ) {

						buffergeometry.updateFromObject( object );

					}

					geometries.update( buffergeometry );

					updateMap.set( buffergeometry, frame );

				}

				if ( object.isInstancedMesh ) {

					attributes.update( object.instanceMatrix, 34962 );

				}

				return buffergeometry;

			}

			function dispose() {

				updateMap = new WeakMap();

			}

			return {

				update: update,
				dispose: dispose

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;

			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.flipY = false;

		}

		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;

		CubeTexture.prototype.isCubeTexture = true;

		Object.defineProperty( CubeTexture.prototype, 'images', {

			get: function () {

				return this.image;

			},

			set: function ( value ) {

				this.image = value;

			}

		} );

		/**
		 * @author Takahiro https://github.com/takahirox
		 */

		function DataTexture2DArray( data, width, height, depth ) {

			Texture.call( this, null );

			this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;

		}

		DataTexture2DArray.prototype = Object.create( Texture.prototype );
		DataTexture2DArray.prototype.constructor = DataTexture2DArray;
		DataTexture2DArray.prototype.isDataTexture2DArray = true;

		/**
		 * @author Artur Trzesiok
		 */

		function DataTexture3D( data, width, height, depth ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	var texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			Texture.call( this, null );

			this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;


		}

		DataTexture3D.prototype = Object.create( Texture.prototype );
		DataTexture3D.prototype.constructor = DataTexture3D;
		DataTexture3D.prototype.isDataTexture3D = true;

		/**
		 * @author tschw
		 * @author Mugen87 / https://github.com/Mugen87
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [textures] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'textures' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (textures factorizations):
		 *
		 * .upload( gl, seq, values, textures )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (textures factorizations):
		 *
		 * .setValue( gl, name, value, textures )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */

		var emptyTexture = new Texture();
		var emptyTexture2dArray = new DataTexture2DArray();
		var emptyTexture3d = new DataTexture3D();
		var emptyCubeTexture = new CubeTexture();

		// --- Utilities ---

		// Array Caches (provide typed arrays for temporary by size)

		var arrayCacheF32 = [];
		var arrayCacheI32 = [];

		// Float32Array caches used for uploading Matrix uniforms

		var mat4array = new Float32Array( 16 );
		var mat3array = new Float32Array( 9 );
		var mat2array = new Float32Array( 4 );

		// Flattening for arrays of vectors and matrices

		function flatten( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) { return array; }
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		}

		function arraysEqual( a, b ) {

			if ( a.length !== b.length ) { return false; }

			for ( var i = 0, l = a.length; i < l; i ++ ) {

				if ( a[ i ] !== b[ i ] ) { return false; }

			}

			return true;

		}

		function copyArray( a, b ) {

			for ( var i = 0, l = b.length; i < l; i ++ ) {

				a[ i ] = b[ i ];

			}

		}

		// Texture unit allocation

		function allocTexUnits( textures, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				{ r[ i ] = textures.allocateTextureUnit(); }

			return r;

		}

		// --- Setters ---

		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.

		// Single scalar

		function setValueV1f( gl, v ) {

			var cache = this.cache;

			if ( cache[ 0 ] === v ) { return; }

			gl.uniform1f( this.addr, v );

			cache[ 0 ] = v;

		}

		// Single float vector (from flat array or THREE.VectorN)

		function setValueV2f( gl, v ) {

			var cache = this.cache;

			if ( v.x !== undefined ) {

				if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

					gl.uniform2f( this.addr, v.x, v.y );

					cache[ 0 ] = v.x;
					cache[ 1 ] = v.y;

				}

			} else {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniform2fv( this.addr, v );

				copyArray( cache, v );

			}

		}

		function setValueV3f( gl, v ) {

			var cache = this.cache;

			if ( v.x !== undefined ) {

				if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

					gl.uniform3f( this.addr, v.x, v.y, v.z );

					cache[ 0 ] = v.x;
					cache[ 1 ] = v.y;
					cache[ 2 ] = v.z;

				}

			} else if ( v.r !== undefined ) {

				if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

					gl.uniform3f( this.addr, v.r, v.g, v.b );

					cache[ 0 ] = v.r;
					cache[ 1 ] = v.g;
					cache[ 2 ] = v.b;

				}

			} else {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniform3fv( this.addr, v );

				copyArray( cache, v );

			}

		}

		function setValueV4f( gl, v ) {

			var cache = this.cache;

			if ( v.x !== undefined ) {

				if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

					gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

					cache[ 0 ] = v.x;
					cache[ 1 ] = v.y;
					cache[ 2 ] = v.z;
					cache[ 3 ] = v.w;

				}

			} else {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniform4fv( this.addr, v );

				copyArray( cache, v );

			}

		}

		// Single matrix (from flat array or MatrixN)

		function setValueM2( gl, v ) {

			var cache = this.cache;
			var elements = v.elements;

			if ( elements === undefined ) {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniformMatrix2fv( this.addr, false, v );

				copyArray( cache, v );

			} else {

				if ( arraysEqual( cache, elements ) ) { return; }

				mat2array.set( elements );

				gl.uniformMatrix2fv( this.addr, false, mat2array );

				copyArray( cache, elements );

			}

		}

		function setValueM3( gl, v ) {

			var cache = this.cache;
			var elements = v.elements;

			if ( elements === undefined ) {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniformMatrix3fv( this.addr, false, v );

				copyArray( cache, v );

			} else {

				if ( arraysEqual( cache, elements ) ) { return; }

				mat3array.set( elements );

				gl.uniformMatrix3fv( this.addr, false, mat3array );

				copyArray( cache, elements );

			}

		}

		function setValueM4( gl, v ) {

			var cache = this.cache;
			var elements = v.elements;

			if ( elements === undefined ) {

				if ( arraysEqual( cache, v ) ) { return; }

				gl.uniformMatrix4fv( this.addr, false, v );

				copyArray( cache, v );

			} else {

				if ( arraysEqual( cache, elements ) ) { return; }

				mat4array.set( elements );

				gl.uniformMatrix4fv( this.addr, false, mat4array );

				copyArray( cache, elements );

			}

		}

		// Single texture (2D / Cube)

		function setValueT1( gl, v, textures ) {

			var cache = this.cache;
			var unit = textures.allocateTextureUnit();

			if ( cache[ 0 ] !== unit ) {

				gl.uniform1i( this.addr, unit );
				cache[ 0 ] = unit;

			}

			textures.safeSetTexture2D( v || emptyTexture, unit );

		}

		function setValueT2DArray1( gl, v, textures ) {

			var cache = this.cache;
			var unit = textures.allocateTextureUnit();

			if ( cache[ 0 ] !== unit ) {

				gl.uniform1i( this.addr, unit );
				cache[ 0 ] = unit;

			}

			textures.setTexture2DArray( v || emptyTexture2dArray, unit );

		}

		function setValueT3D1( gl, v, textures ) {

			var cache = this.cache;
			var unit = textures.allocateTextureUnit();

			if ( cache[ 0 ] !== unit ) {

				gl.uniform1i( this.addr, unit );
				cache[ 0 ] = unit;

			}

			textures.setTexture3D( v || emptyTexture3d, unit );

		}

		function setValueT6( gl, v, textures ) {

			var cache = this.cache;
			var unit = textures.allocateTextureUnit();

			if ( cache[ 0 ] !== unit ) {

				gl.uniform1i( this.addr, unit );
				cache[ 0 ] = unit;

			}

			textures.safeSetTextureCube( v || emptyCubeTexture, unit );

		}

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		function setValueV1i( gl, v ) {

			var cache = this.cache;

			if ( cache[ 0 ] === v ) { return; }

			gl.uniform1i( this.addr, v );

			cache[ 0 ] = v;

		}

		function setValueV2i( gl, v ) {

			var cache = this.cache;

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform2iv( this.addr, v );

			copyArray( cache, v );

		}

		function setValueV3i( gl, v ) {

			var cache = this.cache;

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform3iv( this.addr, v );

			copyArray( cache, v );

		}

		function setValueV4i( gl, v ) {

			var cache = this.cache;

			if ( arraysEqual( cache, v ) ) { return; }

			gl.uniform4iv( this.addr, v );

			copyArray( cache, v );

		}

		// uint

		function setValueV1ui( gl, v ) {

			var cache = this.cache;

			if ( cache[ 0 ] === v ) { return; }

			gl.uniform1ui( this.addr, v );

			cache[ 0 ] = v;

		}

		// Helper to pick the right setter for the singular case

		function getSingularSetter( type ) {

			switch ( type ) {

				case 0x1406: return setValueV1f; // FLOAT
				case 0x8b50: return setValueV2f; // _VEC2
				case 0x8b51: return setValueV3f; // _VEC3
				case 0x8b52: return setValueV4f; // _VEC4

				case 0x8b5a: return setValueM2; // _MAT2
				case 0x8b5b: return setValueM3; // _MAT3
				case 0x8b5c: return setValueM4; // _MAT4

				case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
				case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
				case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

				case 0x1405: return setValueV1ui; // UINT

				case 0x8b5e: // SAMPLER_2D
				case 0x8d66: // SAMPLER_EXTERNAL_OES
				case 0x8dca: // INT_SAMPLER_2D
				case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
				case 0x8b62: // SAMPLER_2D_SHADOW
					return setValueT1;

				case 0x8b5f: // SAMPLER_3D
				case 0x8dcb: // INT_SAMPLER_3D
				case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
					return setValueT3D1;

				case 0x8b60: // SAMPLER_CUBE
				case 0x8dcc: // INT_SAMPLER_CUBE
				case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
				case 0x8dc5: // SAMPLER_CUBE_SHADOW
					return setValueT6;

				case 0x8dc1: // SAMPLER_2D_ARRAY
				case 0x8dcf: // INT_SAMPLER_2D_ARRAY
				case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
				case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
					return setValueT2DArray1;

			}

		}

		// Array of scalars
		function setValueV1fArray( gl, v ) {

			gl.uniform1fv( this.addr, v );

		}

		// Integer / Boolean vectors or arrays thereof (always flat arrays)
		function setValueV1iArray( gl, v ) {

			gl.uniform1iv( this.addr, v );

		}

		function setValueV2iArray( gl, v ) {

			gl.uniform2iv( this.addr, v );

		}

		function setValueV3iArray( gl, v ) {

			gl.uniform3iv( this.addr, v );

		}

		function setValueV4iArray( gl, v ) {

			gl.uniform4iv( this.addr, v );

		}


		// Array of vectors (flat or from THREE classes)

		function setValueV2fArray( gl, v ) {

			var data = flatten( v, this.size, 2 );

			gl.uniform2fv( this.addr, data );

		}

		function setValueV3fArray( gl, v ) {

			var data = flatten( v, this.size, 3 );

			gl.uniform3fv( this.addr, data );

		}

		function setValueV4fArray( gl, v ) {

			var data = flatten( v, this.size, 4 );

			gl.uniform4fv( this.addr, data );

		}

		// Array of matrices (flat or from THREE clases)

		function setValueM2Array( gl, v ) {

			var data = flatten( v, this.size, 4 );

			gl.uniformMatrix2fv( this.addr, false, data );

		}

		function setValueM3Array( gl, v ) {

			var data = flatten( v, this.size, 9 );

			gl.uniformMatrix3fv( this.addr, false, data );

		}

		function setValueM4Array( gl, v ) {

			var data = flatten( v, this.size, 16 );

			gl.uniformMatrix4fv( this.addr, false, data );

		}

		// Array of textures (2D / Cube)

		function setValueT1Array( gl, v, textures ) {

			var n = v.length;

			var units = allocTexUnits( textures, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

			}

		}

		function setValueT6Array( gl, v, textures ) {

			var n = v.length;

			var units = allocTexUnits( textures, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

			}

		}

		// Helper to pick the right setter for a pure (bottom-level) array

		function getPureArraySetter( type ) {

			switch ( type ) {

				case 0x1406: return setValueV1fArray; // FLOAT
				case 0x8b50: return setValueV2fArray; // _VEC2
				case 0x8b51: return setValueV3fArray; // _VEC3
				case 0x8b52: return setValueV4fArray; // _VEC4

				case 0x8b5a: return setValueM2Array; // _MAT2
				case 0x8b5b: return setValueM3Array; // _MAT3
				case 0x8b5c: return setValueM4Array; // _MAT4

				case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
				case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
				case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

				case 0x8b5e: // SAMPLER_2D
				case 0x8d66: // SAMPLER_EXTERNAL_OES
				case 0x8dca: // INT_SAMPLER_2D
				case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
				case 0x8b62: // SAMPLER_2D_SHADOW
					return setValueT1Array;

				case 0x8b60: // SAMPLER_CUBE
				case 0x8dcc: // INT_SAMPLER_CUBE
				case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
				case 0x8dc5: // SAMPLER_CUBE_SHADOW
					return setValueT6Array;

			}

		}

		// --- Uniform Classes ---

		function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function PureArrayUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		PureArrayUniform.prototype.updateCache = function ( data ) {

			var cache = this.cache;

			if ( data instanceof Float32Array && cache.length !== data.length ) {

				this.cache = new Float32Array( data.length );

			}

			copyArray( cache, data );

		};

		function StructuredUniform( id ) {

			this.id = id;

			this.seq = [];
			this.map = {};

		}

		StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

			var seq = this.seq;

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				u.setValue( gl, value[ u.id ], textures );

			}

		};

		// --- Top-level ---

		// Parser - builds up the property tree from the path strings

		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		function addUniform( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		}

		function parseUniform( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			while ( true ) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) { id = id | 0; } // convert to integer

				if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
						new SingleUniform( id, activeInfo, addr ) :
						new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {

					// step into inner node / create it in case it doesn't exist

					var map = container.map, next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		}

		// Root Container

		function WebGLUniforms( gl, program ) {

			this.seq = [];
			this.map = {};

			var n = gl.getProgramParameter( program, 35718 );

			for ( var i = 0; i < n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					addr = gl.getUniformLocation( program, info.name );

				parseUniform( info, addr, this );

			}

		}

		WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

			var u = this.map[ name ];

			if ( u !== undefined ) { u.setValue( gl, value, textures ); }

		};

		WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

			var v = object[ name ];

			if ( v !== undefined ) { this.setValue( gl, name, v ); }

		};


		// Static interface

		WebGLUniforms.upload = function ( gl, seq, values, textures ) {

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {

					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, textures );

				}

			}

		};

		WebGLUniforms.seqWithValue = function ( seq, values ) {

			var r = [];

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				if ( u.id in values ) { r.push( u ); }

			}

			return r;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			return shader;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var programIdCount = 0;

		function addLineNumbers( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		}

		function getEncodingComponents( encoding ) {

			switch ( encoding ) {

				case LinearEncoding:
					return [ 'Linear', '( value )' ];
				case sRGBEncoding:
					return [ 'sRGB', '( value )' ];
				case RGBEEncoding:
					return [ 'RGBE', '( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM', '( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM', '( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD', '( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
				case LogLuvEncoding:
					return [ 'LogLuv', '( value )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );

			}

		}

		function getShaderErrors( gl, shader, type ) {

			var status = gl.getShaderParameter( shader, 35713 );
			var log = gl.getShaderInfoLog( shader ).trim();

			if ( status && log === '' ) { return ''; }

			// --enable-privileged-webgl-extension
			// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			var source = gl.getShaderSource( shader );

			return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

		}

		function getTexelDecodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

		}

		function getTexelEncodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

		}

		function getToneMappingFunction( functionName, toneMapping ) {

			var toneMappingName;

			switch ( toneMapping ) {

				case LinearToneMapping:
					toneMappingName = 'Linear';
					break;

				case ReinhardToneMapping:
					toneMappingName = 'Reinhard';
					break;

				case Uncharted2ToneMapping:
					toneMappingName = 'Uncharted2';
					break;

				case CineonToneMapping:
					toneMappingName = 'OptimizedCineon';
					break;

				case ACESFilmicToneMapping:
					toneMappingName = 'ACESFilmic';
					break;

				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );

			}

			return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

		}

		function generateExtensions( parameters ) {

			var chunks = [
				( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
				( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
			];

			return chunks.filter( filterEmptyLine ).join( '\n' );

		}

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) { continue; }

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchAttributeLocations( gl, program ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, 35721 );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		function replaceLightNums( string, parameters ) {

			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
				.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
				.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
				.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

		}

		function replaceClippingPlaneNums( string, parameters ) {

			return string
				.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
				.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

		}

		// Resolve Includes

		var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

		function resolveIncludes( string ) {

			return string.replace( includePattern, includeReplacer );

		}

		function includeReplacer( match, include ) {

			var string = ShaderChunk[ include ];

			if ( string === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return resolveIncludes( string );

		}

		// Unroll Loops

		var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
		var unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

		function unrollLoops( string ) {

			return string
				.replace( unrollLoopPattern, loopReplacer )
				.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

		}

		function deprecatedLoopReplacer( match, start, end, snippet ) {

			console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
			return loopReplacer( match, start, end, snippet );

		}

		function loopReplacer( match, start, end, snippet ) {

			var string = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				string += snippet
					.replace( /\[ i \]/g, '[ ' + i + ' ]' )
					.replace( /UNROLLED_LOOP_INDEX/g, i );

			}

			return string;

		}

		//

		function generatePrecision( parameters ) {

			var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

			if ( parameters.precision === "highp" ) {

				precisionstring += "\n#define HIGH_PRECISION";

			} else if ( parameters.precision === "mediump" ) {

				precisionstring += "\n#define MEDIUM_PRECISION";

			} else if ( parameters.precision === "lowp" ) {

				precisionstring += "\n#define LOW_PRECISION";

			}

			return precisionstring;

		}

		function generateShadowMapTypeDefine( parameters ) {

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			} else if ( parameters.shadowMapType === VSMShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

			}

			return shadowMapTypeDefine;

		}

		function generateEnvMapTypeDefine( parameters ) {

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

			if ( parameters.envMap ) {

				switch ( parameters.envMapMode ) {

					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;

					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

			}

			return envMapTypeDefine;

		}

		function generateEnvMapModeDefine( parameters ) {

			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

			if ( parameters.envMap ) {

				switch ( parameters.envMapMode ) {

					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

			}

			return envMapModeDefine;

		}

		function generateEnvMapBlendingDefine( parameters ) {

			var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

			if ( parameters.envMap ) {

				switch ( parameters.combine ) {

					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			return envMapBlendingDefine;

		}

		function WebGLProgram( renderer, cacheKey, parameters ) {

			var gl = renderer.getContext();

			var defines = parameters.defines;

			var vertexShader = parameters.vertexShader;
			var fragmentShader = parameters.fragmentShader;
			var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
			var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
			var envMapModeDefine = generateEnvMapModeDefine( parameters );
			var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

			var customDefines = generateDefines( defines );

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( parameters.isRawShaderMaterial ) {

				prefixVertex = [

					customDefines

				].filter( filterEmptyLine ).join( '\n' );

				if ( prefixVertex.length > 0 ) {

					prefixVertex += '\n';

				}

				prefixFragment = [

					customExtensions,
					customDefines

				].filter( filterEmptyLine ).join( '\n' );

				if ( prefixFragment.length > 0 ) {

					prefixFragment += '\n';

				}

			} else {

				prefixVertex = [

					generatePrecision( parameters ),

					'#define SHADER_NAME ' + parameters.shaderName,

					customDefines,

					parameters.instancing ? '#define USE_INSTANCING' : '',
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_BONES ' + parameters.maxBones,
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
					( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

					parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
					parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
					parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

					parameters.vertexTangents ? '#define USE_TANGENT' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
					parameters.vertexUvs ? '#define USE_UV' : '',
					parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
					'uniform bool isOrthographic;',

					'#ifdef USE_INSTANCING',

					' attribute mat4 instanceMatrix;',

					'#endif',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_TANGENT',

					'	attribute vec4 tangent;',

					'#endif',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,

					generatePrecision( parameters ),

					'#define SHADER_NAME ' + parameters.shaderName,

					customDefines,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.matcap ? '#define USE_MATCAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
					( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
					parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
					parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
					parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

					parameters.sheen ? '#define USE_SHEEN' : '',

					parameters.vertexTangents ? '#define USE_TANGENT' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
					parameters.vertexUvs ? '#define USE_UV' : '',
					parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

					parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

					parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
					'uniform bool isOrthographic;',

					( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

					parameters.dithering ? '#define DITHERING' : '',

					( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?
						ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

					parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			vertexShader = resolveIncludes( vertexShader );
			vertexShader = replaceLightNums( vertexShader, parameters );
			vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

			fragmentShader = resolveIncludes( fragmentShader );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
			fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

			vertexShader = unrollLoops( vertexShader );
			fragmentShader = unrollLoops( fragmentShader );

			if ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {

				var isGLSL3ShaderMaterial = false;

				var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

				if ( parameters.isShaderMaterial &&
					vertexShader.match( versionRegex ) !== null &&
					fragmentShader.match( versionRegex ) !== null ) {

					isGLSL3ShaderMaterial = true;

					vertexShader = vertexShader.replace( versionRegex, '' );
					fragmentShader = fragmentShader.replace( versionRegex, '' );

				}

				// GLSL 3.0 conversion

				prefixVertex = [
					'#version 300 es\n',
					'#define attribute in',
					'#define varying out',
					'#define texture2D texture'
				].join( '\n' ) + '\n' + prefixVertex;

				prefixFragment = [
					'#version 300 es\n',
					'#define varying in',
					isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
					isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
					'#define gl_FragDepthEXT gl_FragDepth',
					'#define texture2D texture',
					'#define textureCube texture',
					'#define texture2DProj textureProj',
					'#define texture2DLodEXT textureLod',
					'#define texture2DProjLodEXT textureProjLod',
					'#define textureCubeLodEXT textureLod',
					'#define texture2DGradEXT textureGrad',
					'#define texture2DProjGradEXT textureProjGrad',
					'#define textureCubeGradEXT textureGrad'
				].join( '\n' ) + '\n' + prefixFragment;

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );

			var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( parameters.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			// check for link errors
			if ( renderer.debug.checkShaderErrors ) {

				var programLog = gl.getProgramInfoLog( program ).trim();
				var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
				var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

				var runnable = true;
				var haveDiagnostics = true;

				if ( gl.getProgramParameter( program, 35714 ) === false ) {

					runnable = false;

					var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
					var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

				} else if ( programLog !== '' ) {

					console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

				} else if ( vertexLog === '' || fragmentLog === '' ) {

					haveDiagnostics = false;

				}

				if ( haveDiagnostics ) {

					this.diagnostics = {

						runnable: runnable,

						programLog: programLog,

						vertexShader: {

							log: vertexLog,
							prefix: prefixVertex

						},

						fragmentShader: {

							log: fragmentLog,
							prefix: prefixFragment

						}

					};

				}

			}

			// clean up

			gl.detachShader( program, glVertexShader );
			gl.detachShader( program, glFragmentShader );

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function () {

				if ( cachedUniforms === undefined ) {

					cachedUniforms = new WebGLUniforms( gl, program );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function () {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function () {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			//

			this.name = parameters.shaderName;
			this.id = programIdCount ++;
			this.cacheKey = cacheKey;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLPrograms( renderer, extensions, capabilities ) {

			var programs = [];

			var isWebGL2 = capabilities.isWebGL2;
			var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
			var floatVertexTextures = capabilities.floatVertexTextures;
			var precision = capabilities.precision;
			var maxVertexUniforms = capabilities.maxVertexUniforms;
			var vertexTextures = capabilities.vertexTextures;

			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshDistanceMaterial: 'distanceRGBA',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'toon',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				MeshMatcapMaterial: 'matcap',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points',
				ShadowMaterial: 'shadow',
				SpriteMaterial: 'sprite'
			};

			var parameterNames = [
				"precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",
				"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
				"lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap", "gradientMap",
				"alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
				"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
				"sheen"
			];

			function getShaderObject( material, shaderID ) {

				var shaderobject;

				if ( shaderID ) {

					var shader = ShaderLib[ shaderID ];

					shaderobject = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					shaderobject = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				return shaderobject;

			}

			function allocateBones( object ) {

				var skeleton = object.skeleton;
				var bones = skeleton.bones;

				if ( floatVertexTextures ) {

					return 1024;

				} else {

					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)

					var nVertexUniforms = maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

					var maxBones = Math.min( nVertexMatrices, bones.length );

					if ( maxBones < bones.length ) {

						console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
						return 0;

					}

					return maxBones;

				}

			}

			function getTextureEncodingFromMap( map ) {

				var encoding;

				if ( ! map ) {

					encoding = LinearEncoding;

				} else if ( map.isTexture ) {

					encoding = map.encoding;

				} else if ( map.isWebGLRenderTarget ) {

					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;

				}

				return encoding;

			}

			this.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {

				var fog = scene.fog;
				var environment = material.isMeshStandardMaterial ? scene.environment : null;

				var envMap = material.envMap || environment;

				var shaderID = shaderIDs[ material.type ];

				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)

				var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;

				if ( material.precision !== null ) {

					precision = capabilities.getMaxPrecision( material.precision );

					if ( precision !== material.precision ) {

						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

					}

				}

				var shaderobject = getShaderObject( material, shaderID );
				material.onBeforeCompile( shaderobject, renderer );

				var currentRenderTarget = renderer.getRenderTarget();

				var parameters = {

					isWebGL2: isWebGL2,

					shaderID: shaderID,
					shaderName: shaderobject.name,

					uniforms: shaderobject.uniforms,
					vertexShader: shaderobject.vertexShader,
					fragmentShader: shaderobject.fragmentShader,
					defines: material.defines,

					isRawShaderMaterial: material.isRawShaderMaterial,
					isShaderMaterial: material.isShaderMaterial,

					precision: precision,

					instancing: object.isInstancedMesh === true,

					supportsVertexTextures: vertexTextures,
					outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map ),
					matcap: !! material.matcap,
					matcapEncoding: getTextureEncodingFromMap( material.matcap ),
					envMap: !! envMap,
					envMapMode: envMap && envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( envMap ),
					envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
					tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
					clearcoatMap: !! material.clearcoatMap,
					clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
					clearcoatNormalMap: !! material.clearcoatNormalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,

					gradientMap: !! material.gradientMap,

					sheen: !! material.sheen,

					combine: material.combine,

					vertexTangents: ( material.normalMap && material.vertexTangents ),
					vertexColors: material.vertexColors,
					vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,
					uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,

					fog: !! fog,
					useFog: material.fog,
					fogExp2: ( fog && fog.isFogExp2 ),

					flatShading: material.flatShading,

					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: logarithmicDepthBuffer,

					skinning: material.skinning && maxBones > 0,
					maxBones: maxBones,
					useVertexTexture: floatVertexTextures,

					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,

					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numRectAreaLights: lights.rectArea.length,
					numHemiLights: lights.hemi.length,

					numDirLightShadows: lights.directionalShadowMap.length,
					numPointLightShadows: lights.pointShadowMap.length,
					numSpotLightShadows: lights.spotShadowMap.length,

					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,

					dithering: material.dithering,

					shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,

					toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,

					premultipliedAlpha: material.premultipliedAlpha,

					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,

					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

					index0AttributeName: material.index0AttributeName,

					extensionDerivatives: material.extensions && material.extensions.derivatives,
					extensionFragDepth: material.extensions && material.extensions.fragDepth,
					extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
					extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

					rendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,
					rendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,
					rendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,

					onBeforeCompile: material.onBeforeCompile

				};

				return parameters;

			};

			this.getProgramCacheKey = function ( parameters ) {

				var array = [];

				if ( parameters.shaderID ) {

					array.push( parameters.shaderID );

				} else {

					array.push( parameters.fragmentShader );
					array.push( parameters.vertexShader );

				}

				if ( parameters.defines !== undefined ) {

					for ( var name in parameters.defines ) {

						array.push( name );
						array.push( parameters.defines[ name ] );

					}

				}

				if ( parameters.isRawShaderMaterial === undefined ) {

					for ( var i = 0; i < parameterNames.length; i ++ ) {

						array.push( parameters[ parameterNames[ i ] ] );

					}

					array.push( renderer.outputEncoding );
					array.push( renderer.gammaFactor );

				}

				array.push( parameters.onBeforeCompile.toString() );

				return array.join();

			};

			this.acquireProgram = function ( parameters, cacheKey ) {

				var program;

				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

					var preexistingProgram = programs[ p ];

					if ( preexistingProgram.cacheKey === cacheKey ) {

						program = preexistingProgram;
						++ program.usedTimes;

						break;

					}

				}

				if ( program === undefined ) {

					program = new WebGLProgram( renderer, cacheKey, parameters );
					programs.push( program );

				}

				return program;

			};

			this.releaseProgram = function ( program ) {

				if ( -- program.usedTimes === 0 ) {

					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();

					// Free WebGL resources
					program.destroy();

				}

			};

			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;

		}

		/**
		 * @author fordacious / fordacious.github.io
		 */

		function WebGLProperties() {

			var properties = new WeakMap();

			function get( object ) {

				var map = properties.get( object );

				if ( map === undefined ) {

					map = {};
					properties.set( object, map );

				}

				return map;

			}

			function remove( object ) {

				properties.delete( object );

			}

			function update( object, key, value ) {

				properties.get( object )[ key ] = value;

			}

			function dispose() {

				properties = new WeakMap();

			}

			return {
				get: get,
				remove: remove,
				update: update,
				dispose: dispose
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function painterSortStable( a, b ) {

			if ( a.groupOrder !== b.groupOrder ) {

				return a.groupOrder - b.groupOrder;

			} else if ( a.renderOrder !== b.renderOrder ) {

				return a.renderOrder - b.renderOrder;

			} else if ( a.program !== b.program ) {

				return a.program.id - b.program.id;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable( a, b ) {

			if ( a.groupOrder !== b.groupOrder ) {

				return a.groupOrder - b.groupOrder;

			} else if ( a.renderOrder !== b.renderOrder ) {

				return a.renderOrder - b.renderOrder;

			} else if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}


		function WebGLRenderList() {

			var renderItems = [];
			var renderItemsIndex = 0;

			var opaque = [];
			var transparent = [];

			var defaultProgram = { id: - 1 };

			function init() {

				renderItemsIndex = 0;

				opaque.length = 0;
				transparent.length = 0;

			}

			function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

				var renderItem = renderItems[ renderItemsIndex ];

				if ( renderItem === undefined ) {

					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						program: material.program || defaultProgram,
						groupOrder: groupOrder,
						renderOrder: object.renderOrder,
						z: z,
						group: group
					};

					renderItems[ renderItemsIndex ] = renderItem;

				} else {

					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.program = material.program || defaultProgram;
					renderItem.groupOrder = groupOrder;
					renderItem.renderOrder = object.renderOrder;
					renderItem.z = z;
					renderItem.group = group;

				}

				renderItemsIndex ++;

				return renderItem;

			}

			function push( object, geometry, material, groupOrder, z, group ) {

				var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

				( material.transparent === true ? transparent : opaque ).push( renderItem );

			}

			function unshift( object, geometry, material, groupOrder, z, group ) {

				var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

				( material.transparent === true ? transparent : opaque ).unshift( renderItem );

			}

			function sort( customOpaqueSort, customTransparentSort ) {

				if ( opaque.length > 1 ) { opaque.sort( customOpaqueSort || painterSortStable ); }
				if ( transparent.length > 1 ) { transparent.sort( customTransparentSort || reversePainterSortStable ); }

			}

			function finish() {

				// Clear references from inactive renderItems in the list

				for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

					var renderItem = renderItems[ i ];

					if ( renderItem.id === null ) { break; }

					renderItem.id = null;
					renderItem.object = null;
					renderItem.geometry = null;
					renderItem.material = null;
					renderItem.program = null;
					renderItem.group = null;

				}

			}

			return {
				opaque: opaque,
				transparent: transparent,

				init: init,
				push: push,
				unshift: unshift,
				finish: finish,

				sort: sort
			};

		}

		function WebGLRenderLists() {

			var lists = new WeakMap();

			function onSceneDispose( event ) {

				var scene = event.target;

				scene.removeEventListener( 'dispose', onSceneDispose );

				lists.delete( scene );

			}

			function get( scene, camera ) {

				var cameras = lists.get( scene );
				var list;
				if ( cameras === undefined ) {

					list = new WebGLRenderList();
					lists.set( scene, new WeakMap() );
					lists.get( scene ).set( camera, list );

					scene.addEventListener( 'dispose', onSceneDispose );

				} else {

					list = cameras.get( camera );
					if ( list === undefined ) {

						list = new WebGLRenderList();
						cameras.set( camera, list );

					}

				}

				return list;

			}

			function dispose() {

				lists = new WeakMap();

			}

			return {
				get: get,
				dispose: dispose
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function UniformsCache() {

			var lights = {};

			return {

				get: function ( light ) {

					if ( lights[ light.id ] !== undefined ) {

						return lights[ light.id ];

					}

					var uniforms;

					switch ( light.type ) {

						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color()
							};
							break;

						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0
							};
							break;

						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0
							};
							break;

						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;

						case 'RectAreaLight':
							uniforms = {
								color: new Color(),
								position: new Vector3(),
								halfWidth: new Vector3(),
								halfHeight: new Vector3()
							};
							break;

					}

					lights[ light.id ] = uniforms;

					return uniforms;

				}

			};

		}

		function ShadowUniformsCache() {

			var lights = {};

			return {

				get: function ( light ) {

					if ( lights[ light.id ] !== undefined ) {

						return lights[ light.id ];

					}

					var uniforms;

					switch ( light.type ) {

						case 'DirectionalLight':
							uniforms = {
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'SpotLight':
							uniforms = {
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'PointLight':
							uniforms = {
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2(),
								shadowCameraNear: 1,
								shadowCameraFar: 1000
							};
							break;

						// TODO (abelnation): set RectAreaLight shadow uniforms

					}

					lights[ light.id ] = uniforms;

					return uniforms;

				}

			};

		}



		var nextVersion = 0;

		function shadowCastingLightsFirst( lightA, lightB ) {

			return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

		}

		function WebGLLights() {

			var cache = new UniformsCache();

			var shadowCache = ShadowUniformsCache();

			var state = {

				version: 0,

				hash: {
					directionalLength: - 1,
					pointLength: - 1,
					spotLength: - 1,
					rectAreaLength: - 1,
					hemiLength: - 1,

					numDirectionalShadows: - 1,
					numPointShadows: - 1,
					numSpotShadows: - 1
				},

				ambient: [ 0, 0, 0 ],
				probe: [],
				directional: [],
				directionalShadow: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadow: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadow: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: []

			};

			for ( var i = 0; i < 9; i ++ ) { state.probe.push( new Vector3() ); }

			var vector3 = new Vector3();
			var matrix4 = new Matrix4();
			var matrix42 = new Matrix4();

			function setup( lights, shadows, camera ) {

				var r = 0, g = 0, b = 0;

				for ( var i = 0; i < 9; i ++ ) { state.probe[ i ].set( 0, 0, 0 ); }

				var directionalLength = 0;
				var pointLength = 0;
				var spotLength = 0;
				var rectAreaLength = 0;
				var hemiLength = 0;

				var numDirectionalShadows = 0;
				var numPointShadows = 0;
				var numSpotShadows = 0;

				var viewMatrix = camera.matrixWorldInverse;

				lights.sort( shadowCastingLightsFirst );

				for ( var i = 0, l = lights.length; i < l; i ++ ) {

					var light = lights[ i ];

					var color = light.color;
					var intensity = light.intensity;
					var distance = light.distance;

					var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

					if ( light.isAmbientLight ) {

						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;

					} else if ( light.isLightProbe ) {

						for ( var j = 0; j < 9; j ++ ) {

							state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

						}

					} else if ( light.isDirectionalLight ) {

						var uniforms = cache.get( light );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						if ( light.castShadow ) {

							var shadow = light.shadow;

							var shadowUniforms = shadowCache.get( light );

							shadowUniforms.shadowBias = shadow.bias;
							shadowUniforms.shadowRadius = shadow.radius;
							shadowUniforms.shadowMapSize = shadow.mapSize;

							state.directionalShadow[ directionalLength ] = shadowUniforms;
							state.directionalShadowMap[ directionalLength ] = shadowMap;
							state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

							numDirectionalShadows ++;

						}

						state.directional[ directionalLength ] = uniforms;

						directionalLength ++;

					} else if ( light.isSpotLight ) {

						var uniforms = cache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = light.decay;

						if ( light.castShadow ) {

							var shadow = light.shadow;

							var shadowUniforms = shadowCache.get( light );

							shadowUniforms.shadowBias = shadow.bias;
							shadowUniforms.shadowRadius = shadow.radius;
							shadowUniforms.shadowMapSize = shadow.mapSize;

							state.spotShadow[ spotLength ] = shadowUniforms;
							state.spotShadowMap[ spotLength ] = shadowMap;
							state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

							numSpotShadows ++;

						}

						state.spot[ spotLength ] = uniforms;

						spotLength ++;

					} else if ( light.isRectAreaLight ) {

						var uniforms = cache.get( light );

						// (a) intensity is the total visible light emitted
						//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

						// (b) intensity is the brightness of the light
						uniforms.color.copy( color ).multiplyScalar( intensity );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						// extract local rotation of light to derive width/height half vectors
						matrix42.identity();
						matrix4.copy( light.matrixWorld );
						matrix4.premultiply( viewMatrix );
						matrix42.extractRotation( matrix4 );

						uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
						uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

						uniforms.halfWidth.applyMatrix4( matrix42 );
						uniforms.halfHeight.applyMatrix4( matrix42 );

						// TODO (abelnation): RectAreaLight distance?
						// uniforms.distance = distance;

						state.rectArea[ rectAreaLength ] = uniforms;

						rectAreaLength ++;

					} else if ( light.isPointLight ) {

						var uniforms = cache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = light.decay;

						if ( light.castShadow ) {

							var shadow = light.shadow;

							var shadowUniforms = shadowCache.get( light );

							shadowUniforms.shadowBias = shadow.bias;
							shadowUniforms.shadowRadius = shadow.radius;
							shadowUniforms.shadowMapSize = shadow.mapSize;
							shadowUniforms.shadowCameraNear = shadow.camera.near;
							shadowUniforms.shadowCameraFar = shadow.camera.far;

							state.pointShadow[ pointLength ] = shadowUniforms;
							state.pointShadowMap[ pointLength ] = shadowMap;
							state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

							numPointShadows ++;

						}

						state.point[ pointLength ] = uniforms;

						pointLength ++;

					} else if ( light.isHemisphereLight ) {

						var uniforms = cache.get( light );

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();

						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

						state.hemi[ hemiLength ] = uniforms;

						hemiLength ++;

					}

				}

				state.ambient[ 0 ] = r;
				state.ambient[ 1 ] = g;
				state.ambient[ 2 ] = b;

				var hash = state.hash;

				if ( hash.directionalLength !== directionalLength ||
					hash.pointLength !== pointLength ||
					hash.spotLength !== spotLength ||
					hash.rectAreaLength !== rectAreaLength ||
					hash.hemiLength !== hemiLength ||
					hash.numDirectionalShadows !== numDirectionalShadows ||
					hash.numPointShadows !== numPointShadows ||
					hash.numSpotShadows !== numSpotShadows ) {

					state.directional.length = directionalLength;
					state.spot.length = spotLength;
					state.rectArea.length = rectAreaLength;
					state.point.length = pointLength;
					state.hemi.length = hemiLength;

					state.directionalShadow.length = numDirectionalShadows;
					state.directionalShadowMap.length = numDirectionalShadows;
					state.pointShadow.length = numPointShadows;
					state.pointShadowMap.length = numPointShadows;
					state.spotShadow.length = numSpotShadows;
					state.spotShadowMap.length = numSpotShadows;
					state.directionalShadowMatrix.length = numDirectionalShadows;
					state.pointShadowMatrix.length = numPointShadows;
					state.spotShadowMatrix.length = numSpotShadows;

					hash.directionalLength = directionalLength;
					hash.pointLength = pointLength;
					hash.spotLength = spotLength;
					hash.rectAreaLength = rectAreaLength;
					hash.hemiLength = hemiLength;

					hash.numDirectionalShadows = numDirectionalShadows;
					hash.numPointShadows = numPointShadows;
					hash.numSpotShadows = numSpotShadows;

					state.version = nextVersion ++;

				}

			}

			return {
				setup: setup,
				state: state
			};

		}

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function WebGLRenderState() {

			var lights = new WebGLLights();

			var lightsArray = [];
			var shadowsArray = [];

			function init() {

				lightsArray.length = 0;
				shadowsArray.length = 0;

			}

			function pushLight( light ) {

				lightsArray.push( light );

			}

			function pushShadow( shadowLight ) {

				shadowsArray.push( shadowLight );

			}

			function setupLights( camera ) {

				lights.setup( lightsArray, shadowsArray, camera );

			}

			var state = {
				lightsArray: lightsArray,
				shadowsArray: shadowsArray,

				lights: lights
			};

			return {
				init: init,
				state: state,
				setupLights: setupLights,

				pushLight: pushLight,
				pushShadow: pushShadow
			};

		}

		function WebGLRenderStates() {

			var renderStates = new WeakMap();

			function onSceneDispose( event ) {

				var scene = event.target;

				scene.removeEventListener( 'dispose', onSceneDispose );

				renderStates.delete( scene );

			}

			function get( scene, camera ) {

				var renderState;

				if ( renderStates.has( scene ) === false ) {

					renderState = new WebGLRenderState();
					renderStates.set( scene, new WeakMap() );
					renderStates.get( scene ).set( camera, renderState );

					scene.addEventListener( 'dispose', onSceneDispose );

				} else {

					if ( renderStates.get( scene ).has( camera ) === false ) {

						renderState = new WebGLRenderState();
						renderStates.get( scene ).set( camera, renderState );

					} else {

						renderState = renderStates.get( scene ).get( camera );

					}

				}

				return renderState;

			}

			function dispose() {

				renderStates = new WeakMap();

			}

			return {
				get: get,
				dispose: dispose
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshDepthMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.setValues( parameters );

		}

		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

		MeshDepthMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  referencePosition: <float>,
		 *  nearDistance: <float>,
		 *  farDistance: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>
		 *
		 * }
		 */

		function MeshDistanceMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshDistanceMaterial';

			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.fog = false;

			this.setValues( parameters );

		}

		MeshDistanceMaterial.prototype = Object.create( Material.prototype );
		MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

		MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

		MeshDistanceMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.referencePosition.copy( source.referencePosition );
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		};

		var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

		var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

			var _frustum = new Frustum(),

				_shadowMapSize = new Vector2(),
				_viewportSize = new Vector2(),

				_viewport = new Vector4(),

				_depthMaterials = [],
				_distanceMaterials = [],

				_materialCache = {};

			var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

			var shadowMaterialVertical = new ShaderMaterial( {

				defines: {
					SAMPLE_RATE: 2.0 / 8.0,
					HALF_SAMPLE_RATE: 1.0 / 8.0
				},

				uniforms: {
					shadow_pass: { value: null },
					resolution: { value: new Vector2() },
					radius: { value: 4.0 }
				},

				vertexShader: vsm_vert,

				fragmentShader: vsm_frag

			} );

			var shadowMaterialHorizonal = shadowMaterialVertical.clone();
			shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;

			var fullScreenTri = new BufferGeometry();
			fullScreenTri.setAttribute(
				"position",
				new BufferAttribute(
					new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
					3
				)
			);

			var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

			var scope = this;

			this.enabled = false;

			this.autoUpdate = true;
			this.needsUpdate = false;

			this.type = PCFShadowMap;

			this.render = function ( lights, scene, camera ) {

				if ( scope.enabled === false ) { return; }
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }

				if ( lights.length === 0 ) { return; }

				var currentRenderTarget = _renderer.getRenderTarget();
				var activeCubeFace = _renderer.getActiveCubeFace();
				var activeMipmapLevel = _renderer.getActiveMipmapLevel();

				var _state = _renderer.state;

				// Set GL state for depth map.
				_state.setBlending( NoBlending );
				_state.buffers.color.setClear( 1, 1, 1, 1 );
				_state.buffers.depth.setTest( true );
				_state.setScissorTest( false );

				// render depth map

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];
					var shadow = light.shadow;

					if ( shadow === undefined ) {

						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;

					}

					_shadowMapSize.copy( shadow.mapSize );

					var shadowFrameExtents = shadow.getFrameExtents();

					_shadowMapSize.multiply( shadowFrameExtents );

					_viewportSize.copy( shadow.mapSize );

					if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

						console.warn( 'THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing' );

						if ( _shadowMapSize.x > maxTextureSize ) {

							_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
							_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
							shadow.mapSize.x = _viewportSize.x;

						}

						if ( _shadowMapSize.y > maxTextureSize ) {

							_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
							_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
							shadow.mapSize.y = _viewportSize.y;

						}

					}

					if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

						var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
						shadow.map.texture.name = light.name + ".shadowMap";

						shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

						shadow.camera.updateProjectionMatrix();

					}

					if ( shadow.map === null ) {

						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
						shadow.map.texture.name = light.name + ".shadowMap";

						shadow.camera.updateProjectionMatrix();

					}

					_renderer.setRenderTarget( shadow.map );
					_renderer.clear();

					var viewportCount = shadow.getViewportCount();

					for ( var vp = 0; vp < viewportCount; vp ++ ) {

						var viewport = shadow.getViewport( vp );

						_viewport.set(
							_viewportSize.x * viewport.x,
							_viewportSize.y * viewport.y,
							_viewportSize.x * viewport.z,
							_viewportSize.y * viewport.w
						);

						_state.viewport( _viewport );

						shadow.updateMatrices( light, vp );

						_frustum = shadow.getFrustum();

						renderObject( scene, camera, shadow.camera, light, this.type );

					}

					// do blur pass for VSM

					if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

						VSMPass( shadow, camera );

					}

				}

				scope.needsUpdate = false;

				_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

			};

			function VSMPass( shadow, camera ) {

				var geometry = _objects.update( fullScreenMesh );

				// vertical pass

				shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
				shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
				shadowMaterialVertical.uniforms.radius.value = shadow.radius;
				_renderer.setRenderTarget( shadow.mapPass );
				_renderer.clear();
				_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

				// horizonal pass

				shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
				shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
				shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();
				_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );

			}

			function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

				var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

				var material = _depthMaterials[ index ];

				if ( material === undefined ) {

					material = new MeshDepthMaterial( {

						depthPacking: RGBADepthPacking,

						morphTargets: useMorphing,
						skinning: useSkinning

					} );

					_depthMaterials[ index ] = material;

				}

				return material;

			}

			function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

				var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

				var material = _distanceMaterials[ index ];

				if ( material === undefined ) {

					material = new MeshDistanceMaterial( {

						morphTargets: useMorphing,
						skinning: useSkinning

					} );

					_distanceMaterials[ index ] = material;

				}

				return material;

			}

			function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

				var geometry = object.geometry;

				var result = null;

				var getMaterialVariant = getDepthMaterialVariant;
				var customMaterial = object.customDepthMaterial;

				if ( light.isPointLight === true ) {

					getMaterialVariant = getDistanceMaterialVariant;
					customMaterial = object.customDistanceMaterial;

				}

				if ( customMaterial === undefined ) {

					var useMorphing = false;

					if ( material.morphTargets === true ) {

						if ( geometry.isBufferGeometry === true ) {

							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

						} else if ( geometry.isGeometry === true ) {

							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

						}

					}

					var useSkinning = false;

					if ( object.isSkinnedMesh === true ) {

						if ( material.skinning === true ) {

							useSkinning = true;

						} else {

							console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

						}

					}

					var useInstancing = object.isInstancedMesh === true;

					result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

				} else {

					result = customMaterial;

				}

				if ( _renderer.localClippingEnabled &&
						material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					var keyA = result.uuid, keyB = material.uuid;

					var materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					var cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

				result.visible = material.visible;
				result.wireframe = material.wireframe;

				if ( type === VSMShadowMap ) {

					result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

				} else {

					result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

				}

				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
				result.clipIntersection = material.clipIntersection;

				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;

				if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

					result.referencePosition.setFromMatrixPosition( light.matrixWorld );
					result.nearDistance = shadowCameraNear;
					result.farDistance = shadowCameraFar;

				}

				return result;

			}

			function renderObject( object, camera, shadowCamera, light, type ) {

				if ( object.visible === false ) { return; }

				var visible = object.layers.test( camera.layers );

				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

					if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

						object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						var geometry = _objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

								var group = groups[ k ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									var depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

									_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

								}

							}

						} else if ( material.visible ) {

							var depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					renderObject( children[ i ], camera, shadowCamera, light, type );

				}

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLState( gl, extensions, capabilities ) {

			var isWebGL2 = capabilities.isWebGL2;

			function ColorBuffer() {

				var locked = false;

				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4( 0, 0, 0, 0 );

				return {

					setMask: function ( colorMask ) {

						if ( currentColorMask !== colorMask && ! locked ) {

							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( r, g, b, a, premultipliedAlpha ) {

						if ( premultipliedAlpha === true ) {

							r *= a; g *= a; b *= a;

						}

						color.set( r, g, b, a );

						if ( currentColorClear.equals( color ) === false ) {

							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );

						}

					},

					reset: function () {

						locked = false;

						currentColorMask = null;
						currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

					}

				};

			}

			function DepthBuffer() {

				var locked = false;

				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;

				return {

					setTest: function ( depthTest ) {

						if ( depthTest ) {

							enable( 2929 );

						} else {

							disable( 2929 );

						}

					},

					setMask: function ( depthMask ) {

						if ( currentDepthMask !== depthMask && ! locked ) {

							gl.depthMask( depthMask );
							currentDepthMask = depthMask;

						}

					},

					setFunc: function ( depthFunc ) {

						if ( currentDepthFunc !== depthFunc ) {

							if ( depthFunc ) {

								switch ( depthFunc ) {

									case NeverDepth:

										gl.depthFunc( 512 );
										break;

									case AlwaysDepth:

										gl.depthFunc( 519 );
										break;

									case LessDepth:

										gl.depthFunc( 513 );
										break;

									case LessEqualDepth:

										gl.depthFunc( 515 );
										break;

									case EqualDepth:

										gl.depthFunc( 514 );
										break;

									case GreaterEqualDepth:

										gl.depthFunc( 518 );
										break;

									case GreaterDepth:

										gl.depthFunc( 516 );
										break;

									case NotEqualDepth:

										gl.depthFunc( 517 );
										break;

									default:

										gl.depthFunc( 515 );

								}

							} else {

								gl.depthFunc( 515 );

							}

							currentDepthFunc = depthFunc;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( depth ) {

						if ( currentDepthClear !== depth ) {

							gl.clearDepth( depth );
							currentDepthClear = depth;

						}

					},

					reset: function () {

						locked = false;

						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;

					}

				};

			}

			function StencilBuffer() {

				var locked = false;

				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;

				return {

					setTest: function ( stencilTest ) {

						if ( ! locked ) {

							if ( stencilTest ) {

								enable( 2960 );

							} else {

								disable( 2960 );

							}

						}

					},

					setMask: function ( stencilMask ) {

						if ( currentStencilMask !== stencilMask && ! locked ) {

							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;

						}

					},

					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {

							gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

							currentStencilFunc = stencilFunc;
							currentStencilRef = stencilRef;
							currentStencilFuncMask = stencilMask;

						}

					},

					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {

							gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

							currentStencilFail = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( stencil ) {

						if ( currentStencilClear !== stencil ) {

							gl.clearStencil( stencil );
							currentStencilClear = stencil;

						}

					},

					reset: function () {

						locked = false;

						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;

					}

				};

			}

			//

			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();

			var maxVertexAttributes = gl.getParameter( 34921 );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );

			var enabledCapabilities = {};

			var currentProgram = null;

			var currentBlendingEnabled = null;
			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;

			var currentFlipSided = null;
			var currentCullFace = null;

			var currentLineWidth = null;

			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;

			var maxTextures = gl.getParameter( 35661 );

			var lineWidthAvailable = false;
			var version = 0;
			var glVersion = gl.getParameter( 7938 );

			if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

				version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
				lineWidthAvailable = ( version >= 1.0 );

			} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

				version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
				lineWidthAvailable = ( version >= 2.0 );

			}

			var currentTextureSlot = null;
			var currentBoundTextures = {};

			var currentScissor = new Vector4();
			var currentViewport = new Vector4();

			function createTexture( type, target, count ) {

				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();

				gl.bindTexture( type, texture );
				gl.texParameteri( type, 10241, 9728 );
				gl.texParameteri( type, 10240, 9728 );

				for ( var i = 0; i < count; i ++ ) {

					gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

				}

				return texture;

			}

			var emptyTextures = {};
			emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
			emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

			// init

			colorBuffer.setClear( 0, 0, 0, 1 );
			depthBuffer.setClear( 1 );
			stencilBuffer.setClear( 0 );

			enable( 2929 );
			depthBuffer.setFunc( LessEqualDepth );

			setFlipSided( false );
			setCullFace( CullFaceBack );
			enable( 2884 );

			setBlending( NoBlending );

			//

			function initAttributes() {

				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

					newAttributes[ i ] = 0;

				}

			}

			function enableAttribute( attribute ) {

				enableAttributeAndDivisor( attribute, 0 );

			}

			function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

					var extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

					extension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;

				}

			}

			function disableUnusedAttributes() {

				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

			}

			function enable( id ) {

				if ( enabledCapabilities[ id ] !== true ) {

					gl.enable( id );
					enabledCapabilities[ id ] = true;

				}

			}

			function disable( id ) {

				if ( enabledCapabilities[ id ] !== false ) {

					gl.disable( id );
					enabledCapabilities[ id ] = false;

				}

			}

			function useProgram( program ) {

				if ( currentProgram !== program ) {

					gl.useProgram( program );

					currentProgram = program;

					return true;

				}

				return false;

			}

			var equationToGL = {};
			equationToGL[ AddEquation ] = 32774;
			equationToGL[ SubtractEquation ] = 32778;
			equationToGL[ ReverseSubtractEquation ] = 32779;

			if ( isWebGL2 ) {

				equationToGL[ MinEquation ] = 32775;
				equationToGL[ MaxEquation ] = 32776;

			} else {

				var extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					equationToGL[ MinEquation ] = extension.MIN_EXT;
					equationToGL[ MaxEquation ] = extension.MAX_EXT;

				}

			}

			var factorToGL = {};
			factorToGL[ ZeroFactor ] = 0;
			factorToGL[ OneFactor ] = 1;
			factorToGL[ SrcColorFactor ] = 768;
			factorToGL[ SrcAlphaFactor ] = 770;
			factorToGL[ SrcAlphaSaturateFactor ] = 776;
			factorToGL[ DstColorFactor ] = 774;
			factorToGL[ DstAlphaFactor ] = 772;
			factorToGL[ OneMinusSrcColorFactor ] = 769;
			factorToGL[ OneMinusSrcAlphaFactor ] = 771;
			factorToGL[ OneMinusDstColorFactor ] = 775;
			factorToGL[ OneMinusDstAlphaFactor ] = 773;

			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

				if ( blending === NoBlending ) {

					if ( currentBlendingEnabled ) {

						disable( 3042 );
						currentBlendingEnabled = false;

					}

					return;

				}

				if ( ! currentBlendingEnabled ) {

					enable( 3042 );
					currentBlendingEnabled = true;

				}

				if ( blending !== CustomBlending ) {

					if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

						if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

							gl.blendEquation( 32774 );

							currentBlendEquation = AddEquation;
							currentBlendEquationAlpha = AddEquation;

						}

						if ( premultipliedAlpha ) {

							switch ( blending ) {

								case NormalBlending:
									gl.blendFuncSeparate( 1, 771, 1, 771 );
									break;

								case AdditiveBlending:
									gl.blendFunc( 1, 1 );
									break;

								case SubtractiveBlending:
									gl.blendFuncSeparate( 0, 0, 769, 771 );
									break;

								case MultiplyBlending:
									gl.blendFuncSeparate( 0, 768, 0, 770 );
									break;

								default:
									console.error( 'THREE.WebGLState: Invalid blending: ', blending );
									break;

							}

						} else {

							switch ( blending ) {

								case NormalBlending:
									gl.blendFuncSeparate( 770, 771, 1, 771 );
									break;

								case AdditiveBlending:
									gl.blendFunc( 770, 1 );
									break;

								case SubtractiveBlending:
									gl.blendFunc( 0, 769 );
									break;

								case MultiplyBlending:
									gl.blendFunc( 0, 768 );
									break;

								default:
									console.error( 'THREE.WebGLState: Invalid blending: ', blending );
									break;

							}

						}

						currentBlendSrc = null;
						currentBlendDst = null;
						currentBlendSrcAlpha = null;
						currentBlendDstAlpha = null;

						currentBlending = blending;
						currentPremultipledAlpha = premultipliedAlpha;

					}

					return;

				}

				// custom blending

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

				currentBlending = blending;
				currentPremultipledAlpha = null;

			}

			function setMaterial( material, frontFaceCW ) {

				material.side === DoubleSide
					? disable( 2884 )
					: enable( 2884 );

				var flipSided = ( material.side === BackSide );
				if ( frontFaceCW ) { flipSided = ! flipSided; }

				setFlipSided( flipSided );

				( material.blending === NormalBlending && material.transparent === false )
					? setBlending( NoBlending )
					: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

				depthBuffer.setFunc( material.depthFunc );
				depthBuffer.setTest( material.depthTest );
				depthBuffer.setMask( material.depthWrite );
				colorBuffer.setMask( material.colorWrite );

				var stencilWrite = material.stencilWrite;
				stencilBuffer.setTest( stencilWrite );
				if ( stencilWrite ) {

					stencilBuffer.setMask( material.stencilWriteMask );
					stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
					stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

				}

				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			//

			function setFlipSided( flipSided ) {

				if ( currentFlipSided !== flipSided ) {

					if ( flipSided ) {

						gl.frontFace( 2304 );

					} else {

						gl.frontFace( 2305 );

					}

					currentFlipSided = flipSided;

				}

			}

			function setCullFace( cullFace ) {

				if ( cullFace !== CullFaceNone ) {

					enable( 2884 );

					if ( cullFace !== currentCullFace ) {

						if ( cullFace === CullFaceBack ) {

							gl.cullFace( 1029 );

						} else if ( cullFace === CullFaceFront ) {

							gl.cullFace( 1028 );

						} else {

							gl.cullFace( 1032 );

						}

					}

				} else {

					disable( 2884 );

				}

				currentCullFace = cullFace;

			}

			function setLineWidth( width ) {

				if ( width !== currentLineWidth ) {

					if ( lineWidthAvailable ) { gl.lineWidth( width ); }

					currentLineWidth = width;

				}

			}

			function setPolygonOffset( polygonOffset, factor, units ) {

				if ( polygonOffset ) {

					enable( 32823 );

					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

						gl.polygonOffset( factor, units );

						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;

					}

				} else {

					disable( 32823 );

				}

			}

			function setScissorTest( scissorTest ) {

				if ( scissorTest ) {

					enable( 3089 );

				} else {

					disable( 3089 );

				}

			}

			// texture

			function activeTexture( webglSlot ) {

				if ( webglSlot === undefined ) { webglSlot = 33984 + maxTextures - 1; }

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

			}

			function bindTexture( webglType, webglTexture ) {

				if ( currentTextureSlot === null ) {

					activeTexture();

				}

				var boundTexture = currentBoundTextures[ currentTextureSlot ];

				if ( boundTexture === undefined ) {

					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;

				}

				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;

				}

			}

			function unbindTexture() {

				var boundTexture = currentBoundTextures[ currentTextureSlot ];

				if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

					gl.bindTexture( boundTexture.type, null );

					boundTexture.type = undefined;
					boundTexture.texture = undefined;

				}

			}

			function compressedTexImage2D() {

				try {

					gl.compressedTexImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( 'THREE.WebGLState:', error );

				}

			}

			function texImage2D() {

				try {

					gl.texImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( 'THREE.WebGLState:', error );

				}

			}

			function texImage3D() {

				try {

					gl.texImage3D.apply( gl, arguments );

				} catch ( error ) {

					console.error( 'THREE.WebGLState:', error );

				}

			}

			//

			function scissor( scissor ) {

				if ( currentScissor.equals( scissor ) === false ) {

					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );

				}

			}

			function viewport( viewport ) {

				if ( currentViewport.equals( viewport ) === false ) {

					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );

				}

			}

			//

			function reset() {

				for ( var i = 0; i < enabledAttributes.length; i ++ ) {

					if ( enabledAttributes[ i ] === 1 ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

				enabledCapabilities = {};

				currentTextureSlot = null;
				currentBoundTextures = {};

				currentProgram = null;

				currentBlending = null;

				currentFlipSided = null;
				currentCullFace = null;

				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();

			}

			return {

				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},

				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,

				useProgram: useProgram,

				setBlending: setBlending,
				setMaterial: setMaterial,

				setFlipSided: setFlipSided,
				setCullFace: setCullFace,

				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,

				setScissorTest: setScissorTest,

				activeTexture: activeTexture,
				bindTexture: bindTexture,
				unbindTexture: unbindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
				texImage3D: texImage3D,

				scissor: scissor,
				viewport: viewport,

				reset: reset

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

			var isWebGL2 = capabilities.isWebGL2;
			var maxTextures = capabilities.maxTextures;
			var maxCubemapSize = capabilities.maxCubemapSize;
			var maxTextureSize = capabilities.maxTextureSize;
			var maxSamples = capabilities.maxSamples;

			var _videoTextures = new WeakMap();
			var _canvas;

			// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
			// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
			// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

			var useOffscreenCanvas = false;

			try {

				useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
					&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;

			} catch ( err ) {

				// Ignore any errors

			}

			function createCanvas( width, height ) {

				// Use OffscreenCanvas when available. Specially needed in web workers

				return useOffscreenCanvas ?
					new OffscreenCanvas( width, height ) :
					document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			}

			function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

				var scale = 1;

				// handle case if texture exceeds max size

				if ( image.width > maxSize || image.height > maxSize ) {

					scale = maxSize / Math.max( image.width, image.height );

				}

				// only perform resize if necessary

				if ( scale < 1 || needsPowerOfTwo === true ) {

					// only perform resize for certain image types

					if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
						( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
						( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

						var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

						var width = floor( scale * image.width );
						var height = floor( scale * image.height );

						if ( _canvas === undefined ) { _canvas = createCanvas( width, height ); }

						// cube textures can't reuse the same canvas

						var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

						canvas.width = width;
						canvas.height = height;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, 0, 0, width, height );

						console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

						return canvas;

					} else {

						if ( 'data' in image ) {

							console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

						}

						return image;

					}

				}

				return image;

			}

			function isPowerOfTwo( image ) {

				return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

			}

			function textureNeedsPowerOfTwo( texture ) {

				if ( isWebGL2 ) { return false; }

				return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
					( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

			}

			function textureNeedsGenerateMipmaps( texture, supportsMips ) {

				return texture.generateMipmaps && supportsMips &&
					texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

			}

			function generateMipmap( target, texture, width, height ) {

				_gl.generateMipmap( target );

				var textureProperties = properties.get( texture );

				// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
				textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

			}

			function getInternalFormat( internalFormatName, glFormat, glType ) {

				if ( isWebGL2 === false ) { return glFormat; }

				if ( internalFormatName !== null ) {

					if ( _gl[ internalFormatName ] !== undefined ) { return _gl[ internalFormatName ]; }

					console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

				}

				var internalFormat = glFormat;

				if ( glFormat === 6403 ) {

					if ( glType === 5126 ) { internalFormat = 33326; }
					if ( glType === 5131 ) { internalFormat = 33325; }
					if ( glType === 5121 ) { internalFormat = 33321; }

				}

				if ( glFormat === 6407 ) {

					if ( glType === 5126 ) { internalFormat = 34837; }
					if ( glType === 5131 ) { internalFormat = 34843; }
					if ( glType === 5121 ) { internalFormat = 32849; }

				}

				if ( glFormat === 6408 ) {

					if ( glType === 5126 ) { internalFormat = 34836; }
					if ( glType === 5131 ) { internalFormat = 34842; }
					if ( glType === 5121 ) { internalFormat = 32856; }

				}

				if ( internalFormat === 33325 || internalFormat === 33326 ||
					internalFormat === 34842 || internalFormat === 34836 ) {

					extensions.get( 'EXT_color_buffer_float' );

				}

				return internalFormat;

			}

			// Fallback filters for non-power-of-2 textures

			function filterFallback( f ) {

				if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

					return 9728;

				}

				return 9729;

			}

			//

			function onTextureDispose( event ) {

				var texture = event.target;

				texture.removeEventListener( 'dispose', onTextureDispose );

				deallocateTexture( texture );

				if ( texture.isVideoTexture ) {

					_videoTextures.delete( texture );

				}

				info.memory.textures --;

			}

			function onRenderTargetDispose( event ) {

				var renderTarget = event.target;

				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

				deallocateRenderTarget( renderTarget );

				info.memory.textures --;

			}

			//

			function deallocateTexture( texture ) {

				var textureProperties = properties.get( texture );

				if ( textureProperties.__webglInit === undefined ) { return; }

				_gl.deleteTexture( textureProperties.__webglTexture );

				properties.remove( texture );

			}

			function deallocateRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				if ( ! renderTarget ) { return; }

				if ( textureProperties.__webglTexture !== undefined ) {

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				if ( renderTarget.depthTexture ) {

					renderTarget.depthTexture.dispose();

				}

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					for ( var i = 0; i < 6; i ++ ) {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }

					}

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }
					if ( renderTargetProperties.__webglMultisampledFramebuffer ) { _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer ); }
					if ( renderTargetProperties.__webglColorRenderbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer ); }
					if ( renderTargetProperties.__webglDepthRenderbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer ); }

				}

				properties.remove( renderTarget.texture );
				properties.remove( renderTarget );

			}

			//

			var textureUnits = 0;

			function resetTextureUnits() {

				textureUnits = 0;

			}

			function allocateTextureUnit() {

				var textureUnit = textureUnits;

				if ( textureUnit >= maxTextures ) {

					console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

				}

				textureUnits += 1;

				return textureUnit;

			}

			//

			function setTexture2D( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.isVideoTexture ) { updateVideoTexture( texture ); }

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					var image = texture.image;

					if ( image === undefined ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

					} else if ( image.complete === false ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

					} else {

						uploadTexture( textureProperties, texture, slot );
						return;

					}

				}

				state.activeTexture( 33984 + slot );
				state.bindTexture( 3553, textureProperties.__webglTexture );

			}

			function setTexture2DArray( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

				state.activeTexture( 33984 + slot );
				state.bindTexture( 35866, textureProperties.__webglTexture );

			}

			function setTexture3D( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

				state.activeTexture( 33984 + slot );
				state.bindTexture( 32879, textureProperties.__webglTexture );

			}

			function setTextureCube( texture, slot ) {

				if ( texture.image.length !== 6 ) { return; }

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					initTexture( textureProperties, texture );

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

					_gl.pixelStorei( 37440, texture.flipY );

					var isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						supportsMips = isPowerOfTwo( image ) || isWebGL2,
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

					setTextureParameters( 34067, texture, supportsMips );

					var mipmaps;

					if ( isCompressed ) {

						for ( var i = 0; i < 6; i ++ ) {

							mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0; j < mipmaps.length; j ++ ) {

								var mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( glFormat !== null ) {

										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

						textureProperties.__maxMipLevel = mipmaps.length - 1;

					} else {

						mipmaps = texture.mipmaps;

						for ( var i = 0; i < 6; i ++ ) {

							if ( isDataTexture ) {

								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

								for ( var j = 0; j < mipmaps.length; j ++ ) {

									var mipmap = mipmaps[ j ];
									var mipmapImage = mipmap.image[ i ].image;

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

								for ( var j = 0; j < mipmaps.length; j ++ ) {

									var mipmap = mipmaps[ j ];

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

						textureProperties.__maxMipLevel = mipmaps.length;

					}

					if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

						// We assume images for cube map have the same size.
						generateMipmap( 34067, texture, image.width, image.height );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) { texture.onUpdate( texture ); }

				} else {

					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__webglTexture );

				}

			}

			function setTextureCubeDynamic( texture, slot ) {

				state.activeTexture( 33984 + slot );
				state.bindTexture( 34067, properties.get( texture ).__webglTexture );

			}

			var wrappingToGL = {};
			wrappingToGL[ RepeatWrapping ] = 10497;
			wrappingToGL[ ClampToEdgeWrapping ] = 33071;
			wrappingToGL[ MirroredRepeatWrapping ] = 33648;

			var filterToGL = {};
			filterToGL[ NearestFilter ] = 9728;
			filterToGL[ NearestMipmapNearestFilter ] = 9984;
			filterToGL[ NearestMipmapLinearFilter ] = 9986;
			filterToGL[ LinearFilter ] = 9729;
			filterToGL[ LinearMipmapNearestFilter ] = 9985;
			filterToGL[ LinearMipmapLinearFilter ] = 9987;

			function setTextureParameters( textureType, texture, supportsMips ) {

				if ( supportsMips ) {

					_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
					_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

					if ( textureType === 32879 || textureType === 35866 ) {

						_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

					}

					_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
					_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

				} else {

					_gl.texParameteri( textureType, 10242, 33071 );
					_gl.texParameteri( textureType, 10243, 33071 );

					if ( textureType === 32879 || textureType === 35866 ) {

						_gl.texParameteri( textureType, 32882, 33071 );

					}

					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

					}

					_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

					}

				}

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension ) {

					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) { return; }
					if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) { return; }

					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;

					}

				}

			}

			function initTexture( textureProperties, texture ) {

				if ( textureProperties.__webglInit === undefined ) {

					textureProperties.__webglInit = true;

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__webglTexture = _gl.createTexture();

					info.memory.textures ++;

				}

			}

			function uploadTexture( textureProperties, texture, slot ) {

				var textureType = 3553;

				if ( texture.isDataTexture2DArray ) { textureType = 35866; }
				if ( texture.isDataTexture3D ) { textureType = 32879; }

				initTexture( textureProperties, texture );

				state.activeTexture( 33984 + slot );
				state.bindTexture( textureType, textureProperties.__webglTexture );

				_gl.pixelStorei( 37440, texture.flipY );
				_gl.pixelStorei( 37441, texture.premultiplyAlpha );
				_gl.pixelStorei( 3317, texture.unpackAlignment );

				var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
				var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

				var supportsMips = isPowerOfTwo( image ) || isWebGL2,
					glFormat = utils.convert( texture.format ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

				setTextureParameters( textureType, texture, supportsMips );

				var mipmap, mipmaps = texture.mipmaps;

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					glInternalFormat = 6402;

					if ( isWebGL2 ) {

						if ( texture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( texture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						} else if ( texture.type === UnsignedInt248Type ) {

							glInternalFormat = 35056;

						} else {

							glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

						}

					} else {

						if ( texture.type === FloatType ) {

							console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

						}

					}

					// validation checks for WebGL 1

					if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

							texture.type = UnsignedShortType;
							glType = utils.convert( texture.type );

						}

					}

					if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = 34041;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

							texture.type = UnsignedInt248Type;
							glType = utils.convert( texture.type );

						}

					}

					//

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

						texture.generateMipmaps = false;
						textureProperties.__maxMipLevel = mipmaps.length - 1;

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
						textureProperties.__maxMipLevel = 0;

					}

				} else if ( texture.isCompressedTexture ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else if ( texture.isDataTexture2DArray ) {

					state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				} else if ( texture.isDataTexture3D ) {

					state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

						}

						texture.generateMipmaps = false;
						textureProperties.__maxMipLevel = mipmaps.length - 1;

					} else {

						state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
						textureProperties.__maxMipLevel = 0;

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( textureType, texture, image.width, image.height );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) { texture.onUpdate( texture ); }

			}

			// Render targets

			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

				var glFormat = utils.convert( renderTarget.texture.format );
				var glType = utils.convert( renderTarget.texture.type );
				var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( 36160, framebuffer );
				_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( 36160, null );

			}

			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

				_gl.bindRenderbuffer( 36161, renderbuffer );

				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

					var glInternalFormat = 33189;

					if ( isMultisample ) {

						var depthTexture = renderTarget.depthTexture;

						if ( depthTexture && depthTexture.isDepthTexture ) {

							if ( depthTexture.type === FloatType ) {

								glInternalFormat = 36012;

							} else if ( depthTexture.type === UnsignedIntType ) {

								glInternalFormat = 33190;

							}

						}

						var samples = getRenderTargetSamples( renderTarget );

						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

					}

					_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

					if ( isMultisample ) {

						var samples = getRenderTargetSamples( renderTarget );

						_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

					}


					_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

				} else {

					var glFormat = utils.convert( renderTarget.texture.format );
					var glType = utils.convert( renderTarget.texture.type );
					var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

					if ( isMultisample ) {

						var samples = getRenderTargetSamples( renderTarget );

						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				}

				_gl.bindRenderbuffer( 36161, null );

			}

			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {

				var isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
				if ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }

				_gl.bindFramebuffer( 36160, framebuffer );

				if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

					throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

				}

				// upload an empty depth texture with framebuffer size
				if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {

					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;

				}

				setTexture2D( renderTarget.depthTexture, 0 );

				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

				if ( renderTarget.depthTexture.format === DepthFormat ) {

					_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

					_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

				} else {

					throw new Error( 'Unknown depthTexture format' );

				}

			}

			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

				if ( renderTarget.depthTexture ) {

					if ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }

					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

				} else {

					if ( isCube ) {

						renderTargetProperties.__webglDepthbuffer = [];

						for ( var i = 0; i < 6; i ++ ) {

							_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

						}

					} else {

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

					}

				}

				_gl.bindFramebuffer( 36160, null );

			}

			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

				var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
				var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
				var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

				// Handles WebGL2 RGBFormat fallback - #18858

				if ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {

					renderTarget.texture.format = RGBAFormat;

					console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

				}

				// Setup framebuffer

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

					if ( isMultisample ) {

						if ( isWebGL2 ) {

							renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
							renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

							_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

							var glFormat = utils.convert( renderTarget.texture.format );
							var glType = utils.convert( renderTarget.texture.type );
							var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
							var samples = getRenderTargetSamples( renderTarget );
							_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

							_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
							_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
							_gl.bindRenderbuffer( 36161, null );

							if ( renderTarget.depthBuffer ) {

								renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
								setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

							}

							_gl.bindFramebuffer( 36160, null );


						} else {

							console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

						}

					}

				}

				// Setup color buffer

				if ( isCube ) {

					state.bindTexture( 34067, textureProperties.__webglTexture );
					setTextureParameters( 34067, renderTarget.texture, supportsMips );

					for ( var i = 0; i < 6; i ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

					}

					if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

						generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

					}

					state.bindTexture( 34067, null );

				} else {

					state.bindTexture( 3553, textureProperties.__webglTexture );
					setTextureParameters( 3553, renderTarget.texture, supportsMips );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

					if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

						generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

					}

					state.bindTexture( 3553, null );

				}

				// Setup depth and stencil buffers

				if ( renderTarget.depthBuffer ) {

					setupDepthRenderbuffer( renderTarget );

				}

			}

			function updateRenderTargetMipmap( renderTarget ) {

				var texture = renderTarget.texture;
				var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
					var webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					generateMipmap( target, texture, renderTarget.width, renderTarget.height );
					state.bindTexture( target, null );

				}

			}

			function updateMultisampleRenderTarget( renderTarget ) {

				if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					if ( isWebGL2 ) {

						var renderTargetProperties = properties.get( renderTarget );

						_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

						var width = renderTarget.width;
						var height = renderTarget.height;
						var mask = 16384;

						if ( renderTarget.depthBuffer ) { mask |= 256; }
						if ( renderTarget.stencilBuffer ) { mask |= 1024; }

						_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			function getRenderTargetSamples( renderTarget ) {

				return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
					Math.min( maxSamples, renderTarget.samples ) : 0;

			}

			function updateVideoTexture( texture ) {

				var frame = info.render.frame;

				// Check the last frame we updated the VideoTexture

				if ( _videoTextures.get( texture ) !== frame ) {

					_videoTextures.set( texture, frame );
					texture.update();

				}

			}

			// backwards compatibility

			var warnedTexture2D = false;
			var warnedTextureCube = false;

			function safeSetTexture2D( texture, slot ) {

				if ( texture && texture.isWebGLRenderTarget ) {

					if ( warnedTexture2D === false ) {

						console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warnedTexture2D = true;

					}

					texture = texture.texture;

				}

				setTexture2D( texture, slot );

			}

			function safeSetTextureCube( texture, slot ) {

				if ( texture && texture.isWebGLCubeRenderTarget ) {

					if ( warnedTextureCube === false ) {

						console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warnedTextureCube = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					setTextureCube( texture, slot );

				} else {

					// assumed: texture property of THREE.WebGLCubeRenderTarget
					setTextureCubeDynamic( texture, slot );

				}

			}

			//

			this.allocateTextureUnit = allocateTextureUnit;
			this.resetTextureUnits = resetTextureUnits;

			this.setTexture2D = setTexture2D;
			this.setTexture2DArray = setTexture2DArray;
			this.setTexture3D = setTexture3D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;
			this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

			this.safeSetTexture2D = safeSetTexture2D;
			this.safeSetTextureCube = safeSetTextureCube;

		}

		/**
		 * @author thespite / http://www.twitter.com/thespite
		 */

		function WebGLUtils( gl, extensions, capabilities ) {

			var isWebGL2 = capabilities.isWebGL2;

			function convert( p ) {

				var extension;

				if ( p === UnsignedByteType ) { return 5121; }
				if ( p === UnsignedShort4444Type ) { return 32819; }
				if ( p === UnsignedShort5551Type ) { return 32820; }
				if ( p === UnsignedShort565Type ) { return 33635; }

				if ( p === ByteType ) { return 5120; }
				if ( p === ShortType ) { return 5122; }
				if ( p === UnsignedShortType ) { return 5123; }
				if ( p === IntType ) { return 5124; }
				if ( p === UnsignedIntType ) { return 5125; }
				if ( p === FloatType ) { return 5126; }

				if ( p === HalfFloatType ) {

					if ( isWebGL2 ) { return 5131; }

					extension = extensions.get( 'OES_texture_half_float' );

					if ( extension !== null ) {

						return extension.HALF_FLOAT_OES;

					} else {

						return null;

					}

				}

				if ( p === AlphaFormat ) { return 6406; }
				if ( p === RGBFormat ) { return 6407; }
				if ( p === RGBAFormat ) { return 6408; }
				if ( p === LuminanceFormat ) { return 6409; }
				if ( p === LuminanceAlphaFormat ) { return 6410; }
				if ( p === DepthFormat ) { return 6402; }
				if ( p === DepthStencilFormat ) { return 34041; }
				if ( p === RedFormat ) { return 6403; }

				// WebGL2 formats.

				if ( p === RedIntegerFormat ) { return 36244; }
				if ( p === RGFormat ) { return 33319; }
				if ( p === RGIntegerFormat ) { return 33320; }
				if ( p === RGBIntegerFormat ) { return 36248; }
				if ( p === RGBAIntegerFormat ) { return 36249; }

				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }
						if ( p === RGBA_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }
						if ( p === RGBA_S3TC_DXT3_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }
						if ( p === RGBA_S3TC_DXT5_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }

					} else {

						return null;

					}

				}

				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

					if ( extension !== null ) {

						if ( p === RGB_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }
						if ( p === RGB_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }
						if ( p === RGBA_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }
						if ( p === RGBA_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }

					} else {

						return null;

					}

				}

				if ( p === RGB_ETC1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

					if ( extension !== null ) {

						return extension.COMPRESSED_RGB_ETC1_WEBGL;

					} else {

						return null;

					}

				}

				if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_etc' );

					if ( extension !== null ) {

						if ( p === RGB_ETC2_Format ) { return extension.COMPRESSED_RGB8_ETC2; }
						if ( p === RGBA_ETC2_EAC_Format ) { return extension.COMPRESSED_RGBA8_ETC2_EAC; }

					}

				}

				if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
					p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
					p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
					p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
					p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
					p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
					p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
					p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
					p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
					p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_astc' );

					if ( extension !== null ) {

						// TODO Complete?

						return p;

					} else {

						return null;

					}

				}

				if ( p === RGBA_BPTC_Format ) {

					extension = extensions.get( 'EXT_texture_compression_bptc' );

					if ( extension !== null ) {

						// TODO Complete?

						return p;

					} else {

						return null;

					}

				}

				if ( p === UnsignedInt248Type ) {

					if ( isWebGL2 ) { return 34042; }

					extension = extensions.get( 'WEBGL_depth_texture' );

					if ( extension !== null ) {

						return extension.UNSIGNED_INT_24_8_WEBGL;

					} else {

						return null;

					}

				}

			}

			return { convert: convert };

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ArrayCamera( array ) {

			PerspectiveCamera.call( this );

			this.cameras = array || [];

		}

		ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

			constructor: ArrayCamera,

			isArrayCamera: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Group() {

			Object3D.call( this );

			this.type = 'Group';

		}

		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Group,

			isGroup: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebXRManager( renderer, gl ) {

			var scope = this;

			var session = null;

			var framebufferScaleFactor = 1.0;

			var referenceSpace = null;
			var referenceSpaceType = 'local-floor';

			var pose = null;

			var controllers = [];
			var inputSourcesMap = new Map();

			//

			var cameraL = new PerspectiveCamera();
			cameraL.layers.enable( 1 );
			cameraL.viewport = new Vector4();

			var cameraR = new PerspectiveCamera();
			cameraR.layers.enable( 2 );
			cameraR.viewport = new Vector4();

			var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
			cameraVR.layers.enable( 1 );
			cameraVR.layers.enable( 2 );

			var _currentDepthNear = null;
			var _currentDepthFar = null;

			//

			this.enabled = false;

			this.isPresenting = false;

			this.getController = function ( id ) {

				var controller = controllers[ id ];

				if ( controller === undefined ) {

					controller = {};
					controllers[ id ] = controller;

				}

				if ( controller.targetRay === undefined ) {

					controller.targetRay = new Group();
					controller.targetRay.matrixAutoUpdate = false;
					controller.targetRay.visible = false;

				}

				return controller.targetRay;

			};

			this.getControllerGrip = function ( id ) {

				var controller = controllers[ id ];

				if ( controller === undefined ) {

					controller = {};
					controllers[ id ] = controller;

				}

				if ( controller.grip === undefined ) {

					controller.grip = new Group();
					controller.grip.matrixAutoUpdate = false;
					controller.grip.visible = false;

				}

				return controller.grip;

			};

			//

			function onSessionEvent( event ) {

				var controller = inputSourcesMap.get( event.inputSource );

				if ( controller ) {

					if ( controller.targetRay ) {

						controller.targetRay.dispatchEvent( { type: event.type } );

					}

					if ( controller.grip ) {

						controller.grip.dispatchEvent( { type: event.type } );

					}

				}

			}

			function onSessionEnd() {

				inputSourcesMap.forEach( function ( controller, inputSource ) {

					if ( controller.targetRay ) {

						controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );
						controller.targetRay.visible = false;

					}

					if ( controller.grip ) {

						controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );
						controller.grip.visible = false;

					}

				} );

				inputSourcesMap.clear();

				//

				renderer.setFramebuffer( null );
				renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
				animation.stop();

				scope.isPresenting = false;

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			function onRequestReferenceSpace( value ) {

				referenceSpace = value;

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				// Warn if function is used while presenting
				if ( scope.isPresenting == true ) {

					console.warn( "WebXRManager: Cannot change framebuffer scale while presenting VR content" );

				}

			};

			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

			};

			this.getReferenceSpace = function () {

				return referenceSpace;

			};

			this.getSession = function () {

				return session;

			};

			this.setSession = function ( value ) {

				session = value;

				if ( session !== null ) {

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );

					var attributes = gl.getContextAttributes();

					var layerInit = {
						antialias: attributes.antialias,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					// eslint-disable-next-line no-undef
					var baseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: baseLayer } );

					session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

					//

					session.addEventListener( 'inputsourceschange', updateInputSources );

				}

			};

			function updateInputSources( event ) {

				var inputSources = session.inputSources;

				// Assign inputSources to available controllers

				for ( var i = 0; i < controllers.length; i ++ ) {

					inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

				}

				// Notify disconnected

				for ( var i = 0; i < event.removed.length; i ++ ) {

					var inputSource = event.removed[ i ];
					var controller = inputSourcesMap.get( inputSource );

					if ( controller ) {

						if ( controller.targetRay ) {

							controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );

						}

						if ( controller.grip ) {

							controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );

						}

						inputSourcesMap.delete( inputSource );

					}

				}

				// Notify connected

				for ( var i = 0; i < event.added.length; i ++ ) {

					var inputSource = event.added[ i ];
					var controller = inputSourcesMap.get( inputSource );

					if ( controller ) {

						if ( controller.targetRay ) {

							controller.targetRay.dispatchEvent( { type: 'connected', data: inputSource } );

						}

						if ( controller.grip ) {

							controller.grip.dispatchEvent( { type: 'connected', data: inputSource } );

						}

					}

				}

			}

			//

			var cameraLPos = new Vector3();
			var cameraRPos = new Vector3();

			/**
			 * @author jsantell / https://www.jsantell.com/
			 *
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				var ipd = cameraLPos.distanceTo( cameraRPos );

				var projL = cameraL.projectionMatrix.elements;
				var projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				var left = near * leftFov;
				var right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				var zOffset = ipd / ( - leftFov + rightFov );
				var xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.getInverse( camera.matrixWorld );

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				var near2 = near + zOffset;
				var far2 = far + zOffset;
				var left2 = left - xOffset;
				var right2 = right + ( ipd - xOffset );
				var top2 = topFov * far / far2 * near2;
				var bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			}

			this.getCamera = function ( camera ) {

				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					} );

					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;

				}

				var parent = camera.parent;
				var cameras = cameraVR.cameras;

				updateCamera( cameraVR, parent );

				for ( var i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update camera and its children

				camera.matrixWorld.copy( cameraVR.matrixWorld );

				var children = camera.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

				return cameraVR;

			};

			// Animation Loop

			var onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( referenceSpace );

				if ( pose !== null ) {

					var views = pose.views;
					var baseLayer = session.renderState.baseLayer;

					renderer.setFramebuffer( baseLayer.framebuffer );

					for ( var i = 0; i < views.length; i ++ ) {

						var view = views[ i ];
						var viewport = baseLayer.getViewport( view );

						var camera = cameraVR.cameras[ i ];
						camera.matrix.fromArray( view.transform.matrix );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraVR.matrix.copy( camera.matrix );

						}

					}

				}

				//

				var inputSources = session.inputSources;

				for ( var i = 0; i < controllers.length; i ++ ) {

					var controller = controllers[ i ];

					var inputSource = inputSources[ i ];

					var inputPose = null;
					var gripPose = null;

					if ( inputSource ) {

						if ( controller.targetRay ) {

							inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

							if ( inputPose !== null ) {

								controller.targetRay.matrix.fromArray( inputPose.transform.matrix );
								controller.targetRay.matrix.decompose( controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale );

							}

						}

						if ( controller.grip && inputSource.gripSpace ) {

							gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

							if ( gripPose !== null ) {

								controller.grip.matrix.fromArray( gripPose.transform.matrix );
								controller.grip.matrix.decompose( controller.grip.position, controller.grip.rotation, controller.grip.scale );

							}

						}

					}

					if ( controller.targetRay ) {

						controller.targetRay.visible = inputPose !== null;

					}

					if ( controller.grip ) {

						controller.grip.visible = gripPose !== null;

					}

				}

				if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time, frame ); }

			}

			var animation = new WebGLAnimation();
			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

		Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */

		function WebGLRenderer( parameters ) {

			parameters = parameters || {};

			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
				_context = parameters.context !== undefined ? parameters.context : null,

				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
				_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
				_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

			var currentRenderList = null;
			var currentRenderState = null;

			// public properties

			this.domElement = _canvas;

			// Debug configuration container
			this.debug = {

				/**
				 * Enables error checking and reporting when shader programs are being compiled
				 * @type {boolean}
				 */
				checkShaderErrors: true
			};

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.gammaFactor = 2.0;	// for backwards compatibility
			this.outputEncoding = LinearEncoding;

			// physical lights

			this.physicallyCorrectLights = false;

			// tone mapping

			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;

			// morphs

			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;

			// internal properties

			var _this = this,

				_isContextLost = false,

				// internal state cache

				_framebuffer = null,

				_currentActiveCubeFace = 0,
				_currentActiveMipmapLevel = 0,
				_currentRenderTarget = null,
				_currentFramebuffer = null,
				_currentMaterialId = - 1,

				// geometry and program caching

				_currentGeometryProgram = {
					geometry: null,
					program: null,
					wireframe: false
				},

				_currentCamera = null,
				_currentArrayCamera = null,

				_currentViewport = new Vector4(),
				_currentScissor = new Vector4(),
				_currentScissorTest = null,

				//

				_width = _canvas.width,
				_height = _canvas.height,

				_pixelRatio = 1,
				_opaqueSort = null,
				_transparentSort = null,

				_viewport = new Vector4( 0, 0, _width, _height ),
				_scissor = new Vector4( 0, 0, _width, _height ),
				_scissorTest = false,

				// frustum

				_frustum = new Frustum(),

				// clipping

				_clipping = new WebGLClipping(),
				_clippingEnabled = false,
				_localClippingEnabled = false,

				// camera matrices cache

				_projScreenMatrix = new Matrix4(),

				_vector3 = new Vector3();

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			// initialize

			var _gl;

			try {

				var contextAttributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer,
					powerPreference: _powerPreference,
					failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
					xrCompatible: true
				};

				// event listeners must be registered before WebGL context is created, see #12753

				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
				_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

				_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

				if ( _gl === null ) {

					if ( _canvas.getContext( 'webgl' ) !== null ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

			} catch ( error ) {

				console.error( 'THREE.WebGLRenderer: ' + error.message );
				throw error;

			}

			var extensions, capabilities, state, info;
			var properties, textures, attributes, geometries, objects;
			var programCache, renderLists, renderStates;

			var background, morphtargets, bufferRenderer, indexedBufferRenderer;

			var utils;

			function initGLContext() {

				extensions = new WebGLExtensions( _gl );

				capabilities = new WebGLCapabilities( _gl, extensions, parameters );

				if ( capabilities.isWebGL2 === false ) {

					extensions.get( 'WEBGL_depth_texture' );
					extensions.get( 'OES_texture_float' );
					extensions.get( 'OES_texture_half_float' );
					extensions.get( 'OES_texture_half_float_linear' );
					extensions.get( 'OES_standard_derivatives' );
					extensions.get( 'OES_element_index_uint' );
					extensions.get( 'ANGLE_instanced_arrays' );

				}

				extensions.get( 'OES_texture_float_linear' );

				utils = new WebGLUtils( _gl, extensions, capabilities );

				state = new WebGLState( _gl, extensions, capabilities );
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

				info = new WebGLInfo( _gl );
				properties = new WebGLProperties();
				textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
				attributes = new WebGLAttributes( _gl, capabilities );
				geometries = new WebGLGeometries( _gl, attributes, info );
				objects = new WebGLObjects( _gl, geometries, attributes, info );
				morphtargets = new WebGLMorphtargets( _gl );
				programCache = new WebGLPrograms( _this, extensions, capabilities );
				renderLists = new WebGLRenderLists();
				renderStates = new WebGLRenderStates();

				background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

				bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
				indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

				info.programs = programCache.programs;

				_this.capabilities = capabilities;
				_this.extensions = extensions;
				_this.properties = properties;
				_this.renderLists = renderLists;
				_this.state = state;
				_this.info = info;

			}

			initGLContext();

			// xr

			var xr = new WebXRManager( _this, _gl );

			this.xr = xr;

			// shadow map

			var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

			this.shadowMap = shadowMap;

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				var extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) { extension.loseContext(); }

			};

			this.forceContextRestore = function () {

				var extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) { extension.restoreContext(); }

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) { return; }

				_pixelRatio = value;

				this.setSize( _width, _height, false );

			};

			this.getSize = function ( target ) {

				if ( target === undefined ) {

					console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

					target = new Vector2();

				}

				return target.set( _width, _height );

			};

			this.setSize = function ( width, height, updateStyle ) {

				if ( xr.isPresenting ) {

					console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
					return;

				}

				_width = width;
				_height = height;

				_canvas.width = Math.floor( width * _pixelRatio );
				_canvas.height = Math.floor( height * _pixelRatio );

				if ( updateStyle !== false ) {

					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.getDrawingBufferSize = function ( target ) {

				if ( target === undefined ) {

					console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

					target = new Vector2();

				}

				return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

			};

			this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

				_width = width;
				_height = height;

				_pixelRatio = pixelRatio;

				_canvas.width = Math.floor( width * pixelRatio );
				_canvas.height = Math.floor( height * pixelRatio );

				this.setViewport( 0, 0, width, height );

			};

			this.getCurrentViewport = function ( target ) {

				if ( target === undefined ) {

					console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

					target = new Vector4();

				}

				return target.copy( _currentViewport );

			};

			this.getViewport = function ( target ) {

				return target.copy( _viewport );

			};

			this.setViewport = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_viewport.set( x.x, x.y, x.z, x.w );

				} else {

					_viewport.set( x, y, width, height );

				}

				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissor = function ( target ) {

				return target.copy( _scissor );

			};

			this.setScissor = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_scissor.set( x.x, x.y, x.z, x.w );

				} else {

					_scissor.set( x, y, width, height );

				}

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissorTest = function () {

				return _scissorTest;

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			this.setOpaqueSort = function ( method ) {

				_opaqueSort = method;

			};

			this.setTransparentSort = function ( method ) {

				_transparentSort = method;

			};

			// Clearing

			this.getClearColor = function () {

				return background.getClearColor();

			};

			this.setClearColor = function () {

				background.setClearColor.apply( background, arguments );

			};

			this.getClearAlpha = function () {

				return background.getClearAlpha();

			};

			this.setClearAlpha = function () {

				background.setClearAlpha.apply( background, arguments );

			};

			this.clear = function ( color, depth, stencil ) {

				var bits = 0;

				if ( color === undefined || color ) { bits |= 16384; }
				if ( depth === undefined || depth ) { bits |= 256; }
				if ( stencil === undefined || stencil ) { bits |= 1024; }

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			//

			this.dispose = function () {

				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
				_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

				renderLists.dispose();
				renderStates.dispose();
				properties.dispose();
				objects.dispose();

				xr.dispose();

				animation.stop();

				this.forceContextLoss();

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				console.log( 'THREE.WebGLRenderer: Context Lost.' );

				_isContextLost = true;

			}

			function onContextRestore( /* event */ ) {

				console.log( 'THREE.WebGLRenderer: Context Restored.' );

				_isContextLost = false;

				initGLContext();

			}

			function onMaterialDispose( event ) {

				var material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReference( material );

				properties.remove( material );

			}


			function releaseMaterialProgramReference( material ) {

				var programInfo = properties.get( material ).program;

				material.program = undefined;

				if ( programInfo !== undefined ) {

					programCache.releaseProgram( programInfo );

				}

			}

			// Buffer rendering

			function renderObjectImmediate( object, program ) {

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program );

				} );

			}

			this.renderBufferImmediate = function ( object, program ) {

				state.initAttributes();

				var buffers = properties.get( object );

				if ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }
				if ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }
				if ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }
				if ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }

				var programAttributes = program.getAttributes();

				if ( object.hasPositions ) {

					_gl.bindBuffer( 34962, buffers.position );
					_gl.bufferData( 34962, object.positionArray, 35048 );

					state.enableAttribute( programAttributes.position );
					_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

				}

				if ( object.hasNormals ) {

					_gl.bindBuffer( 34962, buffers.normal );
					_gl.bufferData( 34962, object.normalArray, 35048 );

					state.enableAttribute( programAttributes.normal );
					_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

				}

				if ( object.hasUvs ) {

					_gl.bindBuffer( 34962, buffers.uv );
					_gl.bufferData( 34962, object.uvArray, 35048 );

					state.enableAttribute( programAttributes.uv );
					_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

				}

				if ( object.hasColors ) {

					_gl.bindBuffer( 34962, buffers.color );
					_gl.bufferData( 34962, object.colorArray, 35048 );

					state.enableAttribute( programAttributes.color );
					_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

				}

				state.disableUnusedAttributes();

				_gl.drawArrays( 4, 0, object.count );

				object.count = 0;

			};

			var tempScene = new Scene();

			this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

				if ( scene === null ) { scene = tempScene; } // renderBufferDirect second parameter used to be fog (could be null)

				var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				var program = setProgram( camera, scene, material, object );

				state.setMaterial( material, frontFaceCW );

				var updateBuffers = false;

				if ( _currentGeometryProgram.geometry !== geometry.id ||
					_currentGeometryProgram.program !== program.id ||
					_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

					_currentGeometryProgram.geometry = geometry.id;
					_currentGeometryProgram.program = program.id;
					_currentGeometryProgram.wireframe = material.wireframe === true;
					updateBuffers = true;

				}

				if ( material.morphTargets || material.morphNormals ) {

					morphtargets.update( object, geometry, material, program );

					updateBuffers = true;

				}

				//

				var index = geometry.index;
				var position = geometry.attributes.position;

				//

				if ( index === null ) {

					if ( position === undefined || position.count === 0 ) { return; }

				} else if ( index.count === 0 ) {

					return;

				}

				//

				var rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = geometries.getWireframeAttribute( geometry );
					rangeFactor = 2;

				}

				var attribute;
				var renderer = bufferRenderer;

				if ( index !== null ) {

					attribute = attributes.get( index );

					renderer = indexedBufferRenderer;
					renderer.setIndex( attribute );

				}

				if ( updateBuffers ) {

					setupVertexAttributes( object, geometry, material, program );

					if ( index !== null ) {

						_gl.bindBuffer( 34963, attribute.buffer );

					}

				}

				//

				var dataCount = ( index !== null ) ? index.count : position.count;

				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;

				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;

				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

				if ( drawCount === 0 ) { return; }

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( 1 );

					} else {

						renderer.setMode( 4 );

					}

				} else if ( object.isLine ) {

					var lineWidth = material.linewidth;

					if ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( 1 );

					} else if ( object.isLineLoop ) {

						renderer.setMode( 2 );

					} else {

						renderer.setMode( 3 );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( 0 );

				} else if ( object.isSprite ) {

					renderer.setMode( 4 );

				}

				if ( object.isInstancedMesh ) {

					renderer.renderInstances( geometry, drawStart, drawCount, object.count );

				} else if ( geometry.isInstancedBufferGeometry ) {

					renderer.renderInstances( geometry, drawStart, drawCount, geometry.maxInstancedCount );

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			function setupVertexAttributes( object, geometry, material, program ) {

				if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

					if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) { return; }

				}

				state.initAttributes();

				var geometryAttributes = geometry.attributes;

				var programAttributes = program.getAttributes();

				var materialDefaultAttributeValues = material.defaultAttributeValues;

				for ( var name in programAttributes ) {

					var programAttribute = programAttributes[ name ];

					if ( programAttribute >= 0 ) {

						var geometryAttribute = geometryAttributes[ name ];

						if ( geometryAttribute !== undefined ) {

							var normalized = geometryAttribute.normalized;
							var size = geometryAttribute.itemSize;

							var attribute = attributes.get( geometryAttribute );

							// TODO Attribute may not be available on context restore

							if ( attribute === undefined ) { continue; }

							var buffer = attribute.buffer;
							var type = attribute.type;
							var bytesPerElement = attribute.bytesPerElement;

							if ( geometryAttribute.isInterleavedBufferAttribute ) {

								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;

								if ( data && data.isInstancedInterleavedBuffer ) {

									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = data.meshPerAttribute * data.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( 34962, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

							} else {

								if ( geometryAttribute.isInstancedBufferAttribute ) {

									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( 34962, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

							}

						} else if ( name === 'instanceMatrix' ) {

							var attribute = attributes.get( object.instanceMatrix );

							// TODO Attribute may not be available on context restore

							if ( attribute === undefined ) { continue; }

							var buffer = attribute.buffer;
							var type = attribute.type;

							state.enableAttributeAndDivisor( programAttribute + 0, 1 );
							state.enableAttributeAndDivisor( programAttribute + 1, 1 );
							state.enableAttributeAndDivisor( programAttribute + 2, 1 );
							state.enableAttributeAndDivisor( programAttribute + 3, 1 );

							_gl.bindBuffer( 34962, buffer );

							_gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
							_gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
							_gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
							_gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

						} else if ( materialDefaultAttributeValues !== undefined ) {

							var value = materialDefaultAttributeValues[ name ];

							if ( value !== undefined ) {

								switch ( value.length ) {

									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;

									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;

									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;

									default:
										_gl.vertexAttrib1fv( programAttribute, value );

								}

							}

						}

					}

				}

				state.disableUnusedAttributes();

			}

			// Compile

			this.compile = function ( scene, camera ) {

				currentRenderState = renderStates.get( scene, camera );
				currentRenderState.init();

				scene.traverse( function ( object ) {

					if ( object.isLight ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

				currentRenderState.setupLights( camera );

				var compiled = {};

				scene.traverse( function ( object ) {

					if ( object.material ) {

						if ( Array.isArray( object.material ) ) {

							for ( var i = 0; i < object.material.length; i ++ ) {

								if ( object.material[ i ].uuid in compiled === false ) {

									initMaterial( object.material[ i ], scene, object );
									compiled[ object.material[ i ].uuid ] = true;

								}

							}

						} else if ( object.material.uuid in compiled === false ) {

							initMaterial( object.material, scene, object );
							compiled[ object.material.uuid ] = true;

						}

					}

				} );

			};

			// Animation Loop

			var onAnimationFrameCallback = null;

			function onAnimationFrame( time ) {

				if ( xr.isPresenting ) { return; }
				if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

			}

			var animation = new WebGLAnimation();
			animation.setAnimationLoop( onAnimationFrame );

			if ( typeof window !== 'undefined' ) { animation.setContext( window ); }

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;
				xr.setAnimationLoop( callback );

				animation.start();

			};

			// Rendering

			this.render = function ( scene, camera ) {

				var renderTarget, forceClear;

				if ( arguments[ 2 ] !== undefined ) {

					console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
					renderTarget = arguments[ 2 ];

				}

				if ( arguments[ 3 ] !== undefined ) {

					console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
					forceClear = arguments[ 3 ];

				}

				if ( ! ( camera && camera.isCamera ) ) {

					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				if ( _isContextLost ) { return; }

				// reset caching for this frame

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;
				_currentMaterialId = - 1;
				_currentCamera = null;

				// update scene graph

				if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

				// update camera matrices and frustum

				if ( camera.parent === null ) { camera.updateMatrixWorld(); }

				if ( xr.enabled && xr.isPresenting ) {

					camera = xr.getCamera( camera );

				}

				//

				currentRenderState = renderStates.get( scene, camera );
				currentRenderState.init();

				scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromProjectionMatrix( _projScreenMatrix );

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

				currentRenderList = renderLists.get( scene, camera );
				currentRenderList.init();

				projectObject( scene, camera, 0, _this.sortObjects );

				currentRenderList.finish();

				if ( _this.sortObjects === true ) {

					currentRenderList.sort( _opaqueSort, _transparentSort );

				}

				//

				if ( _clippingEnabled ) { _clipping.beginShadows(); }

				var shadowsArray = currentRenderState.state.shadowsArray;

				shadowMap.render( shadowsArray, scene, camera );

				currentRenderState.setupLights( camera );

				if ( _clippingEnabled ) { _clipping.endShadows(); }

				//

				if ( this.info.autoReset ) { this.info.reset(); }

				if ( renderTarget !== undefined ) {

					this.setRenderTarget( renderTarget );

				}

				//

				background.render( currentRenderList, scene, camera, forceClear );

				// render scene

				var opaqueObjects = currentRenderList.opaque;
				var transparentObjects = currentRenderList.transparent;

				if ( scene.overrideMaterial ) {

					var overrideMaterial = scene.overrideMaterial;

					if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera, overrideMaterial ); }
					if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera, overrideMaterial ); }

				} else {

					// opaque pass (front-to-back order)

					if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera ); }

					// transparent pass (back-to-front order)

					if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera ); }

				}

				//

				scene.onAfterRender( _this, scene, camera );

				//

				if ( _currentRenderTarget !== null ) {

					// Generate mipmap if we're using any kind of mipmap filtering

					textures.updateRenderTargetMipmap( _currentRenderTarget );

					// resolve multisample renderbuffers to a single-sample texture if necessary

					textures.updateMultisampleRenderTarget( _currentRenderTarget );

				}

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );

				state.setPolygonOffset( false );

				// _gl.finish();

				currentRenderList = null;
				currentRenderState = null;

			};

			function projectObject( object, camera, groupOrder, sortObjects ) {

				if ( object.visible === false ) { return; }

				var visible = object.layers.test( camera.layers );

				if ( visible ) {

					if ( object.isGroup ) {

						groupOrder = object.renderOrder;

					} else if ( object.isLOD ) {

						if ( object.autoUpdate === true ) { object.update( camera ); }

					} else if ( object.isLight ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					} else if ( object.isSprite ) {

						if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

							if ( sortObjects ) {

								_vector3.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							var geometry = objects.update( object );
							var material = object.material;

							if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					} else if ( object.isImmediateRenderObject ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( object.isSkinnedMesh ) {

							// update skeleton only once in a frame

							if ( object.skeleton.frame !== info.render.frame ) {

								object.skeleton.update();
								object.skeleton.frame = info.render.frame;

							}

						}

						if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

							if ( sortObjects ) {

								_vector3.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							var geometry = objects.update( object );
							var material = object.material;

							if ( Array.isArray( material ) ) {

								var groups = geometry.groups;

								for ( var i = 0, l = groups.length; i < l; i ++ ) {

									var group = groups[ i ];
									var groupMaterial = material[ group.materialIndex ];

									if ( groupMaterial && groupMaterial.visible ) {

										currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

									}

								}

							} else if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, groupOrder, sortObjects );

				}

			}

			function renderObjects( renderList, scene, camera, overrideMaterial ) {

				for ( var i = 0, l = renderList.length; i < l; i ++ ) {

					var renderItem = renderList[ i ];

					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;

					if ( camera.isArrayCamera ) {

						_currentArrayCamera = camera;

						var cameras = camera.cameras;

						for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

							var camera2 = cameras[ j ];

							if ( object.layers.test( camera2.layers ) ) {

								state.viewport( _currentViewport.copy( camera2.viewport ) );

								currentRenderState.setupLights( camera2 );

								renderObject( object, scene, camera2, geometry, material, group );

							}

						}

					} else {

						_currentArrayCamera = null;

						renderObject( object, scene, camera, geometry, material, group );

					}

				}

			}

			function renderObject( object, scene, camera, geometry, material, group ) {

				object.onBeforeRender( _this, scene, camera, geometry, material, group );
				currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				if ( object.isImmediateRenderObject ) {

					var program = setProgram( camera, scene, material, object );

					state.setMaterial( material );

					_currentGeometryProgram.geometry = null;
					_currentGeometryProgram.program = null;
					_currentGeometryProgram.wireframe = false;

					renderObjectImmediate( object, program );

				} else {

					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				}

				object.onAfterRender( _this, scene, camera, geometry, material, group );
				currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			}

			function initMaterial( material, scene, object ) {

				var materialProperties = properties.get( material );

				var lights = currentRenderState.state.lights;
				var shadowsArray = currentRenderState.state.shadowsArray;

				var lightsStateVersion = lights.state.version;

				var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );
				var programCacheKey = programCache.getProgramCacheKey( parameters );

				var program = materialProperties.program;
				var programChange = true;

				if ( program === undefined ) {

					// new material
					material.addEventListener( 'dispose', onMaterialDispose );

				} else if ( program.cacheKey !== programCacheKey ) {

					// changed glsl or parameters
					releaseMaterialProgramReference( material );

				} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

					materialProperties.lightsStateVersion = lightsStateVersion;

					programChange = false;

				} else if ( parameters.shaderID !== undefined ) {

					// same glsl and uniform list
					return;

				} else {

					// only rebuild uniform list
					programChange = false;

				}

				if ( programChange ) {

					program = programCache.acquireProgram( parameters, programCacheKey );

					materialProperties.program = program;
					materialProperties.uniforms = parameters.uniforms;
					materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
					materialProperties.outputEncoding = _this.outputEncoding;
					material.program = program;

				}

				var programAttributes = program.getAttributes();

				if ( material.morphTargets ) {

					material.numSupportedMorphTargets = 0;

					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

						if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

							material.numSupportedMorphTargets ++;

						}

					}

				}

				if ( material.morphNormals ) {

					material.numSupportedMorphNormals = 0;

					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

						if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

							material.numSupportedMorphNormals ++;

						}

					}

				}

				var uniforms = materialProperties.uniforms;

				if ( ! material.isShaderMaterial &&
					! material.isRawShaderMaterial ||
					material.clipping === true ) {

					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;

				}

				materialProperties.fog = scene.fog;

				// store the light setup it was created for

				materialProperties.needsLights = materialNeedsLights( material );
				materialProperties.lightsStateVersion = lightsStateVersion;

				if ( materialProperties.needsLights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = lights.state.ambient;
					uniforms.lightProbe.value = lights.state.probe;
					uniforms.directionalLights.value = lights.state.directional;
					uniforms.directionalLightShadows.value = lights.state.directionalShadow;
					uniforms.spotLights.value = lights.state.spot;
					uniforms.spotLightShadows.value = lights.state.spotShadow;
					uniforms.rectAreaLights.value = lights.state.rectArea;
					uniforms.pointLights.value = lights.state.point;
					uniforms.pointLightShadows.value = lights.state.pointShadow;
					uniforms.hemisphereLights.value = lights.state.hemi;

					uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
					uniforms.spotShadowMap.value = lights.state.spotShadowMap;
					uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
					uniforms.pointShadowMap.value = lights.state.pointShadowMap;
					uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms

				}

				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
						WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.uniformsList = uniformsList;

			}

			function setProgram( camera, scene, material, object ) {

				textures.resetTextureUnits();

				var fog = scene.fog;
				var environment = material.isMeshStandardMaterial ? scene.environment : null;

				var materialProperties = properties.get( material );
				var lights = currentRenderState.state.lights;

				if ( _clippingEnabled ) {

					if ( _localClippingEnabled || camera !== _currentCamera ) {

						var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
							material.clippingPlanes, material.clipIntersection, material.clipShadows,
							camera, materialProperties, useCache );

					}

				}

				if ( material.version === materialProperties.__version ) {

					if ( materialProperties.program === undefined ) {

						initMaterial( material, scene, object );

					} else if ( material.fog && materialProperties.fog !== fog ) {

						initMaterial( material, scene, object );

					} else if ( materialProperties.environment !== environment ) {

						initMaterial( material, scene, object );

					} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

						initMaterial( material, scene, object );

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
						materialProperties.numIntersection !== _clipping.numIntersection ) ) {

						initMaterial( material, scene, object );

					} else if ( materialProperties.outputEncoding !== _this.outputEncoding ) {

						initMaterial( material, scene, object );

					}

				} else {

					initMaterial( material, scene, object );
					materialProperties.__version = material.version;

				}

				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;

				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

				if ( state.useProgram( program.program ) ) {

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || _currentCamera !== camera ) {

					p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}

					if ( _currentCamera !== camera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)

					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {

						var uCamPos = p_uniforms.map.cameraPosition;

						if ( uCamPos !== undefined ) {

							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );

						}

					}

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ) {

						p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

					}

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.skinning ) {

						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					}

				}

				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// otherwise textures used for skinning can take over texture units reserved for other material textures

				if ( material.skinning ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					var skeleton = object.skeleton;

					if ( skeleton ) {

						var bones = skeleton.bones;

						if ( capabilities.floatVertexTextures ) {

							if ( skeleton.boneTexture === undefined ) {

								// layout (1 matrix = 4 pixels)
								//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
								//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
								//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
								//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
								//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


								var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
								size = MathUtils.ceilPowerOfTwo( size );
								size = Math.max( size, 4 );

								var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
								boneMatrices.set( skeleton.boneMatrices ); // copy current values

								var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

								skeleton.boneMatrices = boneMatrices;
								skeleton.boneTexture = boneTexture;
								skeleton.boneTextureSize = size;

							}

							p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
							p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

						} else {

							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

						}

					}

				}

				if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

					materialProperties.receiveShadow = object.receiveShadow;
					p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

				}

				if ( refreshMaterial ) {

					p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
					p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

					if ( materialProperties.needsLights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog ) {

						refreshUniformsFog( m_uniforms, fog );

					}

					if ( material.isMeshBasicMaterial ) {

						refreshUniformsCommon( m_uniforms, material );

					} else if ( material.isMeshLambertMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsLambert( m_uniforms, material );

					} else if ( material.isMeshToonMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsToon( m_uniforms, material );

					} else if ( material.isMeshPhongMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsPhong( m_uniforms, material );

					} else if ( material.isMeshStandardMaterial ) {

						refreshUniformsCommon( m_uniforms, material, environment );

						if ( material.isMeshPhysicalMaterial ) {

							refreshUniformsPhysical( m_uniforms, material, environment );

						} else {

							refreshUniformsStandard( m_uniforms, material, environment );

						}

					} else if ( material.isMeshMatcapMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsMatcap( m_uniforms, material );

					} else if ( material.isMeshDepthMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsDepth( m_uniforms, material );

					} else if ( material.isMeshDistanceMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsDistance( m_uniforms, material );

					} else if ( material.isMeshNormalMaterial ) {

						refreshUniformsCommon( m_uniforms, material );
						refreshUniformsNormal( m_uniforms, material );

					} else if ( material.isLineBasicMaterial ) {

						refreshUniformsLine( m_uniforms, material );

						if ( material.isLineDashedMaterial ) {

							refreshUniformsDash( m_uniforms, material );

						}

					} else if ( material.isPointsMaterial ) {

						refreshUniformsPoints( m_uniforms, material );

					} else if ( material.isSpriteMaterial ) {

						refreshUniformsSprites( m_uniforms, material );

					} else if ( material.isShadowMaterial ) {

						m_uniforms.color.value.copy( material.color );
						m_uniforms.opacity.value = material.opacity;

					}

					// RectAreaLight Texture
					// TODO (mrdoob): Find a nicer implementation

					if ( m_uniforms.ltc_1 !== undefined ) { m_uniforms.ltc_1.value = UniformsLib.LTC_1; }
					if ( m_uniforms.ltc_2 !== undefined ) { m_uniforms.ltc_2.value = UniformsLib.LTC_2; }

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

					if ( material.isShaderMaterial ) {

						material.uniformsNeedUpdate = false; // #15581

					}

				}

				if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
					material.uniformsNeedUpdate = false;

				}

				if ( material.isSpriteMaterial ) {

					p_uniforms.setValue( _gl, 'center', object.center );

				}

				// common matrices

				p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
				p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				return program;

			}

			// Uniforms (refresh uniforms objects)

			function refreshUniformsCommon( uniforms, material, environment ) {

				uniforms.opacity.value = material.opacity;

				if ( material.color ) {

					uniforms.diffuse.value.copy( material.color );

				}

				if ( material.emissive ) {

					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

				}

				if ( material.map ) {

					uniforms.map.value = material.map;

				}

				if ( material.alphaMap ) {

					uniforms.alphaMap.value = material.alphaMap;

				}

				if ( material.specularMap ) {

					uniforms.specularMap.value = material.specularMap;

				}

				var envMap = material.envMap || environment;

				if ( envMap ) {

					uniforms.envMap.value = envMap;

					uniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;

					uniforms.reflectivity.value = material.reflectivity;
					uniforms.refractionRatio.value = material.refractionRatio;

					uniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;

				}

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.aoMap ) {

					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.specularMap ) {

					uvScaleMap = material.specularMap;

				} else if ( material.displacementMap ) {

					uvScaleMap = material.displacementMap;

				} else if ( material.normalMap ) {

					uvScaleMap = material.normalMap;

				} else if ( material.bumpMap ) {

					uvScaleMap = material.bumpMap;

				} else if ( material.roughnessMap ) {

					uvScaleMap = material.roughnessMap;

				} else if ( material.metalnessMap ) {

					uvScaleMap = material.metalnessMap;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				} else if ( material.emissiveMap ) {

					uvScaleMap = material.emissiveMap;

				}

				if ( uvScaleMap !== undefined ) {

					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {

						uvScaleMap = uvScaleMap.texture;

					}

					if ( uvScaleMap.matrixAutoUpdate === true ) {

						uvScaleMap.updateMatrix();

					}

					uniforms.uvTransform.value.copy( uvScaleMap.matrix );

				}

				// uv repeat and offset setting priorities for uv2
				// 1. ao map
				// 2. light map

				var uv2ScaleMap;

				if ( material.aoMap ) {

					uv2ScaleMap = material.aoMap;

				} else if ( material.lightMap ) {

					uv2ScaleMap = material.lightMap;

				}

				if ( uv2ScaleMap !== undefined ) {

					// backwards compatibility
					if ( uv2ScaleMap.isWebGLRenderTarget ) {

						uv2ScaleMap = uv2ScaleMap.texture;

					}

					if ( uv2ScaleMap.matrixAutoUpdate === true ) {

						uv2ScaleMap.updateMatrix();

					}

					uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

				}

			}

			function refreshUniformsLine( uniforms, material ) {

				uniforms.diffuse.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			}

			function refreshUniformsDash( uniforms, material ) {

				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;

			}

			function refreshUniformsPoints( uniforms, material ) {

				uniforms.diffuse.value.copy( material.color );
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;

				if ( material.map ) {

					uniforms.map.value = material.map;

				}

				if ( material.alphaMap ) {

					uniforms.alphaMap.value = material.alphaMap;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. alpha map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				}

				if ( uvScaleMap !== undefined ) {

					if ( uvScaleMap.matrixAutoUpdate === true ) {

						uvScaleMap.updateMatrix();

					}

					uniforms.uvTransform.value.copy( uvScaleMap.matrix );

				}

			}

			function refreshUniformsSprites( uniforms, material ) {

				uniforms.diffuse.value.copy( material.color );
				uniforms.opacity.value = material.opacity;
				uniforms.rotation.value = material.rotation;

				if ( material.map ) {

					uniforms.map.value = material.map;

				}

				if ( material.alphaMap ) {

					uniforms.alphaMap.value = material.alphaMap;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. alpha map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				}

				if ( uvScaleMap !== undefined ) {

					if ( uvScaleMap.matrixAutoUpdate === true ) {

						uvScaleMap.updateMatrix();

					}

					uniforms.uvTransform.value.copy( uvScaleMap.matrix );

				}

			}

			function refreshUniformsFog( uniforms, fog ) {

				uniforms.fogColor.value.copy( fog.color );

				if ( fog.isFog ) {

					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;

				} else if ( fog.isFogExp2 ) {

					uniforms.fogDensity.value = fog.density;

				}

			}

			function refreshUniformsLambert( uniforms, material ) {

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

			}

			function refreshUniformsPhong( uniforms, material ) {

				uniforms.specular.value.copy( material.specular );
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
					if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
					if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsToon( uniforms, material ) {

				uniforms.specular.value.copy( material.specular );
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

				if ( material.gradientMap ) {

					uniforms.gradientMap.value = material.gradientMap;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
					if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
					if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsStandard( uniforms, material, environment ) {

				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;

				if ( material.roughnessMap ) {

					uniforms.roughnessMap.value = material.roughnessMap;

				}

				if ( material.metalnessMap ) {

					uniforms.metalnessMap.value = material.metalnessMap;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
					if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
					if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

				if ( material.envMap || environment ) {

					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;

				}

			}

			function refreshUniformsPhysical( uniforms, material, environment ) {

				refreshUniformsStandard( uniforms, material, environment );

				uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
				if ( material.sheen ) { uniforms.sheen.value.copy( material.sheen ); }

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

				uniforms.transparency.value = material.transparency;

			}

			function refreshUniformsMatcap( uniforms, material ) {

				if ( material.matcap ) {

					uniforms.matcap.value = material.matcap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
					if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
					if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsDepth( uniforms, material ) {

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsDistance( uniforms, material ) {

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

				uniforms.referencePosition.value.copy( material.referencePosition );
				uniforms.nearDistance.value = material.nearDistance;
				uniforms.farDistance.value = material.farDistance;

			}

			function refreshUniformsNormal( uniforms, material ) {

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
					if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
					if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;
				uniforms.lightProbe.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.directionalLightShadows.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.pointLightShadows.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.spotLightShadows.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			function materialNeedsLights( material ) {

				return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial || material.isShadowMaterial ||
					( material.isShaderMaterial && material.lights === true );

			}

			//
			this.setFramebuffer = function ( value ) {

				if ( _framebuffer !== value && _currentRenderTarget === null ) { _gl.bindFramebuffer( 36160, value ); }

				_framebuffer = value;

			};

			this.getActiveCubeFace = function () {

				return _currentActiveCubeFace;

			};

			this.getActiveMipmapLevel = function () {

				return _currentActiveMipmapLevel;

			};

			this.getRenderTarget = function () {

				return _currentRenderTarget;

			};

			this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {

				_currentRenderTarget = renderTarget;
				_currentActiveCubeFace = activeCubeFace;
				_currentActiveMipmapLevel = activeMipmapLevel;

				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				}

				var framebuffer = _framebuffer;
				var isCube = false;

				if ( renderTarget ) {

					var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

					if ( renderTarget.isWebGLCubeRenderTarget ) {

						framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
						isCube = true;

					} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

						framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

					} else {

						framebuffer = __webglFramebuffer;

					}

					_currentViewport.copy( renderTarget.viewport );
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

				} else {

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
					_currentScissorTest = _scissorTest;

				}

				if ( _currentFramebuffer !== framebuffer ) {

					_gl.bindFramebuffer( 36160, framebuffer );
					_currentFramebuffer = framebuffer;

				}

				state.viewport( _currentViewport );
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				if ( isCube ) {

					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipmapLevel || 0 );

				}

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

					framebuffer = framebuffer[ activeCubeFaceIndex ];

				}

				if ( framebuffer ) {

					var restore = false;

					if ( framebuffer !== _currentFramebuffer ) {

						_gl.bindFramebuffer( 36160, framebuffer );

						restore = true;

					}

					try {

						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;

						if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

								_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

							}

						} else {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

						}

					} finally {

						if ( restore ) {

							_gl.bindFramebuffer( 36160, _currentFramebuffer );

						}

					}

				}

			};

			this.copyFramebufferToTexture = function ( position, texture, level ) {

				if ( level === undefined ) { level = 0; }

				var levelScale = Math.pow( 2, - level );
				var width = Math.floor( texture.image.width * levelScale );
				var height = Math.floor( texture.image.height * levelScale );
				var glFormat = utils.convert( texture.format );

				textures.setTexture2D( texture, 0 );

				_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

				state.unbindTexture();

			};

			this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

				var width = srcTexture.image.width;
				var height = srcTexture.image.height;
				var glFormat = utils.convert( dstTexture.format );
				var glType = utils.convert( dstTexture.type );

				textures.setTexture2D( dstTexture, 0 );

				if ( srcTexture.isDataTexture ) {

					_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

				} else {

					_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

				}

				state.unbindTexture();

			};

			this.initTexture = function ( texture ) {

				textures.setTexture2D( texture, 0 );

				state.unbindTexture();

			};

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function FogExp2( color, density ) {

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		Object.assign( FogExp2.prototype, {

			isFogExp2: true,

			clone: function () {

				return new FogExp2( this.color, this.density );

			},

			toJSON: function ( /* meta */ ) {

				return {
					type: 'FogExp2',
					color: this.color.getHex(),
					density: this.density
				};

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Fog( color, near, far ) {

			this.name = '';

			this.color = new Color( color );

			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;

		}

		Object.assign( Fog.prototype, {

			isFog: true,

			clone: function () {

				return new Fog( this.color, this.near, this.far );

			},

			toJSON: function ( /* meta */ ) {

				return {
					type: 'Fog',
					color: this.color.getHex(),
					near: this.near,
					far: this.far
				};

			}

		} );

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBuffer( array, stride ) {

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

			set: function ( value ) {

				if ( value === true ) { this.version ++; }

			}

		} );

		Object.assign( InterleavedBuffer.prototype, {

			isInterleavedBuffer: true,

			onUploadCallback: function () {},

			setUsage: function ( value ) {

				this.usage = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.usage = source.usage;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.stride;
				index2 *= attribute.stride;

				for ( var i = 0, l = this.stride; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) { offset = 0; }

				this.array.set( value, offset );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			onUpload: function ( callback ) {

				this.onUploadCallback = callback;

				return this;

			}

		} );

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		var _vector$6 = new Vector3();

		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}

		Object.defineProperties( InterleavedBufferAttribute.prototype, {

			count: {

				get: function () {

					return this.data.count;

				}

			},

			array: {

				get: function () {

					return this.data.array;

				}

			}

		} );

		Object.assign( InterleavedBufferAttribute.prototype, {

			isInterleavedBufferAttribute: true,

			applyMatrix4: function ( m ) {

				for ( var i = 0, l = this.data.count; i < l; i ++ ) {

					_vector$6.x = this.getX( i );
					_vector$6.y = this.getY( i );
					_vector$6.z = this.getZ( i );

					_vector$6.applyMatrix4( m );

					this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

				}

				return this;

			},

			setX: function ( index, x ) {

				this.data.array[ index * this.data.stride + this.offset ] = x;

				return this;

			},

			setY: function ( index, y ) {

				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

				return this;

			},

			setZ: function ( index, z ) {

				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

				return this;

			},

			setW: function ( index, w ) {

				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

				return this;

			},

			getX: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset ];

			},

			getY: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 1 ];

			},

			getZ: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 2 ];

			},

			getW: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 3 ];

			},

			setXY: function ( index, x, y ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;

				return this;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  map: new THREE.Texture( <Image> ),
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *  rotation: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */

		function SpriteMaterial( parameters ) {

			Material.call( this );

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.setValues( parameters );

		}

		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;
		SpriteMaterial.prototype.isSpriteMaterial = true;

		SpriteMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		var _geometry;

		var _intersectPoint = new Vector3();
		var _worldScale = new Vector3();
		var _mvPosition = new Vector3();

		var _alignedPosition = new Vector2();
		var _rotatedPosition = new Vector2();
		var _viewWorldMatrix = new Matrix4();

		var _vA$1 = new Vector3();
		var _vB$1 = new Vector3();
		var _vC$1 = new Vector3();

		var _uvA$1 = new Vector2();
		var _uvB$1 = new Vector2();
		var _uvC$1 = new Vector2();

		function Sprite( material ) {

			Object3D.call( this );

			this.type = 'Sprite';

			if ( _geometry === undefined ) {

				_geometry = new BufferGeometry();

				var float32Array = new Float32Array( [
					- 0.5, - 0.5, 0, 0, 0,
					0.5, - 0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					- 0.5, 0.5, 0, 0, 1
				] );

				var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

				_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
				_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
				_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

			}

			this.geometry = _geometry;
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

			this.center = new Vector2( 0.5, 0.5 );

		}

		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Sprite,

			isSprite: true,

			raycast: function ( raycaster, intersects ) {

				if ( raycaster.camera === null ) {

					console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

				}

				_worldScale.setFromMatrixScale( this.matrixWorld );

				_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
				this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

				_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

				if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

					_worldScale.multiplyScalar( - _mvPosition.z );

				}

				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {

					cos = Math.cos( rotation );
					sin = Math.sin( rotation );

				}

				var center = this.center;

				transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
				transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
				transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

				_uvA$1.set( 0, 0 );
				_uvB$1.set( 1, 0 );
				_uvC$1.set( 1, 1 );

				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );

				if ( intersect === null ) {

					// check second triangle
					transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
					_uvB$1.set( 0, 1 );

					intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
					if ( intersect === null ) {

						return;

					}

				}

				var distance = raycaster.ray.origin.distanceTo( _intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) { return; }

				intersects.push( {

					distance: distance,
					point: _intersectPoint.clone(),
					uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
					face: null,
					object: this

				} );

			},

			clone: function () {

				return new this.constructor( this.material ).copy( this );

			},

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				if ( source.center !== undefined ) { this.center.copy( source.center ); }

				return this;

			}


		} );

		function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

			// compute position in camera space
			_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

			// to check if rotation is not zero
			if ( sin !== undefined ) {

				_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
				_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

			} else {

				_rotatedPosition.copy( _alignedPosition );

			}


			vertexPosition.copy( mvPosition );
			vertexPosition.x += _rotatedPosition.x;
			vertexPosition.y += _rotatedPosition.y;

			// transform to world space
			vertexPosition.applyMatrix4( _viewWorldMatrix );

		}

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _v1$4 = new Vector3();
		var _v2$2 = new Vector3();

		function LOD() {

			Object3D.call( this );

			this._currentLevel = 0;

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );

			this.autoUpdate = true;

		}

		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LOD,

			isLOD: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source, false );

				var levels = source.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					this.addLevel( level.object.clone(), level.distance );

				}

				this.autoUpdate = source.autoUpdate;

				return this;

			},

			addLevel: function ( object, distance ) {

				if ( distance === undefined ) { distance = 0; }

				distance = Math.abs( distance );

				var levels = this.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					if ( distance < levels[ l ].distance ) {

						break;

					}

				}

				levels.splice( l, 0, { distance: distance, object: object } );

				this.add( object );

				return this;

			},

			getCurrentLevel: function () {

				return this._currentLevel;

			},

			getObjectForDistance: function ( distance ) {

				var levels = this.levels;

				if ( levels.length > 0 ) {

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance < levels[ i ].distance ) {

							break;

						}

					}

					return levels[ i - 1 ].object;

				}

				return null;

			},

			raycast: function ( raycaster, intersects ) {

				var levels = this.levels;

				if ( levels.length > 0 ) {

					_v1$4.setFromMatrixPosition( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( _v1$4 );

					this.getObjectForDistance( distance ).raycast( raycaster, intersects );

				}

			},

			update: function ( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					_v1$4.setFromMatrixPosition( camera.matrixWorld );
					_v2$2.setFromMatrixPosition( this.matrixWorld );

					var distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					this._currentLevel = i - 1;

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				if ( this.autoUpdate === false ) { data.object.autoUpdate = false; }

				data.object.levels = [];

				var levels = this.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );

				}

				return data;

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function SkinnedMesh( geometry, material ) {

			if ( geometry && geometry.isGeometry ) {

				console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			Mesh.call( this, geometry, material );

			this.type = 'SkinnedMesh';

			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

		}

		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

			constructor: SkinnedMesh,

			isSkinnedMesh: true,

			bind: function ( skeleton, bindMatrix ) {

				this.skeleton = skeleton;

				if ( bindMatrix === undefined ) {

					this.updateMatrixWorld( true );

					this.skeleton.calculateInverses();

					bindMatrix = this.matrixWorld;

				}

				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );

			},

			pose: function () {

				this.skeleton.pose();

			},

			normalizeSkinWeights: function () {

				var vector = new Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

					vector.x = skinWeight.getX( i );
					vector.y = skinWeight.getY( i );
					vector.z = skinWeight.getZ( i );
					vector.w = skinWeight.getW( i );

					var scale = 1.0 / vector.manhattanLength();

					if ( scale !== Infinity ) {

						vector.multiplyScalar( scale );

					} else {

						vector.set( 1, 0, 0, 0 ); // do something reasonable

					}

					skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

				}

			},

			updateMatrixWorld: function ( force ) {

				Mesh.prototype.updateMatrixWorld.call( this, force );

				if ( this.bindMode === 'attached' ) {

					this.bindMatrixInverse.getInverse( this.matrixWorld );

				} else if ( this.bindMode === 'detached' ) {

					this.bindMatrixInverse.getInverse( this.bindMatrix );

				} else {

					console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

				}

			},

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */

		var _offsetMatrix = new Matrix4();
		var _identityMatrix = new Matrix4();

		function Skeleton( bones, boneInverses ) {

			// copy the bone array

			bones = bones || [];

			this.bones = bones.slice( 0 );
			this.boneMatrices = new Float32Array( this.bones.length * 16 );

			this.frame = - 1;

			// use the supplied bone inverses or calculate the inverses

			if ( boneInverses === undefined ) {

				this.calculateInverses();

			} else {

				if ( this.bones.length === boneInverses.length ) {

					this.boneInverses = boneInverses.slice( 0 );

				} else {

					console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

					this.boneInverses = [];

					for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		Object.assign( Skeleton.prototype, {

			calculateInverses: function () {

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					var inverse = new Matrix4();

					if ( this.bones[ i ] ) {

						inverse.getInverse( this.bones[ i ].matrixWorld );

					}

					this.boneInverses.push( inverse );

				}

			},

			pose: function () {

				var bone, i, il;

				// recover the bind-time world matrices

				for ( i = 0, il = this.bones.length; i < il; i ++ ) {

					bone = this.bones[ i ];

					if ( bone ) {

						bone.matrixWorld.getInverse( this.boneInverses[ i ] );

					}

				}

				// compute the local matrices, positions, rotations and scales

				for ( i = 0, il = this.bones.length; i < il; i ++ ) {

					bone = this.bones[ i ];

					if ( bone ) {

						if ( bone.parent && bone.parent.isBone ) {

							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );

						} else {

							bone.matrix.copy( bone.matrixWorld );

						}

						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

					}

				}

			},

			update: function () {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

					_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					_offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			},

			clone: function () {

				return new Skeleton( this.bones, this.boneInverses );

			},

			getBoneByName: function ( name ) {

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					var bone = this.bones[ i ];

					if ( bone.name === name ) {

						return bone;

					}

				}

				return undefined;

			},

			dispose: function ( ) {

				if ( this.boneTexture ) {

					this.boneTexture.dispose();

					this.boneTexture = undefined;

				}

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function Bone() {

			Object3D.call( this );

			this.type = 'Bone';

		}

		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Bone,

			isBone: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _instanceLocalMatrix = new Matrix4();
		var _instanceWorldMatrix = new Matrix4();

		var _instanceIntersects = [];

		var _mesh = new Mesh();

		function InstancedMesh( geometry, material, count ) {

			Mesh.call( this, geometry, material );

			this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );

			this.count = count;

			this.frustumCulled = false;

		}

		InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

			constructor: InstancedMesh,

			isInstancedMesh: true,

			getMatrixAt: function ( index, matrix ) {

				matrix.fromArray( this.instanceMatrix.array, index * 16 );

			},

			raycast: function ( raycaster, intersects ) {

				var matrixWorld = this.matrixWorld;
				var raycastTimes = this.count;

				_mesh.geometry = this.geometry;
				_mesh.material = this.material;

				if ( _mesh.material === undefined ) { return; }

				for ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

					// calculate the world matrix for each instance

					this.getMatrixAt( instanceId, _instanceLocalMatrix );

					_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

					// the mesh represents this single instance

					_mesh.matrixWorld = _instanceWorldMatrix;

					_mesh.raycast( raycaster, _instanceIntersects );

					// process the result of raycast

					if ( _instanceIntersects.length > 0 ) {

						_instanceIntersects[ 0 ].instanceId = instanceId;
						_instanceIntersects[ 0 ].object = this;

						intersects.push( _instanceIntersects[ 0 ] );

						_instanceIntersects.length = 0;

					}

				}

			},

			setMatrixAt: function ( index, matrix ) {

				matrix.toArray( this.instanceMatrix.array, index * 16 );

			},

			updateMorphTargets: function () {

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */

		function LineBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.setValues( parameters );

		}

		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;

		LineBasicMaterial.prototype.isLineBasicMaterial = true;

		LineBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _start = new Vector3();
		var _end = new Vector3();
		var _inverseMatrix$1 = new Matrix4();
		var _ray$1 = new Ray();
		var _sphere$2 = new Sphere();

		function Line( geometry, material, mode ) {

			if ( mode === 1 ) {

				console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

			}

			Object3D.call( this );

			this.type = 'Line';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial();

		}

		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Line,

			isLine: true,

			computeLineDistances: function () {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							_start.fromBufferAttribute( positionAttribute, i - 1 );
							_end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += _start.distanceTo( _end );

						}

						geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			},

			raycast: function ( raycaster, intersects ) {

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Line.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

				_sphere$2.copy( geometry.boundingSphere );
				_sphere$2.applyMatrix4( matrixWorld );
				_sphere$2.radius += threshold;

				if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) { return; }

				//

				_inverseMatrix$1.getInverse( matrixWorld );
				_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localThresholdSq ) { continue; }

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > localThresholdSq ) { continue; }

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > localThresholdSq ) { continue; }

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			},

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _start$1 = new Vector3();
		var _end$1 = new Vector3();

		function LineSegments( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineSegments';

		}

		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

			constructor: LineSegments,

			isLineSegments: true,

			computeLineDistances: function () {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							_start$1.fromBufferAttribute( positionAttribute, i );
							_end$1.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

						}

						geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						_start$1.copy( vertices[ i ] );
						_end$1.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

					}

				}

				return this;

			}

		} );

		/**
		 * @author mgreter / http://github.com/mgreter
		 */

		function LineLoop( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineLoop';

		}

		LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

			constructor: LineLoop,

			isLineLoop: true,

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 *
		 *  morphTargets: <bool>
		 * }
		 */

		function PointsMaterial( parameters ) {

			Material.call( this );

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.morphTargets = false;

			this.setValues( parameters );

		}

		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;

		PointsMaterial.prototype.isPointsMaterial = true;

		PointsMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.morphTargets = source.morphTargets;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		var _inverseMatrix$2 = new Matrix4();
		var _ray$2 = new Ray();
		var _sphere$3 = new Sphere();
		var _position$1 = new Vector3();

		function Points( geometry, material ) {

			Object3D.call( this );

			this.type = 'Points';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial();

			this.updateMorphTargets();

		}

		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Points,

			isPoints: true,

			raycast: function ( raycaster, intersects ) {

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

				_sphere$3.copy( geometry.boundingSphere );
				_sphere$3.applyMatrix4( matrixWorld );
				_sphere$3.radius += threshold;

				if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) { return; }

				//

				_inverseMatrix$2.getInverse( matrixWorld );
				_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							_position$1.fromArray( positions, a * 3 );

							testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							_position$1.fromArray( positions, i * 3 );

							testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				}

			},

			updateMorphTargets: function () {

				var geometry = this.geometry;
				var m, ml, name;

				if ( geometry.isBufferGeometry ) {

					var morphAttributes = geometry.morphAttributes;
					var keys = Object.keys( morphAttributes );

					if ( keys.length > 0 ) {

						var morphAttribute = morphAttributes[ keys[ 0 ] ];

						if ( morphAttribute !== undefined ) {

							this.morphTargetInfluences = [];
							this.morphTargetDictionary = {};

							for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

								name = morphAttribute[ m ].name || String( m );

								this.morphTargetInfluences.push( 0 );
								this.morphTargetDictionary[ name ] = m;

							}

						}

					}

				} else {

					var morphTargets = geometry.morphTargets;

					if ( morphTargets !== undefined && morphTargets.length > 0 ) {

						console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

					}

				}

			},

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

			var rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

			if ( rayPointDistanceSq < localThresholdSq ) {

				var intersectPoint = new Vector3();

				_ray$2.closestPointToPoint( point, intersectPoint );
				intersectPoint.applyMatrix4( matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) { return; }

				intersects.push( {

					distance: distance,
					distanceToRay: Math.sqrt( rayPointDistanceSq ),
					point: intersectPoint,
					index: index,
					face: null,
					object: object

				} );

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.format = format !== undefined ? format : RGBFormat;

			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

			this.generateMipmaps = false;

		}

		VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

			constructor: VideoTexture,

			isVideoTexture: true,

			update: function () {

				var video = this.image;

				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

					this.needsUpdate = true;

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;

		CompressedTexture.prototype.isCompressedTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;
		CanvasTexture.prototype.isCanvasTexture = true;

		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */

		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			if ( type === undefined && format === DepthFormat ) { type = UnsignedShortType; }
			if ( type === undefined && format === DepthStencilFormat ) { type = UnsignedInt248Type; }

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps	= false;

		}

		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function WireframeGeometry( geometry ) {

			BufferGeometry.call( this );

			this.type = 'WireframeGeometry';

			// buffer

			var vertices = [];

			// helper variables

			var i, j, l, o, ol;
			var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
			var key, keys = [ 'a', 'b', 'c' ];
			var vertex;

			// different logic for Geometry and BufferGeometry

			if ( geometry && geometry.isGeometry ) {

				// create a data structure that contains all edges without duplicates

				var faces = geometry.faces;

				for ( i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( j = 0; j < 3; j ++ ) {

						edge1 = face[ keys[ j ] ];
						edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex = geometry.vertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex = geometry.vertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else if ( geometry && geometry.isBufferGeometry ) {

				var position, indices, groups;
				var group, start, count;
				var index1, index2;

				vertex = new Vector3();

				if ( geometry.index !== null ) {

					// indexed BufferGeometry

					position = geometry.attributes.position;
					indices = geometry.index;
					groups = geometry.groups;

					if ( groups.length === 0 ) {

						groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

					}

					// create a data structure that contains all eges without duplicates

					for ( o = 0, ol = groups.length; o < ol; ++ o ) {

						group = groups[ o ];

						start = group.start;
						count = group.count;

						for ( i = start, l = ( start + count ); i < l; i += 3 ) {

							for ( j = 0; j < 3; j ++ ) {

								edge1 = indices.getX( i + j );
								edge2 = indices.getX( i + ( j + 1 ) % 3 );
								edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
								edge[ 1 ] = Math.max( edge1, edge2 );

								key = edge[ 0 ] + ',' + edge[ 1 ];

								if ( edges[ key ] === undefined ) {

									edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

								}

							}

						}

					}

					// generate vertices

					for ( key in edges ) {

						e = edges[ key ];

						vertex.fromBufferAttribute( position, e.index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						vertex.fromBufferAttribute( position, e.index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				} else {

					// non-indexed BufferGeometry

					position = geometry.attributes.position;

					for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

						for ( j = 0; j < 3; j ++ ) {

							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

							index1 = 3 * i + j;
							vertex.fromBufferAttribute( position, index1 );
							vertices.push( vertex.x, vertex.y, vertex.z );

							index2 = 3 * i + ( ( j + 1 ) % 3 );
							vertex.fromBufferAttribute( position, index2 );
							vertices.push( vertex.x, vertex.y, vertex.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;

		/**
		 * @author zz85 / https://github.com/zz85
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
		 */

		// ParametricGeometry

		function ParametricGeometry( func, slices, stacks ) {

			Geometry.call( this );

			this.type = 'ParametricGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();

		}

		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;

		// ParametricBufferGeometry

		function ParametricBufferGeometry( func, slices, stacks ) {

			BufferGeometry.call( this );

			this.type = 'ParametricBufferGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			var EPS = 0.00001;

			var normal = new Vector3();

			var p0 = new Vector3(), p1 = new Vector3();
			var pu = new Vector3(), pv = new Vector3();

			var i, j;

			if ( func.length < 3 ) {

				console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

			}

			// generate vertices, normals and uvs

			var sliceCount = slices + 1;

			for ( i = 0; i <= stacks; i ++ ) {

				var v = i / stacks;

				for ( j = 0; j <= slices; j ++ ) {

					var u = j / slices;

					// vertex

					func( u, v, p0 );
					vertices.push( p0.x, p0.y, p0.z );

					// normal

					// approximate tangent vectors via finite differences

					if ( u - EPS >= 0 ) {

						func( u - EPS, v, p1 );
						pu.subVectors( p0, p1 );

					} else {

						func( u + EPS, v, p1 );
						pu.subVectors( p1, p0 );

					}

					if ( v - EPS >= 0 ) {

						func( u, v - EPS, p1 );
						pv.subVectors( p0, p1 );

					} else {

						func( u, v + EPS, p1 );
						pv.subVectors( p1, p0 );

					}

					// cross product of tangent vectors returns surface normal

					normal.crossVectors( pu, pv ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, v );

				}

			}

			// generate indices

			for ( i = 0; i < stacks; i ++ ) {

				for ( j = 0; j < slices; j ++ ) {

					var a = i * sliceCount + j;
					var b = i * sliceCount + j + 1;
					var c = ( i + 1 ) * sliceCount + j + 1;
					var d = ( i + 1 ) * sliceCount + j;

					// faces one and two

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// PolyhedronGeometry

		function PolyhedronGeometry( vertices, indices, radius, detail ) {

			Geometry.call( this );

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();

		}

		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

		// PolyhedronBufferGeometry

		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

			BufferGeometry.call( this );

			this.type = 'PolyhedronBufferGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			radius = radius || 1;
			detail = detail || 0;

			// default buffer data

			var vertexBuffer = [];
			var uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

			if ( detail === 0 ) {

				this.computeVertexNormals(); // flat normals

			} else {

				this.normalizeNormals(); // smooth normals

			}

			// helper functions

			function subdivide( detail ) {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( var i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				var cols = Math.pow( 2, detail );

				// we use this multidimensional array as a data structure for creating the subdivision

				var v = [];

				var i, j;

				// construct all of the vertices for this subdivision

				for ( i = 0; i <= cols; i ++ ) {

					v[ i ] = [];

					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );

					var rows = cols - i;

					for ( j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( i = 0; i < cols; i ++ ) {

					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						var k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function applyRadius( radius ) {

				var vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				var vertex = new Vector3();

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( var i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];

					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }
						if ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }
						if ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				var stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				var centroid = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					var azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] = uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// TetrahedronGeometry

		function TetrahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

		// TetrahedronBufferGeometry

		function TetrahedronBufferGeometry( radius, detail ) {

			var vertices = [
				1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
			];

			var indices = [
				2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'TetrahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// OctahedronGeometry

		function OctahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;

		// OctahedronBufferGeometry

		function OctahedronBufferGeometry( radius, detail ) {

			var vertices = [
				1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
				0, - 1, 0, 	0, 0, 1,	0, 0, - 1
			];

			var indices = [
				0, 2, 4,	0, 4, 3,	0, 3, 5,
				0, 5, 2,	1, 2, 5,	1, 5, 3,
				1, 3, 4,	1, 4, 2
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'OctahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// IcosahedronGeometry

		function IcosahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

		// IcosahedronBufferGeometry

		function IcosahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;

			var vertices = [
				- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
				 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
				 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
			];

			var indices = [
				 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
				 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
				 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
				 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'IcosahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

		/**
		 * @author Abe Pazos / https://hamoid.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// DodecahedronGeometry

		function DodecahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

		// DodecahedronBufferGeometry

		function DodecahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;

			var vertices = [

				// (±1, ±1, ±1)
				- 1, - 1, - 1,	- 1, - 1, 1,
				- 1, 1, - 1, - 1, 1, 1,
				1, - 1, - 1, 1, - 1, 1,
				1, 1, - 1, 1, 1, 1,

				// (0, ±1/φ, ±φ)
				 0, - r, - t, 0, - r, t,
				 0, r, - t, 0, r, t,

				// (±1/φ, ±φ, 0)
				- r, - t, 0, - r, t, 0,
				 r, - t, 0, r, t, 0,

				// (±φ, 0, ±1/φ)
				- t, 0, - r, t, 0, - r,
				- t, 0, r, t, 0, r
			];

			var indices = [
				3, 11, 7, 	3, 7, 15, 	3, 15, 13,
				7, 19, 17, 	7, 17, 6, 	7, 6, 15,
				17, 4, 8, 	17, 8, 10, 	17, 10, 6,
				8, 0, 16, 	8, 16, 2, 	8, 2, 10,
				0, 12, 1, 	0, 1, 18, 	0, 18, 16,
				6, 10, 2, 	6, 2, 13, 	6, 13, 15,
				2, 16, 18, 	2, 18, 3, 	2, 3, 13,
				18, 1, 9, 	18, 9, 11, 	18, 11, 3,
				4, 14, 12, 	4, 12, 0, 	4, 0, 8,
				11, 9, 5, 	11, 5, 19, 	11, 19, 7,
				19, 5, 14, 	19, 14, 4, 	19, 4, 17,
				1, 12, 14, 	1, 14, 5, 	1, 5, 9
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'DodecahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 */

		// TubeGeometry

		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

			Geometry.call( this );

			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			if ( taper !== undefined ) { console.warn( 'THREE.TubeGeometry: taper has been removed.' ); }

			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

			// expose internals

			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;

			// create geometry

			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();

		}

		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;

		// TubeBufferGeometry

		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

			BufferGeometry.call( this );

			this.type = 'TubeBufferGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;

			var frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
			var P = new Vector3();

			var i, j;

			// buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				P = path.getPointAt( i / tubularSegments, P );

				// retrieve corresponding normal and binormal

				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( j = 0; j <= radialSegments; j ++ ) {

					var v = j / radialSegments * Math.PI * 2;

					var sin = Math.sin( v );
					var cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( j = 1; j <= tubularSegments; j ++ ) {

					for ( i = 1; i <= radialSegments; i ++ ) {

						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					for ( j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}

		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

		TubeBufferGeometry.prototype.toJSON = function () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			data.path = this.parameters.path.toJSON();

			return data;

		};

		/**
		 * @author oosmoxiecode
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://www.blackpawn.com/texts/pqtorus/
		 */

		// TorusKnotGeometry

		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

			Geometry.call( this );

			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			if ( heightScale !== undefined ) { console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ); }

			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();

		}

		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

		// TorusKnotBufferGeometry

		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

			BufferGeometry.call( this );

			this.type = 'TorusKnotBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			radius = radius || 1;
			tube = tube || 0.4;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var i, j;

			var vertex = new Vector3();
			var normal = new Vector3();

			var P1 = new Vector3();
			var P2 = new Vector3();

			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();

			// generate vertices, normals and uvs

			for ( i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				var u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors( vertex, P1 ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					// indices

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// TorusGeometry

		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			Geometry.call( this );

			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
			this.mergeVertices();

		}

		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;

		// TorusBufferGeometry

		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			BufferGeometry.call( this );

			this.type = 'TorusBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radius = radius || 1;
			tube = tube || 0.4;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();

			var j, i;

			// generate vertices, normals and uvs

			for ( j = 0; j <= radialSegments; j ++ ) {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;

					// vertex

					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( j = 1; j <= radialSegments; j ++ ) {

				for ( i = 1; i <= tubularSegments; i ++ ) {

					// indices

					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 * Port from https://github.com/mapbox/earcut (v2.1.5)
		 */

		var Earcut = {

			triangulate: function ( data, holeIndices, dim ) {

				dim = dim || 2;

				var hasHoles = holeIndices && holeIndices.length,
					outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
					outerNode = linkedList( data, 0, outerLen, dim, true ),
					triangles = [];

				if ( ! outerNode || outerNode.next === outerNode.prev ) { return triangles; }

				var minX, minY, maxX, maxY, x, y, invSize;

				if ( hasHoles ) { outerNode = eliminateHoles( data, holeIndices, outerNode, dim ); }

				// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
				if ( data.length > 80 * dim ) {

					minX = maxX = data[ 0 ];
					minY = maxY = data[ 1 ];

					for ( var i = dim; i < outerLen; i += dim ) {

						x = data[ i ];
						y = data[ i + 1 ];
						if ( x < minX ) { minX = x; }
						if ( y < minY ) { minY = y; }
						if ( x > maxX ) { maxX = x; }
						if ( y > maxY ) { maxY = y; }

					}

					// minX, minY and invSize are later used to transform coords into integers for z-order calculation
					invSize = Math.max( maxX - minX, maxY - minY );
					invSize = invSize !== 0 ? 1 / invSize : 0;

				}

				earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

				return triangles;

			}

		};

		// create a circular doubly linked list from polygon points in the specified winding order
		function linkedList( data, start, end, dim, clockwise ) {

			var i, last;

			if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

				for ( i = start; i < end; i += dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

			} else {

				for ( i = end - dim; i >= start; i -= dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

			}

			if ( last && equals( last, last.next ) ) {

				removeNode( last );
				last = last.next;

			}

			return last;

		}

		// eliminate colinear or duplicate points
		function filterPoints( start, end ) {

			if ( ! start ) { return start; }
			if ( ! end ) { end = start; }

			var p = start,
				again;
			do {

				again = false;

				if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

					removeNode( p );
					p = end = p.prev;
					if ( p === p.next ) { break; }
					again = true;

				} else {

					p = p.next;

				}

			} while ( again || p !== end );

			return end;

		}

		// main ear slicing loop which triangulates a polygon (given as a linked list)
		function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

			if ( ! ear ) { return; }

			// interlink polygon nodes in z-order
			if ( ! pass && invSize ) { indexCurve( ear, minX, minY, invSize ); }

			var stop = ear,
				prev, next;

			// iterate through ears, slicing them one by one
			while ( ear.prev !== ear.next ) {

				prev = ear.prev;
				next = ear.next;

				if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

					// cut off the triangle
					triangles.push( prev.i / dim );
					triangles.push( ear.i / dim );
					triangles.push( next.i / dim );

					removeNode( ear );

					// skipping the next vertex leads to less sliver triangles
					ear = next.next;
					stop = next.next;

					continue;

				}

				ear = next;

				// if we looped through the whole remaining polygon and can't find any more ears
				if ( ear === stop ) {

					// try filtering points and slicing again
					if ( ! pass ) {

						earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

						// if this didn't work, try curing all small self-intersections locally

					} else if ( pass === 1 ) {

						ear = cureLocalIntersections( ear, triangles, dim );
						earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

						// as a last resort, try splitting the remaining polygon into two

					} else if ( pass === 2 ) {

						splitEarcut( ear, triangles, dim, minX, minY, invSize );

					}

					break;

				}

			}

		}

		// check whether a polygon node forms a valid ear with adjacent nodes
		function isEar( ear ) {

			var a = ear.prev,
				b = ear,
				c = ear.next;

			if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

			// now make sure we don't have other points inside the potential ear
			var p = ear.next.next;

			while ( p !== ear.prev ) {

				if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) { return false; }
				p = p.next;

			}

			return true;

		}

		function isEarHashed( ear, minX, minY, invSize ) {

			var a = ear.prev,
				b = ear,
				c = ear.next;

			if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

			// triangle bbox; min & max are calculated like this for speed
			var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
				minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
				maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
				maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

			// z-order range for the current triangle bbox;
			var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
				maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

			var p = ear.prevZ,
				n = ear.nextZ;

			// look for points inside the triangle in both directions
			while ( p && p.z >= minZ && n && n.z <= maxZ ) {

				if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) { return false; }
				p = p.prevZ;

				if ( n !== ear.prev && n !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
					area( n.prev, n, n.next ) >= 0 ) { return false; }
				n = n.nextZ;

			}

			// look for remaining points in decreasing z-order
			while ( p && p.z >= minZ ) {

				if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) { return false; }
				p = p.prevZ;

			}

			// look for remaining points in increasing z-order
			while ( n && n.z <= maxZ ) {

				if ( n !== ear.prev && n !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
					area( n.prev, n, n.next ) >= 0 ) { return false; }
				n = n.nextZ;

			}

			return true;

		}

		// go through all polygon nodes and cure small local self-intersections
		function cureLocalIntersections( start, triangles, dim ) {

			var p = start;
			do {

				var a = p.prev,
					b = p.next.next;

				if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

					triangles.push( a.i / dim );
					triangles.push( p.i / dim );
					triangles.push( b.i / dim );

					// remove two nodes involved
					removeNode( p );
					removeNode( p.next );

					p = start = b;

				}

				p = p.next;

			} while ( p !== start );

			return p;

		}

		// try splitting polygon into two and triangulate them independently
		function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

			// look for a valid diagonal that divides the polygon into two
			var a = start;
			do {

				var b = a.next.next;
				while ( b !== a.prev ) {

					if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

						// split the polygon in two by the diagonal
						var c = splitPolygon( a, b );

						// filter colinear points around the cuts
						a = filterPoints( a, a.next );
						c = filterPoints( c, c.next );

						// run earcut on each half
						earcutLinked( a, triangles, dim, minX, minY, invSize );
						earcutLinked( c, triangles, dim, minX, minY, invSize );
						return;

					}

					b = b.next;

				}

				a = a.next;

			} while ( a !== start );

		}

		// link every hole into the outer loop, producing a single-ring polygon without holes
		function eliminateHoles( data, holeIndices, outerNode, dim ) {

			var queue = [],
				i, len, start, end, list;

			for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

				start = holeIndices[ i ] * dim;
				end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
				list = linkedList( data, start, end, dim, false );
				if ( list === list.next ) { list.steiner = true; }
				queue.push( getLeftmost( list ) );

			}

			queue.sort( compareX );

			// process holes from left to right
			for ( i = 0; i < queue.length; i ++ ) {

				eliminateHole( queue[ i ], outerNode );
				outerNode = filterPoints( outerNode, outerNode.next );

			}

			return outerNode;

		}

		function compareX( a, b ) {

			return a.x - b.x;

		}

		// find a bridge between vertices that connects hole with an outer ring and and link it
		function eliminateHole( hole, outerNode ) {

			outerNode = findHoleBridge( hole, outerNode );
			if ( outerNode ) {

				var b = splitPolygon( outerNode, hole );
				filterPoints( b, b.next );

			}

		}

		// David Eberly's algorithm for finding a bridge between hole and outer polygon
		function findHoleBridge( hole, outerNode ) {

			var p = outerNode,
				hx = hole.x,
				hy = hole.y,
				qx = - Infinity,
				m;

			// find a segment intersected by a ray from the hole's leftmost point to the left;
			// segment's endpoint with lesser x will be potential connection point
			do {

				if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

					var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
					if ( x <= hx && x > qx ) {

						qx = x;
						if ( x === hx ) {

							if ( hy === p.y ) { return p; }
							if ( hy === p.next.y ) { return p.next; }

						}

						m = p.x < p.next.x ? p : p.next;

					}

				}

				p = p.next;

			} while ( p !== outerNode );

			if ( ! m ) { return null; }

			if ( hx === qx ) { return m.prev; } // hole touches outer segment; pick lower endpoint

			// look for points inside the triangle of hole point, segment intersection and endpoint;
			// if there are no points found, we have a valid connection;
			// otherwise choose the point of the minimum angle with the ray as connection point

			var stop = m,
				mx = m.x,
				my = m.y,
				tanMin = Infinity,
				tan;

			p = m.next;

			while ( p !== stop ) {

				if ( hx >= p.x && p.x >= mx && hx !== p.x &&
						pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

					tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

					if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

						m = p;
						tanMin = tan;

					}

				}

				p = p.next;

			}

			return m;

		}

		// interlink polygon nodes in z-order
		function indexCurve( start, minX, minY, invSize ) {

			var p = start;
			do {

				if ( p.z === null ) { p.z = zOrder( p.x, p.y, minX, minY, invSize ); }
				p.prevZ = p.prev;
				p.nextZ = p.next;
				p = p.next;

			} while ( p !== start );

			p.prevZ.nextZ = null;
			p.prevZ = null;

			sortLinked( p );

		}

		// Simon Tatham's linked list merge sort algorithm
		// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
		function sortLinked( list ) {

			var i, p, q, e, tail, numMerges, pSize, qSize,
				inSize = 1;

			do {

				p = list;
				list = null;
				tail = null;
				numMerges = 0;

				while ( p ) {

					numMerges ++;
					q = p;
					pSize = 0;
					for ( i = 0; i < inSize; i ++ ) {

						pSize ++;
						q = q.nextZ;
						if ( ! q ) { break; }

					}

					qSize = inSize;

					while ( pSize > 0 || ( qSize > 0 && q ) ) {

						if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

							e = p;
							p = p.nextZ;
							pSize --;

						} else {

							e = q;
							q = q.nextZ;
							qSize --;

						}

						if ( tail ) { tail.nextZ = e; }
						else { list = e; }

						e.prevZ = tail;
						tail = e;

					}

					p = q;

				}

				tail.nextZ = null;
				inSize *= 2;

			} while ( numMerges > 1 );

			return list;

		}

		// z-order of a point given coords and inverse of the longer side of data bbox
		function zOrder( x, y, minX, minY, invSize ) {

			// coords are transformed into non-negative 15-bit integer range
			x = 32767 * ( x - minX ) * invSize;
			y = 32767 * ( y - minY ) * invSize;

			x = ( x | ( x << 8 ) ) & 0x00FF00FF;
			x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
			x = ( x | ( x << 2 ) ) & 0x33333333;
			x = ( x | ( x << 1 ) ) & 0x55555555;

			y = ( y | ( y << 8 ) ) & 0x00FF00FF;
			y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
			y = ( y | ( y << 2 ) ) & 0x33333333;
			y = ( y | ( y << 1 ) ) & 0x55555555;

			return x | ( y << 1 );

		}

		// find the leftmost node of a polygon ring
		function getLeftmost( start ) {

			var p = start,
				leftmost = start;
			do {

				if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) { leftmost = p; }
				p = p.next;

			} while ( p !== start );

			return leftmost;

		}

		// check if a point lies within a convex triangle
		function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

			return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
				   ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
				   ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

		}

		// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
		function isValidDiagonal( a, b ) {

			return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
				   locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

		}

		// signed area of a triangle
		function area( p, q, r ) {

			return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

		}

		// check if two points are equal
		function equals( p1, p2 ) {

			return p1.x === p2.x && p1.y === p2.y;

		}

		// check if two segments intersect
		function intersects( p1, q1, p2, q2 ) {

			if ( ( equals( p1, p2 ) && equals( q1, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) { return true; }
			return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
				   area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

		}

		// check if a polygon diagonal intersects any polygon segments
		function intersectsPolygon( a, b ) {

			var p = a;
			do {

				if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
						intersects( p, p.next, a, b ) ) { return true; }
				p = p.next;

			} while ( p !== a );

			return false;

		}

		// check if a polygon diagonal is locally inside the polygon
		function locallyInside( a, b ) {

			return area( a.prev, a, a.next ) < 0 ?
				area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
				area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

		}

		// check if the middle point of a polygon diagonal is inside the polygon
		function middleInside( a, b ) {

			var p = a,
				inside = false,
				px = ( a.x + b.x ) / 2,
				py = ( a.y + b.y ) / 2;
			do {

				if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
						( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
					{ inside = ! inside; }
				p = p.next;

			} while ( p !== a );

			return inside;

		}

		// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
		// if one belongs to the outer ring and another to a hole, it merges it into a single ring
		function splitPolygon( a, b ) {

			var a2 = new Node( a.i, a.x, a.y ),
				b2 = new Node( b.i, b.x, b.y ),
				an = a.next,
				bp = b.prev;

			a.next = b;
			b.prev = a;

			a2.next = an;
			an.prev = a2;

			b2.next = a2;
			a2.prev = b2;

			bp.next = b2;
			b2.prev = bp;

			return b2;

		}

		// create a node and optionally link it with previous one (in a circular doubly linked list)
		function insertNode( i, x, y, last ) {

			var p = new Node( i, x, y );

			if ( ! last ) {

				p.prev = p;
				p.next = p;

			} else {

				p.next = last.next;
				p.prev = last;
				last.next.prev = p;
				last.next = p;

			}

			return p;

		}

		function removeNode( p ) {

			p.next.prev = p.prev;
			p.prev.next = p.next;

			if ( p.prevZ ) { p.prevZ.nextZ = p.nextZ; }
			if ( p.nextZ ) { p.nextZ.prevZ = p.prevZ; }

		}

		function Node( i, x, y ) {

			// vertex index in coordinates array
			this.i = i;

			// vertex coordinates
			this.x = x;
			this.y = y;

			// previous and next vertex nodes in a polygon ring
			this.prev = null;
			this.next = null;

			// z-order curve value
			this.z = null;

			// previous and next nodes in z-order
			this.prevZ = null;
			this.nextZ = null;

			// indicates whether this is a steiner point
			this.steiner = false;

		}

		function signedArea( data, start, end, dim ) {

			var sum = 0;
			for ( var i = start, j = end - dim; i < end; i += dim ) {

				sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
				j = i;

			}

			return sum;

		}

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var ShapeUtils = {

			// calculate area of the contour polygon

			area: function ( contour ) {

				var n = contour.length;
				var a = 0.0;

				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

				}

				return a * 0.5;

			},

			isClockWise: function ( pts ) {

				return ShapeUtils.area( pts ) < 0;

			},

			triangulateShape: function ( contour, holes ) {

				var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
				var holeIndices = []; // array of hole indices
				var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

				removeDupEndPts( contour );
				addContour( vertices, contour );

				//

				var holeIndex = contour.length;

				holes.forEach( removeDupEndPts );

				for ( var i = 0; i < holes.length; i ++ ) {

					holeIndices.push( holeIndex );
					holeIndex += holes[ i ].length;
					addContour( vertices, holes[ i ] );

				}

				//

				var triangles = Earcut.triangulate( vertices, holeIndices );

				//

				for ( var i = 0; i < triangles.length; i += 3 ) {

					faces.push( triangles.slice( i, i + 3 ) );

				}

				return faces;

			}

		};

		function removeDupEndPts( points ) {

			var l = points.length;

			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

				points.pop();

			}

		}

		function addContour( vertices, contour ) {

			for ( var i = 0; i < contour.length; i ++ ) {

				vertices.push( contour[ i ].x );
				vertices.push( contour[ i ].y );

			}

		}

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  depth: <float>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
		 *  bevelOffset: <float>, // how far from shape outline does bevel start
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *
		 *  UVGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 */

		// ExtrudeGeometry

		function ExtrudeGeometry( shapes, options ) {

			Geometry.call( this );

			this.type = 'ExtrudeGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
			this.mergeVertices();

		}

		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

		ExtrudeGeometry.prototype.toJSON = function () {

			var data = Geometry.prototype.toJSON.call( this );

			var shapes = this.parameters.shapes;
			var options = this.parameters.options;

			return toJSON( shapes, options, data );

		};

		// ExtrudeBufferGeometry

		function ExtrudeBufferGeometry( shapes, options ) {

			BufferGeometry.call( this );

			this.type = 'ExtrudeBufferGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			var scope = this;

			var verticesArray = [];
			var uvArray = [];

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];
				addShape( shape );

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

			this.computeVertexNormals();

			// functions

			function addShape( shape ) {

				var placeholder = [];

				// options

				var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				var steps = options.steps !== undefined ? options.steps : 1;
				var depth = options.depth !== undefined ? options.depth : 100;

				var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				var extrudePath = options.extrudePath;

				var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				// deprecated options

				if ( options.amount !== undefined ) {

					console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
					depth = options.amount;

				}

				//

				var extrudePts, extrudeByPath = false;
				var splineTube, binormal, normal, position2;

				if ( extrudePath ) {

					extrudePts = extrudePath.getSpacedPoints( steps );

					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames( steps, false );

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();

				}

				// Safeguards if bevels are not enabled

				if ( ! bevelEnabled ) {

					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;

				}

				// Variables initialization

				var ahole, h, hl; // looping of holes

				var shapePoints = shape.extractPoints( curveSegments );

				var vertices = shapePoints.shape;
				var holes = shapePoints.holes;

				var reverse = ! ShapeUtils.isClockWise( vertices );

				if ( reverse ) {

					vertices = vertices.reverse();

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for ( h = 0, hl = holes.length; h < hl; h ++ ) {

						ahole = holes[ h ];

						if ( ShapeUtils.isClockWise( ahole ) ) {

							holes[ h ] = ahole.reverse();

						}

					}

				}


				var faces = ShapeUtils.triangulateShape( vertices, holes );

				/* Vertices */

				var contour = vertices; // vertices has all points but contour has only points of circumference

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					vertices = vertices.concat( ahole );

				}


				function scalePt2( pt, vec, size ) {

					if ( ! vec ) { console.error( "THREE.ExtrudeGeometry: vec does not exist" ); }

					return vec.clone().multiplyScalar( size ).add( pt );

				}

				var b, bs, t, z,
					vert, vlen = vertices.length,
					face, flen = faces.length;


				// Find directions for point movement


				function getBevelVec( inPt, inPrev, inNext ) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					var v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					var v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;

					var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

					// check for collinear edges
					var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					if ( Math.abs( collinear0 ) > Number.EPSILON ) {

						// not collinear

						// length of vectors for normalizing

						var v_prev_len = Math.sqrt( v_prev_lensq );
						var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

						// shift adjacent points by unit vectors to the left

						var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
						var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

						var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
						var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

						// scaling factor for v_prev to intersection point

						var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
							( v_prev_x * v_next_y - v_prev_y * v_next_x );

						// vector from inPt to intersection point

						v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
						v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
						if ( v_trans_lensq <= 2 ) {

							return new Vector2( v_trans_x, v_trans_y );

						} else {

							shrink_by = Math.sqrt( v_trans_lensq / 2 );

						}

					} else {

						// handle special case of collinear edges

						var direction_eq = false; // assumes: opposite
						if ( v_prev_x > Number.EPSILON ) {

							if ( v_next_x > Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( v_prev_x < - Number.EPSILON ) {

								if ( v_next_x < - Number.EPSILON ) {

									direction_eq = true;

								}

							} else {

								if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

									direction_eq = true;

								}

							}

						}

						if ( direction_eq ) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt( v_prev_lensq );

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt( v_prev_lensq / 2 );

						}

					}

					return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

				}


				var contourMovements = [];

				for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) { j = 0; }
					if ( k === il ) { k = 0; }

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

				}

				var holesMovements = [],
					oneHoleMovements, verticesMovements = contourMovements.concat();

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					oneHoleMovements = [];

					for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

						if ( j === il ) { j = 0; }
						if ( k === il ) { k = 0; }

						//  (j)---(i)---(k)
						oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

					}

					holesMovements.push( oneHoleMovements );
					verticesMovements = verticesMovements.concat( oneHoleMovements );

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					t = b / bevelSegments;
					z = bevelThickness * Math.cos( t * Math.PI / 2 );
					bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( i = 0, il = contour.length; i < il; i ++ ) {

						vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

					// expand holes

					for ( h = 0, hl = holes.length; h < hl; h ++ ) {

						ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( i = 0, il = ahole.length; i < il; i ++ ) {

							vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							v( vert.x, vert.y, - z );

						}

					}

				}

				bs = bevelSize + bevelOffset;

				// Back facing vertices

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, 0 );

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				var s;

				for ( s = 1; s <= steps; s ++ ) {

					for ( i = 0; i < vlen; i ++ ) {

						vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth / steps * s );

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
							binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

							position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

							v( position2.x, position2.y, position2.z );

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for ( b = bevelSegments - 1; b >= 0; b -- ) {

					t = b / bevelSegments;
					z = bevelThickness * Math.cos( t * Math.PI / 2 );
					bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( i = 0, il = contour.length; i < il; i ++ ) {

						vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
						v( vert.x, vert.y, depth + z );

					}

					// expand holes

					for ( h = 0, hl = holes.length; h < hl; h ++ ) {

						ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( i = 0, il = ahole.length; i < il; i ++ ) {

							vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							if ( ! extrudeByPath ) {

								v( vert.x, vert.y, depth + z );

							} else {

								v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces();

				// Sides faces

				buildSideFaces();


				/////  Internal functions

				function buildLidFaces() {

					var start = verticesArray.length / 3;

					if ( bevelEnabled ) {

						var layer = 0; // steps + 1
						var offset = vlen * layer;

						// Bottom faces

						for ( i = 0; i < flen; i ++ ) {

							face = faces[ i ];
							f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer;

						// Top faces

						for ( i = 0; i < flen; i ++ ) {

							face = faces[ i ];
							f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

						}

					} else {

						// Bottom faces

						for ( i = 0; i < flen; i ++ ) {

							face = faces[ i ];
							f3( face[ 2 ], face[ 1 ], face[ 0 ] );

						}

						// Top faces

						for ( i = 0; i < flen; i ++ ) {

							face = faces[ i ];
							f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

						}

					}

					scope.addGroup( start, verticesArray.length / 3 - start, 0 );

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces() {

					var start = verticesArray.length / 3;
					var layeroffset = 0;
					sidewalls( contour, layeroffset );
					layeroffset += contour.length;

					for ( h = 0, hl = holes.length; h < hl; h ++ ) {

						ahole = holes[ h ];
						sidewalls( ahole, layeroffset );

						//, true
						layeroffset += ahole.length;

					}


					scope.addGroup( start, verticesArray.length / 3 - start, 1 );


				}

				function sidewalls( contour, layeroffset ) {

					var j, k;
					i = contour.length;

					while ( -- i >= 0 ) {

						j = i;
						k = i - 1;
						if ( k < 0 ) { k = contour.length - 1; }

						//console.log('b', i,j, i-1, k,vertices.length);

						var s = 0,
							sl = steps + bevelSegments * 2;

						for ( s = 0; s < sl; s ++ ) {

							var slen1 = vlen * s;
							var slen2 = vlen * ( s + 1 );

							var a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;

							f4( a, b, c, d );

						}

					}

				}

				function v( x, y, z ) {

					placeholder.push( x );
					placeholder.push( y );
					placeholder.push( z );

				}


				function f3( a, b, c ) {

					addVertex( a );
					addVertex( b );
					addVertex( c );

					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );

				}

				function f4( a, b, c, d ) {

					addVertex( a );
					addVertex( b );
					addVertex( d );

					addVertex( b );
					addVertex( c );
					addVertex( d );


					var nextIndex = verticesArray.length / 3;
					var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 3 ] );

					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );
					addUV( uvs[ 3 ] );

				}

				function addVertex( index ) {

					verticesArray.push( placeholder[ index * 3 + 0 ] );
					verticesArray.push( placeholder[ index * 3 + 1 ] );
					verticesArray.push( placeholder[ index * 3 + 2 ] );

				}


				function addUV( vector2 ) {

					uvArray.push( vector2.x );
					uvArray.push( vector2.y );

				}

			}

		}

		ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

		ExtrudeBufferGeometry.prototype.toJSON = function () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			var shapes = this.parameters.shapes;
			var options = this.parameters.options;

			return toJSON( shapes, options, data );

		};

		//

		var WorldUVGenerator = {

			generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

				var a_x = vertices[ indexA * 3 ];
				var a_y = vertices[ indexA * 3 + 1 ];
				var b_x = vertices[ indexB * 3 ];
				var b_y = vertices[ indexB * 3 + 1 ];
				var c_x = vertices[ indexC * 3 ];
				var c_y = vertices[ indexC * 3 + 1 ];

				return [
					new Vector2( a_x, a_y ),
					new Vector2( b_x, b_y ),
					new Vector2( c_x, c_y )
				];

			},

			generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

				var a_x = vertices[ indexA * 3 ];
				var a_y = vertices[ indexA * 3 + 1 ];
				var a_z = vertices[ indexA * 3 + 2 ];
				var b_x = vertices[ indexB * 3 ];
				var b_y = vertices[ indexB * 3 + 1 ];
				var b_z = vertices[ indexB * 3 + 2 ];
				var c_x = vertices[ indexC * 3 ];
				var c_y = vertices[ indexC * 3 + 1 ];
				var c_z = vertices[ indexC * 3 + 2 ];
				var d_x = vertices[ indexD * 3 ];
				var d_y = vertices[ indexD * 3 + 1 ];
				var d_z = vertices[ indexD * 3 + 2 ];

				if ( Math.abs( a_y - b_y ) < 0.01 ) {

					return [
						new Vector2( a_x, 1 - a_z ),
						new Vector2( b_x, 1 - b_z ),
						new Vector2( c_x, 1 - c_z ),
						new Vector2( d_x, 1 - d_z )
					];

				} else {

					return [
						new Vector2( a_y, 1 - a_z ),
						new Vector2( b_y, 1 - b_z ),
						new Vector2( c_y, 1 - c_z ),
						new Vector2( d_y, 1 - d_z )
					];

				}

			}
		};

		function toJSON( shapes, options, data ) {

			//

			data.shapes = [];

			if ( Array.isArray( shapes ) ) {

				for ( var i = 0, l = shapes.length; i < l; i ++ ) {

					var shape = shapes[ i ];

					data.shapes.push( shape.uuid );

				}

			} else {

				data.shapes.push( shapes.uuid );

			}

			//

			if ( options.extrudePath !== undefined ) { data.options.extrudePath = options.extrudePath.toJSON(); }

			return data;

		}

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
		 *  bevelOffset: <float> // how far from text outline does bevel start
		 * }
		 */

		// TextGeometry

		function TextGeometry( text, parameters ) {

			Geometry.call( this );

			this.type = 'TextGeometry';

			this.parameters = {
				text: text,
				parameters: parameters
			};

			this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
			this.mergeVertices();

		}

		TextGeometry.prototype = Object.create( Geometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;

		// TextBufferGeometry

		function TextBufferGeometry( text, parameters ) {

			parameters = parameters || {};

			var font = parameters.font;

			if ( ! ( font && font.isFont ) ) {

				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();

			}

			var shapes = font.generateShapes( text, parameters.size );

			// translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) { parameters.bevelThickness = 10; }
			if ( parameters.bevelSize === undefined ) { parameters.bevelSize = 8; }
			if ( parameters.bevelEnabled === undefined ) { parameters.bevelEnabled = false; }

			ExtrudeBufferGeometry.call( this, shapes, parameters );

			this.type = 'TextBufferGeometry';

		}

		TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
		TextBufferGeometry.prototype.constructor = TextBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// SphereGeometry

		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;

		// SphereBufferGeometry

		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'SphereBufferGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 1;

			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

			var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			var ix, iy;

			var index = 0;
			var grid = [];

			var vertex = new Vector3();
			var normal = new Vector3();

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// generate vertices, normals and uvs

			for ( iy = 0; iy <= heightSegments; iy ++ ) {

				var verticesRow = [];

				var v = iy / heightSegments;

				// special case for the poles

				var uOffset = 0;

				if ( iy == 0 && thetaStart == 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( ix = 0; ix <= widthSegments; ix ++ ) {

					var u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( iy = 0; iy < heightSegments; iy ++ ) {

				for ( ix = 0; ix < widthSegments; ix ++ ) {

					var a = grid[ iy ][ ix + 1 ];
					var b = grid[ iy ][ ix ];
					var c = grid[ iy + 1 ][ ix ];
					var d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

		/**
		 * @author Kaleb Murphy
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// RingGeometry

		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;

		// RingBufferGeometry

		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'RingBufferGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			innerRadius = innerRadius || 0.5;
			outerRadius = outerRadius || 1;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// some helper variables

			var segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;

			// generate vertices, normals and uvs

			for ( j = 0; j <= phiSegments; j ++ ) {

				for ( i = 0; i <= thetaSegments; i ++ ) {

					// values are generate from the inside of the ring to the outside

					segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex

					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, 0, 1 );

					// uv

					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;

					uvs.push( uv.x, uv.y );

				}

				// increase the radius for next row of vertices

				radius += radiusStep;

			}

			// indices

			for ( j = 0; j < phiSegments; j ++ ) {

				var thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( i = 0; i < thetaSegments; i ++ ) {

					segment = i + thetaSegmentLevel;

					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;

		/**
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// LatheGeometry

		function LatheGeometry( points, segments, phiStart, phiLength ) {

			Geometry.call( this );

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();

		}

		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;

		// LatheBufferGeometry

		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

			BufferGeometry.call( this );

			this.type = 'LatheBufferGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;

			// clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );


			// buffers

			var indices = [];
			var vertices = [];
			var uvs = [];

			// helper variables

			var base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;

			// generate vertices and uvs

			for ( i = 0; i <= segments; i ++ ) {

				var phi = phiStart + i * inverseSegments * phiLength;

				var sin = Math.sin( phi );
				var cos = Math.cos( phi );

				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex

					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;

					vertices.push( vertex.x, vertex.y, vertex.z );

					// uv

					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );

					uvs.push( uv.x, uv.y );


				}

			}

			// indices

			for ( i = 0; i < segments; i ++ ) {

				for ( j = 0; j < ( points.length - 1 ); j ++ ) {

					base = j + i * points.length;

					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// generate normals

			this.computeVertexNormals();

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if ( phiLength === Math.PI * 2 ) {

				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();

				// this is the buffer offset for the last line of vertices

				base = segments * points.length * 3;

				for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

					// select the normal of the vertex in the first line

					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];

					// select the normal of the vertex in the last line

					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];

					// average normals

					n.addVectors( n1, n2 ).normalize();

					// assign the new values to both normals

					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

				}

			}

		}

		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

		/**
		 * @author jonobr1 / http://jonobr1.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// ShapeGeometry

		function ShapeGeometry( shapes, curveSegments ) {

			Geometry.call( this );

			this.type = 'ShapeGeometry';

			if ( typeof curveSegments === 'object' ) {

				console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

				curveSegments = curveSegments.curveSegments;

			}

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
			this.mergeVertices();

		}

		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;

		ShapeGeometry.prototype.toJSON = function () {

			var data = Geometry.prototype.toJSON.call( this );

			var shapes = this.parameters.shapes;

			return toJSON$1( shapes, data );

		};

		// ShapeBufferGeometry

		function ShapeBufferGeometry( shapes, curveSegments ) {

			BufferGeometry.call( this );

			this.type = 'ShapeBufferGeometry';

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			curveSegments = curveSegments || 12;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var groupStart = 0;
			var groupCount = 0;

			// allow single and array values for "shapes" parameter

			if ( Array.isArray( shapes ) === false ) {

				addShape( shapes );

			} else {

				for ( var i = 0; i < shapes.length; i ++ ) {

					addShape( shapes[ i ] );

					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


			// helper functions

			function addShape( shape ) {

				var i, l, shapeHole;

				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints( curveSegments );

				var shapeVertices = points.shape;
				var shapeHoles = points.holes;

				// check direction of vertices

				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

					shapeVertices = shapeVertices.reverse();

				}

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

				var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

				// join vertices of inner and outer paths to a single array

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );

				}

				// vertices, normals, uvs

				for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

					var vertex = shapeVertices[ i ];

					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs

				}

				// incides

				for ( i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var a = face[ 0 ] + indexOffset;
					var b = face[ 1 ] + indexOffset;
					var c = face[ 2 ] + indexOffset;

					indices.push( a, b, c );
					groupCount += 3;

				}

			}

		}

		ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

		ShapeBufferGeometry.prototype.toJSON = function () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			var shapes = this.parameters.shapes;

			return toJSON$1( shapes, data );

		};

		//

		function toJSON$1( shapes, data ) {

			data.shapes = [];

			if ( Array.isArray( shapes ) ) {

				for ( var i = 0, l = shapes.length; i < l; i ++ ) {

					var shape = shapes[ i ];

					data.shapes.push( shape.uuid );

				}

			} else {

				data.shapes.push( shapes.uuid );

			}

			return data;

		}

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function EdgesGeometry( geometry, thresholdAngle ) {

			BufferGeometry.call( this );

			this.type = 'EdgesGeometry';

			this.parameters = {
				thresholdAngle: thresholdAngle
			};

			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

			// buffer

			var vertices = [];

			// helper variables

			var thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );
			var edge = [ 0, 0 ], edges = {}, edge1, edge2;
			var key, keys = [ 'a', 'b', 'c' ];

			// prepare source geometry

			var geometry2;

			if ( geometry.isBufferGeometry ) {

				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );

			} else {

				geometry2 = geometry.clone();

			}

			geometry2.mergeVertices();
			geometry2.computeFaceNormals();

			var sourceVertices = geometry2.vertices;
			var faces = geometry2.faces;

			// now create a data structure where each entry represents an edge with its adjoining faces

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 );
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

					} else {

						edges[ key ].face2 = i;

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				var e = edges[ key ];

				// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

				if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

					var vertex = sourceVertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex = sourceVertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		// CylinderGeometry

		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;

		// CylinderBufferGeometry

		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CylinderBufferGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = this;

			radiusTop = radiusTop !== undefined ? radiusTop : 1;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
			height = height || 1;

			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;

			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var index = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) { generateCap( true ); }
				if ( radiusBottom > 0 ) { generateCap( false ); }

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();

				var groupCount = 0;

				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( y = 0; y <= heightSegments; y ++ ) {

					var indexRow = [];

					var v = y / heightSegments;

					// calculate the radius of the current row

					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( x = 0; x <= radialSegments; x ++ ) {

						var u = x / radialSegments;

						var theta = u * thetaLength + thetaStart;

						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					for ( y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						var a = indexArray[ y ][ x ];
						var b = indexArray[ y + 1 ][ x ];
						var c = indexArray[ y + 1 ][ x + 1 ];
						var d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				var x, centerIndexStart, centerIndexEnd;

				var uv = new Vector2();
				var vertex = new Vector3();

				var groupCount = 0;

				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;

				// save the index of the first center vertex
				centerIndexStart = index;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex

				centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;

					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		// ConeGeometry

		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;

		// ConeBufferGeometry

		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeBufferGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 * @author hughes
		 */

		// CircleGeometry

		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;

		// CircleBufferGeometry

		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CircleBufferGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 1;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var i, s;
			var vertex = new Vector3();
			var uv = new Vector2();

			// center point

			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );

			for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

				var segment = thetaStart + s / segments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uvs

				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// indices

			for ( i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



		var Geometries = /*#__PURE__*/Object.freeze({
			__proto__: null,
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			TextBufferGeometry: TextBufferGeometry,
			SphereGeometry: SphereGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ShapeBufferGeometry: ShapeBufferGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			ExtrudeBufferGeometry: ExtrudeBufferGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleGeometry: CircleGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			BoxGeometry: BoxGeometry,
			BoxBufferGeometry: BoxBufferGeometry
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * parameters = {
		 *  color: <THREE.Color>
		 * }
		 */

		function ShadowMaterial( parameters ) {

			Material.call( this );

			this.type = 'ShadowMaterial';

			this.color = new Color( 0x000000 );
			this.transparent = true;

			this.setValues( parameters );

		}

		ShadowMaterial.prototype = Object.create( Material.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;

		ShadowMaterial.prototype.isShadowMaterial = true;

		ShadowMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function RawShaderMaterial( parameters ) {

			ShaderMaterial.call( this, parameters );

			this.type = 'RawShaderMaterial';

		}

		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;

		RawShaderMaterial.prototype.isRawShaderMaterial = true;

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalMapType: THREE.TangentSpaceNormalMap,
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshStandardMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 1.0;
			this.metalness = 0.0;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.vertexTangents = false;

			this.setValues( parameters );

		}

		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

		MeshStandardMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.vertexTangents = source.vertexTangents;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  clearcoat: <float>,
		 *  clearcoatMap: new THREE.Texture( <Image> ),
		 *  clearcoatRoughness: <float>,
		 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
		 *  clearcoatNormalScale: <Vector2>,
		 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
		 *
		 *  reflectivity: <float>,
		 *
		 *  sheen: <Color>,
		 *
		 *  transparency: <float>
		 * }
		 */

		function MeshPhysicalMaterial( parameters ) {

			MeshStandardMaterial.call( this );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.type = 'MeshPhysicalMaterial';

			this.clearcoat = 0.0;
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2( 1, 1 );
			this.clearcoatNormalMap = null;

			this.reflectivity = 0.5; // maps to F0 = 0.04

			this.sheen = null; // null will disable sheen bsdf

			this.transparency = 0.0;

			this.setValues( parameters );

		}

		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

		MeshPhysicalMaterial.prototype.copy = function ( source ) {

			MeshStandardMaterial.prototype.copy.call( this, source );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

			this.reflectivity = source.reflectivity;

			if ( source.sheen ) {

				this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

			} else {

				this.sheen = null;

			}

			this.transparency = source.transparency;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalMapType: THREE.TangentSpaceNormalMap,
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.MultiplyOperation,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshPhongMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

		MeshPhongMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author takahirox / http://github.com/takahirox
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *  gradientMap: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalMapType: THREE.TangentSpaceNormalMap,
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshToonMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshToonMaterial.prototype = Object.create( Material.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;

		MeshToonMaterial.prototype.isMeshToonMaterial = true;

		MeshToonMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalMapType: THREE.TangentSpaceNormalMap,
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshNormalMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

		MeshNormalMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshLambertMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

		MeshLambertMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  matcap: new THREE.Texture( <Image> ),
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalMapType: THREE.TangentSpaceNormalMap,
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshMatcapMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshMatcapMaterial.prototype = Object.create( Material.prototype );
		MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

		MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

		MeshMatcapMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */

		function LineDashedMaterial( parameters ) {

			LineBasicMaterial.call( this );

			this.type = 'LineDashedMaterial';

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.setValues( parameters );

		}

		LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;

		LineDashedMaterial.prototype.isLineDashedMaterial = true;

		LineDashedMaterial.prototype.copy = function ( source ) {

			LineBasicMaterial.prototype.copy.call( this, source );

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		};



		var Materials = /*#__PURE__*/Object.freeze({
			__proto__: null,
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshToonMaterial: MeshToonMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshDistanceMaterial: MeshDistanceMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			MeshMatcapMaterial: MeshMatcapMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});

		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		var AnimationUtils = {

			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function ( array, from, to ) {

				if ( AnimationUtils.isTypedArray( array ) ) {

					// in ios9 array.subarray(from, undefined) will return empty array
					// but array.subarray(from) or array.subarray(from, len) is correct
					return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

				}

				return array.slice( from, to );

			},

			// converts an array to a specific type
			convertArray: function ( array, type, forceClone ) {

				if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) { return array; }

				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

					return new type( array ); // create typed array

				}

				return Array.prototype.slice.call( array ); // create Array

			},

			isTypedArray: function ( object ) {

				return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );

			},

			// returns an array by which times and values can be sorted
			getKeyframeOrder: function ( times ) {

				function compareTime( i, j ) {

					return times[ i ] - times[ j ];

				}

				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }

				result.sort( compareTime );

				return result;

			},

			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function ( values, stride, order ) {

				var nValues = values.length;
				var result = new values.constructor( nValues );

				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

					var srcOffset = order[ i ] * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						result[ dstOffset ++ ] = values[ srcOffset + j ];

					}

				}

				return result;

			},

			// function for parsing AOS keyframe formats
			flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

				var i = 1, key = jsonKeys[ 0 ];

				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

					key = jsonKeys[ i ++ ];

				}

				if ( key === undefined ) { return; } // no data

				var value = key[ valuePropertyName ];
				if ( value === undefined ) { return; } // no data

				if ( Array.isArray( value ) ) {

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push.apply( values, value ); // push all elements

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else if ( value.toArray !== undefined ) {

					// ...assume THREE.Math-ish

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							value.toArray( values, values.length );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else {

					// otherwise push as-is

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push( value );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				}

			},

			subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {

				fps = fps || 30;

				var clip = sourceClip.clone();

				clip.name = name;

				var tracks = [];

				for ( var i = 0; i < clip.tracks.length; ++ i ) {

					var track = clip.tracks[ i ];
					var valueSize = track.getValueSize();

					var times = [];
					var values = [];

					for ( var j = 0; j < track.times.length; ++ j ) {

						var frame = track.times[ j ] * fps;

						if ( frame < startFrame || frame >= endFrame ) { continue; }

						times.push( track.times[ j ] );

						for ( var k = 0; k < valueSize; ++ k ) {

							values.push( track.values[ j * valueSize + k ] );

						}

					}

					if ( times.length === 0 ) { continue; }

					track.times = AnimationUtils.convertArray( times, track.times.constructor );
					track.values = AnimationUtils.convertArray( values, track.values.constructor );

					tracks.push( track );

				}

				clip.tracks = tracks;

				// find minimum .times value across all tracks in the trimmed clip

				var minStartTime = Infinity;

				for ( var i = 0; i < clip.tracks.length; ++ i ) {

					if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

						minStartTime = clip.tracks[ i ].times[ 0 ];

					}

				}

				// shift all tracks such that clip begins at t=0

				for ( var i = 0; i < clip.tracks.length; ++ i ) {

					clip.tracks[ i ].shift( - 1 * minStartTime );

				}

				clip.resetDuration();

				return clip;

			}

		};

		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */

		function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

		}

		Object.assign( Interpolant.prototype, {

			evaluate: function ( t ) {

				var pp = this.parameterPositions,
					i1 = this._cachedIndex,

					t1 = pp[ i1 ],
					t0 = pp[ i1 - 1 ];

				validate_interval: {

					seek: {

						var right;

						linear_scan: {

							//- See http://jsperf.com/comparison-to-undefined/3
							//- slower code:
							//-
							//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {

								for ( var giveUpAt = i1 + 2; ; ) {

									if ( t1 === undefined ) {

										if ( t < t0 ) { break forward_scan; }

										// after end

										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );

									}

									if ( i1 === giveUpAt ) { break; } // this loop

									t0 = t1;
									t1 = pp[ ++ i1 ];

									if ( t < t1 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;

							}

							//- slower code:
							//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {

								// looping?

								var t1global = pp[ 1 ];

								if ( t < t1global ) {

									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;

								}

								// linear reverse scan

								for ( var giveUpAt = i1 - 2; ; ) {

									if ( t0 === undefined ) {

										// before start

										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );

									}

									if ( i1 === giveUpAt ) { break; } // this loop

									t1 = t0;
									t0 = pp[ -- i1 - 1 ];

									if ( t >= t0 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;

							}

							// the interval is valid

							break validate_interval;

						} // linear scan

						// binary search

						while ( i1 < right ) {

							var mid = ( i1 + right ) >>> 1;

							if ( t < pp[ mid ] ) {

								right = mid;

							} else {

								i1 = mid + 1;

							}

						}

						t1 = pp[ i1 ];
						t0 = pp[ i1 - 1 ];

						// check boundary cases, again

						if ( t0 === undefined ) {

							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );

						}

						if ( t1 === undefined ) {

							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );

						}

					} // seek

					this._cachedIndex = i1;

					this.intervalChanged_( i1, t0, t1 );

				} // validate_interval

				return this.interpolate_( i1, t0, t, t1 );

			},

			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.

			// --- Protected interface

			DefaultSettings_: {},

			getSettings_: function () {

				return this.settings || this.DefaultSettings_;

			},

			copySampleValue_: function ( index ) {

				// copies a sample value to the result buffer

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] = values[ offset + i ];

				}

				return result;

			},

			// Template methods for derived classes:

			interpolate_: function ( /* i1, t0, t, t1 */ ) {

				throw new Error( 'call to abstract method' );
				// implementations shall return this.resultBuffer

			},

			intervalChanged_: function ( /* i1, t0, t1 */ ) {

				// empty

			}

		} );

		// DECLARE ALIAS AFTER assign prototype
		Object.assign( Interpolant.prototype, {

			//( 0, t, t0 ), returns this.resultBuffer
			beforeStart_: Interpolant.prototype.copySampleValue_,

			//( N-1, tN-1, t ), returns this.resultBuffer
			afterEnd_: Interpolant.prototype.copySampleValue_,

		} );

		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */

		function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = - 0;
			this._offsetPrev = - 0;
			this._weightNext = - 0;
			this._offsetNext = - 0;

		}

		CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

			constructor: CubicInterpolant,

			DefaultSettings_: {

				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding

			},

			intervalChanged_: function ( i1, t0, t1 ) {

				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,

					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];

				if ( tPrev === undefined ) {

					switch ( this.getSettings_().endingStart ) {

						case ZeroSlopeEnding:

							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;

					}

				}

				if ( tNext === undefined ) {

					switch ( this.getSettings_().endingEnd ) {

						case ZeroSlopeEnding:

							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;

					}

				}

				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;

				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;

			},

			interpolate_: function ( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,

					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;

				// evaluate polynomials

				var sP = - wP * ppp + 2 * wP * pp - wP * p;
				var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
				var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
				var sN = wN * ppp - wN * pp;

				// combine data linearly

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];

				}

				return result;

			}

		} );

		/**
		 * @author tschw
		 */

		function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

			constructor: LinearInterpolant,

			interpolate_: function ( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset1 = i1 * stride,
					offset0 = offset1 - stride,

					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;

				}

				return result;

			}

		} );

		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */

		function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

			constructor: DiscreteInterpolant,

			interpolate_: function ( i1 /*, t0, t, t1 */ ) {

				return this.copySampleValue_( i1 - 1 );

			}

		} );

		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function KeyframeTrack( name, times, values, interpolation ) {

			if ( name === undefined ) { throw new Error( 'THREE.KeyframeTrack: track name is undefined' ); }
			if ( times === undefined || times.length === 0 ) { throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name ); }

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

		}

		// Static methods

		Object.assign( KeyframeTrack, {

			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):

			toJSON: function ( track ) {

				var trackType = track.constructor;

				var json;

				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {

					json = trackType.toJSON( track );

				} else {

					// by default, we assume the data can be serialized as-is
					json = {

						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )

					};

					var interpolation = track.getInterpolation();

					if ( interpolation !== track.DefaultInterpolation ) {

						json.interpolation = interpolation;

					}

				}

				json.type = track.ValueTypeName; // mandatory

				return json;

			}

		} );

		Object.assign( KeyframeTrack.prototype, {

			constructor: KeyframeTrack,

			TimeBufferType: Float32Array,

			ValueBufferType: Float32Array,

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodDiscrete: function ( result ) {

				return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodLinear: function ( result ) {

				return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: function ( result ) {

				return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

			},

			setInterpolation: function ( interpolation ) {

				var factoryMethod;

				switch ( interpolation ) {

					case InterpolateDiscrete:

						factoryMethod = this.InterpolantFactoryMethodDiscrete;

						break;

					case InterpolateLinear:

						factoryMethod = this.InterpolantFactoryMethodLinear;

						break;

					case InterpolateSmooth:

						factoryMethod = this.InterpolantFactoryMethodSmooth;

						break;

				}

				if ( factoryMethod === undefined ) {

					var message = "unsupported interpolation for " +
						this.ValueTypeName + " keyframe track named " + this.name;

					if ( this.createInterpolant === undefined ) {

						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {

							this.setInterpolation( this.DefaultInterpolation );

						} else {

							throw new Error( message ); // fatal, in this case

						}

					}

					console.warn( 'THREE.KeyframeTrack:', message );
					return this;

				}

				this.createInterpolant = factoryMethod;

				return this;

			},

			getInterpolation: function () {

				switch ( this.createInterpolant ) {

					case this.InterpolantFactoryMethodDiscrete:

						return InterpolateDiscrete;

					case this.InterpolantFactoryMethodLinear:

						return InterpolateLinear;

					case this.InterpolantFactoryMethodSmooth:

						return InterpolateSmooth;

				}

			},

			getValueSize: function () {

				return this.values.length / this.times.length;

			},

			// move all keyframes either forwards or backwards in time
			shift: function ( timeOffset ) {

				if ( timeOffset !== 0.0 ) {

					var times = this.times;

					for ( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] += timeOffset;

					}

				}

				return this;

			},

			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function ( timeScale ) {

				if ( timeScale !== 1.0 ) {

					var times = this.times;

					for ( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] *= timeScale;

					}

				}

				return this;

			},

			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function ( startTime, endTime ) {

				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;

				while ( from !== nKeys && times[ from ] < startTime ) {

					++ from;

				}

				while ( to !== - 1 && times[ to ] > endTime ) {

					-- to;

				}

				++ to; // inclusive -> exclusive bound

				if ( from !== 0 || to !== nKeys ) {

					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) {

						to = Math.max( to, 1 );
						from = to - 1;

					}

					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

				}

				return this;

			},

			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function () {

				var valid = true;

				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {

					console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
					valid = false;

				}

				var times = this.times,
					values = this.values,

					nKeys = times.length;

				if ( nKeys === 0 ) {

					console.error( 'THREE.KeyframeTrack: Track is empty.', this );
					valid = false;

				}

				var prevTime = null;

				for ( var i = 0; i !== nKeys; i ++ ) {

					var currTime = times[ i ];

					if ( typeof currTime === 'number' && isNaN( currTime ) ) {

						console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
						valid = false;
						break;

					}

					if ( prevTime !== null && prevTime > currTime ) {

						console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
						valid = false;
						break;

					}

					prevTime = currTime;

				}

				if ( values !== undefined ) {

					if ( AnimationUtils.isTypedArray( values ) ) {

						for ( var i = 0, n = values.length; i !== n; ++ i ) {

							var value = values[ i ];

							if ( isNaN( value ) ) {

								console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
								valid = false;
								break;

							}

						}

					}

				}

				return valid;

			},

			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function () {

				// times or values may be shared with other tracks, so overwriting is unsafe
				var times = AnimationUtils.arraySlice( this.times ),
					values = AnimationUtils.arraySlice( this.values ),
					stride = this.getValueSize(),

					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

					writeIndex = 1,
					lastIndex = times.length - 1;

				for ( var i = 1; i < lastIndex; ++ i ) {

					var keep = false;

					var time = times[ i ];
					var timeNext = times[ i + 1 ];

					// remove adjacent keyframes scheduled at the same time

					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

						if ( ! smoothInterpolation ) {

							// remove unnecessary keyframes same as their neighbors

							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

							for ( var j = 0; j !== stride; ++ j ) {

								var value = values[ offset + j ];

								if ( value !== values[ offsetP + j ] ||
									value !== values[ offsetN + j ] ) {

									keep = true;
									break;

								}

							}

						} else {

							keep = true;

						}

					}

					// in-place compaction

					if ( keep ) {

						if ( i !== writeIndex ) {

							times[ writeIndex ] = times[ i ];

							var readOffset = i * stride,
								writeOffset = writeIndex * stride;

							for ( var j = 0; j !== stride; ++ j ) {

								values[ writeOffset + j ] = values[ readOffset + j ];

							}

						}

						++ writeIndex;

					}

				}

				// flush last keyframe (compaction looks ahead)

				if ( lastIndex > 0 ) {

					times[ writeIndex ] = times[ lastIndex ];

					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

					++ writeIndex;

				}

				if ( writeIndex !== times.length ) {

					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

				} else {

					this.times = times;
					this.values = values;

				}

				return this;

			},

			clone: function () {

				var times = AnimationUtils.arraySlice( this.times, 0 );
				var values = AnimationUtils.arraySlice( this.values, 0 );

				var TypedKeyframeTrack = this.constructor;
				var track = new TypedKeyframeTrack( this.name, times, values );

				// Interpolant argument to constructor is not saved, so copy the factory method directly.
				track.createInterpolant = this.createInterpolant;

				return track;

			}

		} );

		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function BooleanKeyframeTrack( name, times, values ) {

			KeyframeTrack.call( this, name, times, values );

		}

		BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: BooleanKeyframeTrack,

			ValueTypeName: 'bool',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined

			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".

		} );

		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function ColorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrack.call( this, name, times, values, interpolation );

		}

		ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: ColorKeyframeTrack,

			ValueTypeName: 'color'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.

		} );

		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function NumberKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrack.call( this, name, times, values, interpolation );

		}

		NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: NumberKeyframeTrack,

			ValueTypeName: 'number'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */

		function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

			constructor: QuaternionLinearInterpolant,

			interpolate_: function ( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset = i1 * stride,

					alpha = ( t - t0 ) / ( t1 - t0 );

				for ( var end = offset + stride; offset !== end; offset += 4 ) {

					Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

				}

				return result;

			}

		} );

		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function QuaternionKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrack.call( this, name, times, values, interpolation );

		}

		QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: QuaternionKeyframeTrack,

			ValueTypeName: 'quaternion',

			// ValueBufferType is inherited

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodLinear: function ( result ) {

				return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: undefined // not yet implemented

		} );

		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function StringKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrack.call( this, name, times, values, interpolation );

		}

		StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: StringKeyframeTrack,

			ValueTypeName: 'string',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,

			InterpolantFactoryMethodSmooth: undefined

		} );

		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function VectorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrack.call( this, name, times, values, interpolation );

		}

		VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

			constructor: VectorKeyframeTrack,

			ValueTypeName: 'vector'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		function AnimationClip( name, duration, tracks ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : - 1;

			this.uuid = MathUtils.generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

		}

		function getTrackTypeForValueTypeName( typeName ) {

			switch ( typeName.toLowerCase() ) {

				case 'scalar':
				case 'double':
				case 'float':
				case 'number':
				case 'integer':

					return NumberKeyframeTrack;

				case 'vector':
				case 'vector2':
				case 'vector3':
				case 'vector4':

					return VectorKeyframeTrack;

				case 'color':

					return ColorKeyframeTrack;

				case 'quaternion':

					return QuaternionKeyframeTrack;

				case 'bool':
				case 'boolean':

					return BooleanKeyframeTrack;

				case 'string':

					return StringKeyframeTrack;

			}

			throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

		}

		function parseKeyframeTrack( json ) {

			if ( json.type === undefined ) {

				throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

			}

			var trackType = getTrackTypeForValueTypeName( json.type );

			if ( json.times === undefined ) {

				var times = [], values = [];

				AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

				json.times = times;
				json.values = values;

			}

			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {

				return trackType.parse( json );

			} else {

				// by default, we assume a constructor compatible with the base
				return new trackType( json.name, json.times, json.values, json.interpolation );

			}

		}

		Object.assign( AnimationClip, {

			parse: function ( json ) {

				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );

				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

					tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

				}

				return new AnimationClip( json.name, json.duration, tracks );

			},

			toJSON: function ( clip ) {

				var tracks = [],
					clipTracks = clip.tracks;

				var json = {

					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks,
					'uuid': clip.uuid

				};

				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

				}

				return json;

			},

			CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];

				for ( var i = 0; i < numMorphTargets; i ++ ) {

					var times = [];
					var values = [];

					times.push(
						( i + numMorphTargets - 1 ) % numMorphTargets,
						i,
						( i + 1 ) % numMorphTargets );

					values.push( 0, 1, 0 );

					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );

					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {

						times.push( numMorphTargets );
						values.push( values[ 0 ] );

					}

					tracks.push(
						new NumberKeyframeTrack(
							'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
							times, values
						).scale( 1.0 / fps ) );

				}

				return new AnimationClip( name, - 1, tracks );

			},

			findByName: function ( objectOrClipArray, name ) {

				var clipArray = objectOrClipArray;

				if ( ! Array.isArray( objectOrClipArray ) ) {

					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;

				}

				for ( var i = 0; i < clipArray.length; i ++ ) {

					if ( clipArray[ i ].name === name ) {

						return clipArray[ i ];

					}

				}

				return null;

			},

			CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

				var animationToMorphTargets = {};

				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;

				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );

					if ( parts && parts.length > 1 ) {

						var name = parts[ 1 ];

						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {

							animationToMorphTargets[ name ] = animationMorphTargets = [];

						}

						animationMorphTargets.push( morphTarget );

					}

				}

				var clips = [];

				for ( var name in animationToMorphTargets ) {

					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

				}

				return clips;

			},

			// parse the animation.hierarchy format
			parseAnimation: function ( animation, bones ) {

				if ( ! animation ) {

					console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
					return null;

				}

				var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {

						var times = [];
						var values = [];

						AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {

							destTracks.push( new trackType( trackName, times, values ) );

						}

					}

				};

				var tracks = [];

				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || - 1;
				var fps = animation.fps || 30;

				var hierarchyTracks = animation.hierarchy || [];

				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

					var animationKeys = hierarchyTracks[ h ].keys;

					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) { continue; }

					// process morph targets
					if ( animationKeys[ 0 ].morphTargets ) {

						// figure out all morph targets used in this track
						var morphTargetNames = {};

						for ( var k = 0; k < animationKeys.length; k ++ ) {

							if ( animationKeys[ k ].morphTargets ) {

								for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

									morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

								}

							}

						}

						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {

							var times = [];
							var values = [];

							for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

								var animationKey = animationKeys[ k ];

								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

							}

							tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

						}

						duration = morphTargetNames.length * ( fps || 1.0 );

					} else {

						// ...assume skeletal animation

						var boneName = '.bones[' + bones[ h ].name + ']';

						addNonemptyTrack(
							VectorKeyframeTrack, boneName + '.position',
							animationKeys, 'pos', tracks );

						addNonemptyTrack(
							QuaternionKeyframeTrack, boneName + '.quaternion',
							animationKeys, 'rot', tracks );

						addNonemptyTrack(
							VectorKeyframeTrack, boneName + '.scale',
							animationKeys, 'scl', tracks );

					}

				}

				if ( tracks.length === 0 ) {

					return null;

				}

				var clip = new AnimationClip( clipName, duration, tracks );

				return clip;

			}

		} );

		Object.assign( AnimationClip.prototype, {

			resetDuration: function () {

				var tracks = this.tracks, duration = 0;

				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

					var track = this.tracks[ i ];

					duration = Math.max( duration, track.times[ track.times.length - 1 ] );

				}

				this.duration = duration;

				return this;

			},

			trim: function () {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].trim( 0, this.duration );

				}

				return this;

			},

			validate: function () {

				var valid = true;

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					valid = valid && this.tracks[ i ].validate();

				}

				return valid;

			},

			optimize: function () {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].optimize();

				}

				return this;

			},

			clone: function () {

				var tracks = [];

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					tracks.push( this.tracks[ i ].clone() );

				}

				return new AnimationClip( this.name, this.duration, tracks );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var Cache = {

			enabled: false,

			files: {},

			add: function ( key, file ) {

				if ( this.enabled === false ) { return; }

				// console.log( 'THREE.Cache', 'Adding key:', key );

				this.files[ key ] = file;

			},

			get: function ( key ) {

				if ( this.enabled === false ) { return; }

				// console.log( 'THREE.Cache', 'Checking key:', key );

				return this.files[ key ];

			},

			remove: function ( key ) {

				delete this.files[ key ];

			},

			clear: function () {

				this.files = {};

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LoadingManager( onLoad, onProgress, onError ) {

			var scope = this;

			var isLoading = false;
			var itemsLoaded = 0;
			var itemsTotal = 0;
			var urlModifier = undefined;
			var handlers = [];

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

			this.resolveURL = function ( url ) {

				if ( urlModifier ) {

					return urlModifier( url );

				}

				return url;

			};

			this.setURLModifier = function ( transform ) {

				urlModifier = transform;

				return this;

			};

			this.addHandler = function ( regex, loader ) {

				handlers.push( regex, loader );

				return this;

			};

			this.removeHandler = function ( regex ) {

				var index = handlers.indexOf( regex );

				if ( index !== - 1 ) {

					handlers.splice( index, 2 );

				}

				return this;

			};

			this.getHandler = function ( file ) {

				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

					var regex = handlers[ i ];
					var loader = handlers[ i + 1 ];

					if ( regex.global ) { regex.lastIndex = 0; } // see #17920

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			};

		}

		var DefaultLoadingManager = new LoadingManager();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Loader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.crossOrigin = 'anonymous';
			this.path = '';
			this.resourcePath = '';

		}

		Object.assign( Loader.prototype, {

			load: function ( /* url, onLoad, onProgress, onError */ ) {},

			parse: function ( /* data */ ) {},

			setCrossOrigin: function ( crossOrigin ) {

				this.crossOrigin = crossOrigin;
				return this;

			},

			setPath: function ( path ) {

				this.path = path;
				return this;

			},

			setResourcePath: function ( resourcePath ) {

				this.resourcePath = resourcePath;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var loading = {};

		function FileLoader( manager ) {

			Loader.call( this, manager );

		}

		FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: FileLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) { url = ''; }

				if ( this.path !== undefined ) { url = this.path + url; }

				url = this.manager.resolveURL( url );

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) { onLoad( cached ); }

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				// Check if request is duplicate

				if ( loading[ url ] !== undefined ) {

					loading[ url ].push( {

						onLoad: onLoad,
						onProgress: onProgress,
						onError: onError

					} );

					return;

				}

				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );

				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {

					var mimeType = dataUriRegexResult[ 1 ];
					var isBase64 = !! dataUriRegexResult[ 2 ];
					var data = dataUriRegexResult[ 3 ];

					data = decodeURIComponent( data );

					if ( isBase64 ) { data = atob( data ); }

					try {

						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();

						switch ( responseType ) {

							case 'arraybuffer':
							case 'blob':

								var view = new Uint8Array( data.length );

								for ( var i = 0; i < data.length; i ++ ) {

									view[ i ] = data.charCodeAt( i );

								}

								if ( responseType === 'blob' ) {

									response = new Blob( [ view.buffer ], { type: mimeType } );

								} else {

									response = view.buffer;

								}

								break;

							case 'document':

								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );

								break;

							case 'json':

								response = JSON.parse( data );

								break;

							default: // 'text' or other

								response = data;

								break;

						}

						// Wait for next browser tick like standard XMLHttpRequest event dispatching does
						setTimeout( function () {

							if ( onLoad ) { onLoad( response ); }

							scope.manager.itemEnd( url );

						}, 0 );

					} catch ( error ) {

						// Wait for next browser tick like standard XMLHttpRequest event dispatching does
						setTimeout( function () {

							if ( onError ) { onError( error ); }

							scope.manager.itemError( url );
							scope.manager.itemEnd( url );

						}, 0 );

					}

				} else {

					// Initialise array for duplicate requests

					loading[ url ] = [];

					loading[ url ].push( {

						onLoad: onLoad,
						onProgress: onProgress,
						onError: onError

					} );

					var request = new XMLHttpRequest();

					request.open( 'GET', url, true );

					request.addEventListener( 'load', function ( event ) {

						var response = this.response;

						var callbacks = loading[ url ];

						delete loading[ url ];

						if ( this.status === 200 || this.status === 0 ) {

							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.

							if ( this.status === 0 ) { console.warn( 'THREE.FileLoader: HTTP Status 0 received.' ); }

							// Add to cache only on HTTP success, so that we do not cache
							// error response bodies as proper responses to requests.
							Cache.add( url, response );

							for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

								var callback = callbacks[ i ];
								if ( callback.onLoad ) { callback.onLoad( response ); }

							}

							scope.manager.itemEnd( url );

						} else {

							for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

								var callback = callbacks[ i ];
								if ( callback.onError ) { callback.onError( event ); }

							}

							scope.manager.itemError( url );
							scope.manager.itemEnd( url );

						}

					}, false );

					request.addEventListener( 'progress', function ( event ) {

						var callbacks = loading[ url ];

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onProgress ) { callback.onProgress( event ); }

						}

					}, false );

					request.addEventListener( 'error', function ( event ) {

						var callbacks = loading[ url ];

						delete loading[ url ];

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) { callback.onError( event ); }

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, false );

					request.addEventListener( 'abort', function ( event ) {

						var callbacks = loading[ url ];

						delete loading[ url ];

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) { callback.onError( event ); }

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, false );

					if ( this.responseType !== undefined ) { request.responseType = this.responseType; }
					if ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }

					if ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }

					for ( var header in this.requestHeader ) {

						request.setRequestHeader( header, this.requestHeader[ header ] );

					}

					request.send( null );

				}

				scope.manager.itemStart( url );

				return request;

			},

			setResponseType: function ( value ) {

				this.responseType = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setMimeType: function ( value ) {

				this.mimeType = value;
				return this;

			},

			setRequestHeader: function ( value ) {

				this.requestHeader = value;
				return this;

			}

		} );

		/**
		 * @author bhouston / http://clara.io/
		 */

		function AnimationLoader( manager ) {

			Loader.call( this, manager );

		}

		AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: AnimationLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.setPath( scope.path );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var animations = [];

				for ( var i = 0; i < json.length; i ++ ) {

					var clip = AnimationClip.parse( json[ i ] );

					animations.push( clip );

				}

				return animations;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 *
		 * Sub classes have to implement the parse() method which will be used in load().
		 */

		function CompressedTextureLoader( manager ) {

			Loader.call( this, manager );

		}

		CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: CompressedTextureLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var images = [];

				var texture = new CompressedTexture();
				texture.image = images;

				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );

				function loadTexture( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope.parse( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
								{ texture.minFilter = LinearFilter; }

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) { onLoad( texture ); }

						}

					}, onProgress, onError );

				}

				if ( Array.isArray( url ) ) {

					var loaded = 0;

					for ( var i = 0, il = url.length; i < il; ++ i ) {

						loadTexture( i );

					}

				} else {

					// compressed cubemap texture stored in a single DDS file

					loader.load( url, function ( buffer ) {

						var texDatas = scope.parse( buffer, true );

						if ( texDatas.isCubemap ) {

							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

							for ( var f = 0; f < faces; f ++ ) {

								images[ f ] = { mipmaps: [] };

								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;

								}

							}

						} else {

							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;

						}

						if ( texDatas.mipmapCount === 1 ) {

							texture.minFilter = LinearFilter;

						}

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) { onLoad( texture ); }

					}, onProgress, onError );

				}

				return texture;

			}

		} );

		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 *
		 * Sub classes have to implement the parse() method which will be used in load().
		 */

		function DataTextureLoader( manager ) {

			Loader.call( this, manager );

		}

		DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: DataTextureLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texture = new DataTexture();

				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.setPath( this.path );
				loader.load( url, function ( buffer ) {

					var texData = scope.parse( buffer );

					if ( ! texData ) { return; }

					if ( texData.image !== undefined ) {

						texture.image = texData.image;

					} else if ( texData.data !== undefined ) {

						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;

					}

					texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

					texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
					texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

					texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

					if ( texData.format !== undefined ) {

						texture.format = texData.format;

					}
					if ( texData.type !== undefined ) {

						texture.type = texData.type;

					}

					if ( texData.mipmaps !== undefined ) {

						texture.mipmaps = texData.mipmaps;
						texture.minFilter = LinearMipmapLinearFilter; // presumably...

					}

					if ( texData.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.needsUpdate = true;

					if ( onLoad ) { onLoad( texture, texData ); }

				}, onProgress, onError );


				return texture;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ImageLoader( manager ) {

			Loader.call( this, manager );

		}

		ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: ImageLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				if ( this.path !== undefined ) { url = this.path + url; }

				url = this.manager.resolveURL( url );

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) { onLoad( cached ); }

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

				function onImageLoad() {

					image.removeEventListener( 'load', onImageLoad, false );
					image.removeEventListener( 'error', onImageError, false );

					Cache.add( url, this );

					if ( onLoad ) { onLoad( this ); }

					scope.manager.itemEnd( url );

				}

				function onImageError( event ) {

					image.removeEventListener( 'load', onImageLoad, false );
					image.removeEventListener( 'error', onImageError, false );

					if ( onError ) { onError( event ); }

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

				image.addEventListener( 'load', onImageLoad, false );
				image.addEventListener( 'error', onImageError, false );

				if ( url.substr( 0, 5 ) !== 'data:' ) {

					if ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }

				}

				scope.manager.itemStart( url );

				image.src = url;

				return image;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */


		function CubeTextureLoader( manager ) {

			Loader.call( this, manager );

		}

		CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: CubeTextureLoader,

			load: function ( urls, onLoad, onProgress, onError ) {

				var texture = new CubeTexture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );

				var loaded = 0;

				function loadTexture( i ) {

					loader.load( urls[ i ], function ( image ) {

						texture.images[ i ] = image;

						loaded ++;

						if ( loaded === 6 ) {

							texture.needsUpdate = true;

							if ( onLoad ) { onLoad( texture ); }

						}

					}, undefined, onError );

				}

				for ( var i = 0; i < urls.length; ++ i ) {

					loadTexture( i );

				}

				return texture;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function TextureLoader( manager ) {

			Loader.call( this, manager );

		}

		TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: TextureLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var texture = new Texture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );

				loader.load( url, function ( image ) {

					texture.image = image;

					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.needsUpdate = true;

					if ( onLoad !== undefined ) {

						onLoad( texture );

					}

				}, onProgress, onError );

				return texture;

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of curve methods:
		 * .getPoint( t, optionalTarget ), .getTangent( t )
		 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following curves inherit from THREE.Curve:
		 *
		 * -- 2D curves --
		 * THREE.ArcCurve
		 * THREE.CubicBezierCurve
		 * THREE.EllipseCurve
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.SplineCurve
		 *
		 * -- 3D curves --
		 * THREE.CatmullRomCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath.
		 *
		 **/

		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/

		function Curve() {

			this.type = 'Curve';

			this.arcLengthDivisions = 200;

		}

		Object.assign( Curve.prototype, {

			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]

			getPoint: function ( /* t, optionalTarget */ ) {

				console.warn( 'THREE.Curve: .getPoint() not implemented.' );
				return null;

			},

			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]

			getPointAt: function ( u, optionalTarget ) {

				var t = this.getUtoTmapping( u );
				return this.getPoint( t, optionalTarget );

			},

			// Get sequence of points using getPoint( t )

			getPoints: function ( divisions ) {

				if ( divisions === undefined ) { divisions = 5; }

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPoint( d / divisions ) );

				}

				return points;

			},

			// Get sequence of points using getPointAt( u )

			getSpacedPoints: function ( divisions ) {

				if ( divisions === undefined ) { divisions = 5; }

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPointAt( d / divisions ) );

				}

				return points;

			},

			// Get total curve arc length

			getLength: function () {

				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];

			},

			// Get list of cumulative segment lengths

			getLengths: function ( divisions ) {

				if ( divisions === undefined ) { divisions = this.arcLengthDivisions; }

				if ( this.cacheArcLengths &&
					( this.cacheArcLengths.length === divisions + 1 ) &&
					! this.needsUpdate ) {

					return this.cacheArcLengths;

				}

				this.needsUpdate = false;

				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;

				cache.push( 0 );

				for ( p = 1; p <= divisions; p ++ ) {

					current = this.getPoint( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;

				}

				this.cacheArcLengths = cache;

				return cache; // { sums: cache, sum: sum }; Sum is in the last element.

			},

			updateArcLengths: function () {

				this.needsUpdate = true;
				this.getLengths();

			},

			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

			getUtoTmapping: function ( u, distance ) {

				var arcLengths = this.getLengths();

				var i = 0, il = arcLengths.length;

				var targetArcLength; // The targeted u distance value to get

				if ( distance ) {

					targetArcLength = distance;

				} else {

					targetArcLength = u * arcLengths[ il - 1 ];

				}

				// binary search for the index with largest value smaller than target u distance

				var low = 0, high = il - 1, comparison;

				while ( low <= high ) {

					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

					comparison = arcLengths[ i ] - targetArcLength;

					if ( comparison < 0 ) {

						low = i + 1;

					} else if ( comparison > 0 ) {

						high = i - 1;

					} else {

						high = i;
						break;

						// DONE

					}

				}

				i = high;

				if ( arcLengths[ i ] === targetArcLength ) {

					return i / ( il - 1 );

				}

				// we could get finer grain at lengths, or use simple interpolation between two points

				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];

				var segmentLength = lengthAfter - lengthBefore;

				// determine where we are between the 'before' and 'after' points

				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

				// add that fractional amount to t

				var t = ( i + segmentFraction ) / ( il - 1 );

				return t;

			},

			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation

			getTangent: function ( t ) {

				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;

				// Capping in case of danger

				if ( t1 < 0 ) { t1 = 0; }
				if ( t2 > 1 ) { t2 = 1; }

				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );

				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();

			},

			getTangentAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getTangent( t );

			},

			computeFrenetFrames: function ( segments, closed ) {

				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

				var normal = new Vector3();

				var tangents = [];
				var normals = [];
				var binormals = [];

				var vec = new Vector3();
				var mat = new Matrix4();

				var i, u, theta;

				// compute the tangent vectors for each segment on the curve

				for ( i = 0; i <= segments; i ++ ) {

					u = i / segments;

					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();

				}

				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component

				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );

				if ( tx <= min ) {

					min = tx;
					normal.set( 1, 0, 0 );

				}

				if ( ty <= min ) {

					min = ty;
					normal.set( 0, 1, 0 );

				}

				if ( tz <= min ) {

					normal.set( 0, 0, 1 );

				}

				vec.crossVectors( tangents[ 0 ], normal ).normalize();

				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


				// compute the slowly-varying normal and binormal vectors for each segment on the curve

				for ( i = 1; i <= segments; i ++ ) {

					normals[ i ] = normals[ i - 1 ].clone();

					binormals[ i ] = binormals[ i - 1 ].clone();

					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

					if ( vec.length() > Number.EPSILON ) {

						vec.normalize();

						theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

					}

					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

				if ( closed === true ) {

					theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;

					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

						theta = - theta;

					}

					for ( i = 1; i <= segments; i ++ ) {

						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

					}

				}

				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.arcLengthDivisions = source.arcLengthDivisions;

				return this;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.5,
						type: 'Curve',
						generator: 'Curve.toJSON'
					}
				};

				data.arcLengthDivisions = this.arcLengthDivisions;
				data.type = this.type;

				return data;

			},

			fromJSON: function ( json ) {

				this.arcLengthDivisions = json.arcLengthDivisions;

				return this;

			}

		} );

		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			Curve.call( this );

			this.type = 'EllipseCurve';

			this.aX = aX || 0;
			this.aY = aY || 0;

			this.xRadius = xRadius || 1;
			this.yRadius = yRadius || 1;

			this.aStartAngle = aStartAngle || 0;
			this.aEndAngle = aEndAngle || 2 * Math.PI;

			this.aClockwise = aClockwise || false;

			this.aRotation = aRotation || 0;

		}

		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;

		EllipseCurve.prototype.isEllipseCurve = true;

		EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) { deltaAngle += twoPi; }
			while ( deltaAngle > twoPi ) { deltaAngle -= twoPi; }

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );

				var tx = x - this.aX;
				var ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return point.set( x, y );

		};

		EllipseCurve.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.aX = source.aX;
			this.aY = source.aY;

			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;

			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;

			this.aClockwise = source.aClockwise;

			this.aRotation = source.aRotation;

			return this;

		};


		EllipseCurve.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.aX = this.aX;
			data.aY = this.aY;

			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;

			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;

			data.aClockwise = this.aClockwise;

			data.aRotation = this.aRotation;

			return data;

		};

		EllipseCurve.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.aX = json.aX;
			this.aY = json.aY;

			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;

			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;

			this.aClockwise = json.aClockwise;

			this.aRotation = json.aRotation;

			return this;

		};

		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			this.type = 'ArcCurve';

		}

		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;

		ArcCurve.prototype.isArcCurve = true;

		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */


		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM

		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

			var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			function init( x0, x1, t0, t1 ) {

				c0 = x0;
				c1 = t0;
				c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				c3 = 2 * x0 - 2 * x1 + t0 + t1;

			}

			return {

				initCatmullRom: function ( x0, x1, x2, x3, tension ) {

					init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

				},

				initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

					// compute tangents when parameterized in [t1,t2]
					var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
					var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

					// rescale tangents for parametrization in [0,1]
					t1 *= dt1;
					t2 *= dt1;

					init( x1, x2, t1, t2 );

				},

				calc: function ( t ) {

					var t2 = t * t;
					var t3 = t2 * t;
					return c0 + c1 * t + c2 * t2 + c3 * t3;

				}

			};

		}

		//

		var tmp = new Vector3();
		var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

		function CatmullRomCurve3( points, closed, curveType, tension ) {

			Curve.call( this );

			this.type = 'CatmullRomCurve3';

			this.points = points || [];
			this.closed = closed || false;
			this.curveType = curveType || 'centripetal';
			this.tension = tension || 0.5;

		}

		CatmullRomCurve3.prototype = Object.create( Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

		CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

		CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector3();

			var points = this.points;
			var l = points.length;

			var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( p );
			var weight = p - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3; // 4 points

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) { dt1 = 1.0; }
				if ( dt0 < 1e-4 ) { dt0 = dt1; }
				if ( dt2 < 1e-4 ) { dt2 = dt1; }

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.curveType === 'catmullrom' ) {

				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

			}

			point.set(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return point;

		};

		CatmullRomCurve3.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.points = [];

			for ( var i = 0, l = source.points.length; i < l; i ++ ) {

				var point = source.points[ i ];

				this.points.push( point.clone() );

			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;

			return this;

		};

		CatmullRomCurve3.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.points = [];

			for ( var i = 0, l = this.points.length; i < l; i ++ ) {

				var point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;

			return data;

		};

		CatmullRomCurve3.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.points = [];

			for ( var i = 0, l = json.points.length; i < l; i ++ ) {

				var point = json.points[ i ];
				this.points.push( new Vector3().fromArray( point ) );

			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;

			return this;

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bézier_curve
		 */

		function CatmullRom( t, p0, p1, p2, p3 ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

		//

		function QuadraticBezierP0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function QuadraticBezierP1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function QuadraticBezierP2( t, p ) {

			return t * t * p;

		}

		function QuadraticBezier( t, p0, p1, p2 ) {

			return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
				QuadraticBezierP2( t, p2 );

		}

		//

		function CubicBezierP0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function CubicBezierP1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function CubicBezierP2( t, p ) {

			return 3 * ( 1 - t ) * t * t * p;

		}

		function CubicBezierP3( t, p ) {

			return t * t * t * p;

		}

		function CubicBezier( t, p0, p1, p2, p3 ) {

			return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
				CubicBezierP3( t, p3 );

		}

		function CubicBezierCurve( v0, v1, v2, v3 ) {

			Curve.call( this );

			this.type = 'CubicBezierCurve';

			this.v0 = v0 || new Vector2();
			this.v1 = v1 || new Vector2();
			this.v2 = v2 || new Vector2();
			this.v3 = v3 || new Vector2();

		}

		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;

		CubicBezierCurve.prototype.isCubicBezierCurve = true;

		CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

			return point;

		};

		CubicBezierCurve.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		};

		CubicBezierCurve.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		};

		CubicBezierCurve.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		};

		function CubicBezierCurve3( v0, v1, v2, v3 ) {

			Curve.call( this );

			this.type = 'CubicBezierCurve3';

			this.v0 = v0 || new Vector3();
			this.v1 = v1 || new Vector3();
			this.v2 = v2 || new Vector3();
			this.v3 = v3 || new Vector3();

		}

		CubicBezierCurve3.prototype = Object.create( Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

		CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

		CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector3();

			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

			return point;

		};

		CubicBezierCurve3.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		};

		CubicBezierCurve3.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		};

		CubicBezierCurve3.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		};

		function LineCurve( v1, v2 ) {

			Curve.call( this );

			this.type = 'LineCurve';

			this.v1 = v1 || new Vector2();
			this.v2 = v2 || new Vector2();

		}

		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;

		LineCurve.prototype.isLineCurve = true;

		LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt

		LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		};

		LineCurve.prototype.getTangent = function ( /* t */ ) {

			var tangent = this.v2.clone().sub( this.v1 );

			return tangent.normalize();

		};

		LineCurve.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		LineCurve.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		LineCurve.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		function LineCurve3( v1, v2 ) {

			Curve.call( this );

			this.type = 'LineCurve3';

			this.v1 = v1 || new Vector3();
			this.v2 = v2 || new Vector3();

		}

		LineCurve3.prototype = Object.create( Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;

		LineCurve3.prototype.isLineCurve3 = true;

		LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector3();

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt

		LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		};

		LineCurve3.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		LineCurve3.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		LineCurve3.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		function QuadraticBezierCurve( v0, v1, v2 ) {

			Curve.call( this );

			this.type = 'QuadraticBezierCurve';

			this.v0 = v0 || new Vector2();
			this.v1 = v1 || new Vector2();
			this.v2 = v2 || new Vector2();

		}

		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

		QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

		QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

			return point;

		};

		QuadraticBezierCurve.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		QuadraticBezierCurve.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		function QuadraticBezierCurve3( v0, v1, v2 ) {

			Curve.call( this );

			this.type = 'QuadraticBezierCurve3';

			this.v0 = v0 || new Vector3();
			this.v1 = v1 || new Vector3();
			this.v2 = v2 || new Vector3();

		}

		QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

		QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

		QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector3();

			var v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

			return point;

		};

		QuadraticBezierCurve3.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		};

		QuadraticBezierCurve3.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		};

		QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		};

		function SplineCurve( points /* array of Vector2 */ ) {

			Curve.call( this );

			this.type = 'SplineCurve';

			this.points = points || [];

		}

		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;

		SplineCurve.prototype.isSplineCurve = true;

		SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

			var point = optionalTarget || new Vector2();

			var points = this.points;
			var p = ( points.length - 1 ) * t;

			var intPoint = Math.floor( p );
			var weight = p - intPoint;

			var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var p1 = points[ intPoint ];
			var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			point.set(
				CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
				CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
			);

			return point;

		};

		SplineCurve.prototype.copy = function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.points = [];

			for ( var i = 0, l = source.points.length; i < l; i ++ ) {

				var point = source.points[ i ];

				this.points.push( point.clone() );

			}

			return this;

		};

		SplineCurve.prototype.toJSON = function () {

			var data = Curve.prototype.toJSON.call( this );

			data.points = [];

			for ( var i = 0, l = this.points.length; i < l; i ++ ) {

				var point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			return data;

		};

		SplineCurve.prototype.fromJSON = function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.points = [];

			for ( var i = 0, l = json.points.length; i < l; i ++ ) {

				var point = json.points[ i ];
				this.points.push( new Vector2().fromArray( point ) );

			}

			return this;

		};



		var Curves = /*#__PURE__*/Object.freeze({
			__proto__: null,
			ArcCurve: ArcCurve,
			CatmullRomCurve3: CatmullRomCurve3,
			CubicBezierCurve: CubicBezierCurve,
			CubicBezierCurve3: CubicBezierCurve3,
			EllipseCurve: EllipseCurve,
			LineCurve: LineCurve,
			LineCurve3: LineCurve3,
			QuadraticBezierCurve: QuadraticBezierCurve,
			QuadraticBezierCurve3: QuadraticBezierCurve3,
			SplineCurve: SplineCurve
		});

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/

		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/

		function CurvePath() {

			Curve.call( this );

			this.type = 'CurvePath';

			this.curves = [];
			this.autoClose = false; // Automatically closes the path

		}

		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

			constructor: CurvePath,

			add: function ( curve ) {

				this.curves.push( curve );

			},

			closePath: function () {

				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

				if ( ! startPoint.equals( endPoint ) ) {

					this.curves.push( new LineCurve( endPoint, startPoint ) );

				}

			},

			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:

			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')

			getPoint: function ( t ) {

				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;

				// To think about boundaries points.

				while ( i < curveLengths.length ) {

					if ( curveLengths[ i ] >= d ) {

						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];

						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

						return curve.getPointAt( u );

					}

					i ++;

				}

				return null;

				// loop where sum != 0, sum > d , sum+1 <d

			},

			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength

			getLength: function () {

				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];

			},

			// cacheLengths must be recalculated.
			updateArcLengths: function () {

				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getCurveLengths();

			},

			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.

			getCurveLengths: function () {

				// We use cache values if curves and cache array are same length

				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

					return this.cacheLengths;

				}

				// Get length of sub-curve
				// Push sums into cached array

				var lengths = [], sums = 0;

				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

					sums += this.curves[ i ].getLength();
					lengths.push( sums );

				}

				this.cacheLengths = lengths;

				return lengths;

			},

			getSpacedPoints: function ( divisions ) {

				if ( divisions === undefined ) { divisions = 40; }

				var points = [];

				for ( var i = 0; i <= divisions; i ++ ) {

					points.push( this.getPoint( i / divisions ) );

				}

				if ( this.autoClose ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			getPoints: function ( divisions ) {

				divisions = divisions || 12;

				var points = [], last;

				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

					var curve = curves[ i ];
					var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
						: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
							: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
								: divisions;

					var pts = curve.getPoints( resolution );

					for ( var j = 0; j < pts.length; j ++ ) {

						var point = pts[ j ];

						if ( last && last.equals( point ) ) { continue; } // ensures no consecutive points are duplicates

						points.push( point );
						last = point;

					}

				}

				if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			copy: function ( source ) {

				Curve.prototype.copy.call( this, source );

				this.curves = [];

				for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

					var curve = source.curves[ i ];

					this.curves.push( curve.clone() );

				}

				this.autoClose = source.autoClose;

				return this;

			},

			toJSON: function () {

				var data = Curve.prototype.toJSON.call( this );

				data.autoClose = this.autoClose;
				data.curves = [];

				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

					var curve = this.curves[ i ];
					data.curves.push( curve.toJSON() );

				}

				return data;

			},

			fromJSON: function ( json ) {

				Curve.prototype.fromJSON.call( this, json );

				this.autoClose = json.autoClose;
				this.curves = [];

				for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

					var curve = json.curves[ i ];
					this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

				}

				return this;

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/

		function Path( points ) {

			CurvePath.call( this );

			this.type = 'Path';

			this.currentPoint = new Vector2();

			if ( points ) {

				this.setFromPoints( points );

			}

		}

		Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

			constructor: Path,

			setFromPoints: function ( points ) {

				this.moveTo( points[ 0 ].x, points[ 0 ].y );

				for ( var i = 1, l = points.length; i < l; i ++ ) {

					this.lineTo( points[ i ].x, points[ i ].y );

				}

				return this;

			},

			moveTo: function ( x, y ) {

				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

				return this;

			},

			lineTo: function ( x, y ) {

				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );

				this.currentPoint.set( x, y );

				return this;

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

				return this;

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

				return this;

			},

			splineThru: function ( pts /*Array of Vector*/ ) {

				var npts = [ this.currentPoint.clone() ].concat( pts );

				var curve = new SplineCurve( npts );
				this.curves.push( curve );

				this.currentPoint.copy( pts[ pts.length - 1 ] );

				return this;

			},

			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );

				return this;

			},

			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

				return this;

			},

			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

				return this;

			},

			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

				if ( this.curves.length > 0 ) {

					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );

					if ( ! firstPoint.equals( this.currentPoint ) ) {

						this.lineTo( firstPoint.x, firstPoint.y );

					}

				}

				this.curves.push( curve );

				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );

				return this;

			},

			copy: function ( source ) {

				CurvePath.prototype.copy.call( this, source );

				this.currentPoint.copy( source.currentPoint );

				return this;

			},

			toJSON: function () {

				var data = CurvePath.prototype.toJSON.call( this );

				data.currentPoint = this.currentPoint.toArray();

				return data;

			},

			fromJSON: function ( json ) {

				CurvePath.prototype.fromJSON.call( this, json );

				this.currentPoint.fromArray( json.currentPoint );

				return this;

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/

		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.

		function Shape( points ) {

			Path.call( this, points );

			this.uuid = MathUtils.generateUUID();

			this.type = 'Shape';

			this.holes = [];

		}

		Shape.prototype = Object.assign( Object.create( Path.prototype ), {

			constructor: Shape,

			getPointsHoles: function ( divisions ) {

				var holesPts = [];

				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

					holesPts[ i ] = this.holes[ i ].getPoints( divisions );

				}

				return holesPts;

			},

			// get points of shape and holes (keypoints based on segments parameter)

			extractPoints: function ( divisions ) {

				return {

					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )

				};

			},

			copy: function ( source ) {

				Path.prototype.copy.call( this, source );

				this.holes = [];

				for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

					var hole = source.holes[ i ];

					this.holes.push( hole.clone() );

				}

				return this;

			},

			toJSON: function () {

				var data = Path.prototype.toJSON.call( this );

				data.uuid = this.uuid;
				data.holes = [];

				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

					var hole = this.holes[ i ];
					data.holes.push( hole.toJSON() );

				}

				return data;

			},

			fromJSON: function ( json ) {

				Path.prototype.fromJSON.call( this, json );

				this.uuid = json.uuid;
				this.holes = [];

				for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

					var hole = json.holes[ i ];
					this.holes.push( new Path().fromJSON( hole ) );

				}

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Light( color, intensity ) {

			Object3D.call( this );

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;

			this.receiveShadow = undefined;

		}

		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Light,

			isLight: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.color.copy( source.color );
				this.intensity = source.intensity;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;

				if ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }

				if ( this.distance !== undefined ) { data.object.distance = this.distance; }
				if ( this.angle !== undefined ) { data.object.angle = this.angle; }
				if ( this.decay !== undefined ) { data.object.decay = this.decay; }
				if ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }

				if ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function HemisphereLight( skyColor, groundColor, intensity ) {

			Light.call( this, skyColor, intensity );

			this.type = 'HemisphereLight';

			this.castShadow = undefined;

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: HemisphereLight,

			isHemisphereLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.groundColor.copy( source.groundColor );

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LightShadow( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.radius = 1;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		Object.assign( LightShadow.prototype, {

			_projScreenMatrix: new Matrix4(),

			_lightPositionWorld: new Vector3(),

			_lookTarget: new Vector3(),

			getViewportCount: function () {

				return this._viewportCount;

			},

			getFrustum: function () {

				return this._frustum;

			},

			updateMatrices: function ( light ) {

				var shadowCamera = this.camera,
					shadowMatrix = this.matrix,
					projScreenMatrix = this._projScreenMatrix,
					lookTarget = this._lookTarget,
					lightPositionWorld = this._lightPositionWorld;

				lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( lightPositionWorld );

				lookTarget.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( lookTarget );
				shadowCamera.updateMatrixWorld();

				projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				this._frustum.setFromProjectionMatrix( projScreenMatrix );

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			},

			getViewport: function ( viewportIndex ) {

				return this._viewports[ viewportIndex ];

			},

			getFrameExtents: function () {

				return this._frameExtents;

			},

			copy: function ( source ) {

				this.camera = source.camera.clone();

				this.bias = source.bias;
				this.radius = source.radius;

				this.mapSize.copy( source.mapSize );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			toJSON: function () {

				var object = {};

				if ( this.bias !== 0 ) { object.bias = this.bias; }
				if ( this.radius !== 1 ) { object.radius = this.radius; }
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }

				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;

				return object;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SpotLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		}

		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: SpotLightShadow,

			isSpotLightShadow: true,

			updateMatrices: function ( light ) {

				var camera = this.camera;

				var fov = MathUtils.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || camera.far;

				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();

				}

				LightShadow.prototype.updateMatrices.call( this, light );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

			Light.call( this, color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			Object.defineProperty( this, 'power', {
				get: function () {

					// intensity = power per solid angle.
					// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
					return this.intensity * Math.PI;

				},
				set: function ( power ) {

					// intensity = power per solid angle.
					// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
					this.intensity = power / Math.PI;

				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: SpotLight,

			isSpotLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		function PointLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: PointLightShadow,

			isPointLightShadow: true,

			updateMatrices: function ( light, viewportIndex ) {

				if ( viewportIndex === undefined ) { viewportIndex = 0; }

				var camera = this.camera,
					shadowMatrix = this.matrix,
					lightPositionWorld = this._lightPositionWorld,
					lookTarget = this._lookTarget,
					projScreenMatrix = this._projScreenMatrix;

				lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				camera.position.copy( lightPositionWorld );

				lookTarget.copy( camera.position );
				lookTarget.add( this._cubeDirections[ viewportIndex ] );
				camera.up.copy( this._cubeUps[ viewportIndex ] );
				camera.lookAt( lookTarget );
				camera.updateMatrixWorld();

				shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );

				projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				this._frustum.setFromProjectionMatrix( projScreenMatrix );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */


		function PointLight( color, intensity, distance, decay ) {

			Light.call( this, color, intensity );

			this.type = 'PointLight';

			Object.defineProperty( this, 'power', {
				get: function () {

					// intensity = power per solid angle.
					// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
					return this.intensity * 4 * Math.PI;

				},
				set: function ( power ) {

					// intensity = power per solid angle.
					// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
					this.intensity = power / ( 4 * Math.PI );

				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();

		}

		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: PointLight,

			isPointLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.decay = source.decay;

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */

		function OrthographicCamera( left, right, top, bottom, near, far ) {

			Camera.call( this );

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = ( left !== undefined ) ? left : - 1;
			this.right = ( right !== undefined ) ? right : 1;
			this.top = ( top !== undefined ) ? top : 1;
			this.bottom = ( bottom !== undefined ) ? bottom : - 1;

			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;

			this.updateProjectionMatrix();

		}

		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: OrthographicCamera,

			isOrthographicCamera: true,

			copy: function ( source, recursive ) {

				Camera.prototype.copy.call( this, source, recursive );

				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;

				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				return this;

			},

			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

				if ( this.view === null ) {

					this.view = {
						enabled: true,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					};

				}

				this.view.enabled = true;
				this.view.fullWidth = fullWidth;
				this.view.fullHeight = fullHeight;
				this.view.offsetX = x;
				this.view.offsetY = y;
				this.view.width = width;
				this.view.height = height;

				this.updateProjectionMatrix();

			},

			clearViewOffset: function () {

				if ( this.view !== null ) {

					this.view.enabled = false;

				}

				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;

				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;

				if ( this.view !== null && this.view.enabled ) {

					var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
					var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

					left += scaleW * this.view.offsetX;
					right = left + scaleW * this.view.width;
					top -= scaleH * this.view.offsetY;
					bottom = top - scaleH * this.view.height;

				}

				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

				this.projectionMatrixInverse.getInverse( this.projectionMatrix );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;

				if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectionalLightShadow() {

			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: DirectionalLightShadow,

			isDirectionalLightShadow: true,

			updateMatrices: function ( light ) {

				LightShadow.prototype.updateMatrices.call( this, light );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DirectionalLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: DirectionalLight,

			isDirectionalLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AmbientLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'AmbientLight';

			this.castShadow = undefined;

		}

		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: AmbientLight,

			isAmbientLight: true

		} );

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		function RectAreaLight( color, intensity, width, height ) {

			Light.call( this, color, intensity );

			this.type = 'RectAreaLight';

			this.width = ( width !== undefined ) ? width : 10;
			this.height = ( height !== undefined ) ? height : 10;

		}

		RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: RectAreaLight,

			isRectAreaLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.width = source.width;
				this.height = source.height;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Light.prototype.toJSON.call( this, meta );

				data.object.width = this.width;
				data.object.height = this.height;

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MaterialLoader( manager ) {

			Loader.call( this, manager );

			this.textures = {};

		}

		MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: MaterialLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.setPath( scope.path );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var textures = this.textures;

				function getTexture( name ) {

					if ( textures[ name ] === undefined ) {

						console.warn( 'THREE.MaterialLoader: Undefined texture', name );

					}

					return textures[ name ];

				}

				var material = new Materials[ json.type ]();

				if ( json.uuid !== undefined ) { material.uuid = json.uuid; }
				if ( json.name !== undefined ) { material.name = json.name; }
				if ( json.color !== undefined ) { material.color.setHex( json.color ); }
				if ( json.roughness !== undefined ) { material.roughness = json.roughness; }
				if ( json.metalness !== undefined ) { material.metalness = json.metalness; }
				if ( json.sheen !== undefined ) { material.sheen = new Color().setHex( json.sheen ); }
				if ( json.emissive !== undefined ) { material.emissive.setHex( json.emissive ); }
				if ( json.specular !== undefined ) { material.specular.setHex( json.specular ); }
				if ( json.shininess !== undefined ) { material.shininess = json.shininess; }
				if ( json.clearcoat !== undefined ) { material.clearcoat = json.clearcoat; }
				if ( json.clearcoatRoughness !== undefined ) { material.clearcoatRoughness = json.clearcoatRoughness; }
				if ( json.fog !== undefined ) { material.fog = json.fog; }
				if ( json.flatShading !== undefined ) { material.flatShading = json.flatShading; }
				if ( json.blending !== undefined ) { material.blending = json.blending; }
				if ( json.combine !== undefined ) { material.combine = json.combine; }
				if ( json.side !== undefined ) { material.side = json.side; }
				if ( json.opacity !== undefined ) { material.opacity = json.opacity; }
				if ( json.transparent !== undefined ) { material.transparent = json.transparent; }
				if ( json.alphaTest !== undefined ) { material.alphaTest = json.alphaTest; }
				if ( json.depthTest !== undefined ) { material.depthTest = json.depthTest; }
				if ( json.depthWrite !== undefined ) { material.depthWrite = json.depthWrite; }
				if ( json.colorWrite !== undefined ) { material.colorWrite = json.colorWrite; }

				if ( json.stencilWrite !== undefined ) { material.stencilWrite = json.stencilWrite; }
				if ( json.stencilWriteMask !== undefined ) { material.stencilWriteMask = json.stencilWriteMask; }
				if ( json.stencilFunc !== undefined ) { material.stencilFunc = json.stencilFunc; }
				if ( json.stencilRef !== undefined ) { material.stencilRef = json.stencilRef; }
				if ( json.stencilFuncMask !== undefined ) { material.stencilFuncMask = json.stencilFuncMask; }
				if ( json.stencilFail !== undefined ) { material.stencilFail = json.stencilFail; }
				if ( json.stencilZFail !== undefined ) { material.stencilZFail = json.stencilZFail; }
				if ( json.stencilZPass !== undefined ) { material.stencilZPass = json.stencilZPass; }

				if ( json.wireframe !== undefined ) { material.wireframe = json.wireframe; }
				if ( json.wireframeLinewidth !== undefined ) { material.wireframeLinewidth = json.wireframeLinewidth; }
				if ( json.wireframeLinecap !== undefined ) { material.wireframeLinecap = json.wireframeLinecap; }
				if ( json.wireframeLinejoin !== undefined ) { material.wireframeLinejoin = json.wireframeLinejoin; }

				if ( json.rotation !== undefined ) { material.rotation = json.rotation; }

				if ( json.linewidth !== 1 ) { material.linewidth = json.linewidth; }
				if ( json.dashSize !== undefined ) { material.dashSize = json.dashSize; }
				if ( json.gapSize !== undefined ) { material.gapSize = json.gapSize; }
				if ( json.scale !== undefined ) { material.scale = json.scale; }

				if ( json.polygonOffset !== undefined ) { material.polygonOffset = json.polygonOffset; }
				if ( json.polygonOffsetFactor !== undefined ) { material.polygonOffsetFactor = json.polygonOffsetFactor; }
				if ( json.polygonOffsetUnits !== undefined ) { material.polygonOffsetUnits = json.polygonOffsetUnits; }

				if ( json.skinning !== undefined ) { material.skinning = json.skinning; }
				if ( json.morphTargets !== undefined ) { material.morphTargets = json.morphTargets; }
				if ( json.morphNormals !== undefined ) { material.morphNormals = json.morphNormals; }
				if ( json.dithering !== undefined ) { material.dithering = json.dithering; }

				if ( json.vertexTangents !== undefined ) { material.vertexTangents = json.vertexTangents; }

				if ( json.visible !== undefined ) { material.visible = json.visible; }

				if ( json.toneMapped !== undefined ) { material.toneMapped = json.toneMapped; }

				if ( json.userData !== undefined ) { material.userData = json.userData; }

				if ( json.vertexColors !== undefined ) {

					if ( typeof json.vertexColors === 'number' ) {

						material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

					} else {

						material.vertexColors = json.vertexColors;

					}

				}

				// Shader Material

				if ( json.uniforms !== undefined ) {

					for ( var name in json.uniforms ) {

						var uniform = json.uniforms[ name ];

						material.uniforms[ name ] = {};

						switch ( uniform.type ) {

							case 't':
								material.uniforms[ name ].value = getTexture( uniform.value );
								break;

							case 'c':
								material.uniforms[ name ].value = new Color().setHex( uniform.value );
								break;

							case 'v2':
								material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
								break;

							case 'v3':
								material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
								break;

							case 'v4':
								material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
								break;

							case 'm3':
								material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

							case 'm4':
								material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
								break;

							default:
								material.uniforms[ name ].value = uniform.value;

						}

					}

				}

				if ( json.defines !== undefined ) { material.defines = json.defines; }
				if ( json.vertexShader !== undefined ) { material.vertexShader = json.vertexShader; }
				if ( json.fragmentShader !== undefined ) { material.fragmentShader = json.fragmentShader; }

				if ( json.extensions !== undefined ) {

					for ( var key in json.extensions ) {

						material.extensions[ key ] = json.extensions[ key ];

					}

				}

				// Deprecated

				if ( json.shading !== undefined ) { material.flatShading = json.shading === 1; } // THREE.FlatShading

				// for PointsMaterial

				if ( json.size !== undefined ) { material.size = json.size; }
				if ( json.sizeAttenuation !== undefined ) { material.sizeAttenuation = json.sizeAttenuation; }

				// maps

				if ( json.map !== undefined ) { material.map = getTexture( json.map ); }
				if ( json.matcap !== undefined ) { material.matcap = getTexture( json.matcap ); }

				if ( json.alphaMap !== undefined ) { material.alphaMap = getTexture( json.alphaMap ); }

				if ( json.bumpMap !== undefined ) { material.bumpMap = getTexture( json.bumpMap ); }
				if ( json.bumpScale !== undefined ) { material.bumpScale = json.bumpScale; }

				if ( json.normalMap !== undefined ) { material.normalMap = getTexture( json.normalMap ); }
				if ( json.normalMapType !== undefined ) { material.normalMapType = json.normalMapType; }
				if ( json.normalScale !== undefined ) {

					var normalScale = json.normalScale;

					if ( Array.isArray( normalScale ) === false ) {

						// Blender exporter used to export a scalar. See #7459

						normalScale = [ normalScale, normalScale ];

					}

					material.normalScale = new Vector2().fromArray( normalScale );

				}

				if ( json.displacementMap !== undefined ) { material.displacementMap = getTexture( json.displacementMap ); }
				if ( json.displacementScale !== undefined ) { material.displacementScale = json.displacementScale; }
				if ( json.displacementBias !== undefined ) { material.displacementBias = json.displacementBias; }

				if ( json.roughnessMap !== undefined ) { material.roughnessMap = getTexture( json.roughnessMap ); }
				if ( json.metalnessMap !== undefined ) { material.metalnessMap = getTexture( json.metalnessMap ); }

				if ( json.emissiveMap !== undefined ) { material.emissiveMap = getTexture( json.emissiveMap ); }
				if ( json.emissiveIntensity !== undefined ) { material.emissiveIntensity = json.emissiveIntensity; }

				if ( json.specularMap !== undefined ) { material.specularMap = getTexture( json.specularMap ); }

				if ( json.envMap !== undefined ) { material.envMap = getTexture( json.envMap ); }
				if ( json.envMapIntensity !== undefined ) { material.envMapIntensity = json.envMapIntensity; }

				if ( json.reflectivity !== undefined ) { material.reflectivity = json.reflectivity; }
				if ( json.refractionRatio !== undefined ) { material.refractionRatio = json.refractionRatio; }

				if ( json.lightMap !== undefined ) { material.lightMap = getTexture( json.lightMap ); }
				if ( json.lightMapIntensity !== undefined ) { material.lightMapIntensity = json.lightMapIntensity; }

				if ( json.aoMap !== undefined ) { material.aoMap = getTexture( json.aoMap ); }
				if ( json.aoMapIntensity !== undefined ) { material.aoMapIntensity = json.aoMapIntensity; }

				if ( json.gradientMap !== undefined ) { material.gradientMap = getTexture( json.gradientMap ); }

				if ( json.clearcoatMap !== undefined ) { material.clearcoatMap = getTexture( json.clearcoatMap ); }
				if ( json.clearcoatRoughnessMap !== undefined ) { material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap ); }
				if ( json.clearcoatNormalMap !== undefined ) { material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap ); }
				if ( json.clearcoatNormalScale !== undefined ) { material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale ); }

				return material;

			},

			setTextures: function ( value ) {

				this.textures = value;
				return this;

			}

		} );

		/**
		 * @author Don McCurdy / https://www.donmccurdy.com
		 */

		var LoaderUtils = {

			decodeText: function ( array ) {

				if ( typeof TextDecoder !== 'undefined' ) {

					return new TextDecoder().decode( array );

				}

				// Avoid the String.fromCharCode.apply(null, array) shortcut, which
				// throws a "maximum call stack size exceeded" error for large arrays.

				var s = '';

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					// Implicitly assumes little-endian.
					s += String.fromCharCode( array[ i ] );

				}

				try {

					// merges multi-byte utf-8 characters.

					return decodeURIComponent( escape( s ) );

				} catch ( e ) { // see #16358

					return s;

				}

			},

			extractUrlBase: function ( url ) {

				var index = url.lastIndexOf( '/' );

				if ( index === - 1 ) { return './'; }

				return url.substr( 0, index + 1 );

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferGeometry() {

			BufferGeometry.call( this );

			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;

		}

		InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

			constructor: InstancedBufferGeometry,

			isInstancedBufferGeometry: true,

			copy: function ( source ) {

				BufferGeometry.prototype.copy.call( this, source );

				this.maxInstancedCount = source.maxInstancedCount;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			toJSON: function () {

				var data = BufferGeometry.prototype.toJSON.call( this );

				data.maxInstancedCount = this.maxInstancedCount;

				data.isInstancedBufferGeometry = true;

				return data;

			}

		} );

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

			if ( typeof ( normalized ) === 'number' ) {

				meshPerAttribute = normalized;

				normalized = false;

				console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

			}

			BufferAttribute.call( this, array, itemSize, normalized );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

			constructor: InstancedBufferAttribute,

			isInstancedBufferAttribute: true,

			copy: function ( source ) {

				BufferAttribute.prototype.copy.call( this, source );

				this.meshPerAttribute = source.meshPerAttribute;

				return this;

			},

			toJSON: function ()	{

				var data = BufferAttribute.prototype.toJSON.call( this );

				data.meshPerAttribute = this.meshPerAttribute;

				data.isInstancedBufferAttribute = true;

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometryLoader( manager ) {

			Loader.call( this, manager );

		}

		BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: BufferGeometryLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( scope.manager );
				loader.setPath( scope.path );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

				var index = json.data.index;

				if ( index !== undefined ) {

					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

				}

				var attributes = json.data.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
					var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					var bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );
					if ( attribute.name !== undefined ) { bufferAttribute.name = attribute.name; }
					geometry.setAttribute( key, bufferAttribute );

				}

				var morphAttributes = json.data.morphAttributes;

				if ( morphAttributes ) {

					for ( var key in morphAttributes ) {

						var attributeArray = morphAttributes[ key ];

						var array = [];

						for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

							var attribute = attributeArray[ i ];
							var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

							var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
							if ( attribute.name !== undefined ) { bufferAttribute.name = attribute.name; }
							array.push( bufferAttribute );

						}

						geometry.morphAttributes[ key ] = array;

					}

				}

				var morphTargetsRelative = json.data.morphTargetsRelative;

				if ( morphTargetsRelative ) {

					geometry.morphTargetsRelative = true;

				}

				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

				if ( groups !== undefined ) {

					for ( var i = 0, n = groups.length; i !== n; ++ i ) {

						var group = groups[ i ];

						geometry.addGroup( group.start, group.count, group.materialIndex );

					}

				}

				var boundingSphere = json.data.boundingSphere;

				if ( boundingSphere !== undefined ) {

					var center = new Vector3();

					if ( boundingSphere.center !== undefined ) {

						center.fromArray( boundingSphere.center );

					}

					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

				}

				if ( json.name ) { geometry.name = json.name; }
				if ( json.userData ) { geometry.userData = json.userData; }

				return geometry;

			}

		} );

		var TYPED_ARRAYS = {
			Int8Array: Int8Array,
			Uint8Array: Uint8Array,
			// Workaround for IE11 pre KB2929437. See #11440
			Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
			Int16Array: Int16Array,
			Uint16Array: Uint16Array,
			Int32Array: Int32Array,
			Uint32Array: Uint32Array,
			Float32Array: Float32Array,
			Float64Array: Float64Array
		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ObjectLoader( manager ) {

			Loader.call( this, manager );

		}

		ObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: ObjectLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
				this.resourcePath = this.resourcePath || path;

				var loader = new FileLoader( scope.manager );
				loader.setPath( this.path );
				loader.load( url, function ( text ) {

					var json = null;

					try {

						json = JSON.parse( text );

					} catch ( error ) {

						if ( onError !== undefined ) { onError( error ); }

						console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

						return;

					}

					var metadata = json.metadata;

					if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

						console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
						return;

					}

					scope.parse( json, onLoad );

				}, onProgress, onError );

			},

			parse: function ( json, onLoad ) {

				var shapes = this.parseShape( json.shapes );
				var geometries = this.parseGeometries( json.geometries, shapes );

				var images = this.parseImages( json.images, function () {

					if ( onLoad !== undefined ) { onLoad( object ); }

				} );

				var textures = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );

				var object = this.parseObject( json.object, geometries, materials );

				if ( json.animations ) {

					object.animations = this.parseAnimations( json.animations );

				}

				if ( json.images === undefined || json.images.length === 0 ) {

					if ( onLoad !== undefined ) { onLoad( object ); }

				}

				return object;

			},

			parseShape: function ( json ) {

				var shapes = {};

				if ( json !== undefined ) {

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var shape = new Shape().fromJSON( json[ i ] );

						shapes[ shape.uuid ] = shape;

					}

				}

				return shapes;

			},

			parseGeometries: function ( json, shapes ) {

				var geometries = {};

				if ( json !== undefined ) {

					var bufferGeometryLoader = new BufferGeometryLoader();

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var geometry;
						var data = json[ i ];

						switch ( data.type ) {

							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);

								break;

							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);

								break;

							case 'CircleGeometry':
							case 'CircleBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'ConeGeometry':
							case 'ConeBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'SphereGeometry':
							case 'SphereBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'DodecahedronGeometry':
							case 'DodecahedronBufferGeometry':
							case 'IcosahedronGeometry':
							case 'IcosahedronBufferGeometry':
							case 'OctahedronGeometry':
							case 'OctahedronBufferGeometry':
							case 'TetrahedronGeometry':
							case 'TetrahedronBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);

								break;

							case 'RingGeometry':
							case 'RingBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'TorusGeometry':
							case 'TorusBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);

								break;

							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);

								break;

							case 'TubeGeometry':
							case 'TubeBufferGeometry':

								// This only works for built-in curves (e.g. CatmullRomCurve3).
								// User defined curves or instances of CurvePath will not be deserialized.
								geometry = new Geometries[ data.type ](
									new Curves[ data.path.type ]().fromJSON( data.path ),
									data.tubularSegments,
									data.radius,
									data.radialSegments,
									data.closed
								);

								break;

							case 'LatheGeometry':
							case 'LatheBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);

								break;

							case 'PolyhedronGeometry':
							case 'PolyhedronBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.vertices,
									data.indices,
									data.radius,
									data.details
								);

								break;

							case 'ShapeGeometry':
							case 'ShapeBufferGeometry':

								var geometryShapes = [];

								for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

									var shape = shapes[ data.shapes[ j ] ];

									geometryShapes.push( shape );

								}

								geometry = new Geometries[ data.type ](
									geometryShapes,
									data.curveSegments
								);

								break;


							case 'ExtrudeGeometry':
							case 'ExtrudeBufferGeometry':

								var geometryShapes = [];

								for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

									var shape = shapes[ data.shapes[ j ] ];

									geometryShapes.push( shape );

								}

								var extrudePath = data.options.extrudePath;

								if ( extrudePath !== undefined ) {

									data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

								}

								geometry = new Geometries[ data.type ](
									geometryShapes,
									data.options
								);

								break;

							case 'BufferGeometry':
							case 'InstancedBufferGeometry':

								geometry = bufferGeometryLoader.parse( data );

								break;

							case 'Geometry':

								console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

								break;

							default:

								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

								continue;

						}

						geometry.uuid = data.uuid;

						if ( data.name !== undefined ) { geometry.name = data.name; }
						if ( geometry.isBufferGeometry === true && data.userData !== undefined ) { geometry.userData = data.userData; }

						geometries[ data.uuid ] = geometry;

					}

				}

				return geometries;

			},

			parseMaterials: function ( json, textures ) {

				var cache = {}; // MultiMaterial
				var materials = {};

				if ( json !== undefined ) {

					var loader = new MaterialLoader();
					loader.setTextures( textures );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var data = json[ i ];

						if ( data.type === 'MultiMaterial' ) {

							// Deprecated

							var array = [];

							for ( var j = 0; j < data.materials.length; j ++ ) {

								var material = data.materials[ j ];

								if ( cache[ material.uuid ] === undefined ) {

									cache[ material.uuid ] = loader.parse( material );

								}

								array.push( cache[ material.uuid ] );

							}

							materials[ data.uuid ] = array;

						} else {

							if ( cache[ data.uuid ] === undefined ) {

								cache[ data.uuid ] = loader.parse( data );

							}

							materials[ data.uuid ] = cache[ data.uuid ];

						}

					}

				}

				return materials;

			},

			parseAnimations: function ( json ) {

				var animations = [];

				for ( var i = 0; i < json.length; i ++ ) {

					var data = json[ i ];

					var clip = AnimationClip.parse( data );

					if ( data.uuid !== undefined ) { clip.uuid = data.uuid; }

					animations.push( clip );

				}

				return animations;

			},

			parseImages: function ( json, onLoad ) {

				var scope = this;
				var images = {};

				function loadImage( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					}, undefined, function () {

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					} );

				}

				if ( json !== undefined && json.length > 0 ) {

					var manager = new LoadingManager( onLoad );

					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );

					for ( var i = 0, il = json.length; i < il; i ++ ) {

						var image = json[ i ];
						var url = image.url;

						if ( Array.isArray( url ) ) {

							// load array of images e.g CubeTexture

							images[ image.uuid ] = [];

							for ( var j = 0, jl = url.length; j < jl; j ++ ) {

								var currentUrl = url[ j ];

								var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

								images[ image.uuid ].push( loadImage( path ) );

							}

						} else {

							// load single image

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

							images[ image.uuid ] = loadImage( path );

						}

					}

				}

				return images;

			},

			parseTextures: function ( json, images ) {

				function parseConstant( value, type ) {

					if ( typeof value === 'number' ) { return value; }

					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

					return type[ value ];

				}

				var textures = {};

				if ( json !== undefined ) {

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var data = json[ i ];

						if ( data.image === undefined ) {

							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

						}

						if ( images[ data.image ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

						}

						var texture;

						if ( Array.isArray( images[ data.image ] ) ) {

							texture = new CubeTexture( images[ data.image ] );

						} else {

							texture = new Texture( images[ data.image ] );

						}

						texture.needsUpdate = true;

						texture.uuid = data.uuid;

						if ( data.name !== undefined ) { texture.name = data.name; }

						if ( data.mapping !== undefined ) { texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); }

						if ( data.offset !== undefined ) { texture.offset.fromArray( data.offset ); }
						if ( data.repeat !== undefined ) { texture.repeat.fromArray( data.repeat ); }
						if ( data.center !== undefined ) { texture.center.fromArray( data.center ); }
						if ( data.rotation !== undefined ) { texture.rotation = data.rotation; }

						if ( data.wrap !== undefined ) {

							texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

						}

						if ( data.format !== undefined ) { texture.format = data.format; }
						if ( data.type !== undefined ) { texture.type = data.type; }
						if ( data.encoding !== undefined ) { texture.encoding = data.encoding; }

						if ( data.minFilter !== undefined ) { texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); }
						if ( data.magFilter !== undefined ) { texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); }
						if ( data.anisotropy !== undefined ) { texture.anisotropy = data.anisotropy; }

						if ( data.flipY !== undefined ) { texture.flipY = data.flipY; }

						if ( data.premultiplyAlpha !== undefined ) { texture.premultiplyAlpha = data.premultiplyAlpha; }
						if ( data.unpackAlignment !== undefined ) { texture.unpackAlignment = data.unpackAlignment; }

						textures[ data.uuid ] = texture;

					}

				}

				return textures;

			},

			parseObject: function ( data, geometries, materials ) {

				var object;

				function getGeometry( name ) {

					if ( geometries[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				}

				function getMaterial( name ) {

					if ( name === undefined ) { return undefined; }

					if ( Array.isArray( name ) ) {

						var array = [];

						for ( var i = 0, l = name.length; i < l; i ++ ) {

							var uuid = name[ i ];

							if ( materials[ uuid ] === undefined ) {

								console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

							}

							array.push( materials[ uuid ] );

						}

						return array;

					}

					if ( materials[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				}

				switch ( data.type ) {

					case 'Scene':

						object = new Scene();

						if ( data.background !== undefined ) {

							if ( Number.isInteger( data.background ) ) {

								object.background = new Color( data.background );

							}

						}

						if ( data.fog !== undefined ) {

							if ( data.fog.type === 'Fog' ) {

								object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

							} else if ( data.fog.type === 'FogExp2' ) {

								object.fog = new FogExp2( data.fog.color, data.fog.density );

							}

						}

						break;

					case 'PerspectiveCamera':

						object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						if ( data.focus !== undefined ) { object.focus = data.focus; }
						if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
						if ( data.filmGauge !== undefined ) { object.filmGauge = data.filmGauge; }
						if ( data.filmOffset !== undefined ) { object.filmOffset = data.filmOffset; }
						if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

						break;

					case 'OrthographicCamera':

						object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
						if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

						break;

					case 'AmbientLight':

						object = new AmbientLight( data.color, data.intensity );

						break;

					case 'DirectionalLight':

						object = new DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'RectAreaLight':

						object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

						break;

					case 'SpotLight':

						object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

						break;

					case 'HemisphereLight':

						object = new HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'SkinnedMesh':

						console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

					case 'Mesh':

						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );

						object = new Mesh( geometry, material );

						break;

					case 'InstancedMesh':

						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );
						var count = data.count;
						var instanceMatrix = data.instanceMatrix;

						object = new InstancedMesh( geometry, material, count );
						object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

						break;

					case 'LOD':

						object = new LOD();

						break;

					case 'Line':

						object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'LineLoop':

						object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'LineSegments':

						object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'PointCloud':
					case 'Points':

						object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new Group();

						break;

					default:

						object = new Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) { object.name = data.name; }

				if ( data.matrix !== undefined ) {

					object.matrix.fromArray( data.matrix );

					if ( data.matrixAutoUpdate !== undefined ) { object.matrixAutoUpdate = data.matrixAutoUpdate; }
					if ( object.matrixAutoUpdate ) { object.matrix.decompose( object.position, object.quaternion, object.scale ); }

				} else {

					if ( data.position !== undefined ) { object.position.fromArray( data.position ); }
					if ( data.rotation !== undefined ) { object.rotation.fromArray( data.rotation ); }
					if ( data.quaternion !== undefined ) { object.quaternion.fromArray( data.quaternion ); }
					if ( data.scale !== undefined ) { object.scale.fromArray( data.scale ); }

				}

				if ( data.castShadow !== undefined ) { object.castShadow = data.castShadow; }
				if ( data.receiveShadow !== undefined ) { object.receiveShadow = data.receiveShadow; }

				if ( data.shadow ) {

					if ( data.shadow.bias !== undefined ) { object.shadow.bias = data.shadow.bias; }
					if ( data.shadow.radius !== undefined ) { object.shadow.radius = data.shadow.radius; }
					if ( data.shadow.mapSize !== undefined ) { object.shadow.mapSize.fromArray( data.shadow.mapSize ); }
					if ( data.shadow.camera !== undefined ) { object.shadow.camera = this.parseObject( data.shadow.camera ); }

				}

				if ( data.visible !== undefined ) { object.visible = data.visible; }
				if ( data.frustumCulled !== undefined ) { object.frustumCulled = data.frustumCulled; }
				if ( data.renderOrder !== undefined ) { object.renderOrder = data.renderOrder; }
				if ( data.userData !== undefined ) { object.userData = data.userData; }
				if ( data.layers !== undefined ) { object.layers.mask = data.layers; }

				if ( data.children !== undefined ) {

					var children = data.children;

					for ( var i = 0; i < children.length; i ++ ) {

						object.add( this.parseObject( children[ i ], geometries, materials ) );

					}

				}

				if ( data.type === 'LOD' ) {

					if ( data.autoUpdate !== undefined ) { object.autoUpdate = data.autoUpdate; }

					var levels = data.levels;

					for ( var l = 0; l < levels.length; l ++ ) {

						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );

						if ( child !== undefined ) {

							object.addLevel( child, level.distance );

						}

					}

				}

				return object;

			}

		} );

		var TEXTURE_MAPPING = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};

		var TEXTURE_WRAPPING = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};

		var TEXTURE_FILTER = {
			NearestFilter: NearestFilter,
			NearestMipmapNearestFilter: NearestMipmapNearestFilter,
			NearestMipmapLinearFilter: NearestMipmapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipmapNearestFilter: LinearMipmapNearestFilter,
			LinearMipmapLinearFilter: LinearMipmapLinearFilter
		};

		/**
		 * @author thespite / http://clicktorelease.com/
		 */


		function ImageBitmapLoader( manager ) {

			if ( typeof createImageBitmap === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

			}

			if ( typeof fetch === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

			}

			Loader.call( this, manager );

			this.options = undefined;

		}

		ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: ImageBitmapLoader,

			setOptions: function setOptions( options ) {

				this.options = options;

				return this;

			},

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) { url = ''; }

				if ( this.path !== undefined ) { url = this.path + url; }

				url = this.manager.resolveURL( url );

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) { onLoad( cached ); }

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				fetch( url ).then( function ( res ) {

					return res.blob();

				} ).then( function ( blob ) {

					if ( scope.options === undefined ) {

						// Workaround for FireFox. It causes an error if you pass options.
						return createImageBitmap( blob );

					} else {

						return createImageBitmap( blob, scope.options );

					}

				} ).then( function ( imageBitmap ) {

					Cache.add( url, imageBitmap );

					if ( onLoad ) { onLoad( imageBitmap ); }

					scope.manager.itemEnd( url );

				} ).catch( function ( e ) {

					if ( onError ) { onError( e ); }

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				} );

				scope.manager.itemStart( url );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/

		function ShapePath() {

			this.type = 'ShapePath';

			this.color = new Color();

			this.subPaths = [];
			this.currentPath = null;

		}

		Object.assign( ShapePath.prototype, {

			moveTo: function ( x, y ) {

				this.currentPath = new Path();
				this.subPaths.push( this.currentPath );
				this.currentPath.moveTo( x, y );

				return this;

			},

			lineTo: function ( x, y ) {

				this.currentPath.lineTo( x, y );

				return this;

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

				return this;

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

				return this;

			},

			splineThru: function ( pts ) {

				this.currentPath.splineThru( pts );

				return this;

			},

			toShapes: function ( isCCW, noHoles ) {

				function toShapesNoHoles( inSubpaths ) {

					var shapes = [];

					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

						var tmpPath = inSubpaths[ i ];

						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;

						shapes.push( tmpShape );

					}

					return shapes;

				}

				function isPointInsidePolygon( inPt, inPolygon ) {

					var polyLen = inPolygon.length;

					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

						var edgeLowPt = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];

						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;

						if ( Math.abs( edgeDy ) > Number.EPSILON ) {

							// not parallel
							if ( edgeDy < 0 ) {

								edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		{ continue; }

							if ( inPt.y === edgeLowPt.y ) {

								if ( inPt.x === edgeLowPt.x )		{ return	true; }		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!

							} else {

								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				{ return	true; }		// inPt is on contour ?
								if ( perpEdge < 0 ) 				{ continue; }
								inside = ! inside;		// true intersection left of inPt

							}

						} else {

							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		{ continue; }			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		{ return	true; }	// inPt: Point on contour !
							// continue;

						}

					}

					return	inside;

				}

				var isClockWise = ShapeUtils.isClockWise;

				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) { return []; }

				if ( noHoles === true )	{ return	toShapesNoHoles( subPaths ); }


				var solid, tmpPath, tmpShape, shapes = [];

				if ( subPaths.length === 1 ) {

					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;

				}

				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;

				// console.log("Holes first", holesFirst);

				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;

				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];

				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;

					if ( solid ) {

						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	{ mainIdx ++; }

						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;

						if ( holesFirst )	{ mainIdx ++; }
						newShapeHoles[ mainIdx ] = [];

						//console.log('cw', i);

					} else {

						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

						//console.log('ccw', i);

					}

				}

				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	{ return	toShapesNoHoles( subPaths ); }


				if ( newShapes.length > 1 ) {

					var ambiguous = false;
					var toChange = [];

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						betterShapeHoles[ sIdx ] = [];

					}

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						var sho = newShapeHoles[ sIdx ];

						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

							var ho = sho[ hIdx ];
							var hole_unassigned = true;

							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

									if ( sIdx !== s2Idx )	{ toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); }
									if ( hole_unassigned ) {

										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );

									} else {

										ambiguous = true;

									}

								}

							}
							if ( hole_unassigned ) {

								betterShapeHoles[ sIdx ].push( ho );

							}

						}

					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {

						// console.log("to change: ", toChange);
						if ( ! ambiguous )	{ newShapeHoles = betterShapeHoles; }

					}

				}

				var tmpHoles;

				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];

					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

						tmpShape.holes.push( tmpHoles[ j ].h );

					}

				}

				//console.log("shape", shapes);

				return shapes;

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */


		function Font( data ) {

			this.type = 'Font';

			this.data = data;

		}

		Object.assign( Font.prototype, {

			isFont: true,

			generateShapes: function ( text, size ) {

				if ( size === undefined ) { size = 100; }

				var shapes = [];
				var paths = createPaths( text, size, this.data );

				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

				}

				return shapes;

			}

		} );

		function createPaths( text, size, data ) {

			var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
			var scale = size / data.resolution;
			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

			var paths = [];

			var offsetX = 0, offsetY = 0;

			for ( var i = 0; i < chars.length; i ++ ) {

				var char = chars[ i ];

				if ( char === '\n' ) {

					offsetX = 0;
					offsetY -= line_height;

				} else {

					var ret = createPath( char, scale, offsetX, offsetY, data );
					offsetX += ret.offsetX;
					paths.push( ret.path );

				}

			}

			return paths;

		}

		function createPath( char, scale, offsetX, offsetY, data ) {

			var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

			if ( ! glyph ) {

				console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

				return;

			}

			var path = new ShapePath();

			var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offsetX;
							y = outline[ i ++ ] * scale + offsetY;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx = outline[ i ++ ] * scale + offsetX;
							cpy = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							break;

						case 'b': // bezierCurveTo

							cpx = outline[ i ++ ] * scale + offsetX;
							cpy = outline[ i ++ ] * scale + offsetY;
							cpx1 = outline[ i ++ ] * scale + offsetX;
							cpy1 = outline[ i ++ ] * scale + offsetY;
							cpx2 = outline[ i ++ ] * scale + offsetX;
							cpy2 = outline[ i ++ ] * scale + offsetY;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							break;

					}

				}

			}

			return { offsetX: glyph.ha * scale, path: path };

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function FontLoader( manager ) {

			Loader.call( this, manager );

		}

		FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: FontLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.load( url, function ( text ) {

					var json;

					try {

						json = JSON.parse( text );

					} catch ( e ) {

						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );

					}

					var font = scope.parse( json );

					if ( onLoad ) { onLoad( font ); }

				}, onProgress, onError );

			},

			parse: function ( json ) {

				return new Font( json );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _context;

		var AudioContext = {

			getContext: function () {

				if ( _context === undefined ) {

					_context = new ( window.AudioContext || window.webkitAudioContext )();

				}

				return _context;

			},

			setContext: function ( value ) {

				_context = value;

			}

		};

		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function AudioLoader( manager ) {

			Loader.call( this, manager );

		}

		AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

			constructor: AudioLoader,

			load: function ( url, onLoad, onProgress, onError ) {

				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.setPath( this.path );
				loader.load( url, function ( buffer ) {

					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					var bufferCopy = buffer.slice( 0 );

					var context = AudioContext.getContext();
					context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				}, onProgress, onError );

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Primary reference:
		 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
		 *
		 * Secondary reference:
		 *   https://www.ppsloan.org/publications/StupidSH36.pdf
		 */

		// 3-band SH defined by 9 coefficients

		function SphericalHarmonics3() {

			this.coefficients = [];

			for ( var i = 0; i < 9; i ++ ) {

				this.coefficients.push( new Vector3() );

			}

		}

		Object.assign( SphericalHarmonics3.prototype, {

			isSphericalHarmonics3: true,

			set: function ( coefficients ) {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].copy( coefficients[ i ] );

				}

				return this;

			},

			zero: function () {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].set( 0, 0, 0 );

				}

				return this;

			},

			// get the radiance in the direction of the normal
			// target is a Vector3
			getAt: function ( normal, target ) {

				// normal is assumed to be unit length

				var x = normal.x, y = normal.y, z = normal.z;

				var coeff = this.coefficients;

				// band 0
				target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

				// band 1
				target.addScaledVector( coeff[ 1 ], 0.488603 * y );
				target.addScaledVector( coeff[ 2 ], 0.488603 * z );
				target.addScaledVector( coeff[ 3 ], 0.488603 * x );

				// band 2
				target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
				target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
				target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
				target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
				target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

				return target;

			},

			// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
			// target is a Vector3
			// https://graphics.stanford.edu/papers/envmap/envmap.pdf
			getIrradianceAt: function ( normal, target ) {

				// normal is assumed to be unit length

				var x = normal.x, y = normal.y, z = normal.z;

				var coeff = this.coefficients;

				// band 0
				target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

				// band 1
				target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
				target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
				target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

				// band 2
				target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
				target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
				target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
				target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
				target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

				return target;

			},

			add: function ( sh ) {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].add( sh.coefficients[ i ] );

				}

				return this;

			},

			addScaledSH: function ( sh, s ) {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

				}

				return this;

			},

			scale: function ( s ) {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].multiplyScalar( s );

				}

				return this;

			},

			lerp: function ( sh, alpha ) {

				for ( var i = 0; i < 9; i ++ ) {

					this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

				}

				return this;

			},

			equals: function ( sh ) {

				for ( var i = 0; i < 9; i ++ ) {

					if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

						return false;

					}

				}

				return true;

			},

			copy: function ( sh ) {

				return this.set( sh.coefficients );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) { offset = 0; }

				var coefficients = this.coefficients;

				for ( var i = 0; i < 9; i ++ ) {

					coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) { array = []; }
				if ( offset === undefined ) { offset = 0; }

				var coefficients = this.coefficients;

				for ( var i = 0; i < 9; i ++ ) {

					coefficients[ i ].toArray( array, offset + ( i * 3 ) );

				}

				return array;

			}

		} );

		Object.assign( SphericalHarmonics3, {

			// evaluate the basis functions
			// shBasis is an Array[ 9 ]
			getBasisAt: function ( normal, shBasis ) {

				// normal is assumed to be unit length

				var x = normal.x, y = normal.y, z = normal.z;

				// band 0
				shBasis[ 0 ] = 0.282095;

				// band 1
				shBasis[ 1 ] = 0.488603 * y;
				shBasis[ 2 ] = 0.488603 * z;
				shBasis[ 3 ] = 0.488603 * x;

				// band 2
				shBasis[ 4 ] = 1.092548 * x * y;
				shBasis[ 5 ] = 1.092548 * y * z;
				shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
				shBasis[ 7 ] = 1.092548 * x * z;
				shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

			}

		} );

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * A LightProbe is a source of indirect-diffuse light
		 */

		function LightProbe( sh, intensity ) {

			Light.call( this, undefined, intensity );

			this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();

		}

		LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: LightProbe,

			isLightProbe: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.sh.copy( source.sh );
				this.intensity = source.intensity;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Light.prototype.toJSON.call( this, meta );

				// data.sh = this.sh.toArray(); // todo

				return data;

			}

		} );

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function HemisphereLightProbe( skyColor, groundColor, intensity ) {

			LightProbe.call( this, undefined, intensity );

			var color1 = new Color().set( skyColor );
			var color2 = new Color().set( groundColor );

			var sky = new Vector3( color1.r, color1.g, color1.b );
			var ground = new Vector3( color2.r, color2.g, color2.b );

			// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
			var c0 = Math.sqrt( Math.PI );
			var c1 = c0 * Math.sqrt( 0.75 );

			this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
			this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

		}

		HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

			constructor: HemisphereLightProbe,

			isHemisphereLightProbe: true,

			copy: function ( source ) { // modifying colors not currently supported

				LightProbe.prototype.copy.call( this, source );

				return this;

			},

			toJSON: function ( meta ) {

				var data = LightProbe.prototype.toJSON.call( this, meta );

				// data.sh = this.sh.toArray(); // todo

				return data;

			}

		} );

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function AmbientLightProbe( color, intensity ) {

			LightProbe.call( this, undefined, intensity );

			var color1 = new Color().set( color );

			// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
			this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

		}

		AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

			constructor: AmbientLightProbe,

			isAmbientLightProbe: true,

			copy: function ( source ) { // modifying color not currently supported

				LightProbe.prototype.copy.call( this, source );

				return this;

			},

			toJSON: function ( meta ) {

				var data = LightProbe.prototype.toJSON.call( this, meta );

				// data.sh = this.sh.toArray(); // todo

				return data;

			}

		} );

		var _eyeRight = new Matrix4();
		var _eyeLeft = new Matrix4();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function StereoCamera() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};

		}

		Object.assign( StereoCamera.prototype, {

			update: function ( camera ) {

				var cache = this._cache;

				var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
					cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
					cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					cache.focus = camera.focus;
					cache.fov = camera.fov;
					cache.aspect = camera.aspect * this.aspect;
					cache.near = camera.near;
					cache.far = camera.far;
					cache.zoom = camera.zoom;
					cache.eyeSep = this.eyeSep;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					var eyeSepHalf = cache.eyeSep / 2;
					var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
					var ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
					var xmin, xmax;

					// translate xOffset

					_eyeLeft.elements[ 12 ] = - eyeSepHalf;
					_eyeRight.elements[ 12 ] = eyeSepHalf;

					// for left eye

					xmin = - ymax * cache.aspect + eyeSepOnProjection;
					xmax = ymax * cache.aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * cache.aspect - eyeSepOnProjection;
					xmax = ymax * cache.aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Clock( autoStart ) {

			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		Object.assign( Clock.prototype, {

			start: function () {

				this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;

			},

			stop: function () {

				this.getElapsedTime();
				this.running = false;
				this.autoStart = false;

			},

			getElapsedTime: function () {

				this.getDelta();
				return this.elapsedTime;

			},

			getDelta: function () {

				var diff = 0;

				if ( this.autoStart && ! this.running ) {

					this.start();
					return 0;

				}

				if ( this.running ) {

					var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;

					this.elapsedTime += diff;

				}

				return diff;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _position$2 = new Vector3();
		var _quaternion$3 = new Quaternion();
		var _scale$1 = new Vector3();
		var _orientation = new Vector3();

		function AudioListener() {

			Object3D.call( this );

			this.type = 'AudioListener';

			this.context = AudioContext.getContext();

			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );

			this.filter = null;

			this.timeDelta = 0;

			// private

			this._clock = new Clock();

		}

		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: AudioListener,

			getInput: function () {

				return this.gain;

			},

			removeFilter: function ( ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;

				}

				return this;

			},

			getFilter: function () {

				return this.filter;

			},

			setFilter: function ( value ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );

				} else {

					this.gain.disconnect( this.context.destination );

				}

				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );

				return this;

			},

			getMasterVolume: function () {

				return this.gain.gain.value;

			},

			setMasterVolume: function ( value ) {

				this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

				return this;

			},

			updateMatrixWorld: function ( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.timeDelta = this._clock.getDelta();

				this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

				_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

				if ( listener.positionX ) {

					// code path for Chrome (see #14393)

					var endTime = this.context.currentTime + this.timeDelta;

					listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
					listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
					listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
					listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
					listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
					listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
					listener.upX.linearRampToValueAtTime( up.x, endTime );
					listener.upY.linearRampToValueAtTime( up.y, endTime );
					listener.upZ.linearRampToValueAtTime( up.z, endTime );

				} else {

					listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
					listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function Audio( listener ) {

			Object3D.call( this );

			this.type = 'Audio';

			this.listener = listener;
			this.context = listener.context;

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';

			this._startedAt = 0;
			this._pausedAt = 0;

			this.filters = [];

		}

		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Audio,

			getOutput: function () {

				return this.gain;

			},

			setNodeSource: function ( audioNode ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();

				return this;

			},

			setMediaElementSource: function ( mediaElement ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'mediaNode';
				this.source = this.context.createMediaElementSource( mediaElement );
				this.connect();

				return this;

			},

			setMediaStreamSource: function ( mediaStream ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'mediaStreamNode';
				this.source = this.context.createMediaStreamSource( mediaStream );
				this.connect();

				return this;

			},

			setBuffer: function ( audioBuffer ) {

				this.buffer = audioBuffer;
				this.sourceType = 'buffer';

				if ( this.autoplay ) { this.play(); }

				return this;

			},

			play: function ( delay ) {

				if ( delay === undefined ) { delay = 0; }

				if ( this.isPlaying === true ) {

					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;

				}

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this._startedAt = this.context.currentTime + delay;

				var source = this.context.createBufferSource();
				source.buffer = this.buffer;
				source.loop = this.loop;
				source.loopStart = this.loopStart;
				source.loopEnd = this.loopEnd;
				source.onended = this.onEnded.bind( this );
				source.start( this._startedAt, this._pausedAt + this.offset, this.duration );

				this.isPlaying = true;

				this.source = source;

				this.setDetune( this.detune );
				this.setPlaybackRate( this.playbackRate );

				return this.connect();

			},

			pause: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				if ( this.isPlaying === true ) {

					this._pausedAt += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

					this.source.stop();
					this.source.onended = null;

					this.isPlaying = false;

				}

				return this;

			},

			stop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this._pausedAt = 0;

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;

				return this;

			},

			connect: function () {

				if ( this.filters.length > 0 ) {

					this.source.connect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].connect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

				} else {

					this.source.connect( this.getOutput() );

				}

				return this;

			},

			disconnect: function () {

				if ( this.filters.length > 0 ) {

					this.source.disconnect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].disconnect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

				} else {

					this.source.disconnect( this.getOutput() );

				}

				return this;

			},

			getFilters: function () {

				return this.filters;

			},

			setFilters: function ( value ) {

				if ( ! value ) { value = []; }

				if ( this.isPlaying === true ) {

					this.disconnect();
					this.filters = value;
					this.connect();

				} else {

					this.filters = value;

				}

				return this;

			},

			setDetune: function ( value ) {

				this.detune = value;

				if ( this.source.detune === undefined ) { return; } // only set detune when available

				if ( this.isPlaying === true ) {

					this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

				}

				return this;

			},

			getDetune: function () {

				return this.detune;

			},

			getFilter: function () {

				return this.getFilters()[ 0 ];

			},

			setFilter: function ( filter ) {

				return this.setFilters( filter ? [ filter ] : [] );

			},

			setPlaybackRate: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.playbackRate = value;

				if ( this.isPlaying === true ) {

					this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

				}

				return this;

			},

			getPlaybackRate: function () {

				return this.playbackRate;

			},

			onEnded: function () {

				this.isPlaying = false;

			},

			getLoop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;

				}

				return this.loop;

			},

			setLoop: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.loop = value;

				if ( this.isPlaying === true ) {

					this.source.loop = this.loop;

				}

				return this;

			},

			setLoopStart: function ( value ) {

				this.loopStart = value;

				return this;

			},

			setLoopEnd: function ( value ) {

				this.loopEnd = value;

				return this;

			},

			getVolume: function () {

				return this.gain.gain.value;

			},

			setVolume: function ( value ) {

				this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _position$3 = new Vector3();
		var _quaternion$4 = new Quaternion();
		var _scale$2 = new Vector3();
		var _orientation$1 = new Vector3();

		function PositionalAudio( listener ) {

			Audio.call( this, listener );

			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect( this.gain );

		}

		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

			constructor: PositionalAudio,

			getOutput: function () {

				return this.panner;

			},

			getRefDistance: function () {

				return this.panner.refDistance;

			},

			setRefDistance: function ( value ) {

				this.panner.refDistance = value;

				return this;

			},

			getRolloffFactor: function () {

				return this.panner.rolloffFactor;

			},

			setRolloffFactor: function ( value ) {

				this.panner.rolloffFactor = value;

				return this;

			},

			getDistanceModel: function () {

				return this.panner.distanceModel;

			},

			setDistanceModel: function ( value ) {

				this.panner.distanceModel = value;

				return this;

			},

			getMaxDistance: function () {

				return this.panner.maxDistance;

			},

			setMaxDistance: function ( value ) {

				this.panner.maxDistance = value;

				return this;

			},

			setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

				this.panner.coneInnerAngle = coneInnerAngle;
				this.panner.coneOuterAngle = coneOuterAngle;
				this.panner.coneOuterGain = coneOuterGain;

				return this;

			},

			updateMatrixWorld: function ( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				if ( this.hasPlaybackControl === true && this.isPlaying === false ) { return; }

				this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

				_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

				var panner = this.panner;

				if ( panner.positionX ) {

					// code path for Chrome and Firefox (see #14393)

					var endTime = this.context.currentTime + this.listener.timeDelta;

					panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
					panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
					panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
					panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
					panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
					panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

				} else {

					panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
					panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioAnalyser( audio, fftSize ) {

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

			this.data = new Uint8Array( this.analyser.frequencyBinCount );

			audio.getOutput().connect( this.analyser );

		}

		Object.assign( AudioAnalyser.prototype, {

			getFrequencyData: function () {

				this.analyser.getByteFrequencyData( this.data );

				return this.data;

			},

			getAverageFrequency: function () {

				var value = 0, data = this.getFrequencyData();

				for ( var i = 0; i < data.length; i ++ ) {

					value += data[ i ];

				}

				return value / data.length;

			}

		} );

		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyMixer( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			var bufferType = Float64Array,
				mixFunction;

			switch ( typeName ) {

				case 'quaternion':
					mixFunction = this._slerp;
					break;

				case 'string':
				case 'bool':
					bufferType = Array;
					mixFunction = this._select;
					break;

				default:
					mixFunction = this._lerp;

			}

			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property

			this._mixBufferRegion = mixFunction;

			this.cumulativeWeight = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		Object.assign( PropertyMixer.prototype, {

			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function ( accuIndex, weight ) {

				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place

				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,

					currentWeight = this.cumulativeWeight;

				if ( currentWeight === 0 ) {

					// accuN := incoming * weight

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ offset + i ] = buffer[ i ];

					}

					currentWeight = weight;

				} else {

					// accuN := accuN + incoming * weight

					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );

				}

				this.cumulativeWeight = currentWeight;

			},

			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function ( accuIndex ) {

				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,

					weight = this.cumulativeWeight,

					binding = this.binding;

				this.cumulativeWeight = 0;

				if ( weight < 1 ) {

					// accuN := accuN + original * ( 1 - cumulativeWeight )

					var originalValueOffset = stride * 3;

					this._mixBufferRegion(
						buffer, offset, originalValueOffset, 1 - weight, stride );

				}

				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

					if ( buffer[ i ] !== buffer[ i + stride ] ) {

						// value has changed -> update scene graph

						binding.setValue( buffer, offset );
						break;

					}

				}

			},

			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function () {

				var binding = this.binding;

				var buffer = this.buffer,
					stride = this.valueSize,

					originalValueOffset = stride * 3;

				binding.getValue( buffer, originalValueOffset );

				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

				}

				this.cumulativeWeight = 0;

			},

			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function () {

				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );

			},


			// mix functions

			_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

				if ( t >= 0.5 ) {

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

					}

				}

			},

			_slerp: function ( buffer, dstOffset, srcOffset, t ) {

				Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

			},

			_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

				var s = 1 - t;

				for ( var i = 0; i !== stride; ++ i ) {

					var j = dstOffset + i;

					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

				}

			}

		} );

		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		// Characters [].:/ are reserved for track binding syntax.
		var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
		var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

		// Attempts to allow node names from any language. ES5's `\w` regexp matches
		// only latin characters, and the unicode \p{L} is not yet supported. So
		// instead, we exclude reserved characters and match everything else.
		var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
		var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

		// Parent directories, delimited by '/' or ':'. Currently unused, but must
		// be matched to parse the rest of the track name.
		var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
		var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

		// Object on target node, and accessor. May not contain reserved
		// characters. Accessor may contain any character except closing bracket.
		var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

		// Property and accessor. May not contain reserved characters. Accessor may
		// contain any non-bracket characters.
		var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

		var _trackRe = new RegExp( ''
			+ '^'
			+ _directoryRe
			+ _nodeRe
			+ _objectRe
			+ _propertyRe
			+ '$'
		);

		var _supportedObjectNames = [ 'material', 'materials', 'bones' ];

		function Composite( targetGroup, path, optionalParsedPath ) {

			var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		}

		Object.assign( Composite.prototype, {

			getValue: function ( array, offset ) {

				this.bind(); // bind all binding

				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];

				// and only call .getValue on the first
				if ( binding !== undefined ) { binding.getValue( array, offset ); }

			},

			setValue: function ( array, offset ) {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].setValue( array, offset );

				}

			},

			bind: function () {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].bind();

				}

			},

			unbind: function () {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].unbind();

				}

			}

		} );


		function PropertyBinding( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

			this.rootNode = rootNode;

		}

		Object.assign( PropertyBinding, {

			Composite: Composite,

			create: function ( root, path, parsedPath ) {

				if ( ! ( root && root.isAnimationObjectGroup ) ) {

					return new PropertyBinding( root, path, parsedPath );

				} else {

					return new PropertyBinding.Composite( root, path, parsedPath );

				}

			},

			/**
			 * Replaces spaces with underscores and removes unsupported characters from
			 * node names, to ensure compatibility with parseTrackName().
			 *
			 * @param {string} name Node name to be sanitized.
			 * @return {string}
			 */
			sanitizeNodeName: function ( name ) {

				return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

			},

			parseTrackName: function ( trackName ) {

				var matches = _trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			},

			findNode: function ( root, nodeName ) {

				if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

					return root;

				}

				// search into skeleton bones.
				if ( root.skeleton ) {

					var bone = root.skeleton.getBoneByName( nodeName );

					if ( bone !== undefined ) {

						return bone;

					}

				}

				// search into node subtree.
				if ( root.children ) {

					var searchNodeSubtree = function ( children ) {

						for ( var i = 0; i < children.length; i ++ ) {

							var childNode = children[ i ];

							if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

								return childNode;

							}

							var result = searchNodeSubtree( childNode.children );

							if ( result ) { return result; }

						}

						return null;

					};

					var subTreeNode = searchNodeSubtree( root.children );

					if ( subTreeNode ) {

						return subTreeNode;

					}

				}

				return null;

			}

		} );

		Object.assign( PropertyBinding.prototype, { // prototype, continued

			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function () {},
			_setValue_unavailable: function () {},

			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},

			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},

			GetterByBindingType: [

				function getValue_direct( buffer, offset ) {

					buffer[ offset ] = this.node[ this.propertyName ];

				},

				function getValue_array( buffer, offset ) {

					var source = this.resolvedProperty;

					for ( var i = 0, n = source.length; i !== n; ++ i ) {

						buffer[ offset ++ ] = source[ i ];

					}

				},

				function getValue_arrayElement( buffer, offset ) {

					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

				},

				function getValue_toArray( buffer, offset ) {

					this.resolvedProperty.toArray( buffer, offset );

				}

			],

			SetterByBindingTypeAndVersioning: [

				[
					// Direct

					function setValue_direct( buffer, offset ) {

						this.targetObject[ this.propertyName ] = buffer[ offset ];

					},

					function setValue_direct_setNeedsUpdate( buffer, offset ) {

						this.targetObject[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.targetObject[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// EntireArray

					function setValue_array( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

					},

					function setValue_array_setNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.needsUpdate = true;

					},

					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// ArrayElement

					function setValue_arrayElement( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

					},

					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// HasToFromArray

					function setValue_fromArray( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );

					},

					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;

					},

					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				]

			],

			getValue: function getValue_unbound( targetArray, offset ) {

				this.bind();
				this.getValue( targetArray, offset );

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.

			},

			setValue: function getValue_unbound( sourceArray, offset ) {

				this.bind();
				this.setValue( sourceArray, offset );

			},

			// create getter / setter pair for a property in the scene graph
			bind: function () {

				var targetObject = this.node,
					parsedPath = this.parsedPath,

					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;

				if ( ! targetObject ) {

					targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

					this.node = targetObject;

				}

				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;

				// ensure there is a value node
				if ( ! targetObject ) {

					console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
					return;

				}

				if ( objectName ) {

					var objectIndex = parsedPath.objectIndex;

					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {

						case 'materials':

							if ( ! targetObject.material ) {

								console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
								return;

							}

							if ( ! targetObject.material.materials ) {

								console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
								return;

							}

							targetObject = targetObject.material.materials;

							break;

						case 'bones':

							if ( ! targetObject.skeleton ) {

								console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
								return;

							}

							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.

							targetObject = targetObject.skeleton.bones;

							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {

								if ( targetObject[ i ].name === objectIndex ) {

									objectIndex = i;
									break;

								}

							}

							break;

						default:

							if ( targetObject[ objectName ] === undefined ) {

								console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
								return;

							}

							targetObject = targetObject[ objectName ];

					}


					if ( objectIndex !== undefined ) {

						if ( targetObject[ objectIndex ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
							return;

						}

						targetObject = targetObject[ objectIndex ];

					}

				}

				// resolve property
				var nodeProperty = targetObject[ propertyName ];

				if ( nodeProperty === undefined ) {

					var nodeName = parsedPath.nodeName;

					console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
						'.' + propertyName + ' but it wasn\'t found.', targetObject );
					return;

				}

				// determine versioning scheme
				var versioning = this.Versioning.None;

				this.targetObject = targetObject;

				if ( targetObject.needsUpdate !== undefined ) { // material

					versioning = this.Versioning.NeedsUpdate;

				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

					versioning = this.Versioning.MatrixWorldNeedsUpdate;

				}

				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;

				if ( propertyIndex !== undefined ) {

					// access a sub element of the property array (only primitives are supported right now)

					if ( propertyName === "morphTargetInfluences" ) {

						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
							return;

						}

						if ( targetObject.geometry.isBufferGeometry ) {

							if ( ! targetObject.geometry.morphAttributes ) {

								console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
								return;

							}

							for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

								if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

									propertyIndex = i;
									break;

								}

							}


						} else {

							if ( ! targetObject.geometry.morphTargets ) {

								console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
								return;

							}

							for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

								if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

									propertyIndex = i;
									break;

								}

							}

						}

					}

					bindingType = this.BindingType.ArrayElement;

					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;

				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

					// must use copy for Object3D.Euler/Quaternion

					bindingType = this.BindingType.HasFromToArray;

					this.resolvedProperty = nodeProperty;

				} else if ( Array.isArray( nodeProperty ) ) {

					bindingType = this.BindingType.EntireArray;

					this.resolvedProperty = nodeProperty;

				} else {

					this.propertyName = propertyName;

				}

				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

			},

			unbind: function () {

				this.node = null;

				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;

			}

		} );

		// DECLARE ALIAS AFTER assign prototype
		Object.assign( PropertyBinding.prototype, {

			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,

		} );

		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 *  - Add objects you would otherwise pass as 'root' to the
		 *    constructor or the .clipAction method of AnimationMixer.
		 *
		 *  - Instead pass this object as 'root'.
		 *
		 *  - You can also add and remove objects later when the mixer
		 *    is running.
		 *
		 * Note:
		 *
		 *    Objects of this class appear as one object to the mixer,
		 *    so cache control of the individual objects must be done
		 *    on the group.
		 *
		 * Limitation:
		 *
		 *  - The animated properties must be compatible among the
		 *    all objects in the group.
		 *
		 *  - A single property can either be controlled through a
		 *    target group or directly, but not both.
		 *
		 * @author tschw
		 */

		function AnimationObjectGroup() {

			this.uuid = MathUtils.generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			var indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = []; // inside: string
			this._parsedPaths = []; // inside: { we don't care, here }
			this._bindings = []; // inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			var scope = this;

			this.stats = {

				objects: {
					get total() {

						return scope._objects.length;

					},
					get inUse() {

						return this.total - scope.nCachedObjects_;

					}
				},
				get bindingsPerObject() {

					return scope._bindings.length;

				}

			};

		}

		Object.assign( AnimationObjectGroup.prototype, {

			isAnimationObjectGroup: true,

			add: function () {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length,
					knownObject = undefined;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index === undefined ) {

						// unknown object -> add it to the ACTIVE region

						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

						}

					} else if ( index < nCachedObjects ) {

						knownObject = objects[ index ];

						// move existing object to the ACTIVE region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];

						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = lastCached;

							if ( binding === undefined ) {

								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist

								binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

							}

							bindingsForPath[ firstActiveIndex ] = binding;

						}

					} else if ( objects[ index ] !== knownObject ) {

						console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

					} // else the object is already where we want it to be

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			remove: function () {

				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined && index >= nCachedObjects ) {

						// move existing object into the CACHED region

						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];

						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;

						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;

						}

					}

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// remove & forget
			uncache: function () {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined ) {

						delete indicesByUUID[ uuid ];

						if ( index < nCachedObjects ) {

							// object is cached, shrink the CACHED region

							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;

							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];

								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();

							}

						} else {

							// object is active, just swap with the last and pop

							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ];

								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();

							}

						} // cached or active

					} // if object is known

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// Internal interface used by befriended PropertyBinding.Composite:

			subscribe_: function ( path, parsedPath ) {

				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;

				if ( index !== undefined ) { return bindings[ index ]; }

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );

				index = bindings.length;

				indicesByPath[ path ] = index;

				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );

				for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

					var object = objects[ i ];
					bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

				}

				return bindingsForPath;

			},

			unsubscribe_: function ( path ) {

				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];

				if ( index !== undefined ) {

					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];

					indicesByPath[ lastBindingsPath ] = index;

					bindings[ index ] = lastBindings;
					bindings.pop();

					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();

					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();

				}

			}

		} );

		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */

		function AnimationAction( mixer, clip, localRoot ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;

			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			var interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for ( var i = 0; i !== nTracks; ++ i ) {

				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants; // bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null; // for the memory manager
			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = - 1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale
			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false;// keep feeding the last frame?

			this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true;// clips for start, loop and end

		}

		Object.assign( AnimationAction.prototype, {

			// State & Scheduling

			play: function () {

				this._mixer._activateAction( this );

				return this;

			},

			stop: function () {

				this._mixer._deactivateAction( this );

				return this.reset();

			},

			reset: function () {

				this.paused = false;
				this.enabled = true;

				this.time = 0; // restart clip
				this._loopCount = - 1;// forget previous loops
				this._startTime = null;// forget scheduling

				return this.stopFading().stopWarping();

			},

			isRunning: function () {

				return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );

			},

			// return true when play has been called
			isScheduled: function () {

				return this._mixer._isActiveAction( this );

			},

			startAt: function ( time ) {

				this._startTime = time;

				return this;

			},

			setLoop: function ( mode, repetitions ) {

				this.loop = mode;
				this.repetitions = repetitions;

				return this;

			},

			// Weight

			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function ( weight ) {

				this.weight = weight;

				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;

				return this.stopFading();

			},

			// return the weight considering fading and .enabled
			getEffectiveWeight: function () {

				return this._effectiveWeight;

			},

			fadeIn: function ( duration ) {

				return this._scheduleFading( duration, 0, 1 );

			},

			fadeOut: function ( duration ) {

				return this._scheduleFading( duration, 1, 0 );

			},

			crossFadeFrom: function ( fadeOutAction, duration, warp ) {

				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );

				if ( warp ) {

					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,

						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;

					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );

				}

				return this;

			},

			crossFadeTo: function ( fadeInAction, duration, warp ) {

				return fadeInAction.crossFadeFrom( this, duration, warp );

			},

			stopFading: function () {

				var weightInterpolant = this._weightInterpolant;

				if ( weightInterpolant !== null ) {

					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );

				}

				return this;

			},

			// Time Scale Control

			// set the time scale stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function ( timeScale ) {

				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 : timeScale;

				return this.stopWarping();

			},

			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function () {

				return this._effectiveTimeScale;

			},

			setDuration: function ( duration ) {

				this.timeScale = this._clip.duration / duration;

				return this.stopWarping();

			},

			syncWith: function ( action ) {

				this.time = action.time;
				this.timeScale = action.timeScale;

				return this.stopWarping();

			},

			halt: function ( duration ) {

				return this.warp( this._effectiveTimeScale, 0, duration );

			},

			warp: function ( startTimeScale, endTimeScale, duration ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,

					timeScale = this.timeScale;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant();
					this._timeScaleInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now;
				times[ 1 ] = now + duration;

				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;

				return this;

			},

			stopWarping: function () {

				var timeScaleInterpolant = this._timeScaleInterpolant;

				if ( timeScaleInterpolant !== null ) {

					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

				}

				return this;

			},

			// Object Accessors

			getMixer: function () {

				return this._mixer;

			},

			getClip: function () {

				return this._clip;

			},

			getRoot: function () {

				return this._localRoot || this._mixer._root;

			},

			// Interna

			_update: function ( time, deltaTime, timeDirection, accuIndex ) {

				// called by the mixer

				if ( ! this.enabled ) {

					// call ._updateWeight() to update ._effectiveWeight

					this._updateWeight( time );
					return;

				}

				var startTime = this._startTime;

				if ( startTime !== null ) {

					// check for scheduled start of action

					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {

						return; // yet to come / don't decide when delta = 0

					}

					// start

					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;

				}

				// apply time scale and advance time

				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );

				// note: _updateTime may disable the action resulting in
				// an effective weight of 0

				var weight = this._updateWeight( time );

				if ( weight > 0 ) {

					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

				}

			},

			_updateWeight: function ( time ) {

				var weight = 0;

				if ( this.enabled ) {

					weight = this.weight;
					var interpolant = this._weightInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						weight *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopFading();

							if ( interpolantValue === 0 ) {

								// faded out, disable
								this.enabled = false;

							}

						}

					}

				}

				this._effectiveWeight = weight;
				return weight;

			},

			_updateTimeScale: function ( time ) {

				var timeScale = 0;

				if ( ! this.paused ) {

					timeScale = this.timeScale;

					var interpolant = this._timeScaleInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						timeScale *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopWarping();

							if ( timeScale === 0 ) {

								// motion has halted, pause
								this.paused = true;

							} else {

								// warp done - apply final time scale
								this.timeScale = timeScale;

							}

						}

					}

				}

				this._effectiveTimeScale = timeScale;
				return timeScale;

			},

			_updateTime: function ( deltaTime ) {

				var time = this.time + deltaTime;
				var duration = this._clip.duration;
				var loop = this.loop;
				var loopCount = this._loopCount;

				var pingPong = ( loop === LoopPingPong );

				if ( deltaTime === 0 ) {

					if ( loopCount === - 1 ) { return time; }

					return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

				}

				if ( loop === LoopOnce ) {

					if ( loopCount === - 1 ) {

						// just started

						this._loopCount = 0;
						this._setEndings( true, true, false );

					}

					handle_stop: {

						if ( time >= duration ) {

							time = duration;

						} else if ( time < 0 ) {

							time = 0;

						} else {

							this.time = time;

							break handle_stop;

						}

						if ( this.clampWhenFinished ) { this.paused = true; }
						else { this.enabled = false; }

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? - 1 : 1
						} );

					}

				} else { // repetitive Repeat or PingPong

					if ( loopCount === - 1 ) {

						// just started

						if ( deltaTime >= 0 ) {

							loopCount = 0;

							this._setEndings( true, this.repetitions === 0, pingPong );

						} else {

							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1

							this._setEndings( this.repetitions === 0, true, pingPong );

						}

					}

					if ( time >= duration || time < 0 ) {

						// wrap around

						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;

						loopCount += Math.abs( loopDelta );

						var pending = this.repetitions - loopCount;

						if ( pending <= 0 ) {

							// have to stop (switch state, clamp time, fire event)

							if ( this.clampWhenFinished ) { this.paused = true; }
							else { this.enabled = false; }

							time = deltaTime > 0 ? duration : 0;

							this.time = time;

							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : - 1
							} );

						} else {

							// keep running

							if ( pending === 1 ) {

								// entering the last round

								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );

							} else {

								this._setEndings( false, false, pingPong );

							}

							this._loopCount = loopCount;

							this.time = time;

							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );

						}

					} else {

						this.time = time;

					}

					if ( pingPong && ( loopCount & 1 ) === 1 ) {

						// invert time for the "pong round"

						return duration - time;

					}

				}

				return time;

			},

			_setEndings: function ( atStart, atEnd, pingPong ) {

				var settings = this._interpolantSettings;

				if ( pingPong ) {

					settings.endingStart = ZeroSlopeEnding;
					settings.endingEnd = ZeroSlopeEnding;

				} else {

					// assuming for LoopOnce atStart == atEnd == true

					if ( atStart ) {

						settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingStart = WrapAroundEnding;

					}

					if ( atEnd ) {

						settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingEnd 	 = WrapAroundEnding;

					}

				}

			},

			_scheduleFading: function ( duration, weightNow, weightThen ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant();
					this._weightInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now;
				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;
				values[ 1 ] = weightThen;

				return this;

			}

		} );

		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function AnimationMixer( root ) {

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;

			this.time = 0;

			this.timeScale = 1.0;

		}

		AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

			constructor: AnimationMixer,

			_bindAction: function ( action, prototypeAction ) {

				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];

				if ( bindingsByName === undefined ) {

					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;

				}

				for ( var i = 0; i !== nTracks; ++ i ) {

					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];

					if ( binding !== undefined ) {

						bindings[ i ] = binding;

					} else {

						binding = bindings[ i ];

						if ( binding !== undefined ) {

							// existing binding, make sure the cache knows

							if ( binding._cacheIndex === null ) {

								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );

							}

							continue;

						}

						var path = prototypeAction && prototypeAction.
							_propertyBindings[ i ].binding.parsedPath;

						binding = new PropertyMixer(
							PropertyBinding.create( root, trackName, path ),
							track.ValueTypeName, track.getValueSize() );

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

						bindings[ i ] = binding;

					}

					interpolants[ i ].resultBuffer = binding.buffer;

				}

			},

			_activateAction: function ( action ) {

				if ( ! this._isActiveAction( action ) ) {

					if ( action._cacheIndex === null ) {

						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind

						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];

						this._bindAction( action,
							actionsForClip && actionsForClip.knownActions[ 0 ] );

						this._addInactiveAction( action, clipUuid, rootUuid );

					}

					var bindings = action._propertyBindings;

					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( binding.useCount ++ === 0 ) {

							this._lendBinding( binding );
							binding.saveOriginalState();

						}

					}

					this._lendAction( action );

				}

			},

			_deactivateAction: function ( action ) {

				if ( this._isActiveAction( action ) ) {

					var bindings = action._propertyBindings;

					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( -- binding.useCount === 0 ) {

							binding.restoreOriginalState();
							this._takeBackBinding( binding );

						}

					}

					this._takeBackAction( action );

				}

			},

			// Memory manager

			_initMemoryManager: function () {

				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;

				this._actionsByClip = {};
				// inside:
				// {
				// 	knownActions: Array< AnimationAction > - used as prototypes
				// 	actionByRoot: AnimationAction - lookup
				// }


				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;

				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;

				var scope = this;

				this.stats = {

					actions: {
						get total() {

							return scope._actions.length;

						},
						get inUse() {

							return scope._nActiveActions;

						}
					},
					bindings: {
						get total() {

							return scope._bindings.length;

						},
						get inUse() {

							return scope._nActiveBindings;

						}
					},
					controlInterpolants: {
						get total() {

							return scope._controlInterpolants.length;

						},
						get inUse() {

							return scope._nActiveControlInterpolants;

						}
					}

				};

			},

			// Memory management for AnimationAction objects

			_isActiveAction: function ( action ) {

				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;

			},

			_addInactiveAction: function ( action, clipUuid, rootUuid ) {

				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip === undefined ) {

					actionsForClip = {

						knownActions: [ action ],
						actionByRoot: {}

					};

					action._byClipCacheIndex = 0;

					actionsByClip[ clipUuid ] = actionsForClip;

				} else {

					var knownActions = actionsForClip.knownActions;

					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );

				}

				action._cacheIndex = actions.length;
				actions.push( action );

				actionsForClip.actionByRoot[ rootUuid ] = action;

			},

			_removeInactiveAction: function ( action ) {

				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				action._cacheIndex = null;


				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,

					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],

					byClipCacheIndex = action._byClipCacheIndex;

				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();

				action._byClipCacheIndex = null;


				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( action._localRoot || this._root ).uuid;

				delete actionByRoot[ rootUuid ];

				if ( knownActionsForClip.length === 0 ) {

					delete actionsByClip[ clipUuid ];

				}

				this._removeInactiveBindingsForAction( action );

			},

			_removeInactiveBindingsForAction: function ( action ) {

				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.referenceCount === 0 ) {

						this._removeInactiveBinding( binding );

					}

				}

			},

			_lendAction: function ( action ) {

				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					lastActiveIndex = this._nActiveActions ++,

					firstInactiveAction = actions[ lastActiveIndex ];

				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;

				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;

			},

			_takeBackAction: function ( action ) {

				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					firstInactiveIndex = -- this._nActiveActions,

					lastActiveAction = actions[ firstInactiveIndex ];

				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;

				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;

			},

			// Memory management for PropertyMixer objects

			_addInactiveBinding: function ( binding, rootUuid, trackName ) {

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					bindings = this._bindings;

				if ( bindingByName === undefined ) {

					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;

				}

				bindingByName[ trackName ] = binding;

				binding._cacheIndex = bindings.length;
				bindings.push( binding );

			},

			_removeInactiveBinding: function ( binding ) {

				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;

				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();

				delete bindingByName[ trackName ];

				if ( Object.keys( bindingByName ).length === 0 ) {

					delete bindingsByRoot[ rootUuid ];

				}

			},

			_lendBinding: function ( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					lastActiveIndex = this._nActiveBindings ++,

					firstInactiveBinding = bindings[ lastActiveIndex ];

				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;

				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;

			},

			_takeBackBinding: function ( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					firstInactiveIndex = -- this._nActiveBindings,

					lastActiveBinding = bindings[ firstInactiveIndex ];

				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;

				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;

			},


			// Memory management of Interpolants for weight and time scale

			_lendControlInterpolant: function () {

				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];

				if ( interpolant === undefined ) {

					interpolant = new LinearInterpolant(
						new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );

					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;

				}

				return interpolant;

			},

			_takeBackControlInterpolant: function ( interpolant ) {

				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,

					firstInactiveIndex = -- this._nActiveControlInterpolants,

					lastActiveInterpolant = interpolants[ firstInactiveIndex ];

				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;

				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;

			},

			_controlInterpolantsResultBuffer: new Float32Array( 1 ),

			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function ( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
						AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject !== null ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;

				if ( actionsForClip !== undefined ) {

					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];

					if ( existingAction !== undefined ) {

						return existingAction;

					}

					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];

					// also, take the clip from the prototype action
					if ( clipObject === null )
						{ clipObject = prototypeAction._clip; }

				}

				// clip must be known when specified via string
				if ( clipObject === null ) { return null; }

				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );

				this._bindAction( newAction, prototypeAction );

				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );

				return newAction;

			},

			// get an existing action
			existingAction: function ( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
						AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					return actionsForClip.actionByRoot[ rootUuid ] || null;

				}

				return null;

			},

			// deactivates all previously scheduled actions
			stopAllAction: function () {

				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;

				this._nActiveActions = 0;
				this._nActiveBindings = 0;

				for ( var i = 0; i !== nActions; ++ i ) {

					actions[ i ].reset();

				}

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].useCount = 0;

				}

				return this;

			},

			// advance the time and update apply the animation
			update: function ( deltaTime ) {

				deltaTime *= this.timeScale;

				var actions = this._actions,
					nActions = this._nActiveActions,

					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),

					accuIndex = this._accuIndex ^= 1;

				// run active actions

				for ( var i = 0; i !== nActions; ++ i ) {

					var action = actions[ i ];

					action._update( time, deltaTime, timeDirection, accuIndex );

				}

				// update scene graph

				var bindings = this._bindings,
					nBindings = this._nActiveBindings;

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].apply( accuIndex );

				}

				return this;

			},

			// Allows you to seek to a specific time in an animation.
			setTime: function ( timeInSeconds ) {

				this.time = 0; // Zero out time attribute for AnimationMixer object;
				for ( var i = 0; i < this._actions.length; i ++ ) {

					this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

				}

				return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

			},

			// return this mixer's root target object
			getRoot: function () {

				return this._root;

			},

			// free all resources specific to a particular clip
			uncacheClip: function ( clip ) {

				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away

					var actionsToRemove = actionsForClip.knownActions;

					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

						var action = actionsToRemove[ i ];

						this._deactivateAction( action );

						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];

						action._cacheIndex = null;
						action._byClipCacheIndex = null;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();

						this._removeInactiveBindingsForAction( action );

					}

					delete actionsByClip[ clipUuid ];

				}

			},

			// free all resources specific to a particular root target object
			uncacheRoot: function ( root ) {

				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

				for ( var clipUuid in actionsByClip ) {

					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];

					if ( action !== undefined ) {

						this._deactivateAction( action );
						this._removeInactiveAction( action );

					}

				}

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];

				if ( bindingByName !== undefined ) {

					for ( var trackName in bindingByName ) {

						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );

					}

				}

			},

			// remove a targeted clip from the cache
			uncacheAction: function ( clip, optionalRoot ) {

				var action = this.existingAction( clip, optionalRoot );

				if ( action !== null ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Uniform( value ) {

			if ( typeof value === 'string' ) {

				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];

			}

			this.value = value;

		}

		Uniform.prototype.clone = function () {

			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

			InterleavedBuffer.call( this, array, stride );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

			constructor: InstancedInterleavedBuffer,

			isInstancedInterleavedBuffer: true,

			copy: function ( source ) {

				InterleavedBuffer.prototype.copy.call( this, source );

				this.meshPerAttribute = source.meshPerAttribute;

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */

		function Raycaster( origin, direction, near, far ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;
			this.camera = null;
			this.layers = new Layers();

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {

						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;

					}
				}
			} );

		}

		function ascSort( a, b ) {

			return a.distance - b.distance;

		}

		function intersectObject( object, raycaster, intersects, recursive ) {

			if ( object.layers.test( raycaster.layers ) ) {

				object.raycast( raycaster, intersects );

			}

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		}

		Object.assign( Raycaster.prototype, {

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( ( camera && camera.isPerspectiveCamera ) ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
					this.camera = camera;

				} else if ( ( camera && camera.isOrthographicCamera ) ) {

					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
					this.camera = camera;

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive, optionalTarget ) {

				var intersects = optionalTarget || [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( ascSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive, optionalTarget ) {

				var intersects = optionalTarget || [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( ascSort );

				return intersects;

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
		 * The azimuthal angle (theta) is measured from the positive z-axis.
		 */

		function Spherical( radius, phi, theta ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
			this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

			return this;

		}

		Object.assign( Spherical.prototype, {

			set: function ( radius, phi, theta ) {

				this.radius = radius;
				this.phi = phi;
				this.theta = theta;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;

				return this;

			},

			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function () {

				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

				return this;

			},

			setFromVector3: function ( v ) {

				return this.setFromCartesianCoords( v.x, v.y, v.z );

			},

			setFromCartesianCoords: function ( x, y, z ) {

				this.radius = Math.sqrt( x * x + y * y + z * z );

				if ( this.radius === 0 ) {

					this.theta = 0;
					this.phi = 0;

				} else {

					this.theta = Math.atan2( x, z );
					this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

				}

				return this;

			}

		} );

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
		 *
		 */

		function Cylindrical( radius, theta, y ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
			this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

			return this;

		}

		Object.assign( Cylindrical.prototype, {

			set: function ( radius, theta, y ) {

				this.radius = radius;
				this.theta = theta;
				this.y = y;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.theta = other.theta;
				this.y = other.y;

				return this;

			},

			setFromVector3: function ( v ) {

				return this.setFromCartesianCoords( v.x, v.y, v.z );

			},

			setFromCartesianCoords: function ( x, y, z ) {

				this.radius = Math.sqrt( x * x + z * z );
				this.theta = Math.atan2( x, z );
				this.y = y;

				return this;

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 */

		var _vector$7 = new Vector2();

		function Box2( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

		}

		Object.assign( Box2.prototype, {

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function ( center, size ) {

				var halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

			},

			getCenter: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box2: .getCenter() target is now required' );
					target = new Vector2();

				}

				return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box2: .getSize() target is now required' );
					target = new Vector2();

				}

				return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ? false : true;

			},

			containsBox: function ( box ) {

				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y;

			},

			getParameter: function ( point, target ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				if ( target === undefined ) {

					console.warn( 'THREE.Box2: .getParameter() target is now required' );
					target = new Vector2();

				}

				return target.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);

			},

			intersectsBox: function ( box ) {

				// using 4 splitting planes to rule out intersections

				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

			},

			clampPoint: function ( point, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box2: .clampPoint() target is now required' );
					target = new Vector2();

				}

				return target.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function ( point ) {

				var clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			},

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		} );

		/**
		 * @author bhouston / http://clara.io
		 */

		var _startP = new Vector3();
		var _startEnd = new Vector3();

		function Line3( start, end ) {

			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();

		}

		Object.assign( Line3.prototype, {

			set: function ( start, end ) {

				this.start.copy( start );
				this.end.copy( end );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( line ) {

				this.start.copy( line.start );
				this.end.copy( line.end );

				return this;

			},

			getCenter: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Line3: .getCenter() target is now required' );
					target = new Vector3();

				}

				return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

			},

			delta: function ( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Line3: .delta() target is now required' );
					target = new Vector3();

				}

				return target.subVectors( this.end, this.start );

			},

			distanceSq: function () {

				return this.start.distanceToSquared( this.end );

			},

			distance: function () {

				return this.start.distanceTo( this.end );

			},

			at: function ( t, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Line3: .at() target is now required' );
					target = new Vector3();

				}

				return this.delta( target ).multiplyScalar( t ).add( this.start );

			},

			closestPointToPointParameter: function ( point, clampToLine ) {

				_startP.subVectors( point, this.start );
				_startEnd.subVectors( this.end, this.start );

				var startEnd2 = _startEnd.dot( _startEnd );
				var startEnd_startP = _startEnd.dot( _startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = MathUtils.clamp( t, 0, 1 );

				}

				return t;

			},

			closestPointToPoint: function ( point, clampToLine, target ) {

				var t = this.closestPointToPointParameter( point, clampToLine );

				if ( target === undefined ) {

					console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				return this.delta( target ).multiplyScalar( t ).add( this.start );

			},

			applyMatrix4: function ( matrix ) {

				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );

				return this;

			},

			equals: function ( line ) {

				return line.start.equals( this.start ) && line.end.equals( this.end );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function ImmediateRenderObject( material ) {

			Object3D.call( this );

			this.material = material;
			this.render = function ( /* renderCallback */ ) {};

		}

		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

		ImmediateRenderObject.prototype.isImmediateRenderObject = true;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		var _vector$8 = new Vector3();

		function SpotLightHelper( light, color ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			var geometry = new BufferGeometry();

			var positions = [
				0, 0, 0, 	0, 0, 1,
				0, 0, 0, 	1, 0, 1,
				0, 0, 0,	- 1, 0, 1,
				0, 0, 0, 	0, 1, 1,
				0, 0, 0, 	0, - 1, 1
			];

			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;

		SpotLightHelper.prototype.dispose = function () {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		};

		SpotLightHelper.prototype.update = function () {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( _vector$8 );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		var _vector$9 = new Vector3();
		var _boneMatrix = new Matrix4();
		var _matrixWorldInv = new Matrix4();

		function getBoneList( object ) {

			var boneList = [];

			if ( object && object.isBone ) {

				boneList.push( object );

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

			}

			return boneList;

		}

		function SkeletonHelper( object ) {

			var bones = getBoneList( object );

			var geometry = new BufferGeometry();

			var vertices = [];
			var colors = [];

			var color1 = new Color( 0, 0, 1 );
			var color2 = new Color( 0, 1, 0 );

			for ( var i = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );

				}

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

			LineSegments.call( this, geometry, material );

			this.root = object;
			this.bones = bones;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

		}

		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;

		SkeletonHelper.prototype.isSkeletonHelper = true;

		SkeletonHelper.prototype.updateMatrixWorld = function ( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			_matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
					_vector$9.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
					_vector$9.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PointLightHelper( light, sphereSize, color ) {

			this.light = light;
			this.light.updateMatrixWorld();

			this.color = color;

			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

			Mesh.call( this, geometry, material );

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();


			/*
			var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

			var d = light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.scale.set( d, d, d );

			}

			this.add( this.lightDistance );
			*/

		}

		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;

		PointLightHelper.prototype.dispose = function () {

			this.geometry.dispose();
			this.material.dispose();

		};

		PointLightHelper.prototype.update = function () {

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				this.material.color.copy( this.light.color );

			}

			/*
			var d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		var _vector$a = new Vector3();
		var _color1 = new Color();
		var _color2 = new Color();

		function HemisphereLightHelper( light, size, color ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			var geometry = new OctahedronBufferGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );

			this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
			if ( this.color === undefined ) { this.material.vertexColors = true; }

			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );

			geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

			this.add( new Mesh( geometry, this.material ) );

			this.update();

		}

		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

		HemisphereLightHelper.prototype.dispose = function () {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		};

		HemisphereLightHelper.prototype.update = function () {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				_color1.copy( this.light.color );
				_color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? _color1 : _color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function GridHelper( size, divisions, color1, color2 ) {

			size = size || 10;
			divisions = divisions || 10;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;

			var vertices = [], colors = [];

			for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );

				var color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			LineSegments.call( this, geometry, material );

		}

		GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

			constructor: GridHelper,

			copy: function ( source ) {

				LineSegments.prototype.copy.call( this, source );

				this.geometry.copy( source.geometry );
				this.material.copy( source.material );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author Hectate / http://www.github.com/Hectate
		 */

		function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

			radius = radius || 10;
			radials = radials || 16;
			circles = circles || 8;
			divisions = divisions || 64;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var vertices = [];
			var colors = [];

			var x, z;
			var v, i, j, r, color;

			// create the radials

			for ( i = 0; i <= radials; i ++ ) {

				v = ( i / radials ) * ( Math.PI * 2 );

				x = Math.sin( v ) * radius;
				z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

			// create the circles

			for ( i = 0; i <= circles; i ++ ) {

				color = ( i & 1 ) ? color1 : color2;

				r = radius - ( radius / circles * i );

				for ( j = 0; j < divisions; j ++ ) {

					// first vertex

					v = ( j / divisions ) * ( Math.PI * 2 );

					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

					// second vertex

					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

				}

			}

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			LineSegments.call( this, geometry, material );

		}

		PolarGridHelper.prototype = Object.create( LineSegments.prototype );
		PolarGridHelper.prototype.constructor = PolarGridHelper;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		var _v1$5 = new Vector3();
		var _v2$3 = new Vector3();
		var _v3$1 = new Vector3();

		function DirectionalLightHelper( light, size, color ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			if ( size === undefined ) { size = 1; }

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [
				- size, size, 0,
				size, size, 0,
				size, - size, 0,
				- size, - size, 0,
				- size, size, 0
			], 3 ) );

			var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.lightPlane = new Line( geometry, material );
			this.add( this.lightPlane );

			geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.targetLine = new Line( geometry, material );
			this.add( this.targetLine );

			this.update();

		}

		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

		DirectionalLightHelper.prototype.dispose = function () {

			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();

		};

		DirectionalLightHelper.prototype.update = function () {

			_v1$5.setFromMatrixPosition( this.light.matrixWorld );
			_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
			_v3$1.subVectors( _v2$3, _v1$5 );

			this.lightPlane.lookAt( _v2$3 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( _v2$3 );
			this.targetLine.scale.z = _v3$1.length();

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */

		var _vector$b = new Vector3();
		var _camera = new Camera();

		function CameraHelper( camera ) {

			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

			var vertices = [];
			var colors = [];

			var pointMap = {};

			// colors

			var colorFrustum = new Color( 0xffaa00 );
			var colorCone = new Color( 0xff0000 );
			var colorUp = new Color( 0x00aaff );
			var colorTarget = new Color( 0xffffff );
			var colorCross = new Color( 0x333333 );

			// near

			addLine( 'n1', 'n2', colorFrustum );
			addLine( 'n2', 'n4', colorFrustum );
			addLine( 'n4', 'n3', colorFrustum );
			addLine( 'n3', 'n1', colorFrustum );

			// far

			addLine( 'f1', 'f2', colorFrustum );
			addLine( 'f2', 'f4', colorFrustum );
			addLine( 'f4', 'f3', colorFrustum );
			addLine( 'f3', 'f1', colorFrustum );

			// sides

			addLine( 'n1', 'f1', colorFrustum );
			addLine( 'n2', 'f2', colorFrustum );
			addLine( 'n3', 'f3', colorFrustum );
			addLine( 'n4', 'f4', colorFrustum );

			// cone

			addLine( 'p', 'n1', colorCone );
			addLine( 'p', 'n2', colorCone );
			addLine( 'p', 'n3', colorCone );
			addLine( 'p', 'n4', colorCone );

			// up

			addLine( 'u1', 'u2', colorUp );
			addLine( 'u2', 'u3', colorUp );
			addLine( 'u3', 'u1', colorUp );

			// target

			addLine( 'c', 't', colorTarget );
			addLine( 'p', 'c', colorCross );

			// cross

			addLine( 'cn1', 'cn2', colorCross );
			addLine( 'cn3', 'cn4', colorCross );

			addLine( 'cf1', 'cf2', colorCross );
			addLine( 'cf3', 'cf4', colorCross );

			function addLine( a, b, color ) {

				addPoint( a, color );
				addPoint( b, color );

			}

			function addPoint( id, color ) {

				vertices.push( 0, 0, 0 );
				colors.push( color.r, color.g, color.b );

				if ( pointMap[ id ] === undefined ) {

					pointMap[ id ] = [];

				}

				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			LineSegments.call( this, geometry, material );

			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) { this.camera.updateProjectionMatrix(); }

			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;

			this.pointMap = pointMap;

			this.update();

		}

		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;

		CameraHelper.prototype.update = function () {

			var geometry = this.geometry;
			var pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

			// center / target

			setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
			setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

			// near

			setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
			setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
			setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
			setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

			// far

			setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
			setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
			setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
			setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

			// up

			setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
			setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
			setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
			setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

			setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
			setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
			setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
			setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

		function setPoint( point, pointMap, geometry, camera, x, y, z ) {

			_vector$b.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );

				}

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 */

		var _box$3 = new Box3();

		function BoxHelper( object, color ) {

			this.object = object;

			if ( color === undefined ) { color = 0xffff00; }

			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );

			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.matrixAutoUpdate = false;

			this.update();

		}

		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;

		BoxHelper.prototype.update = function ( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				_box$3.setFromObject( this.object );

			}

			if ( _box$3.isEmpty() ) { return; }

			var min = _box$3.min;
			var max = _box$3.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();


		};

		BoxHelper.prototype.setFromObject = function ( object ) {

			this.object = object;
			this.update();

			return this;

		};

		BoxHelper.prototype.copy = function ( source ) {

			LineSegments.prototype.copy.call( this, source );

			this.object = source.object;

			return this;

		};

		BoxHelper.prototype.clone = function () {

			return new this.constructor().copy( this );

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Box3Helper( box, color ) {

			this.type = 'Box3Helper';

			this.box = box;

			color = color || 0xffff00;

			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

			var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

			var geometry = new BufferGeometry();

			geometry.setIndex( new BufferAttribute( indices, 1 ) );

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.geometry.computeBoundingSphere();

		}

		Box3Helper.prototype = Object.create( LineSegments.prototype );
		Box3Helper.prototype.constructor = Box3Helper;

		Box3Helper.prototype.updateMatrixWorld = function ( force ) {

			var box = this.box;

			if ( box.isEmpty() ) { return; }

			box.getCenter( this.position );

			box.getSize( this.scale );

			this.scale.multiplyScalar( 0.5 );

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function PlaneHelper( plane, size, hex ) {

			this.type = 'PlaneHelper';

			this.plane = plane;

			this.size = ( size === undefined ) ? 1 : size;

			var color = ( hex !== undefined ) ? hex : 0xffff00;

			var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
			geometry.computeBoundingSphere();

			Line.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			//

			var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

			var geometry2 = new BufferGeometry();
			geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
			geometry2.computeBoundingSphere();

			this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

		}

		PlaneHelper.prototype = Object.create( Line.prototype );
		PlaneHelper.prototype.constructor = PlaneHelper;

		PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

			var scale = - this.plane.constant;

			if ( Math.abs( scale ) < 1e-8 ) { scale = 1e-8; } // sign does not matter

			this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

			this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt( this.plane.normal );

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */

		var _axis = new Vector3();
		var _lineGeometry, _coneGeometry;

		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			Object3D.call( this );

			if ( dir === undefined ) { dir = new Vector3( 0, 0, 1 ); }
			if ( origin === undefined ) { origin = new Vector3( 0, 0, 0 ); }
			if ( length === undefined ) { length = 1; }
			if ( color === undefined ) { color = 0xffff00; }
			if ( headLength === undefined ) { headLength = 0.2 * length; }
			if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

			if ( _lineGeometry === undefined ) {

				_lineGeometry = new BufferGeometry();
				_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

				_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
				_coneGeometry.translate( 0, - 0.5, 0 );

			}

			this.position.copy( origin );

			this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;

		ArrowHelper.prototype.setDirection = function ( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				_axis.set( dir.z, 0, - dir.x ).normalize();

				var radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( _axis, radians );

			}

		};

		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

			if ( headLength === undefined ) { headLength = 0.2 * length; }
			if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

			this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
			this.line.updateMatrix();

			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();

		};

		ArrowHelper.prototype.setColor = function ( color ) {

			this.line.material.color.set( color );
			this.cone.material.color.set( color );

		};

		ArrowHelper.prototype.copy = function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			this.line.copy( source.line );
			this.cone.copy( source.cone );

			return this;

		};

		ArrowHelper.prototype.clone = function () {

			return new this.constructor().copy( this );

		};

		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AxesHelper( size ) {

			size = size || 1;

			var vertices = [
				0, 0, 0,	size, 0, 0,
				0, 0, 0,	0, size, 0,
				0, 0, 0,	0, 0, size
			];

			var colors = [
				1, 0, 0,	1, 0.6, 0,
				0, 1, 0,	0.6, 1, 0,
				0, 0, 1,	0, 0.6, 1
			];

			var geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			LineSegments.call( this, geometry, material );

		}

		AxesHelper.prototype = Object.create( LineSegments.prototype );
		AxesHelper.prototype.constructor = AxesHelper;

		/**
		 * @author Emmett Lalish / elalish
		 *
		 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
		 * (PMREM) from a cubeMap environment texture. This allows different levels of
		 * blur to be quickly accessed based on material roughness. It is packed into a
		 * special CubeUV format that allows us to perform custom interpolation so that
		 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
		 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
		 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
		 * higher roughness levels. In this way we maintain resolution to smoothly
		 * interpolate diffuse lighting while limiting sampling computation.
		 */

		var LOD_MIN = 4;
		var LOD_MAX = 8;
		var SIZE_MAX = Math.pow( 2, LOD_MAX );
		// The standard deviations (radians) associated with the extra mips. These are
		// chosen to approximate a Trowbridge-Reitz distribution function times the
		// geometric shadowing function. These sigma values squared must match the
		// variance #defines in cube_uv_reflection_fragment.glsl.js.
		var EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];
		var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
		// The maximum length of the blur for loop. Smaller sigmas will use fewer
		// samples and exit early, but not recompile the shader.
		var MAX_SAMPLES = 20;
		var ENCODINGS = {};
		ENCODINGS[ LinearEncoding ] = 0;
		ENCODINGS[ sRGBEncoding ] = 1;
		ENCODINGS[ RGBEEncoding ] = 2;
		ENCODINGS[ RGBM7Encoding ] = 3;
		ENCODINGS[ RGBM16Encoding ] = 4;
		ENCODINGS[ RGBDEncoding ] = 5;
		ENCODINGS[ GammaEncoding ] = 6;

		var _flatCamera = new OrthographicCamera();
		var _blurMaterial = _getBlurShader( MAX_SAMPLES );
		var _equirectShader = null;
		var _cubemapShader = null;

		var ref = _createPlanes();
		var _lodPlanes = ref._lodPlanes;
		var _sizeLods = ref._sizeLods;
		var _sigmas = ref._sigmas;
		var _pingPongRenderTarget = null;
		var _renderer = null;

		var _oldTarget = null;

		// Golden Ratio
		var PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
		var INV_PHI = 1 / PHI;
		// Vertices of a dodecahedron (except the opposites, which represent the
		// same axis), used as axis directions evenly spread on a sphere.
		var _axisDirections = [
			new Vector3( 1, 1, 1 ),
			new Vector3( - 1, 1, 1 ),
			new Vector3( 1, 1, - 1 ),
			new Vector3( - 1, 1, - 1 ),
			new Vector3( 0, PHI, INV_PHI ),
			new Vector3( 0, PHI, - INV_PHI ),
			new Vector3( INV_PHI, 0, PHI ),
			new Vector3( - INV_PHI, 0, PHI ),
			new Vector3( PHI, INV_PHI, 0 ),
			new Vector3( - PHI, INV_PHI, 0 ) ];

		function PMREMGenerator( renderer ) {

			_renderer = renderer;
			_compileMaterial( _blurMaterial );

		}

		PMREMGenerator.prototype = {

			constructor: PMREMGenerator,

			/**
			 * Generates a PMREM from a supplied Scene, which can be faster than using an
			 * image if networking bandwidth is low. Optional sigma specifies a blur radius
			 * in radians to be applied to the scene before PMREM generation. Optional near
			 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
			 * is placed at the origin).
			 */
			fromScene: function ( scene, sigma, near, far ) {
				if ( sigma === void 0 ) sigma = 0;
				if ( near === void 0 ) near = 0.1;
				if ( far === void 0 ) far = 100;


				_oldTarget = _renderer.getRenderTarget();
				var cubeUVRenderTarget = _allocateTargets();
				_sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
				if ( sigma > 0 ) {

					_blur( cubeUVRenderTarget, 0, 0, sigma );

				}
				_applyPMREM( cubeUVRenderTarget );
				_cleanup( cubeUVRenderTarget );

				return cubeUVRenderTarget;

			},

			/**
			 * Generates a PMREM from an equirectangular texture, which can be either LDR
			 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
			 * as this matches best with the 256 x 256 cubemap output.
			 */
			fromEquirectangular: function ( equirectangular ) {

				equirectangular.magFilter = NearestFilter;
				equirectangular.minFilter = NearestFilter;
				equirectangular.generateMipmaps = false;

				return this.fromCubemap( equirectangular );

			},

			/**
			 * Generates a PMREM from an cubemap texture, which can be either LDR
			 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
			 * as this matches best with the 256 x 256 cubemap output.
			 */
			fromCubemap: function ( cubemap ) {

				_oldTarget = _renderer.getRenderTarget();
				var cubeUVRenderTarget = _allocateTargets( cubemap );
				_textureToCubeUV( cubemap, cubeUVRenderTarget );
				_applyPMREM( cubeUVRenderTarget );
				_cleanup( cubeUVRenderTarget );

				return cubeUVRenderTarget;

			},

			/**
			 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
			 * your texture's network fetch for increased concurrency.
			 */
			compileCubemapShader: function () {

				if ( _cubemapShader == null ) {

					_cubemapShader = _getCubemapShader();
					_compileMaterial( _cubemapShader );

				}

			},

			/**
			 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
			 * your texture's network fetch for increased concurrency.
			 */
			compileEquirectangularShader: function () {

				if ( _equirectShader == null ) {

					_equirectShader = _getEquirectShader();
					_compileMaterial( _equirectShader );

				}

			},

			/**
			 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
			 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
			 * one of them will cause any others to also become unusable.
			 */
			dispose: function () {

				_blurMaterial.dispose();

				if ( _cubemapShader != null ) { _cubemapShader.dispose(); }
				if ( _equirectShader != null ) { _equirectShader.dispose(); }

				for ( var i = 0; i < _lodPlanes.length; i ++ ) {

					_lodPlanes[ i ].dispose();

				}

			},

		};

		function _createPlanes() {

			var _lodPlanes = [];
			var _sizeLods = [];
			var _sigmas = [];

			var lod = LOD_MAX;
			for ( var i = 0; i < TOTAL_LODS; i ++ ) {

				var sizeLod = Math.pow( 2, lod );
				_sizeLods.push( sizeLod );
				var sigma = 1.0 / sizeLod;
				if ( i > LOD_MAX - LOD_MIN ) {

					sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

				} else if ( i == 0 ) {

					sigma = 0;

				}
				_sigmas.push( sigma );

				var texelSize = 1.0 / ( sizeLod - 1 );
				var min = - texelSize / 2;
				var max = 1 + texelSize / 2;
				var uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

				var cubeFaces = 6;
				var vertices = 6;
				var positionSize = 3;
				var uvSize = 2;
				var faceIndexSize = 1;

				var position = new Float32Array( positionSize * vertices * cubeFaces );
				var uv = new Float32Array( uvSize * vertices * cubeFaces );
				var faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

				for ( var face = 0; face < cubeFaces; face ++ ) {

					var x = ( face % 3 ) * 2 / 3 - 1;
					var y = face > 2 ? 0 : - 1;
					var coordinates = [
						x, y, 0,
						x + 2 / 3, y, 0,
						x + 2 / 3, y + 1, 0,
						x, y, 0,
						x + 2 / 3, y + 1, 0,
						x, y + 1, 0
					];
					position.set( coordinates, positionSize * vertices * face );
					uv.set( uv1, uvSize * vertices * face );
					var fill = [ face, face, face, face, face, face ];
					faceIndex.set( fill, faceIndexSize * vertices * face );

				}
				var planes = new BufferGeometry();
				planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
				planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
				planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
				_lodPlanes.push( planes );

				if ( lod > LOD_MIN ) {

					lod --;

				}

			}
			return { _lodPlanes: _lodPlanes, _sizeLods: _sizeLods, _sigmas: _sigmas };

		}

		function _allocateTargets( equirectangular ) {

			var params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: equirectangular ? equirectangular.type : UnsignedByteType,
				format: equirectangular ? equirectangular.format : RGBEFormat,
				encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
				depthBuffer: false,
				stencilBuffer: false
			};
			var cubeUVRenderTarget = _createRenderTarget( params );
			cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
			_pingPongRenderTarget = _createRenderTarget( params );
			return cubeUVRenderTarget;

		}

		function _cleanup( outputTarget ) {

			_pingPongRenderTarget.dispose();
			_renderer.setRenderTarget( _oldTarget );
			outputTarget.scissorTest = false;
			// reset viewport and scissor
			outputTarget.setSize( outputTarget.width, outputTarget.height );

		}

		function _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

			var fov = 90;
			var aspect = 1;
			var cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			var upSign = [ 1, 1, 1, 1, - 1, 1 ];
			var forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];

			var outputEncoding = _renderer.outputEncoding;
			var toneMapping = _renderer.toneMapping;
			var toneMappingExposure = _renderer.toneMappingExposure;
			var clearColor = _renderer.getClearColor();
			var clearAlpha = _renderer.getClearAlpha();

			_renderer.toneMapping = LinearToneMapping;
			_renderer.toneMappingExposure = 1.0;
			_renderer.outputEncoding = LinearEncoding;
			scene.scale.z *= - 1;

			var background = scene.background;
			if ( background && background.isColor ) {

				background.convertSRGBToLinear();
				// Convert linear to RGBE
				var maxComponent = Math.max( background.r, background.g, background.b );
				var fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
				background = background.multiplyScalar( Math.pow( 2.0, - fExp ) );
				var alpha = ( fExp + 128.0 ) / 255.0;
				_renderer.setClearColor( background, alpha );
				scene.background = null;

			}

			for ( var i = 0; i < 6; i ++ ) {

				var col = i % 3;
				if ( col == 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

				} else if ( col == 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

				}
				_setViewport( cubeUVRenderTarget,
					col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
				_renderer.setRenderTarget( cubeUVRenderTarget );
				_renderer.render( scene, cubeCamera );

			}

			_renderer.toneMapping = toneMapping;
			_renderer.toneMappingExposure = toneMappingExposure;
			_renderer.outputEncoding = outputEncoding;
			_renderer.setClearColor( clearColor, clearAlpha );
			scene.scale.z *= - 1;

		}

		function _textureToCubeUV( texture, cubeUVRenderTarget ) {

			var scene = new Scene();
			if ( texture.isCubeTexture ) {

				if ( _cubemapShader == null ) {

					_cubemapShader = _getCubemapShader();

				}

			} else {

				if ( _equirectShader == null ) {

					_equirectShader = _getEquirectShader();

				}

			}
			var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;
			scene.add( new Mesh( _lodPlanes[ 0 ], material ) );
			var uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;
			if ( ! texture.isCubeTexture ) {

				uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

			}
			uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
			uniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );
			_renderer.setRenderTarget( cubeUVRenderTarget );
			_renderer.render( scene, _flatCamera );

		}

		function _compileMaterial( material ) {

			var tmpScene = new Scene();
			tmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );
			_renderer.compile( tmpScene, _flatCamera );

		}

		function _createRenderTarget( params ) {

			var cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
			cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
			cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
			cubeUVRenderTarget.scissorTest = true;
			return cubeUVRenderTarget;

		}

		function _setViewport( target, x, y, width, height ) {

			target.viewport.set( x, y, width, height );
			target.scissor.set( x, y, width, height );

		}

		function _applyPMREM( cubeUVRenderTarget ) {

			var autoClear = _renderer.autoClear;
			_renderer.autoClear = false;

			for ( var i = 1; i < TOTAL_LODS; i ++ ) {

				var sigma = Math.sqrt(
					_sigmas[ i ] * _sigmas[ i ] -
				_sigmas[ i - 1 ] * _sigmas[ i - 1 ] );
				var poleAxis =
				_axisDirections[ ( i - 1 ) % _axisDirections.length ];
				_blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			_renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		function _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			_halfBlur(
				cubeUVRenderTarget,
				_pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			_halfBlur(
				_pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		function _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

				console.error(
					'blur direction must be either latitudinal or longitudinal!' );

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			var STANDARD_DEVIATIONS = 3;

			var blurScene = new Scene();
			blurScene.add( new Mesh( _lodPlanes[ lodOut ], _blurMaterial ) );
			var blurUniforms = _blurMaterial.uniforms;

			var pixels = _sizeLods[ lodIn ] - 1;
			var radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			var sigmaPixels = sigmaRadians / radiansPerPixel;
			var samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			if ( samples > MAX_SAMPLES ) {

				console.warn( ("sigmaRadians, " + sigmaRadians + ", is too large and will clip, as it requested " + samples + " samples when the maximum is set to " + MAX_SAMPLES) );

			}

			var weights = [];
			var sum = 0;

			for ( var i = 0; i < MAX_SAMPLES; ++ i ) {

				var x = i / sigmaPixels;
				var weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i == 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( var i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';
			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
			blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
			blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

			var outputSize = _sizeLods[ lodOut ];
			var x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
			var y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +
			2 * outputSize *
				( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			_renderer.setRenderTarget( targetOut );
			_renderer.render( blurScene, _flatCamera );

		}

		function _getBlurShader( maxSamples ) {

			var weights = new Float32Array( maxSamples );
			var poleAxis = new Vector3( 0, 1, 0 );
			var shaderMaterial = new RawShaderMaterial( {

				defines: { 'n': maxSamples },

				uniforms: {
					'envMap': { value: null },
					'samples': { value: 1 },
					'weights': { value: weights },
					'latitudinal': { value: false },
					'dTheta': { value: 0 },
					'mipInt': { value: 0 },
					'poleAxis': { value: poleAxis },
					'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
					'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
				},

				vertexShader: _getCommonVertexShader(),

				fragmentShader: ("\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n" + (_getEncodings()) + "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),

				blending: NoBlending,
				depthTest: false,
				depthWrite: false

			} );

			shaderMaterial.type = 'SphericalGaussianBlur';

			return shaderMaterial;

		}

		function _getEquirectShader() {

			var texelSize = new Vector2( 1, 1 );
			var shaderMaterial = new RawShaderMaterial( {

				uniforms: {
					'envMap': { value: null },
					'texelSize': { value: texelSize },
					'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
					'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
				},

				vertexShader: _getCommonVertexShader(),

				fragmentShader: ("\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n" + (_getEncodings()) + "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),

				blending: NoBlending,
				depthTest: false,
				depthWrite: false

			} );

			shaderMaterial.type = 'EquirectangularToCubeUV';

			return shaderMaterial;

		}

		function _getCubemapShader() {

			var shaderMaterial = new RawShaderMaterial( {

				uniforms: {
					'envMap': { value: null },
					'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
					'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
				},

				vertexShader: _getCommonVertexShader(),

				fragmentShader: ("\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n" + (_getEncodings()) + "\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),

				blending: NoBlending,
				depthTest: false,
				depthWrite: false

			} );

			shaderMaterial.type = 'CubemapToCubeUV';

			return shaderMaterial;

		}

		function _getCommonVertexShader() {

			return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";

		}

		function _getEncodings() {

			return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Face4( a, b, c, d, normal, color, materialIndex ) {

			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );

		}

		var LineStrip = 0;
		var LinePieces = 1;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;

		function MeshFaceMaterial( materials ) {

			console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
			return materials;

		}

		function MultiMaterial( materials ) {

			if ( materials === undefined ) { materials = []; }

			console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
			materials.isMultiMaterial = true;
			materials.materials = materials;
			materials.clone = function () {

				return materials.slice();

			};
			return materials;

		}

		function PointCloud( geometry, material ) {

			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );

		}

		function Particle( material ) {

			console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
			return new Sprite( material );

		}

		function ParticleSystem( geometry, material ) {

			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );

		}

		function PointCloudMaterial( parameters ) {

			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function ParticleBasicMaterial( parameters ) {

			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function ParticleSystemMaterial( parameters ) {

			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );

		}

		function Vertex( x, y, z ) {

			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );

		}

		//

		function DynamicBufferAttribute( array, itemSize ) {

			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
			return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

		}

		function Int8Attribute( array, itemSize ) {

			console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
			return new Int8BufferAttribute( array, itemSize );

		}

		function Uint8Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
			return new Uint8BufferAttribute( array, itemSize );

		}

		function Uint8ClampedAttribute( array, itemSize ) {

			console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
			return new Uint8ClampedBufferAttribute( array, itemSize );

		}

		function Int16Attribute( array, itemSize ) {

			console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
			return new Int16BufferAttribute( array, itemSize );

		}

		function Uint16Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
			return new Uint16BufferAttribute( array, itemSize );

		}

		function Int32Attribute( array, itemSize ) {

			console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
			return new Int32BufferAttribute( array, itemSize );

		}

		function Uint32Attribute( array, itemSize ) {

			console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
			return new Uint32BufferAttribute( array, itemSize );

		}

		function Float32Attribute( array, itemSize ) {

			console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
			return new Float32BufferAttribute( array, itemSize );

		}

		function Float64Attribute( array, itemSize ) {

			console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
			return new Float64BufferAttribute( array, itemSize );

		}

		//

		Curve.create = function ( construct, getPoint ) {

			console.log( 'THREE.Curve.create() has been deprecated' );

			construct.prototype = Object.create( Curve.prototype );
			construct.prototype.constructor = construct;
			construct.prototype.getPoint = getPoint;

			return construct;

		};

		//

		Object.assign( CurvePath.prototype, {

			createPointsGeometry: function ( divisions ) {

				console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

				// generate geometry from path points (for Line or Points objects)

				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );

			},

			createSpacedPointsGeometry: function ( divisions ) {

				console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

				// generate geometry from equidistant sampling along the path

				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );

			},

			createGeometry: function ( points ) {

				console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

				var geometry = new Geometry();

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

				}

				return geometry;

			}

		} );

		//

		Object.assign( Path.prototype, {

			fromPoints: function ( points ) {

				console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
				return this.setFromPoints( points );

			}

		} );

		//

		function ClosedSplineCurve3( points ) {

			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;

		}

		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		//

		function SplineCurve3( points ) {

			console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';

		}

		SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		//

		function Spline( points ) {

			console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';

		}

		Spline.prototype = Object.create( CatmullRomCurve3.prototype );

		Object.assign( Spline.prototype, {

			initFromArray: function ( /* a */ ) {

				console.error( 'THREE.Spline: .initFromArray() has been removed.' );

			},
			getControlPointsArray: function ( /* optionalTarget */ ) {

				console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

			},
			reparametrizeByArcLength: function ( /* samplingCoef */ ) {

				console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

			}

		} );

		//

		function AxisHelper( size ) {

			console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
			return new AxesHelper( size );

		}

		function BoundingBoxHelper( object, color ) {

			console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
			return new BoxHelper( object, color );

		}

		function EdgesHelper( object, hex ) {

			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

		}

		GridHelper.prototype.setColors = function () {

			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

		};

		SkeletonHelper.prototype.update = function () {

			console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

		};

		function WireframeHelper( object, hex ) {

			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

		}

		//

		Object.assign( Loader.prototype, {

			extractUrlBase: function ( url ) {

				console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
				return LoaderUtils.extractUrlBase( url );

			}

		} );

		Loader.Handlers = {

			add: function ( /* regex, loader */ ) {

				console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

			},

			get: function ( /* file */ ) {

				console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

			}

		};

		function XHRLoader( manager ) {

			console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
			return new FileLoader( manager );

		}

		function BinaryTextureLoader( manager ) {

			console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
			return new DataTextureLoader( manager );

		}

		Object.assign( ObjectLoader.prototype, {

			setTexturePath: function ( value ) {

				console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
				return this.setResourcePath( value );

			}

		} );

		//

		Object.assign( Box2.prototype, {

			center: function ( optionalTarget ) {

				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );

			},
			empty: function () {

				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();

			},
			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			size: function ( optionalTarget ) {

				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );

			}
		} );

		Object.assign( Box3.prototype, {

			center: function ( optionalTarget ) {

				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );

			},
			empty: function () {

				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();

			},
			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			isIntersectionSphere: function ( sphere ) {

				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );

			},
			size: function ( optionalTarget ) {

				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );

			}
		} );

		Frustum.prototype.setFromMatrix = function ( m ) {

			console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
			return this.setFromProjectionMatrix( m );

		};

		Line3.prototype.center = function ( optionalTarget ) {

			console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		};

		Object.assign( MathUtils, {

			random16: function () {

				console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
				return Math.random();

			},

			nearestPowerOfTwo: function ( value ) {

				console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
				return MathUtils.floorPowerOfTwo( value );

			},

			nextPowerOfTwo: function ( value ) {

				console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
				return MathUtils.ceilPowerOfTwo( value );

			}

		} );

		Object.assign( Matrix3.prototype, {

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );

			},
			multiplyVector3: function ( vector ) {

				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );

			},
			multiplyVector3Array: function ( /* a */ ) {

				console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

			},
			applyToBufferAttribute: function ( attribute ) {

				console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
				return attribute.applyMatrix3( this );

			},
			applyToVector3Array: function ( /* array, offset, length */ ) {

				console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

			}

		} );

		Object.assign( Matrix4.prototype, {

			extractPosition: function ( m ) {

				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );

			},
			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );

			},
			getPosition: function () {

				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return new Vector3().setFromMatrixColumn( this, 3 );

			},
			setRotationFromQuaternion: function ( q ) {

				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );

			},
			multiplyToArray: function () {

				console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

			},
			multiplyVector3: function ( vector ) {

				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			multiplyVector4: function ( vector ) {

				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			multiplyVector3Array: function ( /* a */ ) {

				console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

			},
			rotateAxis: function ( v ) {

				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );

			},
			crossVector: function ( vector ) {

				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );

			},
			translate: function () {

				console.error( 'THREE.Matrix4: .translate() has been removed.' );

			},
			rotateX: function () {

				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

			},
			rotateY: function () {

				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

			},
			rotateZ: function () {

				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

			},
			rotateByAxis: function () {

				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

			},
			applyToBufferAttribute: function ( attribute ) {

				console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
				return attribute.applyMatrix4( this );

			},
			applyToVector3Array: function ( /* array, offset, length */ ) {

				console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

			},
			makeFrustum: function ( left, right, bottom, top, near, far ) {

				console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
				return this.makePerspective( left, right, top, bottom, near, far );

			}

		} );

		Plane.prototype.isIntersectionLine = function ( line ) {

			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );

		};

		Quaternion.prototype.multiplyVector3 = function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		};

		Object.assign( Ray.prototype, {

			isIntersectionBox: function ( box ) {

				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );

			},
			isIntersectionPlane: function ( plane ) {

				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );

			},
			isIntersectionSphere: function ( sphere ) {

				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );

			}

		} );

		Object.assign( Triangle.prototype, {

			area: function () {

				console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
				return this.getArea();

			},
			barycoordFromPoint: function ( point, target ) {

				console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
				return this.getBarycoord( point, target );

			},
			midpoint: function ( target ) {

				console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
				return this.getMidpoint( target );

			},
			normal: function ( target ) {

				console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
				return this.getNormal( target );

			},
			plane: function ( target ) {

				console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
				return this.getPlane( target );

			}

		} );

		Object.assign( Triangle, {

			barycoordFromPoint: function ( point, a, b, c, target ) {

				console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
				return Triangle.getBarycoord( point, a, b, c, target );

			},
			normal: function ( a, b, c, target ) {

				console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
				return Triangle.getNormal( a, b, c, target );

			}

		} );

		Object.assign( Shape.prototype, {

			extractAllPoints: function ( divisions ) {

				console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
				return this.extractPoints( divisions );

			},
			extrude: function ( options ) {

				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );

			},
			makeGeometry: function ( options ) {

				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );

			}

		} );

		Object.assign( Vector2.prototype, {

			fromAttribute: function ( attribute, index, offset ) {

				console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			},
			distanceToManhattan: function ( v ) {

				console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
				return this.manhattanDistanceTo( v );

			},
			lengthManhattan: function () {

				console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
				return this.manhattanLength();

			}

		} );

		Object.assign( Vector3.prototype, {

			setEulerFromRotationMatrix: function () {

				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

			},
			setEulerFromQuaternion: function () {

				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

			},
			getPositionFromMatrix: function ( m ) {

				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );

			},
			getScaleFromMatrix: function ( m ) {

				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );

			},
			getColumnFromMatrix: function ( index, matrix ) {

				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );

			},
			applyProjection: function ( m ) {

				console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
				return this.applyMatrix4( m );

			},
			fromAttribute: function ( attribute, index, offset ) {

				console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			},
			distanceToManhattan: function ( v ) {

				console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
				return this.manhattanDistanceTo( v );

			},
			lengthManhattan: function () {

				console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
				return this.manhattanLength();

			}

		} );

		Object.assign( Vector4.prototype, {

			fromAttribute: function ( attribute, index, offset ) {

				console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );

			},
			lengthManhattan: function () {

				console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
				return this.manhattanLength();

			}

		} );

		//

		Object.assign( Geometry.prototype, {

			computeTangents: function () {

				console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

			},
			computeLineDistances: function () {

				console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

			},
			applyMatrix: function ( matrix ) {

				console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
				return this.applyMatrix4( matrix );

			}

		} );

		Object.assign( Object3D.prototype, {

			getChildByName: function ( name ) {

				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );

			},
			renderDepth: function () {

				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

			},
			translate: function ( distance, axis ) {

				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );

			},
			getWorldRotation: function () {

				console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

			},
			applyMatrix: function ( matrix ) {

				console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
				return this.applyMatrix4( matrix );

			}

		} );

		Object.defineProperties( Object3D.prototype, {

			eulerOrder: {
				get: function () {

					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;

				},
				set: function ( value ) {

					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;

				}
			},
			useQuaternion: {
				get: function () {

					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

				},
				set: function () {

					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

				}
			}

		} );

		Object.assign( Mesh.prototype, {

			setDrawMode: function () {

				console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

			},

		} );

		Object.defineProperties( Mesh.prototype, {

			drawMode: {
				get: function () {

					console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
					return TrianglesDrawMode;

				},
				set: function () {

					console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

				}
			}

		} );

		Object.defineProperties( LOD.prototype, {

			objects: {
				get: function () {

					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;

				}
			}

		} );

		Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

			get: function () {

				console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

			}

		} );

		SkinnedMesh.prototype.initBones = function () {

			console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

		};

		Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

			get: function () {

				console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
				return this.arcLengthDivisions;

			},
			set: function ( value ) {

				console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
				this.arcLengthDivisions = value;

			}

		} );

		//

		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );

			if ( filmGauge !== undefined ) { this.filmGauge = filmGauge; }
			this.setFocalLength( focalLength );

		};

		//

		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function () {

					console.warn( 'THREE.Light: .onlyShadow has been removed.' );

				}
			},
			shadowCameraFov: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;

				}
			},
			shadowCameraLeft: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;

				}
			},
			shadowCameraRight: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;

				}
			},
			shadowCameraTop: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;

				}
			},
			shadowCameraBottom: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;

				}
			},
			shadowCameraNear: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;

				}
			},
			shadowCameraFar: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;

				}
			},
			shadowCameraVisible: {
				set: function () {

					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

				}
			},
			shadowBias: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;

				}
			},
			shadowDarkness: {
				set: function () {

					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

				}
			},
			shadowMapWidth: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;

				}
			},
			shadowMapHeight: {
				set: function ( value ) {

					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;

				}
			}
		} );

		//

		Object.defineProperties( BufferAttribute.prototype, {

			length: {
				get: function () {

					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
					return this.array.length;

				}
			},
			dynamic: {
				get: function () {

					console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
					return this.usage === DynamicDrawUsage;

				},
				set: function ( /* value */ ) {

					console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
					this.setUsage( DynamicDrawUsage );

				}
			}

		} );

		Object.assign( BufferAttribute.prototype, {
			setDynamic: function ( value ) {

				console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
				this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
				return this;

			},
			copyIndicesArray: function ( /* indices */ ) {

				console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

			},
			setArray: function ( /* array */ ) {

				console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

			}
		} );

		Object.assign( BufferGeometry.prototype, {

			addIndex: function ( index ) {

				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );

			},
			addAttribute: function ( name, attribute ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

				if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

					return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				}

				if ( name === 'index' ) {

					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );

					return this;

				}

				return this.setAttribute( name, attribute );

			},
			addDrawCall: function ( start, count, indexOffset ) {

				if ( indexOffset !== undefined ) {

					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );

			},
			clearDrawCalls: function () {

				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();

			},
			computeTangents: function () {

				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

			},
			computeOffsets: function () {

				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

			},
			removeAttribute: function ( name ) {

				console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

				return this.deleteAttribute( name );

			},
			applyMatrix: function ( matrix ) {

				console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
				return this.applyMatrix4( matrix );

			}

		} );

		Object.defineProperties( BufferGeometry.prototype, {

			drawcalls: {
				get: function () {

					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;

				}
			},
			offsets: {
				get: function () {

					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;

				}
			}

		} );

		Object.defineProperties( Raycaster.prototype, {

			linePrecision: {
				get: function () {

					console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
					return this.params.Line.threshold;

				},
				set: function ( value ) {

					console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
					this.params.Line.threshold = value;

				}
			}

		} );

		Object.defineProperties( InterleavedBuffer.prototype, {

			dynamic: {
				get: function () {

					console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
					return this.usage === DynamicDrawUsage;

				},
				set: function ( value ) {

					console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
					this.setUsage( value );

				}
			}

		} );

		Object.assign( InterleavedBuffer.prototype, {
			setDynamic: function ( value ) {

				console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
				this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
				return this;

			},
			setArray: function ( /* array */ ) {

				console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

			}
		} );

		//

		Object.assign( ExtrudeBufferGeometry.prototype, {

			getArrays: function () {

				console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

			},

			addShapeList: function () {

				console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

			},

			addShape: function () {

				console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

			}

		} );

		//

		Object.defineProperties( Uniform.prototype, {

			dynamic: {
				set: function () {

					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

				}
			},
			onUpdate: {
				value: function () {

					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;

				}
			}

		} );

		//

		Object.defineProperties( Material.prototype, {

			wrapAround: {
				get: function () {

					console.warn( 'THREE.Material: .wrapAround has been removed.' );

				},
				set: function () {

					console.warn( 'THREE.Material: .wrapAround has been removed.' );

				}
			},

			overdraw: {
				get: function () {

					console.warn( 'THREE.Material: .overdraw has been removed.' );

				},
				set: function () {

					console.warn( 'THREE.Material: .overdraw has been removed.' );

				}
			},

			wrapRGB: {
				get: function () {

					console.warn( 'THREE.Material: .wrapRGB has been removed.' );
					return new Color();

				}
			},

			shading: {
				get: function () {

					console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

				},
				set: function ( value ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( value === FlatShading );

				}
			},

			stencilMask: {
				get: function () {

					console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
					return this.stencilFuncMask;

				},
				set: function ( value ) {

					console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
					this.stencilFuncMask = value;

				}
			}

		} );

		Object.defineProperties( MeshPhongMaterial.prototype, {

			metal: {
				get: function () {

					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;

				},
				set: function () {

					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

				}
			}

		} );

		Object.defineProperties( ShaderMaterial.prototype, {

			derivatives: {
				get: function () {

					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;

				},
				set: function ( value ) {

					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;

				}
			}

		} );

		//

		Object.assign( WebGLRenderer.prototype, {

			clearTarget: function ( renderTarget, color, depth, stencil ) {

				console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );

			},
			animate: function ( callback ) {

				console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
				this.setAnimationLoop( callback );

			},
			getCurrentRenderTarget: function () {

				console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
				return this.getRenderTarget();

			},
			getMaxAnisotropy: function () {

				console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
				return this.capabilities.getMaxAnisotropy();

			},
			getPrecision: function () {

				console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
				return this.capabilities.precision;

			},
			resetGLState: function () {

				console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
				return this.state.reset();

			},
			supportsFloatTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );

			},
			supportsHalfFloatTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );

			},
			supportsStandardDerivatives: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );

			},
			supportsCompressedTextureS3TC: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

			},
			supportsCompressedTexturePVRTC: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			},
			supportsBlendMinMax: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );

			},
			supportsVertexTextures: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
				return this.capabilities.vertexTextures;

			},
			supportsInstancedArrays: function () {

				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );

			},
			enableScissorTest: function ( boolean ) {

				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );

			},
			initMaterial: function () {

				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

			},
			addPrePlugin: function () {

				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

			},
			addPostPlugin: function () {

				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

			},
			updateShadowMap: function () {

				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

			},
			setFaceCulling: function () {

				console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

			},
			allocTextureUnit: function () {

				console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

			},
			setTexture: function () {

				console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

			},
			setTexture2D: function () {

				console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

			},
			setTextureCube: function () {

				console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

			},
			getActiveMipMapLevel: function () {

				console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
				return this.getActiveMipmapLevel();

			}

		} );

		Object.defineProperties( WebGLRenderer.prototype, {

			shadowMapEnabled: {
				get: function () {

					return this.shadowMap.enabled;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;

				}
			},
			shadowMapType: {
				get: function () {

					return this.shadowMap.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;

				}
			},
			shadowMapCullFace: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
					return undefined;

				},
				set: function ( /* value */ ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

				}
			},
			context: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
					return this.getContext();

				}
			},
			vr: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
					return this.xr;

				}
			},
			gammaInput: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
					return false;

				},
				set: function () {

					console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

				}
			},
			gammaOutput: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
					return false;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
					this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

				}
			}

		} );

		Object.defineProperties( WebGLShadowMap.prototype, {

			cullFace: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
					return undefined;

				},
				set: function ( /* cullFace */ ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

				}
			},
			renderReverseSided: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
					return undefined;

				},
				set: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

				}
			},
			renderSingleSided: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
					return undefined;

				},
				set: function () {

					console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

				}
			}

		} );

		function WebGLRenderTargetCube( width, height, options ) {

			console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
			return new WebGLCubeRenderTarget( width, options );

		}

		//

		Object.defineProperties( WebGLRenderTarget.prototype, {

			wrapS: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;

				}
			},
			wrapT: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;

				}
			},
			magFilter: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;

				}
			},
			minFilter: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;

				}
			},
			anisotropy: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;

				}
			},
			offset: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;

				}
			},
			repeat: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;

				}
			},
			format: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;

				}
			},
			type: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;

				}
			},
			generateMipmaps: {
				get: function () {

					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;

				}
			}

		} );

		//

		Object.defineProperties( Audio.prototype, {

			load: {
				value: function ( file ) {

					console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
					var scope = this;
					var audioLoader = new AudioLoader();
					audioLoader.load( file, function ( buffer ) {

						scope.setBuffer( buffer );

					} );
					return this;

				}
			},
			startTime: {
				set: function () {

					console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

				}
			}

		} );

		AudioAnalyser.prototype.getData = function () {

			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();

		};

		//

		CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

			console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
			return this.update( renderer, scene );

		};

		//

		var GeometryUtils = {

			merge: function ( geometry1, geometry2, materialIndexOffset ) {

				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
				var matrix;

				if ( geometry2.isMesh ) {

					geometry2.matrixAutoUpdate && geometry2.updateMatrix();

					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;

				}

				geometry1.merge( geometry2, matrix, materialIndexOffset );

			},

			center: function ( geometry ) {

				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();

			}

		};

		ImageUtils.crossOrigin = undefined;

		ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( url, onLoad, undefined, onError );

			if ( mapping ) { texture.mapping = mapping; }

			return texture;

		};

		ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( urls, onLoad, undefined, onError );

			if ( mapping ) { texture.mapping = mapping; }

			return texture;

		};

		ImageUtils.loadCompressedTexture = function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

		};

		ImageUtils.loadCompressedTextureCube = function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

		};

		//

		function CanvasRenderer() {

			console.error( 'THREE.CanvasRenderer has been removed' );

		}

		//

		function JSONLoader() {

			console.error( 'THREE.JSONLoader has been removed.' );

		}

		//

		var SceneUtils = {

			createMultiMaterialObject: function ( /* geometry, materials */ ) {

				console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

			},

			detach: function ( /* child, parent, scene */ ) {

				console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

			},

			attach: function ( /* child, scene, parent */ ) {

				console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

			}

		};

		//

		function LensFlare() {

			console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

		}

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			/* eslint-disable no-undef */
			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
				revision: REVISION,
			} } ) );
			/* eslint-enable no-undef */

		}

		exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
		exports.AddEquation = AddEquation;
		exports.AddOperation = AddOperation;
		exports.AdditiveBlending = AdditiveBlending;
		exports.AlphaFormat = AlphaFormat;
		exports.AlwaysDepth = AlwaysDepth;
		exports.AlwaysStencilFunc = AlwaysStencilFunc;
		exports.AmbientLight = AmbientLight;
		exports.AmbientLightProbe = AmbientLightProbe;
		exports.AnimationClip = AnimationClip;
		exports.AnimationLoader = AnimationLoader;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationUtils = AnimationUtils;
		exports.ArcCurve = ArcCurve;
		exports.ArrayCamera = ArrayCamera;
		exports.ArrowHelper = ArrowHelper;
		exports.Audio = Audio;
		exports.AudioAnalyser = AudioAnalyser;
		exports.AudioContext = AudioContext;
		exports.AudioListener = AudioListener;
		exports.AudioLoader = AudioLoader;
		exports.AxesHelper = AxesHelper;
		exports.AxisHelper = AxisHelper;
		exports.BackSide = BackSide;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.BasicShadowMap = BasicShadowMap;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.Bone = Bone;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.Box2 = Box2;
		exports.Box3 = Box3;
		exports.Box3Helper = Box3Helper;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.BoxHelper = BoxHelper;
		exports.BufferAttribute = BufferAttribute;
		exports.BufferGeometry = BufferGeometry;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.ByteType = ByteType;
		exports.Cache = Cache;
		exports.Camera = Camera;
		exports.CameraHelper = CameraHelper;
		exports.CanvasRenderer = CanvasRenderer;
		exports.CanvasTexture = CanvasTexture;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.CineonToneMapping = CineonToneMapping;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.Clock = Clock;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.Color = Color;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.CompressedTexture = CompressedTexture;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.CubeCamera = CubeCamera;
		exports.CubeGeometry = BoxGeometry;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.CubeTexture = CubeTexture;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.CubicInterpolant = CubicInterpolant;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.CullFaceNone = CullFaceNone;
		exports.Curve = Curve;
		exports.CurvePath = CurvePath;
		exports.CustomBlending = CustomBlending;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.Cylindrical = Cylindrical;
		exports.DataTexture = DataTexture;
		exports.DataTexture2DArray = DataTexture2DArray;
		exports.DataTexture3D = DataTexture3D;
		exports.DataTextureLoader = DataTextureLoader;
		exports.DecrementStencilOp = DecrementStencilOp;
		exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.DepthTexture = DepthTexture;
		exports.DirectionalLight = DirectionalLight;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DoubleSide = DoubleSide;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.DynamicCopyUsage = DynamicCopyUsage;
		exports.DynamicDrawUsage = DynamicDrawUsage;
		exports.DynamicReadUsage = DynamicReadUsage;
		exports.EdgesGeometry = EdgesGeometry;
		exports.EdgesHelper = EdgesHelper;
		exports.EllipseCurve = EllipseCurve;
		exports.EqualDepth = EqualDepth;
		exports.EqualStencilFunc = EqualStencilFunc;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.Euler = Euler;
		exports.EventDispatcher = EventDispatcher;
		exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.Face3 = Face3;
		exports.Face4 = Face4;
		exports.FaceColors = FaceColors;
		exports.FileLoader = FileLoader;
		exports.FlatShading = FlatShading;
		exports.Float32Attribute = Float32Attribute;
		exports.Float32BufferAttribute = Float32BufferAttribute;
		exports.Float64Attribute = Float64Attribute;
		exports.Float64BufferAttribute = Float64BufferAttribute;
		exports.FloatType = FloatType;
		exports.Fog = Fog;
		exports.FogExp2 = FogExp2;
		exports.Font = Font;
		exports.FontLoader = FontLoader;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontSide = FrontSide;
		exports.Frustum = Frustum;
		exports.GammaEncoding = GammaEncoding;
		exports.Geometry = Geometry;
		exports.GeometryUtils = GeometryUtils;
		exports.GreaterDepth = GreaterDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
		exports.GreaterStencilFunc = GreaterStencilFunc;
		exports.GridHelper = GridHelper;
		exports.Group = Group;
		exports.HalfFloatType = HalfFloatType;
		exports.HemisphereLight = HemisphereLight;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.HemisphereLightProbe = HemisphereLightProbe;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.ImageBitmapLoader = ImageBitmapLoader;
		exports.ImageLoader = ImageLoader;
		exports.ImageUtils = ImageUtils;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.IncrementStencilOp = IncrementStencilOp;
		exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InstancedMesh = InstancedMesh;
		exports.Int16Attribute = Int16Attribute;
		exports.Int16BufferAttribute = Int16BufferAttribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Int32BufferAttribute = Int32BufferAttribute;
		exports.Int8Attribute = Int8Attribute;
		exports.Int8BufferAttribute = Int8BufferAttribute;
		exports.IntType = IntType;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.Interpolant = Interpolant;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.InvertStencilOp = InvertStencilOp;
		exports.JSONLoader = JSONLoader;
		exports.KeepStencilOp = KeepStencilOp;
		exports.KeyframeTrack = KeyframeTrack;
		exports.LOD = LOD;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.Layers = Layers;
		exports.LensFlare = LensFlare;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.LessEqualStencilFunc = LessEqualStencilFunc;
		exports.LessStencilFunc = LessStencilFunc;
		exports.Light = Light;
		exports.LightProbe = LightProbe;
		exports.LightShadow = LightShadow;
		exports.Line = Line;
		exports.Line3 = Line3;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.LineCurve = LineCurve;
		exports.LineCurve3 = LineCurve3;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineLoop = LineLoop;
		exports.LinePieces = LinePieces;
		exports.LineSegments = LineSegments;
		exports.LineStrip = LineStrip;
		exports.LinearEncoding = LinearEncoding;
		exports.LinearFilter = LinearFilter;
		exports.LinearInterpolant = LinearInterpolant;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
		exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
		exports.LinearToneMapping = LinearToneMapping;
		exports.Loader = Loader;
		exports.LoaderUtils = LoaderUtils;
		exports.LoadingManager = LoadingManager;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.LoopOnce = LoopOnce;
		exports.LoopPingPong = LoopPingPong;
		exports.LoopRepeat = LoopRepeat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.MOUSE = MOUSE;
		exports.Material = Material;
		exports.MaterialLoader = MaterialLoader;
		exports.Math = MathUtils;
		exports.MathUtils = MathUtils;
		exports.Matrix3 = Matrix3;
		exports.Matrix4 = Matrix4;
		exports.MaxEquation = MaxEquation;
		exports.Mesh = Mesh;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshDistanceMaterial = MeshDistanceMaterial;
		exports.MeshFaceMaterial = MeshFaceMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshMatcapMaterial = MeshMatcapMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshToonMaterial = MeshToonMaterial;
		exports.MinEquation = MinEquation;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.MixOperation = MixOperation;
		exports.MultiMaterial = MultiMaterial;
		exports.MultiplyBlending = MultiplyBlending;
		exports.MultiplyOperation = MultiplyOperation;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
		exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
		exports.NeverDepth = NeverDepth;
		exports.NeverStencilFunc = NeverStencilFunc;
		exports.NoBlending = NoBlending;
		exports.NoColors = NoColors;
		exports.NoToneMapping = NoToneMapping;
		exports.NormalBlending = NormalBlending;
		exports.NotEqualDepth = NotEqualDepth;
		exports.NotEqualStencilFunc = NotEqualStencilFunc;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.Object3D = Object3D;
		exports.ObjectLoader = ObjectLoader;
		exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OneFactor = OneFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.OrthographicCamera = OrthographicCamera;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.PMREMGenerator = PMREMGenerator;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.Particle = Particle;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystem = ParticleSystem;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Path = Path;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.Plane = Plane;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.PlaneHelper = PlaneHelper;
		exports.PointCloud = PointCloud;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.PointLight = PointLight;
		exports.PointLightHelper = PointLightHelper;
		exports.Points = Points;
		exports.PointsMaterial = PointsMaterial;
		exports.PolarGridHelper = PolarGridHelper;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PositionalAudio = PositionalAudio;
		exports.PropertyBinding = PropertyBinding;
		exports.PropertyMixer = PropertyMixer;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.Quaternion = Quaternion;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.REVISION = REVISION;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.RGBAFormat = RGBAFormat;
		exports.RGBAIntegerFormat = RGBAIntegerFormat;
		exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
		exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
		exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
		exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
		exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
		exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
		exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
		exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
		exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
		exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
		exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
		exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
		exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
		exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
		exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
		exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGBDEncoding = RGBDEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.RGBEFormat = RGBEFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBIntegerFormat = RGBIntegerFormat;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.RGB_ETC2_Format = RGB_ETC2_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGFormat = RGFormat;
		exports.RGIntegerFormat = RGIntegerFormat;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.Ray = Ray;
		exports.Raycaster = Raycaster;
		exports.RectAreaLight = RectAreaLight;
		exports.RedFormat = RedFormat;
		exports.RedIntegerFormat = RedIntegerFormat;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ReplaceStencilOp = ReplaceStencilOp;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.RingGeometry = RingGeometry;
		exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
		exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
		exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
		exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
		exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
		exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
		exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
		exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
		exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
		exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
		exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
		exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
		exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
		exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
		exports.Scene = Scene;
		exports.SceneUtils = SceneUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.ShaderLib = ShaderLib;
		exports.ShaderMaterial = ShaderMaterial;
		exports.ShadowMaterial = ShadowMaterial;
		exports.Shape = Shape;
		exports.ShapeBufferGeometry = ShapeBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ShapePath = ShapePath;
		exports.ShapeUtils = ShapeUtils;
		exports.ShortType = ShortType;
		exports.Skeleton = Skeleton;
		exports.SkeletonHelper = SkeletonHelper;
		exports.SkinnedMesh = SkinnedMesh;
		exports.SmoothShading = SmoothShading;
		exports.Sphere = Sphere;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.Spherical = Spherical;
		exports.SphericalHarmonics3 = SphericalHarmonics3;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.Spline = Spline;
		exports.SplineCurve = SplineCurve;
		exports.SplineCurve3 = SplineCurve3;
		exports.SpotLight = SpotLight;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SpotLightShadow = SpotLightShadow;
		exports.Sprite = Sprite;
		exports.SpriteMaterial = SpriteMaterial;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.StaticCopyUsage = StaticCopyUsage;
		exports.StaticDrawUsage = StaticDrawUsage;
		exports.StaticReadUsage = StaticReadUsage;
		exports.StereoCamera = StereoCamera;
		exports.StreamCopyUsage = StreamCopyUsage;
		exports.StreamDrawUsage = StreamDrawUsage;
		exports.StreamReadUsage = StreamReadUsage;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.SubtractEquation = SubtractEquation;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.TOUCH = TOUCH;
		exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TextBufferGeometry = TextBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.Texture = Texture;
		exports.TextureLoader = TextureLoader;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.Triangle = Triangle;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.UVMapping = UVMapping;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Uint16BufferAttribute = Uint16BufferAttribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Uint32BufferAttribute = Uint32BufferAttribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Uint8BufferAttribute = Uint8BufferAttribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.Uniform = Uniform;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.UnsignedByteType = UnsignedByteType;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.UnsignedIntType = UnsignedIntType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedShortType = UnsignedShortType;
		exports.VSMShadowMap = VSMShadowMap;
		exports.Vector2 = Vector2;
		exports.Vector3 = Vector3;
		exports.Vector4 = Vector4;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.Vertex = Vertex;
		exports.VertexColors = VertexColors;
		exports.VideoTexture = VideoTexture;
		exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
		exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderer = WebGLRenderer;
		exports.WebGLUtils = WebGLUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.WireframeHelper = WireframeHelper;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.XHRLoader = XHRLoader;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroFactor = ZeroFactor;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.ZeroStencilOp = ZeroStencilOp;
		exports.sRGBEncoding = sRGBEncoding;

		Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	var THREE = __webpack_require__(41);

	/*
	 * @author zz85 / https://github.com/zz85
	 * @author mrdoob / http://mrdoob.com
	 * Running this will allow you to drag three.js objects around the screen.
	 */

	function DragControls(_objects, _camera, _domElement) {

	  if (_objects instanceof THREE.Camera) {

	    console.warn('THREE.DragControls: Constructor now expects ( objects, camera, domElement )');
	    var temp = _objects;
	    _objects = _camera;
	    _camera = temp;

	  }

	  var _plane = new THREE.Plane();
	  var _raycaster = new THREE.Raycaster();

	  var _mouse = new THREE.Vector2();
	  var _offset = new THREE.Vector3();
	  var _intersection = new THREE.Vector3();

	  var _selected = null,
	    _hovered = null;

	  //

	  var scope = this;

	  function activate() {

	    _domElement.addEventListener('mousemove', onDocumentMouseMove, false);
	    _domElement.addEventListener('mousedown', onDocumentMouseDown, false);
	    _domElement.addEventListener('mouseup', onDocumentMouseCancel, false);
	    _domElement.addEventListener('mouseleave', onDocumentMouseCancel, false);
	    _domElement.addEventListener('touchmove', onDocumentTouchMove, false);
	    _domElement.addEventListener('touchstart', onDocumentTouchStart, false);
	    _domElement.addEventListener('touchend', onDocumentTouchEnd, false);

	  }

	  function deactivate() {

	    _domElement.removeEventListener('mousemove', onDocumentMouseMove, false);
	    _domElement.removeEventListener('mousedown', onDocumentMouseDown, false);
	    _domElement.removeEventListener('mouseup', onDocumentMouseCancel, false);
	    _domElement.removeEventListener('mouseleave', onDocumentMouseCancel, false);
	    _domElement.removeEventListener('touchmove', onDocumentTouchMove, false);
	    _domElement.removeEventListener('touchstart', onDocumentTouchStart, false);
	    _domElement.removeEventListener('touchend', onDocumentTouchEnd, false);

	  }

	  function dispose() {

	    deactivate();

	  }

	  function onDocumentMouseMove(event) {

	    event.preventDefault();

	    var rect = _domElement.getBoundingClientRect();

	    _mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
	    _mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

	    _raycaster.setFromCamera(_mouse, _camera);

	    if (_selected && scope.enabled) {

	      if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

	        _selected.position.copy(_intersection.sub(_offset));

	      }

	      scope.dispatchEvent({
	        type: 'drag',
	        object: _selected
	      });

	      return;

	    }

	    _raycaster.setFromCamera(_mouse, _camera);

	    var intersects = _raycaster.intersectObjects(_objects);

	    if (intersects.length > 0) {

	      var object = intersects[0].object;

	      _plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), object.position);

	      if (_hovered !== object) {

	        scope.dispatchEvent({
	          type: 'hoveron',
	          object: object
	        });

	        _domElement.style.cursor = 'pointer';
	        _hovered = object;

	      }

	    } else {

	      if (_hovered !== null) {

	        scope.dispatchEvent({
	          type: 'hoveroff',
	          object: _hovered
	        });

	        _domElement.style.cursor = 'auto';
	        _hovered = null;

	      }

	    }

	  }

	  function onDocumentMouseDown(event) {

	    event.preventDefault();

	    _raycaster.setFromCamera(_mouse, _camera);

	    var intersects = _raycaster.intersectObjects(_objects);

	    if (intersects.length > 0) {

	      _selected = intersects[0].object;

	      if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

	        _offset.copy(_intersection).sub(_selected.position);

	      }

	      _domElement.style.cursor = 'move';

	      scope.dispatchEvent({
	        type: 'dragstart',
	        object: _selected
	      });

	    }


	  }

	  function onDocumentMouseCancel(event) {

	    event.preventDefault();

	    if (_selected) {

	      scope.dispatchEvent({
	        type: 'dragend',
	        object: _selected
	      });

	      _selected = null;

	    }

	    _domElement.style.cursor = 'auto';

	  }

	  function onDocumentTouchMove(event) {

	    event.preventDefault();
	    event = event.changedTouches[0];

	    var rect = _domElement.getBoundingClientRect();

	    _mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
	    _mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

	    _raycaster.setFromCamera(_mouse, _camera);

	    if (_selected && scope.enabled) {

	      if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

	        _selected.position.copy(_intersection.sub(_offset));

	      }

	      scope.dispatchEvent({
	        type: 'drag',
	        object: _selected
	      });

	      return;

	    }

	  }

	  function onDocumentTouchStart(event) {

	    event.preventDefault();
	    event = event.changedTouches[0];

	    var rect = _domElement.getBoundingClientRect();

	    _mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
	    _mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

	    _raycaster.setFromCamera(_mouse, _camera);

	    var intersects = _raycaster.intersectObjects(_objects);

	    if (intersects.length > 0) {

	      _selected = intersects[0].object;

	      _plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), _selected.position);

	      if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

	        _offset.copy(_intersection).sub(_selected.position);

	      }

	      _domElement.style.cursor = 'move';

	      scope.dispatchEvent({
	        type: 'dragstart',
	        object: _selected
	      });

	    }


	  }

	  function onDocumentTouchEnd(event) {

	    event.preventDefault();

	    if (_selected) {

	      scope.dispatchEvent({
	        type: 'dragend',
	        object: _selected
	      });

	      _selected = null;

	    }

	    _domElement.style.cursor = 'auto';

	  }

	  activate();

	  // API

	  this.enabled = true;

	  this.activate = activate;
	  this.deactivate = deactivate;
	  this.dispose = dispose;

	  // Backward compatibility

	  this.setObjects = function() {

	    console.error('THREE.DragControls: setObjects() has been removed.');

	  };

	  this.on = function(type, listener) {

	    console.warn('THREE.DragControls: on() has been deprecated. Use addEventListener() instead.');
	    scope.addEventListener(type, listener);

	  };

	  this.off = function(type, listener) {

	    console.warn('THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.');
	    scope.removeEventListener(type, listener);

	  };

	  this.notify = function(type) {

	    console.error('THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.');
	    scope.dispatchEvent({
	      type: type
	    });

	  };

	}

	DragControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	DragControls.prototype.constructor = DragControls;

	module.exports = DragControls;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var three$2 = __webpack_require__(41);
	var d3Force3d = __webpack_require__(44);
	var graph = _interopDefault(__webpack_require__(47));
	var forcelayout = _interopDefault(__webpack_require__(49));
	var forcelayout3d = _interopDefault(__webpack_require__(65));
	var Kapsule = _interopDefault(__webpack_require__(76));
	var accessorFn = _interopDefault(__webpack_require__(78));
	var dataJoint = _interopDefault(__webpack_require__(79));
	var d3Scale = __webpack_require__(81);
	var d3ScaleChromatic = __webpack_require__(36);
	var tinyColor = _interopDefault(__webpack_require__(83));

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  return function () {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (_isNativeReflectConstruct()) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(n);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var materialDispose = function materialDispose(material) {
	  if (material instanceof Array) {
	    material.forEach(materialDispose);
	  } else {
	    if (material.map) {
	      material.map.dispose();
	    }

	    material.dispose();
	  }
	};

	var deallocate = function deallocate(obj) {
	  if (obj.geometry) {
	    obj.geometry.dispose();
	  }

	  if (obj.material) {
	    materialDispose(obj.material);
	  }

	  if (obj.texture) {
	    obj.texture.dispose();
	  }

	  if (obj.children) {
	    obj.children.forEach(deallocate);
	  }
	};

	var emptyObject = function emptyObject(obj) {
	  while (obj.children.length) {
	    var childObj = obj.children[0];
	    obj.remove(childObj);
	    deallocate(childObj);
	  }
	};

	function threeDigest(data, scene) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var _ref$objFilter = _ref.objFilter,
	      objFilter = _ref$objFilter === void 0 ? function () {
	    return true;
	  } : _ref$objFilter,
	      options = _objectWithoutProperties(_ref, ["objFilter"]);

	  return dataJoint(data, scene.children.filter(objFilter), function (obj) {
	    return scene.add(obj);
	  }, function (obj) {
	    scene.remove(obj);
	    emptyObject(obj);
	  }, _objectSpread2({
	    objBindAttr: '__threeObj'
	  }, options));
	}

	var colorStr2Hex = function colorStr2Hex(str) {
	  return isNaN(str) ? parseInt(tinyColor(str).toHex(), 16) : str;
	};

	var colorAlpha = function colorAlpha(str) {
	  return isNaN(str) ? tinyColor(str).getAlpha() : 1;
	};

	var autoColorScale = d3Scale.scaleOrdinal(d3ScaleChromatic.schemePaired); // Autoset attribute colorField by colorByAccessor property
	// If an object has already a color, don't set it
	// Objects can be nodes or links

	function autoColorObjects(objects, colorByAccessor, colorField) {
	  if (!colorByAccessor || typeof colorField !== 'string') return;
	  objects.filter(function (obj) {
	    return !obj[colorField];
	  }).forEach(function (obj) {
	    obj[colorField] = autoColorScale(colorByAccessor(obj));
	  });
	}

	function getDagDepths (_ref, idAccessor) {
	  var nodes = _ref.nodes,
	      links = _ref.links;
	  // linked graph
	  var graph = {};
	  nodes.forEach(function (node) {
	    return graph[idAccessor(node)] = {
	      data: node,
	      out: [],
	      depth: -1
	    };
	  });
	  links.forEach(function (_ref2) {
	    var source = _ref2.source,
	        target = _ref2.target;
	    var sourceId = getNodeId(source);
	    var targetId = getNodeId(target);
	    if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
	    if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
	    var sourceNode = graph[sourceId];
	    var targetNode = graph[targetId];
	    sourceNode.out.push(targetNode);

	    function getNodeId(node) {
	      return _typeof(node) === 'object' ? idAccessor(node) : node;
	    }
	  });
	  traverse(Object.values(graph)); // cleanup

	  Object.keys(graph).forEach(function (id) {
	    return graph[id] = graph[id].depth;
	  });
	  return graph;

	  function traverse(nodes) {
	    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    var currentDepth = nodeStack.length;

	    for (var i = 0, l = nodes.length; i < l; i++) {
	      var node = nodes[i];

	      if (nodeStack.indexOf(node) !== -1) {
	        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {
	          return idAccessor(d.data);
	        });
	        throw "Invalid DAG structure! Found cycle in node path: ".concat(loop.join(' -> '), ".");
	      }

	      if (currentDepth > node.depth) {
	        // Don't unnecessarily revisit chunks of the graph
	        node.depth = currentDepth;
	        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]));
	      }
	    }
	  }
	}

	var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
	: {
	  Group: three$2.Group,
	  Mesh: three$2.Mesh,
	  MeshLambertMaterial: three$2.MeshLambertMaterial,
	  Color: three$2.Color,
	  BufferGeometry: three$2.BufferGeometry,
	  BufferAttribute: three$2.BufferAttribute,
	  Matrix4: three$2.Matrix4,
	  Vector3: three$2.Vector3,
	  SphereBufferGeometry: three$2.SphereBufferGeometry,
	  CylinderBufferGeometry: three$2.CylinderBufferGeometry,
	  TubeBufferGeometry: three$2.TubeBufferGeometry,
	  ConeBufferGeometry: three$2.ConeBufferGeometry,
	  Line: three$2.Line,
	  LineBasicMaterial: three$2.LineBasicMaterial,
	  QuadraticBezierCurve3: three$2.QuadraticBezierCurve3,
	  CubicBezierCurve3: three$2.CubicBezierCurve3
	};
	var ngraph = {
	  graph: graph,
	  forcelayout: forcelayout,
	  forcelayout3d: forcelayout3d
	};

	var DAG_LEVEL_NODE_RATIO = 2; // support multiple method names for backwards threejs compatibility

	var setAttributeFn = new three.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';
	var applyMatrix4Fn = new three.BufferGeometry().applyMatrix4 ? 'applyMatrix4' : 'applyMatrix';
	var ForceGraph = Kapsule({
	  props: {
	    jsonUrl: {
	      onChange: function onChange(jsonUrl, state) {
	        var _this = this;

	        if (jsonUrl && !state.fetchingJson) {
	          // Load data asynchronously
	          state.fetchingJson = true;
	          state.onLoading();
	          fetch(jsonUrl).then(function (r) {
	            return r.json();
	          }).then(function (json) {
	            state.fetchingJson = false;
	            state.onFinishLoading(json);

	            _this.graphData(json);
	          });
	        }
	      },
	      triggerUpdate: false
	    },
	    graphData: {
	      "default": {
	        nodes: [],
	        links: []
	      },
	      onChange: function onChange(graphData, state) {
	        if (graphData.nodes.length || graphData.links.length) {
	          console.info('force-graph loading', graphData.nodes.length + ' nodes', graphData.links.length + ' links');
	        }

	        state.engineRunning = false; // Pause simulation immediately
	      }
	    },
	    numDimensions: {
	      "default": 3,
	      onChange: function onChange(numDim, state) {
	        var chargeForce = state.d3ForceLayout.force('charge'); // Increase repulsion on 3D mode for improved spatial separation

	        if (chargeForce) {
	          chargeForce.strength(numDim > 2 ? -60 : -30);
	        }

	        if (numDim < 3) {
	          eraseDimension(state.graphData.nodes, 'z');
	        }

	        if (numDim < 2) {
	          eraseDimension(state.graphData.nodes, 'y');
	        }

	        function eraseDimension(nodes, dim) {
	          nodes.forEach(function (d) {
	            delete d[dim]; // position

	            delete d["v".concat(dim)]; // velocity
	          });
	        }
	      }
	    },
	    dagMode: {
	      onChange: function onChange(dagMode, state) {
	        // td, bu, lr, rl, zin, zout, radialin, radialout
	        !dagMode && state.forceEngine === 'd3' && (state.graphData.nodes || []).forEach(function (n) {
	          return n.fx = n.fy = n.fz = undefined;
	        }); // unfix nodes when disabling dag mode
	      }
	    },
	    dagLevelDistance: {},
	    nodeRelSize: {
	      "default": 4
	    },
	    // volume per val unit
	    nodeId: {
	      "default": 'id'
	    },
	    nodeVal: {
	      "default": 'val'
	    },
	    nodeResolution: {
	      "default": 8
	    },
	    // how many slice segments in the sphere's circumference
	    nodeColor: {
	      "default": 'color'
	    },
	    nodeAutoColorBy: {},
	    nodeOpacity: {
	      "default": 0.75
	    },
	    nodeVisibility: {
	      "default": true
	    },
	    nodeThreeObject: {},
	    nodeThreeObjectExtend: {
	      "default": false
	    },
	    linkSource: {
	      "default": 'source'
	    },
	    linkTarget: {
	      "default": 'target'
	    },
	    linkVisibility: {
	      "default": true
	    },
	    linkColor: {
	      "default": 'color'
	    },
	    linkAutoColorBy: {},
	    linkOpacity: {
	      "default": 0.2
	    },
	    linkWidth: {},
	    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
	    linkResolution: {
	      "default": 6
	    },
	    // how many radial segments in each line tube's geometry
	    linkCurvature: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    // line curvature radius (0: straight, 1: semi-circle)
	    linkCurveRotation: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
	    linkMaterial: {},
	    linkThreeObject: {},
	    linkThreeObjectExtend: {
	      "default": false
	    },
	    linkPositionUpdate: {
	      triggerUpdate: false
	    },
	    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
	    linkDirectionalArrowLength: {
	      "default": 0
	    },
	    linkDirectionalArrowColor: {},
	    linkDirectionalArrowRelPos: {
	      "default": 0.5,
	      triggerUpdate: false
	    },
	    // value between 0<>1 indicating the relative pos along the (exposed) line
	    linkDirectionalArrowResolution: {
	      "default": 8
	    },
	    // how many slice segments in the arrow's conic circumference
	    linkDirectionalParticles: {
	      "default": 0
	    },
	    // animate photons travelling in the link direction
	    linkDirectionalParticleSpeed: {
	      "default": 0.01,
	      triggerUpdate: false
	    },
	    // in link length ratio per frame
	    linkDirectionalParticleWidth: {
	      "default": 0.5
	    },
	    linkDirectionalParticleColor: {},
	    linkDirectionalParticleResolution: {
	      "default": 4
	    },
	    // how many slice segments in the particle sphere's circumference
	    forceEngine: {
	      "default": 'd3'
	    },
	    // d3 or ngraph
	    d3AlphaDecay: {
	      "default": 0.0228,
	      triggerUpdate: false,
	      onChange: function onChange(alphaDecay, state) {
	        state.d3ForceLayout.alphaDecay(alphaDecay);
	      }
	    },
	    d3AlphaTarget: {
	      "default": 0,
	      triggerUpdate: false,
	      onChange: function onChange(alphaTarget, state) {
	        state.d3ForceLayout.alphaTarget(alphaTarget);
	      }
	    },
	    d3VelocityDecay: {
	      "default": 0.4,
	      triggerUpdate: false,
	      onChange: function onChange(velocityDecay, state) {
	        state.d3ForceLayout.velocityDecay(velocityDecay);
	      }
	    },
	    warmupTicks: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    // how many times to tick the force engine at init before starting to render
	    cooldownTicks: {
	      "default": Infinity,
	      triggerUpdate: false
	    },
	    cooldownTime: {
	      "default": 15000,
	      triggerUpdate: false
	    },
	    // ms
	    onLoading: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onFinishLoading: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onUpdate: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onFinishUpdate: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onEngineTick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onEngineStop: {
	      "default": function _default() {},
	      triggerUpdate: false
	    }
	  },
	  methods: {
	    refresh: function refresh(state) {
	      state._flushObjects = true;

	      state._rerender();

	      return this;
	    },
	    // Expose d3 forces for external manipulation
	    d3Force: function d3Force(state, forceName, forceFn) {
	      if (forceFn === undefined) {
	        return state.d3ForceLayout.force(forceName); // Force getter
	      }

	      state.d3ForceLayout.force(forceName, forceFn); // Force setter

	      return this;
	    },
	    d3ReheatSimulation: function d3ReheatSimulation(state) {
	      state.d3ForceLayout.alpha(1);
	      this.resetCountdown();
	      return this;
	    },
	    // reset cooldown state
	    resetCountdown: function resetCountdown(state) {
	      state.cntTicks = 0;
	      state.startTickTime = new Date();
	      state.engineRunning = true;
	      return this;
	    },
	    tickFrame: function tickFrame(state) {
	      var isD3Sim = state.forceEngine !== 'ngraph';

	      if (state.engineRunning) {
	        layoutTick();
	      }

	      updateArrows();
	      updatePhotons();
	      return this; //

	      function layoutTick() {
	        if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime) {
	          state.engineRunning = false; // Stop ticking graph

	          state.onEngineStop();
	        } else {
	          state.layout[isD3Sim ? 'tick' : 'step'](); // Tick it

	          state.onEngineTick();
	        } // Update nodes position


	        state.graphData.nodes.forEach(function (node) {
	          var obj = node.__threeObj;
	          if (!obj) return;
	          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);
	          obj.position.x = pos.x;
	          obj.position.y = pos.y || 0;
	          obj.position.z = pos.z || 0;
	        }); // Update links position

	        var linkWidthAccessor = accessorFn(state.linkWidth);
	        var linkCurvatureAccessor = accessorFn(state.linkCurvature);
	        var linkCurveRotationAccessor = accessorFn(state.linkCurveRotation);
	        var linkThreeObjectExtendAccessor = accessorFn(state.linkThreeObjectExtend);
	        state.graphData.links.forEach(function (link) {
	          var lineObj = link.__lineObj;
	          if (!lineObj) return;
	          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
	          var start = pos[isD3Sim ? 'source' : 'from'];
	          var end = pos[isD3Sim ? 'target' : 'to'];
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          calcLinkCurve(link); // calculate link curve for all links, including custom replaced, so it can be used in directional functionality

	          var extendedObj = linkThreeObjectExtendAccessor(link);

	          if (state.linkPositionUpdate && state.linkPositionUpdate(extendedObj ? lineObj.children[1] : lineObj, // pass child custom object if extending the default
	          {
	            start: {
	              x: start.x,
	              y: start.y,
	              z: start.z
	            },
	            end: {
	              x: end.x,
	              y: end.y,
	              z: end.z
	            }
	          }, link) && !extendedObj) {
	            // exit if successfully custom updated position of non-extended obj
	            return;
	          }

	          var curveResolution = 30; // # line segments

	          var curve = link.__curve; // select default line obj if it's an extended group

	          var line = lineObj.children.length ? lineObj.children[0] : lineObj;

	          if (line.type === 'Line') {
	            // Update line geometry
	            if (!curve) {
	              // straight line
	              var linePos = line.geometry.getAttribute('position');

	              if (!linePos || !linePos.array || linePos.array.length !== 6) {
	                line.geometry[setAttributeFn]('position', linePos = new three.BufferAttribute(new Float32Array(2 * 3), 3));
	              }

	              linePos.array[0] = start.x;
	              linePos.array[1] = start.y || 0;
	              linePos.array[2] = start.z || 0;
	              linePos.array[3] = end.x;
	              linePos.array[4] = end.y || 0;
	              linePos.array[5] = end.z || 0;
	              linePos.needsUpdate = true;
	            } else {
	              // bezier curve line
	              line.geometry.setFromPoints(curve.getPoints(curveResolution));
	            }

	            line.geometry.computeBoundingSphere();
	          } else if (line.type === 'Mesh') {
	            // Update cylinder geometry
	            if (!curve) {
	              // straight tube
	              if (line.geometry.type !== 'CylinderBufferGeometry') {
	                var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;
	                var r = linkWidth / 2;
	                var geometry = new three.CylinderBufferGeometry(r, r, 1, state.linkResolution, 1, false);
	                geometry[applyMatrix4Fn](new three.Matrix4().makeTranslation(0, 1 / 2, 0));
	                geometry[applyMatrix4Fn](new three.Matrix4().makeRotationX(Math.PI / 2));
	                line.geometry.dispose();
	                line.geometry = geometry;
	              }

	              var vStart = new three.Vector3(start.x, start.y || 0, start.z || 0);
	              var vEnd = new three.Vector3(end.x, end.y || 0, end.z || 0);
	              var distance = vStart.distanceTo(vEnd);
	              line.position.x = vStart.x;
	              line.position.y = vStart.y;
	              line.position.z = vStart.z;
	              line.scale.z = distance;
	              line.parent.localToWorld(vEnd); // lookAt requires world coords

	              line.lookAt(vEnd);
	            } else {
	              // curved tube
	              if (line.geometry.type !== 'TubeBufferGeometry') {
	                // reset object positioning
	                line.position.set(0, 0, 0);
	                line.rotation.set(0, 0, 0);
	                line.scale.set(1, 1, 1);
	              }

	              var _linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;

	              var _r = _linkWidth / 2;

	              var _geometry = new three.TubeBufferGeometry(curve, curveResolution, _r, state.linkResolution, false);

	              line.geometry.dispose();
	              line.geometry = _geometry;
	            }
	          }
	        }); //

	        function calcLinkCurve(link) {
	          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
	          var start = pos[isD3Sim ? 'source' : 'from'];
	          var end = pos[isD3Sim ? 'target' : 'to'];
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var curvature = linkCurvatureAccessor(link);

	          if (!curvature) {
	            link.__curve = null; // Straight line
	          } else {
	            // bezier curve line (only for line types)
	            var vStart = new three.Vector3(start.x, start.y || 0, start.z || 0);
	            var vEnd = new three.Vector3(end.x, end.y || 0, end.z || 0);
	            var l = vStart.distanceTo(vEnd); // line length

	            var curve;
	            var curveRotation = linkCurveRotationAccessor(link);

	            if (l > 0) {
	              var dx = end.x - start.x;
	              var dy = end.y - start.y || 0;
	              var vLine = new three.Vector3().subVectors(vEnd, vStart);
	              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three.Vector3(0, 0, 1) : new three.Vector3(0, 1, 0)) // avoid cross-product of parallel vectors (prefer Z, fallback to Y)
	              .applyAxisAngle(vLine.normalize(), curveRotation) // rotate along line axis according to linkCurveRotation
	              .add(new three.Vector3().addVectors(vStart, vEnd).divideScalar(2));
	              curve = new three.QuadraticBezierCurve3(vStart, cp, vEnd);
	            } else {
	              // Same point, draw a loop
	              var d = curvature * 70;
	              var endAngle = -curveRotation; // Rotate clockwise (from Z angle perspective)

	              var startAngle = endAngle + Math.PI / 2;
	              curve = new three.CubicBezierCurve3(vStart, new three.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);
	            }

	            link.__curve = curve;
	          }
	        }
	      }

	      function updateArrows() {
	        // update link arrow position
	        var arrowRelPosAccessor = accessorFn(state.linkDirectionalArrowRelPos);
	        var arrowLengthAccessor = accessorFn(state.linkDirectionalArrowLength);
	        var nodeValAccessor = accessorFn(state.nodeVal);
	        state.graphData.links.forEach(function (link) {
	          var arrowObj = link.__arrowObj;
	          if (!arrowObj) return;
	          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
	          var start = pos[isD3Sim ? 'source' : 'from'];
	          var end = pos[isD3Sim ? 'target' : 'to'];
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var startR = Math.sqrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;
	          var endR = Math.sqrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;
	          var arrowLength = arrowLengthAccessor(link);
	          var arrowRelPos = arrowRelPosAccessor(link);
	          var getPosAlongLine = link.__curve ? function (t) {
	            return link.__curve.getPoint(t);
	          } // interpolate along bezier curve
	          : function (t) {
	            // straight line: interpolate linearly
	            var iplt = function iplt(dim, start, end, t) {
	              return start[dim] + (end[dim] - start[dim]) * t || 0;
	            };

	            return {
	              x: iplt('x', start, end, t),
	              y: iplt('y', start, end, t),
	              z: iplt('z', start, end, t)
	            };
	          };
	          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(['x', 'y', 'z'].map(function (dim) {
	            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);
	          }).reduce(function (acc, v) {
	            return acc + v;
	          }, 0));
	          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
	          var arrowHead = getPosAlongLine(posAlongLine / lineLen);
	          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);
	          ['x', 'y', 'z'].forEach(function (dim) {
	            return arrowObj.position[dim] = arrowTail[dim];
	          });

	          var headVec = _construct(three.Vector3, _toConsumableArray(['x', 'y', 'z'].map(function (c) {
	            return arrowHead[c];
	          })));

	          arrowObj.parent.localToWorld(headVec); // lookAt requires world coords

	          arrowObj.lookAt(headVec);
	        });
	      }

	      function updatePhotons() {
	        // update link particle positions
	        var particleSpeedAccessor = accessorFn(state.linkDirectionalParticleSpeed);
	        state.graphData.links.forEach(function (link) {
	          var cyclePhotons = link.__photonsObj && link.__photonsObj.children;
	          var singleHopPhotons = link.__singleHopPhotonsObj && link.__singleHopPhotonsObj.children;
	          if ((!singleHopPhotons || !singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) return;
	          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
	          var start = pos[isD3Sim ? 'source' : 'from'];
	          var end = pos[isD3Sim ? 'target' : 'to'];
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var particleSpeed = particleSpeedAccessor(link);
	          var getPhotonPos = link.__curve ? function (t) {
	            return link.__curve.getPoint(t);
	          } // interpolate along bezier curve
	          : function (t) {
	            // straight line: interpolate linearly
	            var iplt = function iplt(dim, start, end, t) {
	              return start[dim] + (end[dim] - start[dim]) * t || 0;
	            };

	            return {
	              x: iplt('x', start, end, t),
	              y: iplt('y', start, end, t),
	              z: iplt('z', start, end, t)
	            };
	          };
	          var photons = [].concat(_toConsumableArray(cyclePhotons || []), _toConsumableArray(singleHopPhotons || []));
	          photons.forEach(function (photon, idx) {
	            var singleHop = photon.parent.__linkThreeObjType === 'singleHopPhotons';

	            if (!photon.hasOwnProperty('__progressRatio')) {
	              photon.__progressRatio = singleHop ? 0 : idx / cyclePhotons.length;
	            }

	            photon.__progressRatio += particleSpeed;

	            if (photon.__progressRatio >= 1) {
	              if (!singleHop) {
	                photon.__progressRatio = photon.__progressRatio % 1;
	              } else {
	                // remove particle
	                photon.parent.remove(photon);
	                emptyObject(photon);
	                return;
	              }
	            }

	            var photonPosRatio = photon.__progressRatio;
	            var pos = getPhotonPos(photonPosRatio);
	            ['x', 'y', 'z'].forEach(function (dim) {
	              return photon.position[dim] = pos[dim];
	            });
	          });
	        });
	      }
	    },
	    emitParticle: function emitParticle(state, link) {
	      if (link) {
	        if (!link.__singleHopPhotonsObj) {
	          var obj = new three.Group();
	          obj.__linkThreeObjType = 'singleHopPhotons';
	          link.__singleHopPhotonsObj = obj;
	          state.graphScene.add(obj);
	        }

	        var particleWidthAccessor = accessorFn(state.linkDirectionalParticleWidth);
	        var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
	        var numSegments = state.linkDirectionalParticleResolution;
	        var particleGeometry = new three.SphereBufferGeometry(photonR, numSegments, numSegments);
	        var linkColorAccessor = accessorFn(state.linkColor);
	        var particleColorAccessor = accessorFn(state.linkDirectionalParticleColor);
	        var photonColor = particleColorAccessor(link) || linkColorAccessor(link) || '#f0f0f0';
	        var materialColor = new three.Color(colorStr2Hex(photonColor));
	        var opacity = state.linkOpacity * 3;
	        var particleMaterial = new three.MeshLambertMaterial({
	          color: materialColor,
	          transparent: true,
	          opacity: opacity
	        }); // add a single hop particle

	        link.__singleHopPhotonsObj.add(new three.Mesh(particleGeometry, particleMaterial));
	      }

	      return this;
	    }
	  },
	  stateInit: function stateInit() {
	    return {
	      d3ForceLayout: d3Force3d.forceSimulation().force('link', d3Force3d.forceLink()).force('charge', d3Force3d.forceManyBody()).force('center', d3Force3d.forceCenter()).force('dagRadial', null).stop(),
	      engineRunning: false
	    };
	  },
	  init: function init(threeObj, state) {
	    // Main three object to manipulate
	    state.graphScene = threeObj;
	  },
	  update: function update(state, changedProps) {
	    var hasAnyPropChanged = function hasAnyPropChanged(propList) {
	      return propList.some(function (p) {
	        return changedProps.hasOwnProperty(p);
	      });
	    };

	    state.engineRunning = false; // pause simulation

	    state.onUpdate();

	    if (state.nodeAutoColorBy !== null && hasAnyPropChanged(['nodeAutoColorBy', 'graphData', 'nodeColor'])) {
	      // Auto add color to uncolored nodes
	      autoColorObjects(state.graphData.nodes, accessorFn(state.nodeAutoColorBy), state.nodeColor);
	    }

	    if (state.linkAutoColorBy !== null && hasAnyPropChanged(['linkAutoColorBy', 'graphData', 'linkColor'])) {
	      // Auto add color to uncolored links
	      autoColorObjects(state.graphData.links, accessorFn(state.linkAutoColorBy), state.linkColor);
	    } // Digest nodes WebGL objects


	    if (state._flushObjects || hasAnyPropChanged(['graphData', 'nodeThreeObject', 'nodeThreeObjectExtend', 'nodeVal', 'nodeColor', 'nodeVisibility', 'nodeRelSize', 'nodeResolution', 'nodeOpacity'])) {
	      var customObjectAccessor = accessorFn(state.nodeThreeObject);
	      var customObjectExtendAccessor = accessorFn(state.nodeThreeObjectExtend);
	      var valAccessor = accessorFn(state.nodeVal);
	      var colorAccessor = accessorFn(state.nodeColor);
	      var visibilityAccessor = accessorFn(state.nodeVisibility);
	      var sphereGeometries = {}; // indexed by node value

	      var sphereMaterials = {}; // indexed by color

	      var bypassUpdObjs = new Set(); // keep track of custom objects to bypass update

	      threeDigest(state.graphData.nodes.filter(visibilityAccessor), state.graphScene, {
	        purge: state._flushObjects || hasAnyPropChanged([// recreate objects if any of these props have changed
	        'nodeThreeObject', 'nodeThreeObjectExtend']),
	        objFilter: function objFilter(obj) {
	          return obj.__graphObjType === 'node';
	        },
	        createObj: function createObj(node) {
	          var customObj = customObjectAccessor(node);
	          var extendObj = customObjectExtendAccessor(node);

	          if (customObj && state.nodeThreeObject === customObj) {
	            // clone object if it's a shared object among all nodes
	            customObj = customObj.clone();
	          }

	          var obj;

	          if (customObj && !extendObj) {
	            obj = customObj;
	            bypassUpdObjs.add(obj);
	          } else {
	            // Add default object (sphere mesh)
	            obj = new three.Mesh();

	            if (customObj && extendObj) {
	              obj.add(customObj); // extend default with custom
	            }
	          }

	          obj.__graphObjType = 'node'; // Add object type

	          return obj;
	        },
	        updateObj: function updateObj(obj, node) {
	          if (!bypassUpdObjs.has(obj)) {
	            var val = valAccessor(node) || 1;
	            var radius = Math.cbrt(val) * state.nodeRelSize;
	            var numSegments = state.nodeResolution;

	            if (obj.geometry.type !== 'SphereBufferGeometry' || obj.geometry.parameters.radius !== radius || obj.geometry.parameters.widthSegments !== numSegments) {
	              if (!sphereGeometries.hasOwnProperty(val)) {
	                sphereGeometries[val] = new three.SphereBufferGeometry(radius, numSegments, numSegments);
	              }

	              obj.geometry.dispose();
	              obj.geometry = sphereGeometries[val];
	            }

	            var color = colorAccessor(node);
	            var materialColor = new three.Color(colorStr2Hex(color || '#ffffaa'));
	            var opacity = state.nodeOpacity * colorAlpha(color);

	            if (obj.material.type !== 'MeshLambertMaterial' || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {
	              if (!sphereMaterials.hasOwnProperty(color)) {
	                sphereMaterials[color] = new three.MeshLambertMaterial({
	                  color: materialColor,
	                  transparent: true,
	                  opacity: opacity
	                });
	              }

	              obj.material.dispose();
	              obj.material = sphereMaterials[color];
	            }
	          }
	        }
	      });
	    } // Digest links WebGL objects


	    if (state._flushObjects || hasAnyPropChanged(['graphData', 'linkThreeObject', 'linkThreeObjectExtend', 'linkMaterial', 'linkColor', 'linkWidth', 'linkVisibility', 'linkResolution', 'linkOpacity', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution'])) {
	      var _customObjectAccessor = accessorFn(state.linkThreeObject);

	      var _customObjectExtendAccessor = accessorFn(state.linkThreeObjectExtend);

	      var customMaterialAccessor = accessorFn(state.linkMaterial);

	      var _visibilityAccessor = accessorFn(state.linkVisibility);

	      var _colorAccessor = accessorFn(state.linkColor);

	      var widthAccessor = accessorFn(state.linkWidth);
	      var lineMaterials = {}; // indexed by link color

	      var cylinderGeometries = {}; // indexed by link width

	      var visibleLinks = state.graphData.links.filter(_visibilityAccessor);

	      var _bypassUpdObjs = new Set(); // keep track of custom objects to bypass update
	      // lines digest cycle


	      threeDigest(visibleLinks, state.graphScene, {
	        objBindAttr: '__lineObj',
	        purge: state._flushObjects || hasAnyPropChanged([// recreate objects if any of these props have changed
	        'linkThreeObject', 'linkThreeObjectExtend', 'linkWidth']),
	        objFilter: function objFilter(obj) {
	          return obj.__graphObjType === 'link';
	        },
	        createObj: function createObj(link) {
	          var customObj = _customObjectAccessor(link);

	          var extendObj = _customObjectExtendAccessor(link);

	          if (customObj && state.linkThreeObject === customObj) {
	            // clone object if it's a shared object among all links
	            customObj = customObj.clone();
	          }

	          var defaultObj;

	          if (!customObj || extendObj) {
	            // construct default line obj
	            var useCylinder = !!widthAccessor(link);

	            if (useCylinder) {
	              defaultObj = new three.Mesh();
	            } else {
	              // Use plain line (constant width)
	              var lineGeometry = new three.BufferGeometry();
	              lineGeometry[setAttributeFn]('position', new three.BufferAttribute(new Float32Array(2 * 3), 3));
	              defaultObj = new three.Line(lineGeometry);
	            }
	          }

	          var obj;

	          if (!customObj) {
	            obj = defaultObj;
	          } else {
	            if (!extendObj) {
	              // use custom object
	              obj = customObj;

	              _bypassUpdObjs.add(obj);
	            } else {
	              // extend default with custom in a group
	              obj = new three.Group();
	              obj.add(defaultObj);
	              obj.add(customObj);
	            }
	          }

	          obj.renderOrder = 10; // Prevent visual glitches of dark lines on top of nodes by rendering them last

	          obj.__graphObjType = 'link'; // Add object type

	          return obj;
	        },
	        updateObj: function updateObj(updObj, link) {
	          if (!_bypassUpdObjs.has(updObj)) {
	            // select default object if it's an extended group
	            var obj = updObj.children.length ? updObj.children[0] : updObj;
	            var linkWidth = Math.ceil(widthAccessor(link) * 10) / 10;
	            var useCylinder = !!linkWidth;

	            if (useCylinder) {
	              var r = linkWidth / 2;
	              var numSegments = state.linkResolution;

	              if (obj.geometry.type !== 'CylinderBufferGeometry' || obj.geometry.parameters.radiusTop !== r || obj.geometry.parameters.radialSegments !== numSegments) {
	                if (!cylinderGeometries.hasOwnProperty(linkWidth)) {
	                  var geometry = new three.CylinderBufferGeometry(r, r, 1, numSegments, 1, false);
	                  geometry[applyMatrix4Fn](new three.Matrix4().makeTranslation(0, 1 / 2, 0));
	                  geometry[applyMatrix4Fn](new three.Matrix4().makeRotationX(Math.PI / 2));
	                  cylinderGeometries[linkWidth] = geometry;
	                }

	                obj.geometry.dispose();
	                obj.geometry = cylinderGeometries[linkWidth];
	              }
	            }

	            var customMaterial = customMaterialAccessor(link);

	            if (customMaterial) {
	              obj.material = customMaterial;
	            } else {
	              var color = _colorAccessor(link);

	              var materialColor = new three.Color(colorStr2Hex(color || '#f0f0f0'));
	              var opacity = state.linkOpacity * colorAlpha(color);

	              if (obj.material.type !== 'MeshLambertMaterial' || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {
	                if (!lineMaterials.hasOwnProperty(color)) {
	                  lineMaterials[color] = new three.MeshLambertMaterial({
	                    color: materialColor,
	                    transparent: opacity < 1,
	                    opacity: opacity,
	                    depthWrite: opacity >= 1 // Prevent transparency issues

	                  });
	                }

	                obj.material.dispose();
	                obj.material = lineMaterials[color];
	              }
	            }
	          }
	        }
	      }); // Arrows digest cycle

	      if (state.linkDirectionalArrowLength || changedProps.hasOwnProperty('linkDirectionalArrowLength')) {
	        var arrowLengthAccessor = accessorFn(state.linkDirectionalArrowLength);
	        var arrowColorAccessor = accessorFn(state.linkDirectionalArrowColor);
	        threeDigest(visibleLinks.filter(arrowLengthAccessor), state.graphScene, {
	          objBindAttr: '__arrowObj',
	          objFilter: function objFilter(obj) {
	            return obj.__linkThreeObjType === 'arrow';
	          },
	          createObj: function createObj() {
	            var obj = new three.Mesh(undefined, new three.MeshLambertMaterial({
	              transparent: true
	            }));
	            obj.__linkThreeObjType = 'arrow'; // Add object type

	            return obj;
	          },
	          updateObj: function updateObj(obj, link) {
	            var arrowLength = arrowLengthAccessor(link);
	            var numSegments = state.linkDirectionalArrowResolution;

	            if (obj.geometry.type !== 'ConeBufferGeometry' || obj.geometry.parameters.height !== arrowLength || obj.geometry.parameters.radialSegments !== numSegments) {
	              var coneGeometry = new three.ConeBufferGeometry(arrowLength * 0.25, arrowLength, numSegments); // Correct orientation

	              coneGeometry.translate(0, arrowLength / 2, 0);
	              coneGeometry.rotateX(Math.PI / 2);
	              obj.geometry.dispose();
	              obj.geometry = coneGeometry;
	            }

	            obj.material.color = new three.Color(arrowColorAccessor(link) || _colorAccessor(link) || '#f0f0f0');
	            obj.material.opacity = state.linkOpacity * 3;
	          }
	        });
	      } // Photon particles digest cycle


	      if (state.linkDirectionalParticles || changedProps.hasOwnProperty('linkDirectionalParticles')) {
	        var particlesAccessor = accessorFn(state.linkDirectionalParticles);
	        var particleWidthAccessor = accessorFn(state.linkDirectionalParticleWidth);
	        var particleColorAccessor = accessorFn(state.linkDirectionalParticleColor);
	        var particleMaterials = {}; // indexed by link color

	        var particleGeometries = {}; // indexed by particle width

	        threeDigest(visibleLinks.filter(particlesAccessor), state.graphScene, {
	          objBindAttr: '__photonsObj',
	          objFilter: function objFilter(obj) {
	            return obj.__linkThreeObjType === 'photons';
	          },
	          createObj: function createObj() {
	            var obj = new three.Group();
	            obj.__linkThreeObjType = 'photons'; // Add object type

	            return obj;
	          },
	          updateObj: function updateObj(obj, link) {
	            var numPhotons = Math.round(Math.abs(particlesAccessor(link)));
	            var curPhoton = !!obj.children.length && obj.children[0];
	            var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;
	            var numSegments = state.linkDirectionalParticleResolution;
	            var particleGeometry;

	            if (curPhoton && curPhoton.geometry.parameters.radius === photonR && curPhoton.geometry.parameters.widthSegments === numSegments) {
	              particleGeometry = curPhoton.geometry;
	            } else {
	              if (!particleGeometries.hasOwnProperty(photonR)) {
	                particleGeometries[photonR] = new three.SphereBufferGeometry(photonR, numSegments, numSegments);
	              }

	              particleGeometry = particleGeometries[photonR];
	              curPhoton && curPhoton.geometry.dispose();
	            }

	            var photonColor = particleColorAccessor(link) || _colorAccessor(link) || '#f0f0f0';
	            var materialColor = new three.Color(colorStr2Hex(photonColor));
	            var opacity = state.linkOpacity * 3;
	            var particleMaterial;

	            if (curPhoton && curPhoton.material.color.equals(materialColor) && curPhoton.material.opacity === opacity) {
	              particleMaterial = curPhoton.material;
	            } else {
	              if (!particleMaterials.hasOwnProperty(photonColor)) {
	                particleMaterials[photonColor] = new three.MeshLambertMaterial({
	                  color: materialColor,
	                  transparent: true,
	                  opacity: opacity
	                });
	              }

	              particleMaterial = particleMaterials[photonColor];
	              curPhoton && curPhoton.material.dispose();
	            } // digest cycle for each photon


	            threeDigest(_toConsumableArray(new Array(numPhotons)).map(function (_, idx) {
	              return {
	                idx: idx
	              };
	            }), obj, {
	              idAccessor: function idAccessor(d) {
	                return d.idx;
	              },
	              createObj: function createObj() {
	                return new three.Mesh(particleGeometry, particleMaterial);
	              },
	              updateObj: function updateObj(obj) {
	                obj.geometry = particleGeometry;
	                obj.material = particleMaterial;
	              }
	            });
	          }
	        });
	      }
	    }

	    state._flushObjects = false; // reset objects refresh flag
	    // simulation engine

	    if (hasAnyPropChanged(['graphData', 'nodeId', 'linkSource', 'linkTarget', 'numDimensions', 'forceEngine', 'dagMode', 'dagLevelDistance'])) {
	      state.engineRunning = false; // Pause simulation
	      // parse links

	      state.graphData.links.forEach(function (link) {
	        link.source = link[state.linkSource];
	        link.target = link[state.linkTarget];
	      }); // Feed data to force-directed layout

	      var isD3Sim = state.forceEngine !== 'ngraph';
	      var layout;

	      if (isD3Sim) {
	        // D3-force
	        (layout = state.d3ForceLayout).stop().alpha(1) // re-heat the simulation
	        .numDimensions(state.numDimensions).nodes(state.graphData.nodes); // add links (if link force is still active)

	        var linkForce = state.d3ForceLayout.force('link');

	        if (linkForce) {
	          linkForce.id(function (d) {
	            return d[state.nodeId];
	          }).links(state.graphData.links);
	        } // setup dag force constraints


	        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {
	          return node[state.nodeId];
	        });
	        var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
	        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1); // Fix nodes to x,y,z for dag mode

	        if (state.dagMode) {
	          var getFFn = function getFFn(fix, invert) {
	            return function (node) {
	              return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
	            };
	          };

	          var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');
	          var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'td');
	          var fzFn = getFFn(['zin', 'zout'].indexOf(state.dagMode) !== -1, state.dagMode === 'zout');
	          state.graphData.nodes.forEach(function (node) {
	            node.fx = fxFn(node);
	            node.fy = fyFn(node);
	            node.fz = fzFn(node);
	          });
	        } // Use radial force for radial dags


	        state.d3ForceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? d3Force3d.forceRadial(function (node) {
	          var nodeDepth = nodeDepths[node[state.nodeId]];
	          return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
	        }).strength(1) : null);
	      } else {
	        // ngraph
	        var _graph = ngraph.graph();

	        state.graphData.nodes.forEach(function (node) {
	          _graph.addNode(node[state.nodeId]);
	        });
	        state.graphData.links.forEach(function (link) {
	          _graph.addLink(link.source, link.target);
	        });
	        layout = ngraph['forcelayout' + (state.numDimensions === 2 ? '' : '3d')](_graph);
	        layout.graph = _graph; // Attach graph reference to layout
	      }

	      for (var i = 0; i < state.warmupTicks; i++) {
	        layout[isD3Sim ? 'tick' : 'step']();
	      } // Initial ticks before starting to render


	      state.layout = layout;
	      this.resetCountdown();
	    }

	    state.engineRunning = true; // resume simulation

	    state.onFinishUpdate();
	  }
	});

	function fromKapsule (kapsule) {
	  var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;
	  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var FromKapsule = /*#__PURE__*/function (_baseClass) {
	    _inherits(FromKapsule, _baseClass);

	    var _super = _createSuper(FromKapsule);

	    function FromKapsule() {
	      var _this;

	      _classCallCheck(this, FromKapsule);

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      _this = _super.call.apply(_super, [this].concat(args));
	      _this.__kapsuleInstance = kapsule().apply(void 0, [].concat(_toConsumableArray(initKapsuleWithSelf ? [_assertThisInitialized(_this)] : []), args));
	      return _this;
	    }

	    return FromKapsule;
	  }(baseClass); // attach kapsule props/methods to class prototype


	  Object.keys(kapsule()).forEach(function (m) {
	    return FromKapsule.prototype[m] = function () {
	      var _this$__kapsuleInstan;

	      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);

	      return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj
	      : returnVal;
	    };
	  });
	  return FromKapsule;
	}

	var three$1 = window.THREE ? window.THREE : {
	  Group: three$2.Group
	}; // Prefer consumption from global THREE, if exists
	var threeForcegraph = fromKapsule(ForceGraph, three$1.Group, true);

	module.exports = threeForcegraph;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/vasturiano/d3-force-3d v2.1.0 Copyright 2020 Vasco Asturiano
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(45), __webpack_require__(26), __webpack_require__(46), __webpack_require__(9), __webpack_require__(15)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-binarytree', 'd3-quadtree', 'd3-octree', 'd3-dispatch', 'd3-timer'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, (function (exports, d3Binarytree, d3Quadtree, d3Octree, d3Dispatch, d3Timer) { 'use strict';

	function center(x, y, z) {
	  var nodes;

	  if (x == null) x = 0;
	  if (y == null) y = 0;
	  if (z == null) z = 0;

	  function force() {
	    var i,
	        n = nodes.length,
	        node,
	        sx = 0,
	        sy = 0,
	        sz = 0;

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
	    }

	    for (sx = sx / n - x, sy = sy / n - y, sz = sz / n - z, i = 0; i < n; ++i) {
	      node = nodes[i];
	      if (sx) { node.x -= sx; }
	      if (sy) { node.y -= sy; }
	      if (sz) { node.z -= sz; }
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  force.z = function(_) {
	    return arguments.length ? (z = +_, force) : z;
	  };

	  return force;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function jiggle() {
	  return (Math.random() - 0.5) * 1e-6;
	}

	function x(d) {
	  return d.x + d.vx;
	}

	function y(d) {
	  return d.y + d.vy;
	}

	function z(d) {
	  return d.z + d.vz;
	}

	function collide(radius) {
	  var nodes,
	      nDim,
	      radii,
	      strength = 1,
	      iterations = 1;

	  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

	  function force() {
	    var i, n = nodes.length,
	        tree,
	        node,
	        xi,
	        yi,
	        zi,
	        ri,
	        ri2;

	    for (var k = 0; k < iterations; ++k) {
	      tree =
	          (nDim === 1 ? d3Binarytree.binarytree(nodes, x)
	          :(nDim === 2 ? d3Quadtree.quadtree(nodes, x, y)
	          :(nDim === 3 ? d3Octree.octree(nodes, x, y, z)
	          :null
	      ))).visitAfter(prepare);

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        ri = radii[node.index], ri2 = ri * ri;
	        xi = node.x + node.vx;
	        if (nDim > 1) { yi = node.y + node.vy; }
	        if (nDim > 2) { zi = node.z + node.vz; }
	        tree.visit(apply);
	      }
	    }

	    function apply(treeNode, arg1, arg2, arg3, arg4, arg5, arg6) {
	      var args = [arg1, arg2, arg3, arg4, arg5, arg6];
	      var x0 = args[0],
	          y0 = args[1],
	          z0 = args[2],
	          x1 = args[nDim],
	          y1 = args[nDim+1],
	          z1 = args[nDim+2];

	      var data = treeNode.data, rj = treeNode.r, r = ri + rj;
	      if (data) {
	        if (data.index > node.index) {
	          var x = xi - data.x - data.vx,
	              y = (nDim > 1 ? yi - data.y - data.vy : 0),
	              z = (nDim > 2 ? zi - data.z - data.vz : 0),
	              l = x * x + y * y + z * z;
	          if (l < r * r) {
	            if (x === 0) x = jiggle(), l += x * x;
	            if (nDim > 1 && y === 0) y = jiggle(), l += y * y;
	            if (nDim > 2 && z === 0) z = jiggle(), l += z * z;
	            l = (r - (l = Math.sqrt(l))) / l * strength;

	            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
	            if (nDim > 1) { node.vy += (y *= l) * r; }
	            if (nDim > 2) { node.vz += (z *= l) * r; }

	            data.vx -= x * (r = 1 - r);
	            if (nDim > 1) { data.vy -= y * r; }
	            if (nDim > 2) { data.vz -= z * r; }
	          }
	        }
	        return;
	      }
	      return x0 > xi + r || x1 < xi - r
	          || (nDim > 1 && (y0 > yi + r || y1 < yi - r))
	          || (nDim > 2 && (z0 > zi + r || z1 < zi - r));
	    }
	  }

	  function prepare(treeNode) {
	    if (treeNode.data) return treeNode.r = radii[treeNode.data.index];
	    for (var i = treeNode.r = 0; i < Math.pow(2, nDim); ++i) {
	      if (treeNode[i] && treeNode[i].r > treeNode.r) {
	        treeNode.r = treeNode[i].r;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    radii = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
	  }

	  force.initialize = function(initNodes, numDimensions) {
	    nodes = initNodes;
	    nDim = numDimensions;
	    initialize();
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = +_, force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  return force;
	}

	function index(d) {
	  return d.index;
	}

	function find(nodeById, nodeId) {
	  var node = nodeById.get(nodeId);
	  if (!node) throw new Error("node not found: " + nodeId);
	  return node;
	}

	function link(links) {
	  var id = index,
	      strength = defaultStrength,
	      strengths,
	      distance = constant(30),
	      distances,
	      nodes,
	      nDim,
	      count,
	      bias,
	      iterations = 1;

	  if (links == null) links = [];

	  function defaultStrength(link) {
	    return 1 / Math.min(count[link.source.index], count[link.target.index]);
	  }

	  function force(alpha) {
	    for (var k = 0, n = links.length; k < iterations; ++k) {
	      for (var i = 0, link, source, target, x = 0, y = 0, z = 0, l, b; i < n; ++i) {
	        link = links[i], source = link.source, target = link.target;
	        x = target.x + target.vx - source.x - source.vx || jiggle();
	        if (nDim > 1) { y = target.y + target.vy - source.y - source.vy || jiggle(); }
	        if (nDim > 2) { z = target.z + target.vz - source.z - source.vz || jiggle(); }
	        l = Math.sqrt(x * x + y * y + z * z);
	        l = (l - distances[i]) / l * alpha * strengths[i];
	        x *= l, y *= l, z *= l;

	        target.vx -= x * (b = bias[i]);
	        if (nDim > 1) { target.vy -= y * b; }
	        if (nDim > 2) { target.vz -= z * b; }

	        source.vx += x * (b = 1 - b);
	        if (nDim > 1) { source.vy += y * b; }
	        if (nDim > 2) { source.vz += z * b; }
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;

	    var i,
	        n = nodes.length,
	        m = links.length,
	        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
	        link;

	    for (i = 0, count = new Array(n); i < m; ++i) {
	      link = links[i], link.index = i;
	      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
	      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
	      count[link.source.index] = (count[link.source.index] || 0) + 1;
	      count[link.target.index] = (count[link.target.index] || 0) + 1;
	    }

	    for (i = 0, bias = new Array(m); i < m; ++i) {
	      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
	    }

	    strengths = new Array(m), initializeStrength();
	    distances = new Array(m), initializeDistance();
	  }

	  function initializeStrength() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      strengths[i] = +strength(links[i], i, links);
	    }
	  }

	  function initializeDistance() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      distances[i] = +distance(links[i], i, links);
	    }
	  }

	  force.initialize = function(initNodes, numDimensions) {
	    nodes = initNodes;
	    nDim = numDimensions;
	    initialize();
	  };

	  force.links = function(_) {
	    return arguments.length ? (links = _, initialize(), force) : links;
	  };

	  force.id = function(_) {
	    return arguments.length ? (id = _, force) : id;
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
	  };

	  force.distance = function(_) {
	    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
	  };

	  return force;
	}

	var MAX_DIMENSIONS = 3;

	function x$1(d) {
	  return d.x;
	}

	function y$1(d) {
	  return d.y;
	}

	function z$1(d) {
	  return d.z;
	}

	var initialRadius = 10,
	    initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), // Golden ratio angle
	    initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221)); // Markov irrational number

	function simulation(nodes, numDimensions) {
	  numDimensions = numDimensions || 2;

	  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))),
	      simulation,
	      alpha = 1,
	      alphaMin = 0.001,
	      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
	      alphaTarget = 0,
	      velocityDecay = 0.6,
	      forces = new Map(),
	      stepper = d3Timer.timer(step),
	      event = d3Dispatch.dispatch("tick", "end");

	  if (nodes == null) nodes = [];

	  function step() {
	    tick();
	    event.call("tick", simulation);
	    if (alpha < alphaMin) {
	      stepper.stop();
	      event.call("end", simulation);
	    }
	  }

	  function tick(iterations) {
	    var i, n = nodes.length, node;

	    if (iterations === undefined) iterations = 1;

	    for (var k = 0; k < iterations; ++k) {
	      alpha += (alphaTarget - alpha) * alphaDecay;

	      forces.forEach(function (force) {
	        force(alpha);
	      });

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        if (node.fx == null) node.x += node.vx *= velocityDecay;
	        else node.x = node.fx, node.vx = 0;
	        if (nDim > 1) {
	          if (node.fy == null) node.y += node.vy *= velocityDecay;
	          else node.y = node.fy, node.vy = 0;
	        }
	        if (nDim > 2) {
	          if (node.fz == null) node.z += node.vz *= velocityDecay;
	          else node.z = node.fz, node.vz = 0;
	        }
	      }
	    }

	    return simulation;
	  }

	  function initializeNodes() {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.index = i;
	      if (node.fx != null) node.x = node.fx;
	      if (node.fy != null) node.y = node.fy;
	      if (node.fz != null) node.z = node.fz;
	      if (isNaN(node.x) || (nDim > 1 && isNaN(node.y)) || (nDim > 2 && isNaN(node.z))) {
	        var radius = initialRadius * (nDim > 2 ? Math.cbrt(i) : (nDim > 1 ? Math.sqrt(i) : i)),
	          rollAngle = i * initialAngleRoll,
	          yawAngle = i * initialAngleYaw;

	        if (nDim === 1) {
	          node.x = radius;
	        } else if (nDim === 2) {
	          node.x = radius * Math.cos(rollAngle);
	          node.y = radius * Math.sin(rollAngle);
	        } else { // 3 dimensions: use spherical distribution along 2 irrational number angles
	          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
	          node.y = radius * Math.cos(rollAngle);
	          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
	        }
	      }
	      if (isNaN(node.vx) || (nDim > 1 && isNaN(node.vy)) || (nDim > 2 && isNaN(node.vz))) {
	        node.vx = 0;
	        if (nDim > 1) { node.vy = 0; }
	        if (nDim > 2) { node.vz = 0; }
	      }
	    }
	  }

	  function initializeForce(force) {
	    if (force.initialize) force.initialize(nodes, nDim);
	    return force;
	  }

	  initializeNodes();

	  return simulation = {
	    tick: tick,

	    restart: function() {
	      return stepper.restart(step), simulation;
	    },

	    stop: function() {
	      return stepper.stop(), simulation;
	    },

	    numDimensions: function(_) {
	      return arguments.length
	          ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation)
	          : nDim;
	    },

	    nodes: function(_) {
	      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
	    },

	    alpha: function(_) {
	      return arguments.length ? (alpha = +_, simulation) : alpha;
	    },

	    alphaMin: function(_) {
	      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
	    },

	    alphaDecay: function(_) {
	      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
	    },

	    alphaTarget: function(_) {
	      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
	    },

	    velocityDecay: function(_) {
	      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
	    },

	    force: function(name, _) {
	      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
	    },

	    find: function() {
	      var args = Array.prototype.slice.call(arguments);
	      var x = args.shift() || 0,
	          y = (nDim > 1 ? args.shift() : null) || 0,
	          z = (nDim > 2 ? args.shift() : null) || 0,
	          radius = args.shift() || Infinity;

	      var i = 0,
	          n = nodes.length,
	          dx,
	          dy,
	          dz,
	          d2,
	          node,
	          closest;

	      radius *= radius;

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        dx = x - node.x;
	        dy = y - (node.y || 0);
	        dz = z - (node.z ||0);
	        d2 = dx * dx + dy * dy + dz * dz;
	        if (d2 < radius) closest = node, radius = d2;
	      }

	      return closest;
	    },

	    on: function(name, _) {
	      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
	    }
	  };
	}

	function manyBody() {
	  var nodes,
	      nDim,
	      node,
	      alpha,
	      strength = constant(-30),
	      strengths,
	      distanceMin2 = 1,
	      distanceMax2 = Infinity,
	      theta2 = 0.81;

	  function force(_) {
	    var i,
	        n = nodes.length,
	        tree =
	            (nDim === 1 ? d3Binarytree.binarytree(nodes, x$1)
	            :(nDim === 2 ? d3Quadtree.quadtree(nodes, x$1, y$1)
	            :(nDim === 3 ? d3Octree.octree(nodes, x$1, y$1, z$1)
	            :null
	        ))).visitAfter(accumulate);

	    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    strengths = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
	  }

	  function accumulate(treeNode) {
	    var strength = 0, q, c, weight = 0, x, y, z, i;
	    var numChildren = treeNode.length;

	    // For internal nodes, accumulate forces from children.
	    if (numChildren) {
	      for (x = y = z = i = 0; i < numChildren; ++i) {
	        if ((q = treeNode[i]) && (c = Math.abs(q.value))) {
	          strength += q.value, weight += c, x += c * (q.x || 0), y += c * (q.y || 0), z += c * (q.z || 0);
	        }
	      }
	      strength *= Math.sqrt(4 / numChildren); // scale accumulated strength according to number of dimensions

	      treeNode.x = x / weight;
	      if (nDim > 1) { treeNode.y = y / weight; }
	      if (nDim > 2) { treeNode.z = z / weight; }
	    }

	    // For leaf nodes, accumulate forces from coincident nodes.
	    else {
	      q = treeNode;
	      q.x = q.data.x;
	      if (nDim > 1) { q.y = q.data.y; }
	      if (nDim > 2) { q.z = q.data.z; }
	      do strength += strengths[q.data.index];
	      while (q = q.next);
	    }

	    treeNode.value = strength;
	  }

	  function apply(treeNode, x1, arg1, arg2, arg3) {
	    if (!treeNode.value) return true;
	    var x2 = [arg1, arg2, arg3][nDim-1];

	    var x = treeNode.x - node.x,
	        y = (nDim > 1 ? treeNode.y - node.y : 0),
	        z = (nDim > 2 ? treeNode.z - node.z : 0),
	        w = x2 - x1,
	        l = x * x + y * y + z * z;

	    // Apply the Barnes-Hut approximation if possible.
	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (w * w / theta2 < l) {
	      if (l < distanceMax2) {
	        if (x === 0) x = jiggle(), l += x * x;
	        if (nDim > 1 && y === 0) y = jiggle(), l += y * y;
	        if (nDim > 2 && z === 0) z = jiggle(), l += z * z;
	        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	        node.vx += x * treeNode.value * alpha / l;
	        if (nDim > 1) { node.vy += y * treeNode.value * alpha / l; }
	        if (nDim > 2) { node.vz += z * treeNode.value * alpha / l; }
	      }
	      return true;
	    }

	    // Otherwise, process points directly.
	    else if (treeNode.length || l >= distanceMax2) return;

	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (treeNode.data !== node || treeNode.next) {
	      if (x === 0) x = jiggle(), l += x * x;
	      if (nDim > 1 && y === 0) y = jiggle(), l += y * y;
	      if (nDim > 2 && z === 0) z = jiggle(), l += z * z;
	      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	    }

	    do if (treeNode.data !== node) {
	      w = strengths[treeNode.data.index] * alpha / l;
	      node.vx += x * w;
	      if (nDim > 1) { node.vy += y * w; }
	      if (nDim > 2) { node.vz += z * w; }
	    } while (treeNode = treeNode.next);
	  }

	  force.initialize = function(initNodes, numDimensions) {
	    nodes = initNodes;
	    nDim = numDimensions;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.distanceMin = function(_) {
	    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
	  };

	  force.distanceMax = function(_) {
	    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
	  };

	  force.theta = function(_) {
	    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
	  };

	  return force;
	}

	function radial(radius, x, y, z) {
	  var nodes,
	      nDim,
	      strength = constant(0.1),
	      strengths,
	      radiuses;

	  if (typeof radius !== "function") radius = constant(+radius);
	  if (x == null) x = 0;
	  if (y == null) y = 0;
	  if (z == null) z = 0;

	  function force(alpha) {
	    for (var i = 0, n = nodes.length; i < n; ++i) {
	      var node = nodes[i],
	          dx = node.x - x || 1e-6,
	          dy = (node.y || 0) - y || 1e-6,
	          dz = (node.z || 0) - z || 1e-6,
	          r = Math.sqrt(dx * dx + dy * dy + dz * dz),
	          k = (radiuses[i] - r) * strengths[i] * alpha / r;
	      node.vx += dx * k;
	      if (nDim>1) { node.vy += dy * k; }
	      if (nDim>2) { node.vz += dz * k; }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    radiuses = new Array(n);
	    for (i = 0; i < n; ++i) {
	      radiuses[i] = +radius(nodes[i], i, nodes);
	      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(initNodes, numDimensions) {
	    nodes = initNodes;
	    nDim = numDimensions;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  force.z = function(_) {
	    return arguments.length ? (z = +_, force) : z;
	  };

	  return force;
	}

	function x$2(x) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      xz;

	  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    xz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
	  };

	  return force;
	}

	function y$2(y) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      yz;

	  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    yz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
	  };

	  return force;
	}

	function z$2(z) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      zz;

	  if (typeof z !== "function") z = constant(z == null ? 0 : +z);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vz += (zz[i] - node.z) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    zz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(zz[i] = +z(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.z = function(_) {
	    return arguments.length ? (z = typeof _ === "function" ? _ : constant(+_), initialize(), force) : z;
	  };

	  return force;
	}

	exports.forceCenter = center;
	exports.forceCollide = collide;
	exports.forceLink = link;
	exports.forceManyBody = manyBody;
	exports.forceRadial = radial;
	exports.forceSimulation = simulation;
	exports.forceX = x$2;
	exports.forceY = y$2;
	exports.forceZ = z$2;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/vasturiano/d3-binarytree v0.1.8 Copyright 2020 Vasco Asturiano
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, (function (exports) { 'use strict';

	function tree_add(d) {
	  var x = +this._x.call(null, d);
	  return add(this.cover(x), x, d);
	}

	function add(tree, x, d) {
	  if (isNaN(x)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      x1 = tree._x1,
	      xm,
	      xp,
	      right,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (parent = node, !(node = node[i = +right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  if (x === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(2) : tree._root = new Array(2);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	  } while ((i = +right) === (j = +(xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var i, n = data.length,
	      x,
	      xz = new Array(n),
	      x0 = Infinity,
	      x1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, data[i]))) continue;
	    xz[i] = x;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	  }

	  // If there were no (valid) points, inherit the existing extent.
	  if (x1 < x0) x0 = this._x0, x1 = this._x1;

	  // Expand the tree to cover the new points.
	  this.cover(x0).cover(x1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], data[i]);
	  }

	  return this;
	}

	function tree_cover(x) {
	  if (isNaN(x = +x)) return this; // ignore invalid points

	  var x0 = this._x0,
	      x1 = this._x1;

	  // If the binarytree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing half boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else if (x0 > x || x > x1) {
	    var z = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    switch (i = +(x < (x0 + x1) / 2)) {
	      case 0: {
	        do parent = new Array(2), parent[i] = node, node = parent;
	        while (z *= 2, x1 = x0 + z, x > x1);
	        break;
	      }
	      case 1: {
	        do parent = new Array(2), parent[i] = node, node = parent;
	        while (z *= 2, x0 = x1 - z, x0 > x);
	        break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  // If the binarytree covers the point already, just return.
	  else return this;

	  this._x0 = x0;
	  this._x1 = x1;
	  return this;
	}

	function tree_data() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	}

	function tree_extent(_) {
	  return arguments.length
	      ? this.cover(+_[0][0]).cover(+_[1][0])
	      : isNaN(this._x0) ? undefined : [[this._x0], [this._x1]];
	}

	function Half(node, x0, x1) {
	  this.node = node;
	  this.x0 = x0;
	  this.x1 = x1;
	}

	function tree_find(x, radius) {
	  var data,
	      x0 = this._x0,
	      x1,
	      x2,
	      x3 = this._x1,
	      halves = [],
	      node = this._root,
	      q,
	      i;

	  if (node) halves.push(new Half(node, x0, x3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius;
	    x3 = x + radius;
	  }

	  while (q = halves.pop()) {

	    // Stop searching if this half can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (x2 = q.x1) < x0) continue;

	    // Bisect the current half.
	    if (node.length) {
	      var xm = (x1 + x2) / 2;

	      halves.push(
	        new Half(node[1], xm, x2),
	        new Half(node[0], x1, xm)
	      );

	      // Visit the closest half first.
	      if (i = +(x >= xm)) {
	        q = halves[halves.length - 1];
	        halves[halves.length - 1] = halves[halves.length - 1 - i];
	        halves[halves.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var d = Math.abs(x - +this._x.call(null, node.data));
	      if (d < radius) {
	        radius = d;
	        x0 = x - d;
	        x3 = x + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	}

	function tree_remove(d) {
	  if (isNaN(x = +this._x.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      x1 = this._x1,
	      x,
	      xm,
	      right,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (!(parent = node, node = node[i = +right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 1]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1])
	      && node === (parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	}

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	function tree_root() {
	  return this._root;
	}

	function tree_size() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	}

	function tree_visit(callback) {
	  var halves = [], q, node = this._root, child, x0, x1;
	  if (node) halves.push(new Half(node, this._x0, this._x1));
	  while (q = halves.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, x1 = q.x1) && node.length) {
	      var xm = (x0 + x1) / 2;
	      if (child = node[1]) halves.push(new Half(child, xm, x1));
	      if (child = node[0]) halves.push(new Half(child, x0, xm));
	    }
	  }
	  return this;
	}

	function tree_visitAfter(callback) {
	  var halves = [], next = [], q;
	  if (this._root) halves.push(new Half(this._root, this._x0, this._x1));
	  while (q = halves.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, x1 = q.x1, xm = (x0 + x1) / 2;
	      if (child = node[0]) halves.push(new Half(child, x0, xm));
	      if (child = node[1]) halves.push(new Half(child, xm, x1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.x1);
	  }
	  return this;
	}

	function defaultX(d) {
	  return d[0];
	}

	function tree_x(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	}

	function binarytree(nodes, x) {
	  var tree = new Binarytree(x == null ? defaultX : x, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Binarytree(x, x0, x1) {
	  this._x = x;
	  this._x0 = x0;
	  this._x1 = x1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = binarytree.prototype = Binarytree.prototype;

	treeProto.copy = function() {
	  var copy = new Binarytree(this._x, this._x0, this._x1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(2)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 2; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(2)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;

	exports.binarytree = binarytree;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/vasturiano/d3-octree v0.1.8 Copyright 2020 Vasco Asturiano
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, (function (exports) { 'use strict';

	function tree_add(d) {
	  var x = +this._x.call(null, d),
	      y = +this._y.call(null, d),
	      z = +this._z.call(null, d);
	  return add(this.cover(x, y, z), x, y, z, d);
	}

	function add(tree, x, y, z, d) {
	  if (isNaN(x) || isNaN(y) || isNaN(z)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      y0 = tree._y0,
	      z0 = tree._z0,
	      x1 = tree._x1,
	      y1 = tree._y1,
	      z1 = tree._z1,
	      xm,
	      ym,
	      zm,
	      xp,
	      yp,
	      zp,
	      right,
	      bottom,
	      deep,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
	    if (parent = node, !(node = node[i = deep << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  yp = +tree._y.call(null, node.data);
	  zp = +tree._z.call(null, node.data);
	  if (x === xp && y === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
	  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | (xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var d, i, n = data.length,
	      x,
	      y,
	      z,
	      xz = new Array(n),
	      yz = new Array(n),
	      zz = new Array(n),
	      x0 = Infinity,
	      y0 = Infinity,
	      z0 = Infinity,
	      x1 = -Infinity,
	      y1 = -Infinity,
	      z1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) continue;
	    xz[i] = x;
	    yz[i] = y;
	    zz[i] = z;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	    if (y < y0) y0 = y;
	    if (y > y1) y1 = y;
	    if (z < z0) z0 = z;
	    if (z > z1) z1 = z;
	  }

	  // If there were no (valid) points, inherit the existing extent.
	  if (x1 < x0) x0 = this._x0, x1 = this._x1;
	  if (y1 < y0) y0 = this._y0, y1 = this._y1;
	  if (z1 < z0) z0 = this._z0, z1 = this._z1;

	  // Expand the tree to cover the new points.
	  this.cover(x0, y0, z0).cover(x1, y1, z1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], yz[i], zz[i], data[i]);
	  }

	  return this;
	}

	function tree_cover(x, y, z) {
	  if (isNaN(x = +x) || isNaN(y = +y) || isNaN(z = +z)) return this; // ignore invalid points

	  var x0 = this._x0,
	      y0 = this._y0,
	      z0 = this._z0,
	      x1 = this._x1,
	      y1 = this._y1,
	      z1 = this._z1;

	  // If the octree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing octant boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	    y1 = (y0 = Math.floor(y)) + 1;
	    z1 = (z0 = Math.floor(z)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else if (x0 > x || x > x1 || y0 > y || y > y1 || z0 > z || z > z1) {
	    var t = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    switch (i = (z < (z0 + z1) / 2) << 2 | (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
	      case 0: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x1 = x0 + t, y1 = y0 + t, z1 = z0 + t, x > x1 || y > y1 || z > z1);
	        break;
	      }
	      case 1: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x0 = x1 - t, y1 = y0 + t, z1 = z0 + t, x0 > x || y > y1 || z > z1);
	        break;
	      }
	      case 2: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x1 = x0 + t, y0 = y1 - t, z1 = z0 + t, x > x1 || y0 > y || z > z1);
	        break;
	      }
	      case 3: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x0 = x1 - t, y0 = y1 - t, z1 = z0 + t, x0 > x || y0 > y || z > z1);
	        break;
	      }
	      case 4: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x1 = x0 + t, y1 = y0 + t, z0 = z1 - t, x > x1 || y > y1 || z0 > z);
	        break;
	      }
	      case 5: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x0 = x1 - t, y1 = y0 + t, z0 = z1 - t, x0 > x || y > y1 || z0 > z);
	        break;
	      }
	      case 6: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x1 = x0 + t, y0 = y1 - t, z0 = z1 - t, x > x1 || y0 > y || z0 > z);
	        break;
	      }
	      case 7: {
	        do parent = new Array(8), parent[i] = node, node = parent;
	        while (t *= 2, x0 = x1 - t, y0 = y1 - t, z0 = z1 - t, x0 > x || y0 > y || z0 > z);
	        break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  // If the octree covers the point already, just return.
	  else return this;

	  this._x0 = x0;
	  this._y0 = y0;
	  this._z0 = z0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._z1 = z1;
	  return this;
	}

	function tree_data() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	}

	function tree_extent(_) {
	  return arguments.length
	      ? this.cover(+_[0][0], +_[0][1], +_[0][2]).cover(+_[1][0], +_[1][1], +_[1][2])
	      : isNaN(this._x0) ? undefined : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
	}

	function Octant(node, x0, y0, z0, x1, y1, z1) {
	  this.node = node;
	  this.x0 = x0;
	  this.y0 = y0;
	  this.z0 = z0;
	  this.x1 = x1;
	  this.y1 = y1;
	  this.z1 = z1;
	}

	function tree_find(x, y, z, radius) {
	  var data,
	      x0 = this._x0,
	      y0 = this._y0,
	      z0 = this._z0,
	      x1,
	      y1,
	      z1,
	      x2,
	      y2,
	      z2,
	      x3 = this._x1,
	      y3 = this._y1,
	      z3 = this._z1,
	      octs = [],
	      node = this._root,
	      q,
	      i;

	  if (node) octs.push(new Octant(node, x0, y0, z0, x3, y3, z3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius, y0 = y - radius, z0 = z - radius;
	    x3 = x + radius, y3 = y + radius, z3 = z + radius;
	    radius *= radius;
	  }

	  while (q = octs.pop()) {

	    // Stop searching if this octant can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (y1 = q.y0) > y3
	        || (z1 = q.z0) > z3
	        || (x2 = q.x1) < x0
	        || (y2 = q.y1) < y0
	        || (z2 = q.z1) < z0) continue;

	    // Bisect the current octant.
	    if (node.length) {
	      var xm = (x1 + x2) / 2,
	          ym = (y1 + y2) / 2,
	          zm = (z1 + z2) / 2;

	      octs.push(
	        new Octant(node[7], xm, ym, zm, x2, y2, z2),
	        new Octant(node[6], x1, ym, zm, xm, y2, z2),
	        new Octant(node[5], xm, y1, zm, x2, ym, z2),
	        new Octant(node[4], x1, y1, zm, xm, ym, z2),
	        new Octant(node[3], xm, ym, z1, x2, y2, zm),
	        new Octant(node[2], x1, ym, z1, xm, y2, zm),
	        new Octant(node[1], xm, y1, z1, x2, ym, zm),
	        new Octant(node[0], x1, y1, z1, xm, ym, zm)
	      );

	      // Visit the closest octant first.
	      if (i = (z >= zm) << 2 | (y >= ym) << 1 | (x >= xm)) {
	        q = octs[octs.length - 1];
	        octs[octs.length - 1] = octs[octs.length - 1 - i];
	        octs[octs.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var dx = x - +this._x.call(null, node.data),
	          dy = y - +this._y.call(null, node.data),
	          dz = z - +this._z.call(null, node.data),
	          d2 = dx * dx + dy * dy + dz * dz;
	      if (d2 < radius) {
	        var d = Math.sqrt(radius = d2);
	        x0 = x - d, y0 = y - d, z0 = z - d;
	        x3 = x + d, y3 = y + d, z3 = z + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	}

	function tree_remove(d) {
	  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      y0 = this._y0,
	      z0 = this._z0,
	      x1 = this._x1,
	      y1 = this._y1,
	      z1 = this._z1,
	      x,
	      y,
	      z,
	      xm,
	      ym,
	      zm,
	      right,
	      bottom,
	      deep,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
	    if (!(parent = node, node = node[i = deep << 2 | bottom << 1 | right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 7] || parent[(i + 2) & 7] || parent[(i + 3) & 7] || parent[(i + 4) & 7] || parent[(i + 5) & 7] || parent[(i + 6) & 7] || parent[(i + 7) & 7]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7])
	      && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	}

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	function tree_root() {
	  return this._root;
	}

	function tree_size() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	}

	function tree_visit(callback) {
	  var octs = [], q, node = this._root, child, x0, y0, z0, x1, y1, z1;
	  if (node) octs.push(new Octant(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
	  while (q = octs.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1) && node.length) {
	      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
	      if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
	      if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
	      if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
	      if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
	      if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
	      if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
	      if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
	      if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
	    }
	  }
	  return this;
	}

	function tree_visitAfter(callback) {
	  var octs = [], next = [], q;
	  if (this._root) octs.push(new Octant(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
	  while (q = octs.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
	      if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
	      if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
	      if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
	      if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
	      if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
	      if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
	      if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
	      if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);
	  }
	  return this;
	}

	function defaultX(d) {
	  return d[0];
	}

	function tree_x(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	}

	function defaultY(d) {
	  return d[1];
	}

	function tree_y(_) {
	  return arguments.length ? (this._y = _, this) : this._y;
	}

	function defaultZ(d) {
	  return d[2];
	}

	function tree_z(_) {
	  return arguments.length ? (this._z = _, this) : this._z;
	}

	function octree(nodes, x, y, z) {
	  var tree = new Octree(x == null ? defaultX : x, y == null ? defaultY : y, z == null ? defaultZ : z, NaN, NaN, NaN, NaN, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Octree(x, y, z, x0, y0, z0, x1, y1, z1) {
	  this._x = x;
	  this._y = y;
	  this._z = z;
	  this._x0 = x0;
	  this._y0 = y0;
	  this._z0 = z0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._z1 = z1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = octree.prototype = Octree.prototype;

	treeProto.copy = function() {
	  var copy = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(8)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 8; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(8)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;
	treeProto.y = tree_y;
	treeProto.z = tree_z;

	exports.octree = octree;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @fileOverview Contains definition of the core graph object.
	 */

	// TODO: need to change storage layer:
	// 1. Be able to get all nodes O(1)
	// 2. Be able to get number of links O(1)

	/**
	 * @example
	 *  var graph = require('ngraph.graph')();
	 *  graph.addNode(1);     // graph has one node.
	 *  graph.addLink(2, 3);  // now graph contains three nodes and one link.
	 *
	 */
	module.exports = createGraph;

	var eventify = __webpack_require__(48);

	/**
	 * Creates a new graph
	 */
	function createGraph(options) {
	  // Graph structure is maintained as dictionary of nodes
	  // and array of links. Each node has 'links' property which
	  // hold all links related to that node. And general links
	  // array is used to speed up all links enumeration. This is inefficient
	  // in terms of memory, but simplifies coding.
	  options = options || {};
	  if ('uniqueLinkId' in options) {
	    console.warn(
	      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\n' +
	      'Use `multigraph` option instead\n',
	      '\n',
	      'Note: there is also change in default behavior: From now on each graph\n'+
	      'is considered to be not a multigraph by default (each edge is unique).'
	    );

	    options.multigraph = options.uniqueLinkId;
	  }

	  // Dear reader, the non-multigraphs do not guarantee that there is only
	  // one link for a given pair of node. When this option is set to false
	  // we can save some memory and CPU (18% faster for non-multigraph);
	  if (options.multigraph === undefined) options.multigraph = false;

	  if (typeof Map !== 'function') {
	    // TODO: Should we polyfill it ourselves? We don't use much operations there..
	    throw new Error('ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph');
	  } 

	  var nodes = new Map();
	  var links = [],
	    // Hash of multi-edges. Used to track ids of edges between same nodes
	    multiEdges = {},
	    suspendEvents = 0,

	    createLink = options.multigraph ? createUniqueLink : createSingleLink,

	    // Our graph API provides means to listen to graph changes. Users can subscribe
	    // to be notified about changes in the graph by using `on` method. However
	    // in some cases they don't use it. To avoid unnecessary memory consumption
	    // we will not record graph changes until we have at least one subscriber.
	    // Code below supports this optimization.
	    //
	    // Accumulates all changes made during graph updates.
	    // Each change element contains:
	    //  changeType - one of the strings: 'add', 'remove' or 'update';
	    //  node - if change is related to node this property is set to changed graph's node;
	    //  link - if change is related to link this property is set to changed graph's link;
	    changes = [],
	    recordLinkChange = noop,
	    recordNodeChange = noop,
	    enterModification = noop,
	    exitModification = noop;

	  // this is our public API:
	  var graphPart = {
	    /**
	     * Adds node to the graph. If node with given id already exists in the graph
	     * its data is extended with whatever comes in 'data' argument.
	     *
	     * @param nodeId the node's identifier. A string or number is preferred.
	     * @param [data] additional data for the node being added. If node already
	     *   exists its data object is augmented with the new one.
	     *
	     * @return {node} The newly added node or node with given id if it already exists.
	     */
	    addNode: addNode,

	    /**
	     * Adds a link to the graph. The function always create a new
	     * link between two nodes. If one of the nodes does not exists
	     * a new node is created.
	     *
	     * @param fromId link start node id;
	     * @param toId link end node id;
	     * @param [data] additional data to be set on the new link;
	     *
	     * @return {link} The newly created link
	     */
	    addLink: addLink,

	    /**
	     * Removes link from the graph. If link does not exist does nothing.
	     *
	     * @param link - object returned by addLink() or getLinks() methods.
	     *
	     * @returns true if link was removed; false otherwise.
	     */
	    removeLink: removeLink,

	    /**
	     * Removes node with given id from the graph. If node does not exist in the graph
	     * does nothing.
	     *
	     * @param nodeId node's identifier passed to addNode() function.
	     *
	     * @returns true if node was removed; false otherwise.
	     */
	    removeNode: removeNode,

	    /**
	     * Gets node with given identifier. If node does not exist undefined value is returned.
	     *
	     * @param nodeId requested node identifier;
	     *
	     * @return {node} in with requested identifier or undefined if no such node exists.
	     */
	    getNode: getNode,

	    /**
	     * Gets number of nodes in this graph.
	     *
	     * @return number of nodes in the graph.
	     */
	    getNodeCount: getNodeCount,

	    /**
	     * Gets total number of links in the graph.
	     */
	    getLinkCount: getLinkCount,

	    /**
	     * Synonym for `getLinkCount()`
	     */
	    getLinksCount: getLinkCount,
	    
	    /**
	     * Synonym for `getNodeCount()`
	     */
	    getNodesCount: getNodeCount,

	    /**
	     * Gets all links (inbound and outbound) from the node with given id.
	     * If node with given id is not found null is returned.
	     *
	     * @param nodeId requested node identifier.
	     *
	     * @return Array of links from and to requested node if such node exists;
	     *   otherwise null is returned.
	     */
	    getLinks: getLinks,

	    /**
	     * Invokes callback on each node of the graph.
	     *
	     * @param {Function(node)} callback Function to be invoked. The function
	     *   is passed one argument: visited node.
	     */
	    forEachNode: forEachNode,

	    /**
	     * Invokes callback on every linked (adjacent) node to the given one.
	     *
	     * @param nodeId Identifier of the requested node.
	     * @param {Function(node, link)} callback Function to be called on all linked nodes.
	     *   The function is passed two parameters: adjacent node and link object itself.
	     * @param oriented if true graph treated as oriented.
	     */
	    forEachLinkedNode: forEachLinkedNode,

	    /**
	     * Enumerates all links in the graph
	     *
	     * @param {Function(link)} callback Function to be called on all links in the graph.
	     *   The function is passed one parameter: graph's link object.
	     *
	     * Link object contains at least the following fields:
	     *  fromId - node id where link starts;
	     *  toId - node id where link ends,
	     *  data - additional data passed to graph.addLink() method.
	     */
	    forEachLink: forEachLink,

	    /**
	     * Suspend all notifications about graph changes until
	     * endUpdate is called.
	     */
	    beginUpdate: enterModification,

	    /**
	     * Resumes all notifications about graph changes and fires
	     * graph 'changed' event in case there are any pending changes.
	     */
	    endUpdate: exitModification,

	    /**
	     * Removes all nodes and links from the graph.
	     */
	    clear: clear,

	    /**
	     * Detects whether there is a link between two nodes.
	     * Operation complexity is O(n) where n - number of links of a node.
	     * NOTE: this function is synonim for getLink()
	     *
	     * @returns link if there is one. null otherwise.
	     */
	    hasLink: getLink,

	    /**
	     * Detects whether there is a node with given id
	     * 
	     * Operation complexity is O(1)
	     * NOTE: this function is synonim for getNode()
	     *
	     * @returns node if there is one; Falsy value otherwise.
	     */
	    hasNode: getNode,

	    /**
	     * Gets an edge between two nodes.
	     * Operation complexity is O(n) where n - number of links of a node.
	     *
	     * @param {string} fromId link start identifier
	     * @param {string} toId link end identifier
	     *
	     * @returns link if there is one. null otherwise.
	     */
	    getLink: getLink
	  };

	  // this will add `on()` and `fire()` methods.
	  eventify(graphPart);

	  monitorSubscribers();

	  return graphPart;

	  function monitorSubscribers() {
	    var realOn = graphPart.on;

	    // replace real `on` with our temporary on, which will trigger change
	    // modification monitoring:
	    graphPart.on = on;

	    function on() {
	      // now it's time to start tracking stuff:
	      graphPart.beginUpdate = enterModification = enterModificationReal;
	      graphPart.endUpdate = exitModification = exitModificationReal;
	      recordLinkChange = recordLinkChangeReal;
	      recordNodeChange = recordNodeChangeReal;

	      // this will replace current `on` method with real pub/sub from `eventify`.
	      graphPart.on = realOn;
	      // delegate to real `on` handler:
	      return realOn.apply(graphPart, arguments);
	    }
	  }

	  function recordLinkChangeReal(link, changeType) {
	    changes.push({
	      link: link,
	      changeType: changeType
	    });
	  }

	  function recordNodeChangeReal(node, changeType) {
	    changes.push({
	      node: node,
	      changeType: changeType
	    });
	  }

	  function addNode(nodeId, data) {
	    if (nodeId === undefined) {
	      throw new Error('Invalid node identifier');
	    }

	    enterModification();

	    var node = getNode(nodeId);
	    if (!node) {
	      node = new Node(nodeId, data);
	      recordNodeChange(node, 'add');
	    } else {
	      node.data = data;
	      recordNodeChange(node, 'update');
	    }

	    nodes.set(nodeId, node);

	    exitModification();
	    return node;
	  }

	  function getNode(nodeId) {
	    return nodes.get(nodeId);
	  }

	  function removeNode(nodeId) {
	    var node = getNode(nodeId);
	    if (!node) {
	      return false;
	    }

	    enterModification();

	    var prevLinks = node.links;
	    if (prevLinks) {
	      node.links = null;
	      for(var i = 0; i < prevLinks.length; ++i) {
	        removeLink(prevLinks[i]);
	      }
	    }

	    nodes.delete(nodeId)

	    recordNodeChange(node, 'remove');

	    exitModification();

	    return true;
	  }


	  function addLink(fromId, toId, data) {
	    enterModification();

	    var fromNode = getNode(fromId) || addNode(fromId);
	    var toNode = getNode(toId) || addNode(toId);

	    var link = createLink(fromId, toId, data);

	    links.push(link);

	    // TODO: this is not cool. On large graphs potentially would consume more memory.
	    addLinkToNode(fromNode, link);
	    if (fromId !== toId) {
	      // make sure we are not duplicating links for self-loops
	      addLinkToNode(toNode, link);
	    }

	    recordLinkChange(link, 'add');

	    exitModification();

	    return link;
	  }

	  function createSingleLink(fromId, toId, data) {
	    var linkId = makeLinkId(fromId, toId);
	    return new Link(fromId, toId, data, linkId);
	  }

	  function createUniqueLink(fromId, toId, data) {
	    // TODO: Get rid of this method.
	    var linkId = makeLinkId(fromId, toId);
	    var isMultiEdge = multiEdges.hasOwnProperty(linkId);
	    if (isMultiEdge || getLink(fromId, toId)) {
	      if (!isMultiEdge) {
	        multiEdges[linkId] = 0;
	      }
	      var suffix = '@' + (++multiEdges[linkId]);
	      linkId = makeLinkId(fromId + suffix, toId + suffix);
	    }

	    return new Link(fromId, toId, data, linkId);
	  }

	  function getNodeCount() {
	    return nodes.size;
	  }

	  function getLinkCount() {
	    return links.length;
	  }

	  function getLinks(nodeId) {
	    var node = getNode(nodeId);
	    return node ? node.links : null;
	  }

	  function removeLink(link) {
	    if (!link) {
	      return false;
	    }
	    var idx = indexOfElementInArray(link, links);
	    if (idx < 0) {
	      return false;
	    }

	    enterModification();

	    links.splice(idx, 1);

	    var fromNode = getNode(link.fromId);
	    var toNode = getNode(link.toId);

	    if (fromNode) {
	      idx = indexOfElementInArray(link, fromNode.links);
	      if (idx >= 0) {
	        fromNode.links.splice(idx, 1);
	      }
	    }

	    if (toNode) {
	      idx = indexOfElementInArray(link, toNode.links);
	      if (idx >= 0) {
	        toNode.links.splice(idx, 1);
	      }
	    }

	    recordLinkChange(link, 'remove');

	    exitModification();

	    return true;
	  }

	  function getLink(fromNodeId, toNodeId) {
	    // TODO: Use sorted links to speed this up
	    var node = getNode(fromNodeId),
	      i;
	    if (!node || !node.links) {
	      return null;
	    }

	    for (i = 0; i < node.links.length; ++i) {
	      var link = node.links[i];
	      if (link.fromId === fromNodeId && link.toId === toNodeId) {
	        return link;
	      }
	    }

	    return null; // no link.
	  }

	  function clear() {
	    enterModification();
	    forEachNode(function(node) {
	      removeNode(node.id);
	    });
	    exitModification();
	  }

	  function forEachLink(callback) {
	    var i, length;
	    if (typeof callback === 'function') {
	      for (i = 0, length = links.length; i < length; ++i) {
	        callback(links[i]);
	      }
	    }
	  }

	  function forEachLinkedNode(nodeId, callback, oriented) {
	    var node = getNode(nodeId);

	    if (node && node.links && typeof callback === 'function') {
	      if (oriented) {
	        return forEachOrientedLink(node.links, nodeId, callback);
	      } else {
	        return forEachNonOrientedLink(node.links, nodeId, callback);
	      }
	    }
	  }

	  function forEachNonOrientedLink(links, nodeId, callback) {
	    var quitFast;
	    for (var i = 0; i < links.length; ++i) {
	      var link = links[i];
	      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;

	      quitFast = callback(nodes.get(linkedNodeId), link);
	      if (quitFast) {
	        return true; // Client does not need more iterations. Break now.
	      }
	    }
	  }

	  function forEachOrientedLink(links, nodeId, callback) {
	    var quitFast;
	    for (var i = 0; i < links.length; ++i) {
	      var link = links[i];
	      if (link.fromId === nodeId) {
	        quitFast = callback(nodes.get(link.toId), link)
	        if (quitFast) {
	          return true; // Client does not need more iterations. Break now.
	        }
	      }
	    }
	  }

	  // we will not fire anything until users of this library explicitly call `on()`
	  // method.
	  function noop() {}

	  // Enter, Exit modification allows bulk graph updates without firing events.
	  function enterModificationReal() {
	    suspendEvents += 1;
	  }

	  function exitModificationReal() {
	    suspendEvents -= 1;
	    if (suspendEvents === 0 && changes.length > 0) {
	      graphPart.fire('changed', changes);
	      changes.length = 0;
	    }
	  }

	  function forEachNode(callback) {
	    if (typeof callback !== 'function') {
	      throw new Error('Function is expected to iterate over graph nodes. You passed ' + callback);
	    }

	    var valuesIterator = nodes.values();
	    var nextValue = valuesIterator.next();
	    while (!nextValue.done) {
	      if (callback(nextValue.value)) {
	        return true; // client doesn't want to proceed. Return.
	      }
	      nextValue = valuesIterator.next();
	    }
	  }
	}

	// need this for old browsers. Should this be a separate module?
	function indexOfElementInArray(element, array) {
	  if (!array) return -1;

	  if (array.indexOf) {
	    return array.indexOf(element);
	  }

	  var len = array.length,
	    i;

	  for (i = 0; i < len; i += 1) {
	    if (array[i] === element) {
	      return i;
	    }
	  }

	  return -1;
	}

	/**
	 * Internal structure to represent node;
	 */
	function Node(id, data) {
	  this.id = id;
	  this.links = null;
	  this.data = data;
	}

	function addLinkToNode(node, link) {
	  if (node.links) {
	    node.links.push(link);
	  } else {
	    node.links = [link];
	  }
	}

	/**
	 * Internal structure to represent links;
	 */
	function Link(fromId, toId, data, id) {
	  this.fromId = fromId;
	  this.toId = toId;
	  this.data = data;
	  this.id = id;
	}

	function makeLinkId(fromId, toId) {
	  return fromId.toString() + '👉 ' + toId.toString();
	}


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = function eventify(subject) {
	  validateSubject(subject);

	  var eventsStorage = createEventsStorage(subject);
	  subject.on = eventsStorage.on;
	  subject.off = eventsStorage.off;
	  subject.fire = eventsStorage.fire;
	  return subject;
	};

	function createEventsStorage(subject) {
	  // Store all event listeners to this hash. Key is event name, value is array
	  // of callback records.
	  //
	  // A callback record consists of callback function and its optional context:
	  // { 'eventName' => [{callback: function, ctx: object}] }
	  var registeredEvents = Object.create(null);

	  return {
	    on: function (eventName, callback, ctx) {
	      if (typeof callback !== 'function') {
	        throw new Error('callback is expected to be a function');
	      }
	      var handlers = registeredEvents[eventName];
	      if (!handlers) {
	        handlers = registeredEvents[eventName] = [];
	      }
	      handlers.push({callback: callback, ctx: ctx});

	      return subject;
	    },

	    off: function (eventName, callback) {
	      var wantToRemoveAll = (typeof eventName === 'undefined');
	      if (wantToRemoveAll) {
	        // Killing old events storage should be enough in this case:
	        registeredEvents = Object.create(null);
	        return subject;
	      }

	      if (registeredEvents[eventName]) {
	        var deleteAllCallbacksForEvent = (typeof callback !== 'function');
	        if (deleteAllCallbacksForEvent) {
	          delete registeredEvents[eventName];
	        } else {
	          var callbacks = registeredEvents[eventName];
	          for (var i = 0; i < callbacks.length; ++i) {
	            if (callbacks[i].callback === callback) {
	              callbacks.splice(i, 1);
	            }
	          }
	        }
	      }

	      return subject;
	    },

	    fire: function (eventName) {
	      var callbacks = registeredEvents[eventName];
	      if (!callbacks) {
	        return subject;
	      }

	      var fireArguments;
	      if (arguments.length > 1) {
	        fireArguments = Array.prototype.splice.call(arguments, 1);
	      }
	      for(var i = 0; i < callbacks.length; ++i) {
	        var callbackInfo = callbacks[i];
	        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
	      }

	      return subject;
	    }
	  };
	}

	function validateSubject(subject) {
	  if (!subject) {
	    throw new Error('Eventify cannot use falsy object as events subject');
	  }
	  var reservedWords = ['on', 'fire', 'off'];
	  for (var i = 0; i < reservedWords.length; ++i) {
	    if (subject.hasOwnProperty(reservedWords[i])) {
	      throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
	    }
	  }
	}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = createLayout;
	module.exports.simulator = __webpack_require__(50);

	var eventify = __webpack_require__(48);

	/**
	 * Creates force based layout for a given graph.
	 *
	 * @param {ngraph.graph} graph which needs to be laid out
	 * @param {object} physicsSettings if you need custom settings
	 * for physics simulator you can pass your own settings here. If it's not passed
	 * a default one will be created.
	 */
	function createLayout(graph, physicsSettings) {
	  if (!graph) {
	    throw new Error('Graph structure cannot be undefined');
	  }

	  var createSimulator = __webpack_require__(50);
	  var physicsSimulator = createSimulator(physicsSettings);

	  var nodeMass = defaultNodeMass
	  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {
	    nodeMass = physicsSettings.nodeMass
	  }

	  var nodeBodies = Object.create(null);
	  var springs = {};
	  var bodiesCount = 0;

	  var springTransform = physicsSimulator.settings.springTransform || noop;

	  // Initialize physics with what we have in the graph:
	  initPhysics();
	  listenToEvents();

	  var wasStable = false;

	  var api = {
	    /**
	     * Performs one step of iterative layout algorithm
	     *
	     * @returns {boolean} true if the system should be considered stable; False otherwise.
	     * The system is stable if no further call to `step()` can improve the layout.
	     */
	    step: function() {
	      if (bodiesCount === 0) return true; // TODO: This will never fire 'stable'

	      var lastMove = physicsSimulator.step();

	      // Save the movement in case if someone wants to query it in the step
	      // callback.
	      api.lastMove = lastMove;

	      // Allow listeners to perform low-level actions after nodes are updated.
	      api.fire('step');

	      var ratio = lastMove/bodiesCount;
	      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...

	      if (wasStable !== isStableNow) {
	        wasStable = isStableNow;
	        onStableChanged(isStableNow);
	      }

	      return isStableNow;
	    },

	    /**
	     * For a given `nodeId` returns position
	     */
	    getNodePosition: function (nodeId) {
	      return getInitializedBody(nodeId).pos;
	    },

	    /**
	     * Sets position of a node to a given coordinates
	     * @param {string} nodeId node identifier
	     * @param {number} x position of a node
	     * @param {number} y position of a node
	     * @param {number=} z position of node (only if applicable to body)
	     */
	    setNodePosition: function (nodeId) {
	      var body = getInitializedBody(nodeId);
	      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));
	      physicsSimulator.invalidateBBox();
	    },

	    /**
	     * @returns {Object} Link position by link id
	     * @returns {Object.from} {x, y} coordinates of link start
	     * @returns {Object.to} {x, y} coordinates of link end
	     */
	    getLinkPosition: function (linkId) {
	      var spring = springs[linkId];
	      if (spring) {
	        return {
	          from: spring.from.pos,
	          to: spring.to.pos
	        };
	      }
	    },

	    /**
	     * @returns {Object} area required to fit in the graph. Object contains
	     * `x1`, `y1` - top left coordinates
	     * `x2`, `y2` - bottom right coordinates
	     */
	    getGraphRect: function () {
	      return physicsSimulator.getBBox();
	    },

	    /**
	     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
	     */
	    forEachBody: forEachBody,

	    /*
	     * Requests layout algorithm to pin/unpin node to its current position
	     * Pinned nodes should not be affected by layout algorithm and always
	     * remain at their position
	     */
	    pinNode: function (node, isPinned) {
	      var body = getInitializedBody(node.id);
	       body.isPinned = !!isPinned;
	    },

	    /**
	     * Checks whether given graph's node is currently pinned
	     */
	    isNodePinned: function (node) {
	      return getInitializedBody(node.id).isPinned;
	    },

	    /**
	     * Request to release all resources
	     */
	    dispose: function() {
	      graph.off('changed', onGraphChanged);
	      api.fire('disposed');
	    },

	    /**
	     * Gets physical body for a given node id. If node is not found undefined
	     * value is returned.
	     */
	    getBody: getBody,

	    /**
	     * Gets spring for a given edge.
	     *
	     * @param {string} linkId link identifer. If two arguments are passed then
	     * this argument is treated as formNodeId
	     * @param {string=} toId when defined this parameter denotes head of the link
	     * and first argument is treated as tail of the link (fromId)
	     */
	    getSpring: getSpring,

	    /**
	     * [Read only] Gets current physics simulator
	     */
	    simulator: physicsSimulator,

	    /**
	     * Gets the graph that was used for layout
	     */
	    graph: graph,

	    /**
	     * Gets amount of movement performed during last step operation
	     */
	    lastMove: 0
	  };

	  eventify(api);

	  return api;

	  function forEachBody(cb) {
	    Object.keys(nodeBodies).forEach(function(bodyId) {
	      cb(nodeBodies[bodyId], bodyId);
	    });
	  }

	  function getSpring(fromId, toId) {
	    var linkId;
	    if (toId === undefined) {
	      if (typeof fromId !== 'object') {
	        // assume fromId as a linkId:
	        linkId = fromId;
	      } else {
	        // assume fromId to be a link object:
	        linkId = fromId.id;
	      }
	    } else {
	      // toId is defined, should grab link:
	      var link = graph.hasLink(fromId, toId);
	      if (!link) return;
	      linkId = link.id;
	    }

	    return springs[linkId];
	  }

	  function getBody(nodeId) {
	    return nodeBodies[nodeId];
	  }

	  function listenToEvents() {
	    graph.on('changed', onGraphChanged);
	  }

	  function onStableChanged(isStable) {
	    api.fire('stable', isStable);
	  }

	  function onGraphChanged(changes) {
	    for (var i = 0; i < changes.length; ++i) {
	      var change = changes[i];
	      if (change.changeType === 'add') {
	        if (change.node) {
	          initBody(change.node.id);
	        }
	        if (change.link) {
	          initLink(change.link);
	        }
	      } else if (change.changeType === 'remove') {
	        if (change.node) {
	          releaseNode(change.node);
	        }
	        if (change.link) {
	          releaseLink(change.link);
	        }
	      }
	    }
	    bodiesCount = graph.getNodesCount();
	  }

	  function initPhysics() {
	    bodiesCount = 0;

	    graph.forEachNode(function (node) {
	      initBody(node.id);
	      bodiesCount += 1;
	    });

	    graph.forEachLink(initLink);
	  }

	  function initBody(nodeId) {
	    var body = nodeBodies[nodeId];
	    if (!body) {
	      var node = graph.getNode(nodeId);
	      if (!node) {
	        throw new Error('initBody() was called with unknown node id');
	      }

	      var pos = node.position;
	      if (!pos) {
	        var neighbors = getNeighborBodies(node);
	        pos = physicsSimulator.getBestNewBodyPosition(neighbors);
	      }

	      body = physicsSimulator.addBodyAt(pos);
	      body.id = nodeId;

	      nodeBodies[nodeId] = body;
	      updateBodyMass(nodeId);

	      if (isNodeOriginallyPinned(node)) {
	        body.isPinned = true;
	      }
	    }
	  }

	  function releaseNode(node) {
	    var nodeId = node.id;
	    var body = nodeBodies[nodeId];
	    if (body) {
	      nodeBodies[nodeId] = null;
	      delete nodeBodies[nodeId];

	      physicsSimulator.removeBody(body);
	    }
	  }

	  function initLink(link) {
	    updateBodyMass(link.fromId);
	    updateBodyMass(link.toId);

	    var fromBody = nodeBodies[link.fromId],
	        toBody  = nodeBodies[link.toId],
	        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);

	    springTransform(link, spring);

	    springs[link.id] = spring;
	  }

	  function releaseLink(link) {
	    var spring = springs[link.id];
	    if (spring) {
	      var from = graph.getNode(link.fromId),
	          to = graph.getNode(link.toId);

	      if (from) updateBodyMass(from.id);
	      if (to) updateBodyMass(to.id);

	      delete springs[link.id];

	      physicsSimulator.removeSpring(spring);
	    }
	  }

	  function getNeighborBodies(node) {
	    // TODO: Could probably be done better on memory
	    var neighbors = [];
	    if (!node.links) {
	      return neighbors;
	    }
	    var maxNeighbors = Math.min(node.links.length, 2);
	    for (var i = 0; i < maxNeighbors; ++i) {
	      var link = node.links[i];
	      var otherBody = link.fromId !== node.id ? nodeBodies[link.fromId] : nodeBodies[link.toId];
	      if (otherBody && otherBody.pos) {
	        neighbors.push(otherBody);
	      }
	    }

	    return neighbors;
	  }

	  function updateBodyMass(nodeId) {
	    var body = nodeBodies[nodeId];
	    body.mass = nodeMass(nodeId);
	    if (Number.isNaN(body.mass)) {
	      throw new Error('Node mass should be a number')
	    }
	  }

	  /**
	   * Checks whether graph node has in its settings pinned attribute,
	   * which means layout algorithm cannot move it. Node can be marked
	   * as pinned, if it has "isPinned" attribute, or when node.data has it.
	   *
	   * @param {Object} node a graph node to check
	   * @return {Boolean} true if node should be treated as pinned; false otherwise.
	   */
	  function isNodeOriginallyPinned(node) {
	    return (node && (node.isPinned || (node.data && node.data.isPinned)));
	  }

	  function getInitializedBody(nodeId) {
	    var body = nodeBodies[nodeId];
	    if (!body) {
	      initBody(nodeId);
	      body = nodeBodies[nodeId];
	    }
	    return body;
	  }

	  /**
	   * Calculates mass of a body, which corresponds to node with given id.
	   *
	   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated
	   * @returns {Number} recommended mass of the body;
	   */
	  function defaultNodeMass(nodeId) {
	    var links = graph.getLinks(nodeId);
	    if (!links) return 1;
	    return 1 + links.length / 3.0;
	  }
	}

	function noop() { }


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Manages a simulation of physical forces acting on bodies and springs.
	 */
	module.exports = physicsSimulator;

	function physicsSimulator(settings) {
	  var Spring = __webpack_require__(51);
	  var expose = __webpack_require__(52);
	  var merge = __webpack_require__(53);
	  var eventify = __webpack_require__(48);

	  settings = merge(settings, {
	      /**
	       * Ideal length for links (springs in physical model).
	       */
	      springLength: 30,

	      /**
	       * Hook's law coefficient. 1 - solid spring.
	       */
	      springCoeff: 0.0008,

	      /**
	       * Coulomb's law coefficient. It's used to repel nodes thus should be negative
	       * if you make it positive nodes start attract each other :).
	       */
	      gravity: -1.2,

	      /**
	       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
	       * The closer it's to 1 the more nodes algorithm will have to go through.
	       * Setting it to one makes Barnes Hut simulation no different from
	       * brute-force forces calculation (each node is considered).
	       */
	      theta: 0.8,

	      /**
	       * Drag force coefficient. Used to slow down system, thus should be less than 1.
	       * The closer it is to 0 the less tight system will be.
	       */
	      dragCoeff: 0.02,

	      /**
	       * Default time step (dt) for forces integration
	       */
	      timeStep : 20,
	  });

	  // We allow clients to override basic factory methods:
	  var createQuadTree = settings.createQuadTree || __webpack_require__(54);
	  var createBounds = settings.createBounds || __webpack_require__(59);
	  var createDragForce = settings.createDragForce || __webpack_require__(60);
	  var createSpringForce = settings.createSpringForce || __webpack_require__(61);
	  var integrate = settings.integrator || __webpack_require__(62);
	  var createBody = settings.createBody || __webpack_require__(63);

	  var bodies = [], // Bodies in this simulation.
	      springs = [], // Springs in this simulation.
	      quadTree =  createQuadTree(settings),
	      bounds = createBounds(bodies, settings),
	      springForce = createSpringForce(settings),
	      dragForce = createDragForce(settings);

	  var bboxNeedsUpdate = true;
	  var totalMovement = 0; // how much movement we made on last step

	  var publicApi = {
	    /**
	     * Array of bodies, registered with current simulator
	     *
	     * Note: To add new body, use addBody() method. This property is only
	     * exposed for testing/performance purposes.
	     */
	    bodies: bodies,

	    quadTree: quadTree,

	    /**
	     * Array of springs, registered with current simulator
	     *
	     * Note: To add new spring, use addSpring() method. This property is only
	     * exposed for testing/performance purposes.
	     */
	    springs: springs,

	    /**
	     * Returns settings with which current simulator was initialized
	     */
	    settings: settings,

	    /**
	     * Performs one step of force simulation.
	     *
	     * @returns {boolean} true if system is considered stable; False otherwise.
	     */
	    step: function () {
	      accumulateForces();

	      var movement = integrate(bodies, settings.timeStep);
	      bounds.update();

	      return movement;
	    },

	    /**
	     * Adds body to the system
	     *
	     * @param {ngraph.physics.primitives.Body} body physical body
	     *
	     * @returns {ngraph.physics.primitives.Body} added body
	     */
	    addBody: function (body) {
	      if (!body) {
	        throw new Error('Body is required');
	      }
	      bodies.push(body);

	      return body;
	    },

	    /**
	     * Adds body to the system at given position
	     *
	     * @param {Object} pos position of a body
	     *
	     * @returns {ngraph.physics.primitives.Body} added body
	     */
	    addBodyAt: function (pos) {
	      if (!pos) {
	        throw new Error('Body position is required');
	      }
	      var body = createBody(pos);
	      bodies.push(body);

	      return body;
	    },

	    /**
	     * Removes body from the system
	     *
	     * @param {ngraph.physics.primitives.Body} body to remove
	     *
	     * @returns {Boolean} true if body found and removed. falsy otherwise;
	     */
	    removeBody: function (body) {
	      if (!body) { return; }

	      var idx = bodies.indexOf(body);
	      if (idx < 0) { return; }

	      bodies.splice(idx, 1);
	      if (bodies.length === 0) {
	        bounds.reset();
	      }
	      return true;
	    },

	    /**
	     * Adds a spring to this simulation.
	     *
	     * @returns {Object} - a handle for a spring. If you want to later remove
	     * spring pass it to removeSpring() method.
	     */
	    addSpring: function (body1, body2, springLength, springWeight, springCoefficient) {
	      if (!body1 || !body2) {
	        throw new Error('Cannot add null spring to force simulator');
	      }

	      if (typeof springLength !== 'number') {
	        springLength = -1; // assume global configuration
	      }

	      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1, springWeight);
	      springs.push(spring);

	      // TODO: could mark simulator as dirty.
	      return spring;
	    },

	    /**
	     * Returns amount of movement performed on last step() call
	     */
	    getTotalMovement: function () {
	      return totalMovement;
	    },

	    /**
	     * Removes spring from the system
	     *
	     * @param {Object} spring to remove. Spring is an object returned by addSpring
	     *
	     * @returns {Boolean} true if spring found and removed. falsy otherwise;
	     */
	    removeSpring: function (spring) {
	      if (!spring) { return; }
	      var idx = springs.indexOf(spring);
	      if (idx > -1) {
	        springs.splice(idx, 1);
	        return true;
	      }
	    },

	    getBestNewBodyPosition: function (neighbors) {
	      return bounds.getBestNewPosition(neighbors);
	    },

	    /**
	     * Returns bounding box which covers all bodies
	     */
	    getBBox: function () {
	      if (bboxNeedsUpdate) {
	        bounds.update();
	        bboxNeedsUpdate = false;
	      }
	      return bounds.box;
	    },

	    invalidateBBox: function () {
	      bboxNeedsUpdate = true;
	    },

	    gravity: function (value) {
	      if (value !== undefined) {
	        settings.gravity = value;
	        quadTree.options({gravity: value});
	        return this;
	      } else {
	        return settings.gravity;
	      }
	    },

	    theta: function (value) {
	      if (value !== undefined) {
	        settings.theta = value;
	        quadTree.options({theta: value});
	        return this;
	      } else {
	        return settings.theta;
	      }
	    }
	  };

	  // allow settings modification via public API:
	  expose(settings, publicApi);

	  eventify(publicApi);

	  return publicApi;

	  function accumulateForces() {
	    // Accumulate forces acting on bodies.
	    var body,
	        i = bodies.length;

	    if (i) {
	      // only add bodies if there the array is not empty:
	      quadTree.insertBodies(bodies); // performance: O(n * log n)
	      while (i--) {
	        body = bodies[i];
	        // If body is pinned there is no point updating its forces - it should
	        // never move:
	        if (!body.isPinned) {
	          body.force.reset();

	          quadTree.updateBodyForce(body);
	          dragForce.update(body);
	        }
	      }
	    }

	    i = springs.length;
	    while(i--) {
	      springForce.update(springs[i]);
	    }
	  }
	};


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	module.exports = Spring;

	/**
	 * Represents a physical spring. Spring connects two bodies, has rest length
	 * stiffness coefficient and optional weight
	 */
	function Spring(fromBody, toBody, length, coeff, weight) {
	    this.from = fromBody;
	    this.to = toBody;
	    this.length = length;
	    this.coeff = coeff;

	    this.weight = typeof weight === 'number' ? weight : 1;
	};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

	module.exports = exposeProperties;

	/**
	 * Augments `target` object with getter/setter functions, which modify settings
	 *
	 * @example
	 *  var target = {};
	 *  exposeProperties({ age: 42}, target);
	 *  target.age(); // returns 42
	 *  target.age(24); // make age 24;
	 *
	 *  var filteredTarget = {};
	 *  exposeProperties({ age: 42, name: 'John'}, filteredTarget, ['name']);
	 *  filteredTarget.name(); // returns 'John'
	 *  filteredTarget.age === undefined; // true
	 */
	function exposeProperties(settings, target, filter) {
	  var needsFilter = Object.prototype.toString.call(filter) === '[object Array]';
	  if (needsFilter) {
	    for (var i = 0; i < filter.length; ++i) {
	      augment(settings, target, filter[i]);
	    }
	  } else {
	    for (var key in settings) {
	      augment(settings, target, key);
	    }
	  }
	}

	function augment(source, target, key) {
	  if (source.hasOwnProperty(key)) {
	    if (typeof target[key] === 'function') {
	      // this accessor is already defined. Ignore it
	      return;
	    }
	    target[key] = function (value) {
	      if (value !== undefined) {
	        source[key] = value;
	        return target;
	      }
	      return source[key];
	    }
	  }
	}


/***/ }),
/* 53 */
/***/ (function(module, exports) {

	module.exports = merge;

	/**
	 * Augments `target` with properties in `options`. Does not override
	 * target's properties if they are defined and matches expected type in 
	 * options
	 *
	 * @returns {Object} merged object
	 */
	function merge(target, options) {
	  var key;
	  if (!target) { target = {}; }
	  if (options) {
	    for (key in options) {
	      if (options.hasOwnProperty(key)) {
	        var targetHasIt = target.hasOwnProperty(key),
	            optionsValueType = typeof options[key],
	            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);

	        if (shouldReplace) {
	          target[key] = options[key];
	        } else if (optionsValueType === 'object') {
	          // go deep, don't care about loops here, we are simple API!:
	          target[key] = merge(target[key], options[key]);
	        }
	      }
	    }
	  }

	  return target;
	}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This is Barnes Hut simulation algorithm for 2d case. Implementation
	 * is highly optimized (avoids recusion and gc pressure)
	 *
	 * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html
	 */

	module.exports = function(options) {
	  options = options || {};
	  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
	  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

	  // we require deterministic randomness here
	  var random = __webpack_require__(55).random(1984),
	    Node = __webpack_require__(56),
	    InsertStack = __webpack_require__(57),
	    isSamePosition = __webpack_require__(58);

	  var gravity = options.gravity,
	    updateQueue = [],
	    insertStack = new InsertStack(),
	    theta = options.theta,

	    nodesCache = [],
	    currentInCache = 0,
	    root = newNode();

	  return {
	    insertBodies: insertBodies,
	    /**
	     * Gets root node if its present
	     */
	    getRoot: function() {
	      return root;
	    },
	    updateBodyForce: update,
	    options: function(newOptions) {
	      if (newOptions) {
	        if (typeof newOptions.gravity === 'number') {
	          gravity = newOptions.gravity;
	        }
	        if (typeof newOptions.theta === 'number') {
	          theta = newOptions.theta;
	        }

	        return this;
	      }

	      return {
	        gravity: gravity,
	        theta: theta
	      };
	    }
	  };

	  function newNode() {
	    // To avoid pressure on GC we reuse nodes.
	    var node = nodesCache[currentInCache];
	    if (node) {
	      node.quad0 = null;
	      node.quad1 = null;
	      node.quad2 = null;
	      node.quad3 = null;
	      node.body = null;
	      node.mass = node.massX = node.massY = 0;
	      node.left = node.right = node.top = node.bottom = 0;
	    } else {
	      node = new Node();
	      nodesCache[currentInCache] = node;
	    }

	    ++currentInCache;
	    return node;
	  }

	  function update(sourceBody) {
	    var queue = updateQueue,
	      v,
	      dx,
	      dy,
	      r, fx = 0,
	      fy = 0,
	      queueLength = 1,
	      shiftIdx = 0,
	      pushIdx = 1;

	    queue[0] = root;

	    while (queueLength) {
	      var node = queue[shiftIdx],
	        body = node.body;

	      queueLength -= 1;
	      shiftIdx += 1;
	      var differentBody = (body !== sourceBody);
	      if (body && differentBody) {
	        // If the current node is a leaf node (and it is not source body),
	        // calculate the force exerted by the current node on body, and add this
	        // amount to body's net force.
	        dx = body.pos.x - sourceBody.pos.x;
	        dy = body.pos.y - sourceBody.pos.y;
	        r = Math.sqrt(dx * dx + dy * dy);

	        if (r === 0) {
	          // Poor man's protection against zero distance.
	          dx = (random.nextDouble() - 0.5) / 50;
	          dy = (random.nextDouble() - 0.5) / 50;
	          r = Math.sqrt(dx * dx + dy * dy);
	        }

	        // This is standard gravition force calculation but we divide
	        // by r^3 to save two operations when normalizing force vector.
	        v = gravity * body.mass * sourceBody.mass / (r * r * r);
	        fx += v * dx;
	        fy += v * dy;
	      } else if (differentBody) {
	        // Otherwise, calculate the ratio s / r,  where s is the width of the region
	        // represented by the internal node, and r is the distance between the body
	        // and the node's center-of-mass
	        dx = node.massX / node.mass - sourceBody.pos.x;
	        dy = node.massY / node.mass - sourceBody.pos.y;
	        r = Math.sqrt(dx * dx + dy * dy);

	        if (r === 0) {
	          // Sorry about code duplucation. I don't want to create many functions
	          // right away. Just want to see performance first.
	          dx = (random.nextDouble() - 0.5) / 50;
	          dy = (random.nextDouble() - 0.5) / 50;
	          r = Math.sqrt(dx * dx + dy * dy);
	        }
	        // If s / r < θ, treat this internal node as a single body, and calculate the
	        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
	        if ((node.right - node.left) / r < theta) {
	          // in the if statement above we consider node's width only
	          // because the region was squarified during tree creation.
	          // Thus there is no difference between using width or height.
	          v = gravity * node.mass * sourceBody.mass / (r * r * r);
	          fx += v * dx;
	          fy += v * dy;
	        } else {
	          // Otherwise, run the procedure recursively on each of the current node's children.

	          // I intentionally unfolded this loop, to save several CPU cycles.
	          if (node.quad0) {
	            queue[pushIdx] = node.quad0;
	            queueLength += 1;
	            pushIdx += 1;
	          }
	          if (node.quad1) {
	            queue[pushIdx] = node.quad1;
	            queueLength += 1;
	            pushIdx += 1;
	          }
	          if (node.quad2) {
	            queue[pushIdx] = node.quad2;
	            queueLength += 1;
	            pushIdx += 1;
	          }
	          if (node.quad3) {
	            queue[pushIdx] = node.quad3;
	            queueLength += 1;
	            pushIdx += 1;
	          }
	        }
	      }
	    }

	    sourceBody.force.x += fx;
	    sourceBody.force.y += fy;
	  }

	  function insertBodies(bodies) {
	    var x1 = Number.MAX_VALUE,
	      y1 = Number.MAX_VALUE,
	      x2 = Number.MIN_VALUE,
	      y2 = Number.MIN_VALUE,
	      i,
	      max = bodies.length;

	    // To reduce quad tree depth we are looking for exact bounding box of all particles.
	    i = max;
	    while (i--) {
	      var x = bodies[i].pos.x;
	      var y = bodies[i].pos.y;
	      if (x < x1) {
	        x1 = x;
	      }
	      if (x > x2) {
	        x2 = x;
	      }
	      if (y < y1) {
	        y1 = y;
	      }
	      if (y > y2) {
	        y2 = y;
	      }
	    }

	    // Squarify the bounds.
	    var dx = x2 - x1,
	      dy = y2 - y1;
	    if (dx > dy) {
	      y2 = y1 + dx;
	    } else {
	      x2 = x1 + dy;
	    }

	    currentInCache = 0;
	    root = newNode();
	    root.left = x1;
	    root.right = x2;
	    root.top = y1;
	    root.bottom = y2;

	    i = max - 1;
	    if (i >= 0) {
	      root.body = bodies[i];
	    }
	    while (i--) {
	      insert(bodies[i], root);
	    }
	  }

	  function insert(newBody) {
	    insertStack.reset();
	    insertStack.push(root, newBody);

	    while (!insertStack.isEmpty()) {
	      var stackItem = insertStack.pop(),
	        node = stackItem.node,
	        body = stackItem.body;

	      if (!node.body) {
	        // This is internal node. Update the total mass of the node and center-of-mass.
	        var x = body.pos.x;
	        var y = body.pos.y;
	        node.mass = node.mass + body.mass;
	        node.massX = node.massX + body.mass * x;
	        node.massY = node.massY + body.mass * y;

	        // Recursively insert the body in the appropriate quadrant.
	        // But first find the appropriate quadrant.
	        var quadIdx = 0, // Assume we are in the 0's quad.
	          left = node.left,
	          right = (node.right + left) / 2,
	          top = node.top,
	          bottom = (node.bottom + top) / 2;

	        if (x > right) { // somewhere in the eastern part.
	          quadIdx = quadIdx + 1;
	          left = right;
	          right = node.right;
	        }
	        if (y > bottom) { // and in south.
	          quadIdx = quadIdx + 2;
	          top = bottom;
	          bottom = node.bottom;
	        }

	        var child = getChild(node, quadIdx);
	        if (!child) {
	          // The node is internal but this quadrant is not taken. Add
	          // subnode to it.
	          child = newNode();
	          child.left = left;
	          child.top = top;
	          child.right = right;
	          child.bottom = bottom;
	          child.body = body;

	          setChild(node, quadIdx, child);
	        } else {
	          // continue searching in this quadrant.
	          insertStack.push(child, body);
	        }
	      } else {
	        // We are trying to add to the leaf node.
	        // We have to convert current leaf into internal node
	        // and continue adding two nodes.
	        var oldBody = node.body;
	        node.body = null; // internal nodes do not cary bodies

	        if (isSamePosition(oldBody.pos, body.pos)) {
	          // Prevent infinite subdivision by bumping one node
	          // anywhere in this quadrant
	          var retriesCount = 3;
	          do {
	            var offset = random.nextDouble();
	            var dx = (node.right - node.left) * offset;
	            var dy = (node.bottom - node.top) * offset;

	            oldBody.pos.x = node.left + dx;
	            oldBody.pos.y = node.top + dy;
	            retriesCount -= 1;
	            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
	          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

	          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
	            // This is very bad, we ran out of precision.
	            // if we do not return from the method we'll get into
	            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
	            // Next layout iteration should get larger bounding box in the first step and fix this
	            return;
	          }
	        }
	        // Next iteration should subdivide node further.
	        insertStack.push(node, oldBody);
	        insertStack.push(node, body);
	      }
	    }
	  }
	};

	function getChild(node, idx) {
	  if (idx === 0) return node.quad0;
	  if (idx === 1) return node.quad1;
	  if (idx === 2) return node.quad2;
	  if (idx === 3) return node.quad3;
	  return null;
	}

	function setChild(node, idx, child) {
	  if (idx === 0) node.quad0 = child;
	  else if (idx === 1) node.quad1 = child;
	  else if (idx === 2) node.quad2 = child;
	  else if (idx === 3) node.quad3 = child;
	}


/***/ }),
/* 55 */
/***/ (function(module, exports) {

	module.exports = random;

	// TODO: Deprecate?
	module.exports.random = random,
	module.exports.randomIterator = randomIterator

	/**
	 * Creates seeded PRNG with two methods:
	 *   next() and nextDouble()
	 */
	function random(inputSeed) {
	  var seed = typeof inputSeed === 'number' ? inputSeed : (+new Date());
	  return new Generator(seed)
	}

	function Generator(seed) {
	  this.seed = seed;
	}

	/**
	  * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)
	  *
	  * @param maxValue Number REQUIRED. Omitting this number will result in NaN values from PRNG.
	  */
	Generator.prototype.next = next;

	/**
	  * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)
	  * This function is the same as Math.random() (except that it could be seeded)
	  */
	Generator.prototype.nextDouble = nextDouble;

	/**
	 * Returns a random real number uniformly in [0, 1)
	 */
	Generator.prototype.uniform = nextDouble;

	Generator.prototype.gaussian = gaussian;

	function gaussian() {
	  // use the polar form of the Box-Muller transform
	  // based on https://introcs.cs.princeton.edu/java/23recursion/StdRandom.java
	  var r, x, y;
	  do {
	    x = this.nextDouble() * 2 - 1;
	    y = this.nextDouble() * 2 - 1;
	    r = x * x + y * y;
	  } while (r >= 1 || r === 0);

	  return x * Math.sqrt(-2 * Math.log(r)/r);
	}

	function nextDouble() {
	  var seed = this.seed;
	  // Robert Jenkins' 32 bit integer hash function.
	  seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;
	  seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;
	  seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;
	  seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;
	  seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;
	  seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;
	  this.seed = seed;
	  return (seed & 0xfffffff) / 0x10000000;
	}

	function next(maxValue) {
	  return Math.floor(this.nextDouble() * maxValue);
	}

	/*
	 * Creates iterator over array, which returns items of array in random order
	 * Time complexity is guaranteed to be O(n);
	 */
	function randomIterator(array, customRandom) {
	  var localRandom = customRandom || random();
	  if (typeof localRandom.next !== 'function') {
	    throw new Error('customRandom does not match expected API: next() function is missing');
	  }

	  return {
	    forEach: forEach,

	    /**
	     * Shuffles array randomly, in place.
	     */
	    shuffle: shuffle
	  };

	  function shuffle() {
	    var i, j, t;
	    for (i = array.length - 1; i > 0; --i) {
	      j = localRandom.next(i + 1); // i inclusive
	      t = array[j];
	      array[j] = array[i];
	      array[i] = t;
	    }

	    return array;
	  }

	  function forEach(callback) {
	    var i, j, t;
	    for (i = array.length - 1; i > 0; --i) {
	      j = localRandom.next(i + 1); // i inclusive
	      t = array[j];
	      array[j] = array[i];
	      array[i] = t;

	      callback(t);
	    }

	    if (array.length) {
	      callback(array[0]);
	    }
	  }
	}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	/**
	 * Internal data structure to represent 2D QuadTree node
	 */
	module.exports = function Node() {
	  // body stored inside this node. In quad tree only leaf nodes (by construction)
	  // contain boides:
	  this.body = null;

	  // Child nodes are stored in quads. Each quad is presented by number:
	  // 0 | 1
	  // -----
	  // 2 | 3
	  this.quad0 = null;
	  this.quad1 = null;
	  this.quad2 = null;
	  this.quad3 = null;

	  // Total mass of current node
	  this.mass = 0;

	  // Center of mass coordinates
	  this.massX = 0;
	  this.massY = 0;

	  // bounding box coordinates
	  this.left = 0;
	  this.top = 0;
	  this.bottom = 0;
	  this.right = 0;
	};


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	module.exports = InsertStack;

	/**
	 * Our implmentation of QuadTree is non-recursive to avoid GC hit
	 * This data structure represent stack of elements
	 * which we are trying to insert into quad tree.
	 */
	function InsertStack () {
	    this.stack = [];
	    this.popIdx = 0;
	}

	InsertStack.prototype = {
	    isEmpty: function() {
	        return this.popIdx === 0;
	    },
	    push: function (node, body) {
	        var item = this.stack[this.popIdx];
	        if (!item) {
	            // we are trying to avoid memory pressue: create new element
	            // only when absolutely necessary
	            this.stack[this.popIdx] = new InsertStackElement(node, body);
	        } else {
	            item.node = node;
	            item.body = body;
	        }
	        ++this.popIdx;
	    },
	    pop: function () {
	        if (this.popIdx > 0) {
	            return this.stack[--this.popIdx];
	        }
	    },
	    reset: function () {
	        this.popIdx = 0;
	    }
	};

	function InsertStackElement(node, body) {
	    this.node = node; // QuadTree node
	    this.body = body; // physical body which needs to be inserted to node
	}


/***/ }),
/* 58 */
/***/ (function(module, exports) {

	module.exports = function isSamePosition(point1, point2) {
	    var dx = Math.abs(point1.x - point2.x);
	    var dy = Math.abs(point1.y - point2.y);

	    return (dx < 1e-8 && dy < 1e-8);
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = function (bodies, settings) {
	  var random = __webpack_require__(55).random(42);
	  var boundingBox =  { x1: 0, y1: 0, x2: 0, y2: 0 };

	  return {
	    box: boundingBox,

	    update: updateBoundingBox,

	    reset : function () {
	      boundingBox.x1 = boundingBox.y1 = 0;
	      boundingBox.x2 = boundingBox.y2 = 0;
	    },

	    getBestNewPosition: function (neighbors) {
	      var graphRect = boundingBox;

	      var baseX = 0, baseY = 0;

	      if (neighbors.length) {
	        for (var i = 0; i < neighbors.length; ++i) {
	          baseX += neighbors[i].pos.x;
	          baseY += neighbors[i].pos.y;
	        }

	        baseX /= neighbors.length;
	        baseY /= neighbors.length;
	      } else {
	        baseX = (graphRect.x1 + graphRect.x2) / 2;
	        baseY = (graphRect.y1 + graphRect.y2) / 2;
	      }

	      var springLength = settings.springLength;
	      return {
	        x: baseX + random.next(springLength) - springLength / 2,
	        y: baseY + random.next(springLength) - springLength / 2
	      };
	    }
	  };

	  function updateBoundingBox() {
	    var i = bodies.length;
	    if (i === 0) { return; } // don't have to wory here.

	    var x1 = Number.MAX_VALUE,
	        y1 = Number.MAX_VALUE,
	        x2 = Number.MIN_VALUE,
	        y2 = Number.MIN_VALUE;

	    while(i--) {
	      // this is O(n), could it be done faster with quadtree?
	      // how about pinned nodes?
	      var body = bodies[i];
	      if (body.isPinned) {
	        body.pos.x = body.prevPos.x;
	        body.pos.y = body.prevPos.y;
	      } else {
	        body.prevPos.x = body.pos.x;
	        body.prevPos.y = body.pos.y;
	      }
	      if (body.pos.x < x1) {
	        x1 = body.pos.x;
	      }
	      if (body.pos.x > x2) {
	        x2 = body.pos.x;
	      }
	      if (body.pos.y < y1) {
	        y1 = body.pos.y;
	      }
	      if (body.pos.y > y2) {
	        y2 = body.pos.y;
	      }
	    }

	    boundingBox.x1 = x1;
	    boundingBox.x2 = x2;
	    boundingBox.y1 = y1;
	    boundingBox.y2 = y2;
	  }
	}


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Represents drag force, which reduces force value on each step by given
	 * coefficient.
	 *
	 * @param {Object} options for the drag force
	 * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default
	 */
	module.exports = function (options) {
	  var merge = __webpack_require__(53),
	      expose = __webpack_require__(52);

	  options = merge(options, {
	    dragCoeff: 0.02
	  });

	  var api = {
	    update : function (body) {
	      body.force.x -= options.dragCoeff * body.velocity.x;
	      body.force.y -= options.dragCoeff * body.velocity.y;
	    }
	  };

	  // let easy access to dragCoeff:
	  expose(options, api, ['dragCoeff']);

	  return api;
	};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Represents spring force, which updates forces acting on two bodies, conntected
	 * by a spring.
	 *
	 * @param {Object} options for the spring force
	 * @param {Number=} options.springCoeff spring force coefficient.
	 * @param {Number=} options.springLength desired length of a spring at rest.
	 */
	module.exports = function (options) {
	  var merge = __webpack_require__(53);
	  var random = __webpack_require__(55).random(42);
	  var expose = __webpack_require__(52);

	  options = merge(options, {
	    springCoeff: 0.0002,
	    springLength: 80
	  });

	  var api = {
	    /**
	     * Upsates forces acting on a spring
	     */
	    update : function (spring) {
	      var body1 = spring.from,
	          body2 = spring.to,
	          length = spring.length < 0 ? options.springLength : spring.length,
	          dx = body2.pos.x - body1.pos.x,
	          dy = body2.pos.y - body1.pos.y,
	          r = Math.sqrt(dx * dx + dy * dy);

	      if (r === 0) {
	          dx = (random.nextDouble() - 0.5) / 50;
	          dy = (random.nextDouble() - 0.5) / 50;
	          r = Math.sqrt(dx * dx + dy * dy);
	      }

	      var d = r - length;
	      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;

	      body1.force.x += coeff * dx;
	      body1.force.y += coeff * dy;

	      body2.force.x -= coeff * dx;
	      body2.force.y -= coeff * dy;
	    }
	  };

	  expose(options, api, ['springCoeff', 'springLength']);
	  return api;
	}


/***/ }),
/* 62 */
/***/ (function(module, exports) {

	/**
	 * Performs forces integration, using given timestep. Uses Euler method to solve
	 * differential equation (http://en.wikipedia.org/wiki/Euler_method ).
	 *
	 * @returns {Number} squared distance of total position updates.
	 */

	module.exports = integrate;

	function integrate(bodies, timeStep) {
	  var dx = 0, tx = 0,
	      dy = 0, ty = 0,
	      i,
	      max = bodies.length;

	  if (max === 0) {
	    return 0;
	  }

	  for (i = 0; i < max; ++i) {
	    var body = bodies[i],
	        coeff = timeStep / body.mass;

	    body.velocity.x += coeff * body.force.x;
	    body.velocity.y += coeff * body.force.y;
	    var vx = body.velocity.x,
	        vy = body.velocity.y,
	        v = Math.sqrt(vx * vx + vy * vy);

	    if (v > 1) {
	      // We normalize it so that we move within timeStep range. 
	      // for the case when v <= 1 - we let velocity to fade out.
	      body.velocity.x = vx / v;
	      body.velocity.y = vy / v;
	    }

	    dx = timeStep * body.velocity.x;
	    dy = timeStep * body.velocity.y;

	    body.pos.x += dx;
	    body.pos.y += dy;

	    tx += Math.abs(dx); ty += Math.abs(dy);
	  }

	  return (tx * tx + ty * ty)/max;
	}


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var physics = __webpack_require__(64);

	module.exports = function(pos) {
	  return new physics.Body(pos);
	}


/***/ }),
/* 64 */
/***/ (function(module, exports) {

	module.exports = {
	  Body: Body,
	  Vector2d: Vector2d,
	  Body3d: Body3d,
	  Vector3d: Vector3d
	};

	function Body(x, y) {
	  this.pos = new Vector2d(x, y);
	  this.prevPos = new Vector2d(x, y);
	  this.force = new Vector2d();
	  this.velocity = new Vector2d();
	  this.mass = 1;
	}

	Body.prototype.setPosition = function (x, y) {
	  this.prevPos.x = this.pos.x = x;
	  this.prevPos.y = this.pos.y = y;
	};

	function Vector2d(x, y) {
	  if (x && typeof x !== 'number') {
	    // could be another vector
	    this.x = typeof x.x === 'number' ? x.x : 0;
	    this.y = typeof x.y === 'number' ? x.y : 0;
	  } else {
	    this.x = typeof x === 'number' ? x : 0;
	    this.y = typeof y === 'number' ? y : 0;
	  }
	}

	Vector2d.prototype.reset = function () {
	  this.x = this.y = 0;
	};

	function Body3d(x, y, z) {
	  this.pos = new Vector3d(x, y, z);
	  this.prevPos = new Vector3d(x, y, z);
	  this.force = new Vector3d();
	  this.velocity = new Vector3d();
	  this.mass = 1;
	}

	Body3d.prototype.setPosition = function (x, y, z) {
	  this.prevPos.x = this.pos.x = x;
	  this.prevPos.y = this.pos.y = y;
	  this.prevPos.z = this.pos.z = z;
	};

	function Vector3d(x, y, z) {
	  if (x && typeof x !== 'number') {
	    // could be another vector
	    this.x = typeof x.x === 'number' ? x.x : 0;
	    this.y = typeof x.y === 'number' ? x.y : 0;
	    this.z = typeof x.z === 'number' ? x.z : 0;
	  } else {
	    this.x = typeof x === 'number' ? x : 0;
	    this.y = typeof y === 'number' ? y : 0;
	    this.z = typeof z === 'number' ? z : 0;
	  }
	};

	Vector3d.prototype.reset = function () {
	  this.x = this.y = this.z = 0;
	};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This module provides all required forces to regular ngraph.physics.simulator
	 * to make it 3D simulator. Ideally ngraph.physics.simulator should operate
	 * with vectors, but on practices that showed performance decrease... Maybe
	 * I was doing it wrong, will see if I can refactor/throw away this module.
	 */
	module.exports = createLayout;
	createLayout.get2dLayout = __webpack_require__(49);

	function createLayout(graph, physicsSettings) {
	  var merge = __webpack_require__(53);
	  physicsSettings = merge(physicsSettings, {
	        createQuadTree: __webpack_require__(66),
	        createBounds: __webpack_require__(70),
	        createDragForce: __webpack_require__(71),
	        createSpringForce: __webpack_require__(72),
	        integrator: getIntegrator(physicsSettings),
	        createBody: __webpack_require__(73)
	      });

	  return createLayout.get2dLayout(graph, physicsSettings);
	}

	function getIntegrator(physicsSettings) {
	  if (physicsSettings && physicsSettings.integrator === 'verlet') {
	    return __webpack_require__(74);
	  }

	  return __webpack_require__(75)
	}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This is Barnes Hut simulation algorithm for 3d case. Implementation
	 * is highly optimized (avoids recusion and gc pressure)
	 *
	 * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html
	 *
	 * NOTE: This module duplicates a lot of code from 2d case. Primary reason for
	 * this is performance. Every time I tried to abstract away vector operations
	 * I had negative impact on performance. So in this case I'm scarifying code
	 * reuse in favor of speed
	 */

	module.exports = function(options) {
	  options = options || {};
	  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
	  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

	  // we require deterministic randomness here
	  var random = __webpack_require__(55).random(1984),
	    Node = __webpack_require__(67),
	    InsertStack = __webpack_require__(68),
	    isSamePosition = __webpack_require__(69);

	  var gravity = options.gravity,
	    updateQueue = [],
	    insertStack = new InsertStack(),
	    theta = options.theta,

	    nodesCache = [],
	    currentInCache = 0,
	    newNode = function() {
	      // To avoid pressure on GC we reuse nodes.
	      var node = nodesCache[currentInCache];
	      if (node) {
	        node.quad0 = null;
	        node.quad4 = null;
	        node.quad1 = null;
	        node.quad5 = null;
	        node.quad2 = null;
	        node.quad6 = null;
	        node.quad3 = null;
	        node.quad7 = null;
	        node.body = null;
	        node.mass = node.massX = node.massY = node.massZ = 0;
	        node.left = node.right = node.top = node.bottom = node.front = node.back = 0;
	      } else {
	        node = new Node();
	        nodesCache[currentInCache] = node;
	      }

	      ++currentInCache;
	      return node;
	    },

	    root = newNode(),

	    // Inserts body to the tree
	    insert = function(newBody) {
	      insertStack.reset();
	      insertStack.push(root, newBody);

	      while (!insertStack.isEmpty()) {
	        var stackItem = insertStack.pop(),
	          node = stackItem.node,
	          body = stackItem.body;

	        if (!node.body) {
	          // This is internal node. Update the total mass of the node and center-of-mass.
	          var x = body.pos.x;
	          var y = body.pos.y;
	          var z = body.pos.z;
	          node.mass += body.mass;
	          node.massX += body.mass * x;
	          node.massY += body.mass * y;
	          node.massZ += body.mass * z;

	          // Recursively insert the body in the appropriate quadrant.
	          // But first find the appropriate quadrant.
	          var quadIdx = 0, // Assume we are in the 0's quad.
	            left = node.left,
	            right = (node.right + left) / 2,
	            top = node.top,
	            bottom = (node.bottom + top) / 2,
	            back = node.back,
	            front = (node.front + back) / 2;

	          if (x > right) { // somewhere in the eastern part.
	            quadIdx += 1;
	            var oldLeft = left;
	            left = right;
	            right = right + (right - oldLeft);
	          }
	          if (y > bottom) { // and in south.
	            quadIdx += 2;
	            var oldTop = top;
	            top = bottom;
	            bottom = bottom + (bottom - oldTop);
	          }
	          if (z > front) { // and in frontal part
	            quadIdx += 4;
	            var oldBack = back;
	            back = front;
	            front = back + (back - oldBack);
	          }

	          var child = getChild(node, quadIdx);
	          if (!child) {
	            // The node is internal but this quadrant is not taken. Add subnode to it.
	            child = newNode();
	            child.left = left;
	            child.top = top;
	            child.right = right;
	            child.bottom = bottom;
	            child.back = back;
	            child.front = front;
	            child.body = body;

	            setChild(node, quadIdx, child);
	          } else {
	            // continue searching in this quadrant.
	            insertStack.push(child, body);
	          }
	        } else {
	          // We are trying to add to the leaf node.
	          // We have to convert current leaf into internal node
	          // and continue adding two nodes.
	          var oldBody = node.body;
	          node.body = null; // internal nodes do not carry bodies

	          if (isSamePosition(oldBody.pos, body.pos)) {
	            // Prevent infinite subdivision by bumping one node
	            // anywhere in this quadrant
	            var retriesCount = 3;
	            do {
	              var offset = random.nextDouble();
	              var dx = (node.right - node.left) * offset;
	              var dy = (node.bottom - node.top) * offset;
	              var dz = (node.front - node.back) * offset;

	              oldBody.pos.x = node.left + dx;
	              oldBody.pos.y = node.top + dy;
	              oldBody.pos.z = node.back + dz;
	              retriesCount -= 1;
	              // Make sure we don't bump it out of the box. If we do, next iteration should fix it
	            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

	            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
	              // This is very bad, we ran out of precision.
	              // if we do not return from the method we'll get into
	              // infinite loop here. So we sacrifice correctness of layout, and keep the app running
	              // Next layout iteration should get larger bounding box in the first step and fix this
	              return;
	            }
	          }
	          // Next iteration should subdivide node further.
	          insertStack.push(node, oldBody);
	          insertStack.push(node, body);
	        }
	      }
	    },

	    update = function(sourceBody) {
	      var queue = updateQueue,
	        v,
	        dx, dy, dz,
	        r, fx = 0,
	        fy = 0,
	        fz = 0,
	        queueLength = 1,
	        shiftIdx = 0,
	        pushIdx = 1;

	      queue[0] = root;

	      while (queueLength) {
	        var node = queue[shiftIdx],
	          body = node.body;

	        queueLength -= 1;
	        shiftIdx += 1;
	        var differentBody = (body !== sourceBody);
	        if (body && differentBody) {
	          // If the current node is a leaf node (and it is not source body),
	          // calculate the force exerted by the current node on body, and add this
	          // amount to body's net force.
	          dx = body.pos.x - sourceBody.pos.x;
	          dy = body.pos.y - sourceBody.pos.y;
	          dz = body.pos.z - sourceBody.pos.z;
	          r = Math.sqrt(dx * dx + dy * dy + dz * dz);

	          if (r === 0) {
	            // Poor man's protection against zero distance.
	            dx = (random.nextDouble() - 0.5) / 50;
	            dy = (random.nextDouble() - 0.5) / 50;
	            dz = (random.nextDouble() - 0.5) / 50;
	            r = Math.sqrt(dx * dx + dy * dy + dz * dz);
	          }

	          // This is standard gravitation force calculation but we divide
	          // by r^3 to save two operations when normalizing force vector.
	          v = gravity * body.mass * sourceBody.mass / (r * r * r);
	          fx += v * dx;
	          fy += v * dy;
	          fz += v * dz;
	        } else if (differentBody) {
	          // Otherwise, calculate the ratio s / r,  where s is the width of the region
	          // represented by the internal node, and r is the distance between the body
	          // and the node's center-of-mass
	          dx = node.massX / node.mass - sourceBody.pos.x;
	          dy = node.massY / node.mass - sourceBody.pos.y;
	          dz = node.massZ / node.mass - sourceBody.pos.z;

	          r = Math.sqrt(dx * dx + dy * dy + dz * dz);

	          if (r === 0) {
	            // Sorry about code duplication. I don't want to create many functions
	            // right away. Just want to see performance first.
	            dx = (random.nextDouble() - 0.5) / 50;
	            dy = (random.nextDouble() - 0.5) / 50;
	            dz = (random.nextDouble() - 0.5) / 50;
	            r = Math.sqrt(dx * dx + dy * dy + dz * dz);
	          }

	          // If s / r < θ, treat this internal node as a single body, and calculate the
	          // force it exerts on sourceBody, and add this amount to sourceBody's net force.
	          if ((node.right - node.left) / r < theta) {
	            // in the if statement above we consider node's width only
	            // because the region was squarified during tree creation.
	            // Thus there is no difference between using width or height.
	            v = gravity * node.mass * sourceBody.mass / (r * r * r);
	            fx += v * dx;
	            fy += v * dy;
	            fz += v * dz;
	          } else {
	            // Otherwise, run the procedure recursively on each of the current node's children.

	            // I intentionally unfolded this loop, to save several CPU cycles.
	            if (node.quad0) {
	              queue[pushIdx] = node.quad0;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad1) {
	              queue[pushIdx] = node.quad1;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad2) {
	              queue[pushIdx] = node.quad2;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad3) {
	              queue[pushIdx] = node.quad3;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad4) {
	              queue[pushIdx] = node.quad4;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad5) {
	              queue[pushIdx] = node.quad5;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad6) {
	              queue[pushIdx] = node.quad6;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	            if (node.quad7) {
	              queue[pushIdx] = node.quad7;
	              queueLength += 1;
	              pushIdx += 1;
	            }
	          }
	        }
	      }

	      sourceBody.force.x += fx;
	      sourceBody.force.y += fy;
	      sourceBody.force.z += fz;
	    },

	    insertBodies = function(bodies) {
	      var x1 = Number.MAX_VALUE,
	        y1 = Number.MAX_VALUE,
	        z1 = Number.MAX_VALUE,
	        x2 = Number.MIN_VALUE,
	        y2 = Number.MIN_VALUE,
	        z2 = Number.MIN_VALUE,
	        i,
	        max = bodies.length;

	      // To reduce quad tree depth we are looking for exact bounding box of all particles.
	      i = max;
	      while (i--) {
	        var pos = bodies[i].pos;
	        var x = pos.x;
	        var y = pos.y;
	        var z = pos.z;
	        if (x < x1) {
	          x1 = x;
	        }
	        if (x > x2) {
	          x2 = x;
	        }
	        if (y < y1) {
	          y1 = y;
	        }
	        if (y > y2) {
	          y2 = y;
	        }
	        if (z < z1) {
	          z1 = z;
	        }
	        if (z > z2) {
	          z2 = z;
	        }
	      }

	      // Squarify the bounds.
	      var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));

	      x2 = x1 + maxSide;
	      y2 = y1 + maxSide;
	      z2 = z1 + maxSide;

	      currentInCache = 0;
	      root = newNode();
	      root.left = x1;
	      root.right = x2;
	      root.top = y1;
	      root.bottom = y2;
	      root.back = z1;
	      root.front = z2;

	      i = max - 1;
	      if (i > 0) {
	        root.body = bodies[i];
	      }
	      while (i--) {
	        insert(bodies[i], root);
	      }
	    };

	  return {
	    insertBodies: insertBodies,
	    updateBodyForce: update,
	    options: function(newOptions) {
	      if (newOptions) {
	        if (typeof newOptions.gravity === 'number') {
	          gravity = newOptions.gravity;
	        }
	        if (typeof newOptions.theta === 'number') {
	          theta = newOptions.theta;
	        }

	        return this;
	      }

	      return {
	        gravity: gravity,
	        theta: theta
	      };
	    }
	  };
	};

	function getChild(node, idx) {
	  if (idx === 0) return node.quad0;
	  if (idx === 1) return node.quad1;
	  if (idx === 2) return node.quad2;
	  if (idx === 3) return node.quad3;
	  if (idx === 4) return node.quad4;
	  if (idx === 5) return node.quad5;
	  if (idx === 6) return node.quad6;
	  if (idx === 7) return node.quad7;
	  return null;
	}

	function setChild(node, idx, child) {
	  if (idx === 0) node.quad0 = child;
	  else if (idx === 1) node.quad1 = child;
	  else if (idx === 2) node.quad2 = child;
	  else if (idx === 3) node.quad3 = child;
	  else if (idx === 4) node.quad4 = child;
	  else if (idx === 5) node.quad5 = child;
	  else if (idx === 6) node.quad6 = child;
	  else if (idx === 7) node.quad7 = child;
	}


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	/**
	 * Internal data structure to represent 3D QuadTree node
	 */
	module.exports = function Node() {
	  // body stored inside this node. In quad tree only leaf nodes (by construction)
	  // contain boides:
	  this.body = null;

	  // Child nodes are stored in quads. Each quad is presented by number:
	  // Behind Z median:
	  // 0 | 1
	  // -----
	  // 2 | 3
	  // In front of Z median:
	  // 4 | 5
	  // -----
	  // 6 | 7
	  this.quad0 = null;
	  this.quad1 = null;
	  this.quad2 = null;
	  this.quad3 = null;
	  this.quad4 = null;
	  this.quad5 = null;
	  this.quad6 = null;
	  this.quad7 = null;

	  // Total mass of current node
	  this.mass = 0;

	  // Center of mass coordinates
	  this.massX = 0;
	  this.massY = 0;
	  this.massZ = 0;

	  // bounding box coordinates
	  this.left = 0;
	  this.top = 0;
	  this.bottom = 0;
	  this.right = 0;
	  this.front = 0;
	  this.back = 0;
	};


/***/ }),
/* 68 */
/***/ (function(module, exports) {

	module.exports = InsertStack;

	/**
	 * Our implementation of QuadTree is non-recursive to avoid GC hit
	 * This data structure represent stack of elements
	 * which we are trying to insert into quad tree.
	 */
	function InsertStack () {
	    this.stack = [];
	    this.popIdx = 0;
	}

	InsertStack.prototype = {
	    isEmpty: function() {
	        return this.popIdx === 0;
	    },
	    push: function (node, body) {
	        var item = this.stack[this.popIdx];
	        if (!item) {
	            // we are trying to avoid memory pressure: create new element
	            // only when absolutely necessary
	            this.stack[this.popIdx] = new InsertStackElement(node, body);
	        } else {
	            item.node = node;
	            item.body = body;
	        }
	        ++this.popIdx;
	    },
	    pop: function () {
	        if (this.popIdx > 0) {
	            return this.stack[--this.popIdx];
	        }
	    },
	    reset: function () {
	        this.popIdx = 0;
	    }
	};

	function InsertStackElement(node, body) {
	    this.node = node; // QuadTree node
	    this.body = body; // physical body which needs to be inserted to node
	}


/***/ }),
/* 69 */
/***/ (function(module, exports) {

	module.exports = function isSamePosition(point1, point2) {
	    var dx = Math.abs(point1.x - point2.x);
	    var dy = Math.abs(point1.y - point2.y);
	    var dz = Math.abs(point1.z - point2.z);

	    return (dx < 1e-8 && dy < 1e-8 && dz < 1e-8);
	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = function (bodies, settings) {
	  var random = __webpack_require__(55).random(42);
	  var boundingBox =  { x1: 0, y1: 0, z1: 0, x2: 0, y2: 0, z2: 0 };

	  return {
	    box: boundingBox,

	    update: updateBoundingBox,

	    reset : function () {
	      boundingBox.x1 = boundingBox.y1 = 0;
	      boundingBox.x2 = boundingBox.y2 = 0;
	      boundingBox.z1 = boundingBox.z2 = 0;
	    },

	    getBestNewPosition: function (neighbors) {
	      var graphRect = boundingBox;

	      var baseX = 0, baseY = 0, baseZ = 0;

	      if (neighbors.length) {
	        for (var i = 0; i < neighbors.length; ++i) {
	          baseX += neighbors[i].pos.x;
	          baseY += neighbors[i].pos.y;
	          baseZ += neighbors[i].pos.z;
	        }

	        baseX /= neighbors.length;
	        baseY /= neighbors.length;
	        baseZ /= neighbors.length;
	      } else {
	        baseX = (graphRect.x1 + graphRect.x2) / 2;
	        baseY = (graphRect.y1 + graphRect.y2) / 2;
	        baseZ = (graphRect.z1 + graphRect.z2) / 2;
	      }

	      var springLength = settings.springLength;
	      return {
	        x: baseX + random.next(springLength) - springLength / 2,
	        y: baseY + random.next(springLength) - springLength / 2,
	        z: baseZ + random.next(springLength) - springLength / 2
	      };
	    }
	  };

	  function updateBoundingBox() {
	    var i = bodies.length;
	    if (i === 0) { return; } // don't have to wory here.

	    var x1 = Number.MAX_VALUE,
	        y1 = Number.MAX_VALUE,
	        z1 = Number.MAX_VALUE,
	        x2 = Number.MIN_VALUE,
	        y2 = Number.MIN_VALUE,
	        z2 = Number.MIN_VALUE;

	    while(i--) {
	      // this is O(n), could it be done faster with quadtree?
	      // how about pinned nodes?
	      var body = bodies[i];
	      if (body.isPinned) {
	        body.pos.x = body.prevPos.x;
	        body.pos.y = body.prevPos.y;
	        body.pos.z = body.prevPos.z;
	      } else {
	        body.prevPos.x = body.pos.x;
	        body.prevPos.y = body.pos.y;
	        body.prevPos.z = body.pos.z;
	      }
	      if (body.pos.x < x1) {
	        x1 = body.pos.x;
	      }
	      if (body.pos.x > x2) {
	        x2 = body.pos.x;
	      }
	      if (body.pos.y < y1) {
	        y1 = body.pos.y;
	      }
	      if (body.pos.y > y2) {
	        y2 = body.pos.y;
	      }
	      if (body.pos.z < z1) {
	        z1 = body.pos.z;
	      }
	      if (body.pos.z > z2) {
	        z2 = body.pos.z;
	      }
	    }

	    boundingBox.x1 = x1;
	    boundingBox.x2 = x2;
	    boundingBox.y1 = y1;
	    boundingBox.y2 = y2;
	    boundingBox.z1 = z1;
	    boundingBox.z2 = z2;
	  }
	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Represents 3d drag force, which reduces force value on each step by given
	 * coefficient.
	 *
	 * @param {Object} options for the drag force
	 * @param {Number=} options.dragCoeff drag force coefficient. 0.1 by default
	 */
	module.exports = function (options) {
	  var merge = __webpack_require__(53),
	      expose = __webpack_require__(52);

	  options = merge(options, {
	    dragCoeff: 0.02
	  });

	  var api = {
	    update : function (body) {
	      body.force.x -= options.dragCoeff * body.velocity.x;
	      body.force.y -= options.dragCoeff * body.velocity.y;
	      body.force.z -= options.dragCoeff * body.velocity.z;
	    }
	  };

	  // let easy access to dragCoeff:
	  expose(options, api, ['dragCoeff']);

	  return api;
	};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Represents 3d spring force, which updates forces acting on two bodies, conntected
	 * by a spring.
	 *
	 * @param {Object} options for the spring force
	 * @param {Number=} options.springCoeff spring force coefficient.
	 * @param {Number=} options.springLength desired length of a spring at rest.
	 */
	module.exports = function (options) {
	  var merge = __webpack_require__(53);
	  var random = __webpack_require__(55).random(42);
	  var expose = __webpack_require__(52);

	  options = merge(options, {
	    springCoeff: 0.0002,
	    springLength: 80
	  });

	  var api = {
	    /**
	     * Upsates forces acting on a spring
	     */
	    update : function (spring) {
	      var body1 = spring.from,
	          body2 = spring.to,
	          length = spring.length < 0 ? options.springLength : spring.length,
	          dx = body2.pos.x - body1.pos.x,
	          dy = body2.pos.y - body1.pos.y,
	          dz = body2.pos.z - body1.pos.z,
	          r = Math.sqrt(dx * dx + dy * dy + dz * dz);

	      if (r === 0) {
	          dx = (random.nextDouble() - 0.5) / 50;
	          dy = (random.nextDouble() - 0.5) / 50;
	          dz = (random.nextDouble() - 0.5) / 50;
	          r = Math.sqrt(dx * dx + dy * dy + dz * dz);
	      }

	      var d = r - length;
	      var coeff = ((!spring.coeff || spring.coeff < 0) ? options.springCoeff : spring.coeff) * d / r * spring.weight;

	      body1.force.x += coeff * dx;
	      body1.force.y += coeff * dy;
	      body1.force.z += coeff * dz;

	      body2.force.x -= coeff * dx;
	      body2.force.y -= coeff * dy;
	      body2.force.z -= coeff * dz;
	    }
	  };

	  expose(options, api, ['springCoeff', 'springLength']);
	  return api;
	}


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var physics = __webpack_require__(64);

	module.exports = function(pos) {
	  return new physics.Body3d(pos);
	}


/***/ }),
/* 74 */
/***/ (function(module, exports) {

	module.exports = integrate;

	function integrate(bodies, timeStep) {
	  var tx = 0, ty = 0, tz = 0,
	      i, max = bodies.length;

	  for (i = 0; i < max; ++i) {
	    var body = bodies[i],
	      coeff = timeStep * timeStep / body.mass;

	    body.pos.x = 2 * body.pos.x - body.prevPos.x + body.force.x * coeff;
	    body.pos.y = 2 * body.pos.y - body.prevPos.y + body.force.y * coeff;
	    body.pos.z = 2 * body.pos.z - body.prevPos.z + body.force.z * coeff;

	    tx += Math.abs(body.pos.x - body.prevPos.x)
	    ty += Math.abs(body.pos.y - body.prevPos.y)
	    tz += Math.abs(body.pos.z - body.prevPos.z)
	  }

	  return (tx * tx + ty * ty + tz * tz)/bodies.length;
	}


/***/ }),
/* 75 */
/***/ (function(module, exports) {

	/**
	 * Performs 3d forces integration, using given timestep. Uses Euler method to solve
	 * differential equation (http://en.wikipedia.org/wiki/Euler_method ).
	 *
	 * @returns {Number} squared distance of total position updates.
	 */

	module.exports = integrate;

	function integrate(bodies, timeStep) {
	  var dx = 0, tx = 0,
	      dy = 0, ty = 0,
	      dz = 0, tz = 0,
	      i,
	      max = bodies.length;

	  for (i = 0; i < max; ++i) {
	    var body = bodies[i],
	        coeff = timeStep / body.mass;

	    body.velocity.x += coeff * body.force.x;
	    body.velocity.y += coeff * body.force.y;
	    body.velocity.z += coeff * body.force.z;

	    var vx = body.velocity.x,
	        vy = body.velocity.y,
	        vz = body.velocity.z,
	        v = Math.sqrt(vx * vx + vy * vy + vz * vz);

	    if (v > 1) {
	      body.velocity.x = vx / v;
	      body.velocity.y = vy / v;
	      body.velocity.z = vz / v;
	    }

	    dx = timeStep * body.velocity.x;
	    dy = timeStep * body.velocity.y;
	    dz = timeStep * body.velocity.z;

	    body.pos.x += dx;
	    body.pos.y += dy;
	    body.pos.z += dz;

	    tx += Math.abs(dx); ty += Math.abs(dy); tz += Math.abs(dz);
	  }

	  return (tx * tx + ty * ty + tz * tz)/bodies.length;
	}


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var debounce = _interopDefault(__webpack_require__(77));

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
	    return;
	  }

	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	var Prop = function Prop(name, _ref) {
	  var _ref$default = _ref["default"],
	      defaultVal = _ref$default === void 0 ? null : _ref$default,
	      _ref$triggerUpdate = _ref.triggerUpdate,
	      triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,
	      _ref$onChange = _ref.onChange,
	      onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;

	  _classCallCheck(this, Prop);

	  this.name = name;
	  this.defaultVal = defaultVal;
	  this.triggerUpdate = triggerUpdate;
	  this.onChange = onChange;
	};

	function index (_ref2) {
	  var _ref2$stateInit = _ref2.stateInit,
	      stateInit = _ref2$stateInit === void 0 ? function () {
	    return {};
	  } : _ref2$stateInit,
	      _ref2$props = _ref2.props,
	      rawProps = _ref2$props === void 0 ? {} : _ref2$props,
	      _ref2$methods = _ref2.methods,
	      methods = _ref2$methods === void 0 ? {} : _ref2$methods,
	      _ref2$aliases = _ref2.aliases,
	      aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,
	      _ref2$init = _ref2.init,
	      initFn = _ref2$init === void 0 ? function () {} : _ref2$init,
	      _ref2$update = _ref2.update,
	      updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;
	  // Parse props into Prop instances
	  var props = Object.keys(rawProps).map(function (propName) {
	    return new Prop(propName, rawProps[propName]);
	  });
	  return function () {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    // Holds component state
	    var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit, // Support plain objects for backwards compatibility
	    {
	      initialised: false
	    }); // keeps track of which props triggered an update

	    var changedProps = {}; // Component constructor

	    function comp(nodeElement) {
	      initStatic(nodeElement, options);
	      digest();
	      return comp;
	    }

	    var initStatic = function initStatic(nodeElement, options) {
	      initFn.call(comp, nodeElement, state, options);
	      state.initialised = true;
	    };

	    var digest = debounce(function () {
	      if (!state.initialised) {
	        return;
	      }

	      updateFn.call(comp, state, changedProps);
	      changedProps = {};
	    }, 1); // Getter/setter methods

	    props.forEach(function (prop) {
	      comp[prop.name] = getSetProp(prop);

	      function getSetProp(_ref3) {
	        var prop = _ref3.name,
	            _ref3$triggerUpdate = _ref3.triggerUpdate,
	            redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,
	            _ref3$onChange = _ref3.onChange,
	            onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,
	            _ref3$defaultVal = _ref3.defaultVal,
	            defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
	        return function (_) {
	          var curVal = state[prop];

	          if (!arguments.length) {
	            return curVal;
	          } // Getter mode


	          var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined

	          state[prop] = val;
	          onChange.call(comp, val, state, curVal); // track changed props

	          !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);

	          if (redigest) {
	            digest();
	          }

	          return comp;
	        };
	      }
	    }); // Other methods

	    Object.keys(methods).forEach(function (methodName) {
	      comp[methodName] = function () {
	        var _methods$methodName;

	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));
	      };
	    }); // Link aliases

	    Object.entries(aliases).forEach(function (_ref4) {
	      var _ref5 = _slicedToArray(_ref4, 2),
	          alias = _ref5[0],
	          target = _ref5[1];

	      return comp[alias] = comp[target];
	    }); // Reset all component props to their default value

	    comp.resetProps = function () {
	      props.forEach(function (prop) {
	        comp[prop.name](prop.defaultVal);
	      });
	      return comp;
	    }; //


	    comp.resetProps(); // Apply all prop defaults

	    state._rerender = digest; // Expose digest method

	    return comp;
	  };
	}

	module.exports = index;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

	/**
	 * Returns a function, that, as long as it continues to be invoked, will not
	 * be triggered. The function will be called after it stops being called for
	 * N milliseconds. If `immediate` is passed, trigger the function on the
	 * leading edge, instead of the trailing. The function also has a property 'clear' 
	 * that is a function which will clear the timer to prevent previously scheduled executions. 
	 *
	 * @source underscore.js
	 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
	 * @param {Function} function to wrap
	 * @param {Number} timeout in ms (`100`)
	 * @param {Boolean} whether to execute at the beginning (`false`)
	 * @api public
	 */
	function debounce(func, wait, immediate){
	  var timeout, args, context, timestamp, result;
	  if (null == wait) wait = 100;

	  function later() {
	    var last = Date.now() - timestamp;

	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      if (!immediate) {
	        result = func.apply(context, args);
	        context = args = null;
	      }
	    }
	  };

	  var debounced = function(){
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    var callNow = immediate && !timeout;
	    if (!timeout) timeout = setTimeout(later, wait);
	    if (callNow) {
	      result = func.apply(context, args);
	      context = args = null;
	    }

	    return result;
	  };

	  debounced.clear = function() {
	    if (timeout) {
	      clearTimeout(timeout);
	      timeout = null;
	    }
	  };
	  
	  debounced.flush = function() {
	    if (timeout) {
	      result = func.apply(context, args);
	      context = args = null;
	      
	      clearTimeout(timeout);
	      timeout = null;
	    }
	  };

	  return debounced;
	};

	// Adds compatibility for ES modules
	debounce.debounce = debounce;

	module.exports = debounce;


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	'use strict';

	var index = (function (p) {
	  return p instanceof Function ? p // fn
	  : typeof p === 'string' ? function (obj) {
	    return obj[p];
	  } // property name
	  : function (obj) {
	    return p;
	  };
	}); // constant

	module.exports = index;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var indexBy = _interopDefault(__webpack_require__(80));

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
	    return;
	  }

	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	function diffArrays(prev, next, idAccessor) {
	  var result = {
	    enter: [],
	    update: [],
	    exit: []
	  };

	  if (!idAccessor) {
	    // use object references for comparison
	    var prevSet = new Set(prev);
	    var nextSet = new Set(next);
	    new Set([].concat(_toConsumableArray(prevSet), _toConsumableArray(nextSet))).forEach(function (item) {
	      var type = !prevSet.has(item) ? 'enter' : !nextSet.has(item) ? 'exit' : 'update';
	      result[type].push(type === 'update' ? [item, item] : item);
	    });
	  } else {
	    // compare by id (duplicate keys are ignored)
	    var prevById = indexBy(prev, idAccessor, false);
	    var nextById = indexBy(next, idAccessor, false);
	    var byId = Object.assign({}, prevById, nextById);
	    Object.entries(byId).forEach(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 2),
	          id = _ref2[0],
	          item = _ref2[1];

	      var type = !prevById.hasOwnProperty(id) ? 'enter' : !nextById.hasOwnProperty(id) ? 'exit' : 'update';
	      result[type].push(type === 'update' ? [prevById[id], nextById[id]] : item);
	    });
	  }

	  return result;
	}

	function dataBindDiff(data, existingObjs, _ref3) {
	  var _ref3$objBindAttr = _ref3.objBindAttr,
	      objBindAttr = _ref3$objBindAttr === void 0 ? '__obj' : _ref3$objBindAttr,
	      _ref3$dataBindAttr = _ref3.dataBindAttr,
	      dataBindAttr = _ref3$dataBindAttr === void 0 ? '__data' : _ref3$dataBindAttr,
	      idAccessor = _ref3.idAccessor,
	      _ref3$purge = _ref3.purge,
	      purge = _ref3$purge === void 0 ? false : _ref3$purge;

	  var isObjValid = function isObjValid(obj) {
	    return obj.hasOwnProperty(dataBindAttr);
	  };

	  var removeObjs = existingObjs.filter(function (obj) {
	    return !isObjValid(obj);
	  });
	  var prevD = existingObjs.filter(isObjValid).map(function (obj) {
	    return obj[dataBindAttr];
	  });
	  var nextD = data;
	  var diff = purge ? {
	    enter: nextD,
	    exit: prevD,
	    update: []
	  } // don't diff data in purge mode
	  : diffArrays(prevD, nextD, idAccessor);
	  diff.update = diff.update.map(function (_ref4) {
	    var _ref5 = _slicedToArray(_ref4, 2),
	        prevD = _ref5[0],
	        nextD = _ref5[1];

	    if (prevD !== nextD) {
	      // transfer obj to new data point (if different)
	      nextD[objBindAttr] = prevD[objBindAttr];
	      nextD[objBindAttr][dataBindAttr] = nextD;
	    }

	    return nextD;
	  });
	  diff.exit = diff.exit.concat(removeObjs.map(function (obj) {
	    return _defineProperty({}, objBindAttr, obj);
	  }));
	  return diff;
	}

	function viewDigest(data, existingObjs, // list
	appendObj, // item => {...} function
	removeObj, // item => {...} function
	_ref7) {
	  var _ref7$createObj = _ref7.createObj,
	      createObj = _ref7$createObj === void 0 ? function (d) {
	    return {};
	  } : _ref7$createObj,
	      _ref7$updateObj = _ref7.updateObj,
	      updateObj = _ref7$updateObj === void 0 ? function (obj, d) {} : _ref7$updateObj,
	      _ref7$exitObj = _ref7.exitObj,
	      exitObj = _ref7$exitObj === void 0 ? function (obj) {} : _ref7$exitObj,
	      _ref7$objBindAttr = _ref7.objBindAttr,
	      objBindAttr = _ref7$objBindAttr === void 0 ? '__obj' : _ref7$objBindAttr,
	      _ref7$dataBindAttr = _ref7.dataBindAttr,
	      dataBindAttr = _ref7$dataBindAttr === void 0 ? '__data' : _ref7$dataBindAttr,
	      dataDiffOptions = _objectWithoutProperties(_ref7, ["createObj", "updateObj", "exitObj", "objBindAttr", "dataBindAttr"]);

	  var _dataBindDiff = dataBindDiff(data, existingObjs, _objectSpread2({
	    objBindAttr: objBindAttr,
	    dataBindAttr: dataBindAttr
	  }, dataDiffOptions)),
	      enter = _dataBindDiff.enter,
	      update = _dataBindDiff.update,
	      exit = _dataBindDiff.exit; // Remove exiting points


	  exit.forEach(function (d) {
	    var obj = d[objBindAttr];
	    delete d[objBindAttr]; // unbind obj

	    exitObj(obj);
	    removeObj(obj);
	  });
	  var newObjs = createObjs(enter);
	  var pointsData = [].concat(_toConsumableArray(enter), _toConsumableArray(update));
	  updateObjs(pointsData); // Add new points

	  newObjs.forEach(appendObj); //

	  function createObjs(data) {
	    var newObjs = [];
	    data.forEach(function (d) {
	      var obj = createObj(d);

	      if (obj) {
	        obj[dataBindAttr] = d;
	        d[objBindAttr] = obj;
	        newObjs.push(obj);
	      }
	    });
	    return newObjs;
	  }

	  function updateObjs(data) {
	    data.forEach(function (d) {
	      var obj = d[objBindAttr];

	      if (obj) {
	        obj[dataBindAttr] = d;
	        updateObj(obj, d);
	      }
	    });
	  }
	}

	module.exports = viewDigest;


/***/ }),
/* 80 */
/***/ (function(module, exports) {

	'use strict';

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
	    return;
	  }

	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];

	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }

	  return (hint === "string" ? String : Number)(input);
	}

	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");

	  return typeof key === "symbol" ? key : String(key);
	}

	var index = (function () {
	  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  var keyAccessors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var multiItem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  var flattenKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	  var keys = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [undefined] : [keyAccessors]).map(function (key) {
	    return {
	      keyAccessor: key,
	      isProp: !(key instanceof Function)
	    };
	  });
	  var indexedResult = list.reduce(function (res, item) {
	    var iterObj = res;
	    var itemVal = item;
	    keys.forEach(function (_ref, idx) {
	      var keyAccessor = _ref.keyAccessor,
	          isProp = _ref.isProp;
	      var key;

	      if (isProp) {
	        var _itemVal = itemVal,
	            propVal = _itemVal[keyAccessor],
	            rest = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey));

	        key = propVal;
	        itemVal = rest;
	      } else {
	        key = keyAccessor(itemVal, idx);
	      }

	      if (idx + 1 < keys.length) {
	        if (!iterObj.hasOwnProperty(key)) {
	          iterObj[key] = {};
	        }

	        iterObj = iterObj[key];
	      } else {
	        // Leaf key
	        if (multiItem) {
	          if (!iterObj.hasOwnProperty(key)) {
	            iterObj[key] = [];
	          }

	          iterObj[key].push(itemVal);
	        } else {
	          iterObj[key] = itemVal;
	        }
	      }
	    });
	    return res;
	  }, {});

	  if (multiItem instanceof Function) {
	    // Reduce leaf multiple values
	    (function reduce(node) {
	      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	      if (level === keys.length) {
	        Object.keys(node).forEach(function (k) {
	          return node[k] = multiItem(node[k]);
	        });
	      } else {
	        Object.values(node).forEach(function (child) {
	          return reduce(child, level + 1);
	        });
	      }
	    })(indexedResult); // IIFE

	  }

	  var result = indexedResult;

	  if (flattenKeys) {
	    // flatten into array
	    result = [];

	    (function flatten(node) {
	      var accKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	      if (accKeys.length === keys.length) {
	        result.push({
	          keys: accKeys,
	          vals: node
	        });
	      } else {
	        Object.entries(node).forEach(function (_ref2) {
	          var _ref3 = _slicedToArray(_ref2, 2),
	              key = _ref3[0],
	              val = _ref3[1];

	          return flatten(val, [].concat(_toConsumableArray(accKeys), [key]));
	        });
	      }
	    })(indexedResult); //IIFE


	    if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) {
	      // clear keys if there's no key accessors (single result)
	      result[0].keys = [];
	    }
	  }

	  return result;
	});

	module.exports = index;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale/ v3.2.1 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(82), __webpack_require__(12), __webpack_require__(27), __webpack_require__(34), __webpack_require__(35)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Array, d3Interpolate, d3Format, d3Time, d3TimeFormat) { 'use strict';

	function initRange(domain, range) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.range(domain); break;
	    default: this.range(range).domain(domain); break;
	  }
	  return this;
	}

	function initInterpolator(domain, interpolator) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: {
	      if (typeof domain === "function") this.interpolator(domain);
	      else this.range(domain);
	      break;
	    }
	    default: {
	      this.domain(domain);
	      if (typeof interpolator === "function") this.interpolator(interpolator);
	      else this.range(interpolator);
	      break;
	    }
	  }
	  return this;
	}

	const implicit = Symbol("implicit");

	function ordinal() {
	  var index = new Map(),
	      domain = [],
	      range = [],
	      unknown = implicit;

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range[(i - 1) % range.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = new Map();
	    for (const value of _) {
	      const key = value + "";
	      if (index.has(key)) continue;
	      index.set(key, domain.push(value));
	    }
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), scale) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal(domain, range).unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      r0 = 0,
	      r1 = 1,
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = r1 < r0,
	        start = reverse ? r1 : r0,
	        stop = reverse ? r0 : r1;
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = d3Array.range(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
	  };

	  scale.rangeRound = function(_) {
	    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band(domain(), [r0, r1])
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return initRange.apply(rescale(), arguments);
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point() {
	  return pointish(band.apply(null, arguments).paddingInner(1));
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function number(x) {
	  return +x;
	}

	var unit = [0, 1];

	function identity(x) {
	  return x;
	}

	function normalize(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant(isNaN(b) ? NaN : 0.5);
	}

	function clamper(a, b) {
	  var t;
	  if (a > b) t = a, a = b, b = t;
	  return function(x) { return Math.max(a, Math.min(b, x)); };
	}

	// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
	function bimap(domain, range, interpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, interpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = normalize(domain[i], domain[i + 1]);
	    r[i] = interpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = d3Array.bisect(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function transformer() {
	  var domain = unit,
	      range = unit,
	      interpolate = d3Interpolate.interpolate,
	      transform,
	      untransform,
	      unknown,
	      clamp = identity,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    var n = Math.min(domain.length, range.length);
	    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
	    piecewise = n > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
	  }

	  scale.invert = function(y) {
	    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = Array.from(_), interpolate = d3Interpolate.interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, rescale()) : interpolate;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t, u) {
	    transform = t, untransform = u;
	    return rescale();
	  };
	}

	function continuous() {
	  return transformer()(identity, identity);
	}

	function tickFormat(start, stop, count, specifier) {
	  var step = d3Array.tickStep(start, stop, count),
	      precision;
	  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
	      return d3Format.formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return d3Format.format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    var d = domain();
	    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = d3Array.tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = d3Array.tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = d3Array.tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear() {
	  var scale = continuous();

	  scale.copy = function() {
	    return copy(scale, linear());
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function identity$1(domain) {
	  var unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : x;
	  }

	  scale.invert = scale;

	  scale.domain = scale.range = function(_) {
	    return arguments.length ? (domain = Array.from(_, number), scale) : domain.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return identity$1(domain).unknown(unknown);
	  };

	  domain = arguments.length ? Array.from(domain, number) : [0, 1];

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function transformLog(x) {
	  return Math.log(x);
	}

	function transformExp(x) {
	  return Math.exp(x);
	}

	function transformLogn(x) {
	  return -Math.log(-x);
	}

	function transformExpn(x) {
	  return -Math.exp(-x);
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function loggish(transform) {
	  var scale = transform(transformLog, transformExp),
	      domain = scale.domain,
	      base = 10,
	      logs,
	      pows;

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) {
	      logs = reflect(logs), pows = reflect(pows);
	      transform(transformLogn, transformExpn);
	    } else {
	      transform(transformLog, transformExp);
	    }
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.floor(i), j = Math.ceil(j);
	      if (u > 0) for (; i <= j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i <= j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	      if (z.length * 2 < n) z = d3Array.ticks(u, v, n);
	    } else {
	      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  return scale;
	}

	function log() {
	  var scale = loggish(transformer()).domain([1, 10]);

	  scale.copy = function() {
	    return copy(scale, log()).base(scale.base());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function transformSymlog(c) {
	  return function(x) {
	    return Math.sign(x) * Math.log1p(Math.abs(x / c));
	  };
	}

	function transformSymexp(c) {
	  return function(x) {
	    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
	  };
	}

	function symlogish(transform) {
	  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

	  scale.constant = function(_) {
	    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
	  };

	  return linearish(scale);
	}

	function symlog() {
	  var scale = symlogish(transformer());

	  scale.copy = function() {
	    return copy(scale, symlog()).constant(scale.constant());
	  };

	  return initRange.apply(scale, arguments);
	}

	function transformPow(exponent) {
	  return function(x) {
	    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	  };
	}

	function transformSqrt(x) {
	  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
	}

	function transformSquare(x) {
	  return x < 0 ? -x * x : x * x;
	}

	function powish(transform) {
	  var scale = transform(identity, identity),
	      exponent = 1;

	  function rescale() {
	    return exponent === 1 ? transform(identity, identity)
	        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
	        : transform(transformPow(exponent), transformPow(1 / exponent));
	  }

	  scale.exponent = function(_) {
	    return arguments.length ? (exponent = +_, rescale()) : exponent;
	  };

	  return linearish(scale);
	}

	function pow() {
	  var scale = powish(transformer());

	  scale.copy = function() {
	    return copy(scale, pow()).exponent(scale.exponent());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function sqrt() {
	  return pow.apply(null, arguments).exponent(0.5);
	}

	function square(x) {
	  return Math.sign(x) * x * x;
	}

	function unsquare(x) {
	  return Math.sign(x) * Math.sqrt(Math.abs(x));
	}

	function radial() {
	  var squared = continuous(),
	      range = [0, 1],
	      round = false,
	      unknown;

	  function scale(x) {
	    var y = unsquare(squared(x));
	    return isNaN(y) ? unknown : round ? Math.round(y) : y;
	  }

	  scale.invert = function(y) {
	    return squared.invert(square(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (squared.domain(_), scale) : squared.domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (squared.range((range = Array.from(_, number)).map(square)), scale) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return scale.range(_).round(true);
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, scale) : round;
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return radial(squared.domain(), range)
	        .round(round)
	        .clamp(squared.clamp())
	        .unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function quantile() {
	  var domain = [],
	      range = [],
	      thresholds = [],
	      unknown;

	  function rescale() {
	    var i = 0, n = Math.max(1, range.length);
	    thresholds = new Array(n - 1);
	    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
	  }

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN] : [
	      i > 0 ? thresholds[i - 1] : domain[0],
	      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	    ];
	  };

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return rescale();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.quantiles = function() {
	    return thresholds.slice();
	  };

	  scale.copy = function() {
	    return quantile()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	function quantize() {
	  var x0 = 0,
	      x1 = 1,
	      n = 1,
	      domain = [0.5],
	      range = [0, 1],
	      unknown;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  function rescale() {
	    var i = -1;
	    domain = new Array(n);
	    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	    return scale;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
	  };

	  scale.range = function(_) {
	    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN]
	        : i < 1 ? [x0, domain[0]]
	        : i >= n ? [domain[n - 1], x1]
	        : [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : scale;
	  };

	  scale.thresholds = function() {
	    return domain.slice();
	  };

	  scale.copy = function() {
	    return quantize()
	        .domain([x0, x1])
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(linearish(scale), arguments);
	}

	function threshold() {
	  var domain = [0.5],
	      range = [0, 1],
	      unknown,
	      n = 1;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return threshold()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	var durationSecond = 1000,
	    durationMinute = durationSecond * 60,
	    durationHour = durationMinute * 60,
	    durationDay = durationHour * 24,
	    durationWeek = durationDay * 7,
	    durationMonth = durationDay * 30,
	    durationYear = durationDay * 365;

	function date(t) {
	  return new Date(t);
	}

	function number$1(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	  var scale = continuous(),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format(".%L"),
	      formatSecond = format(":%S"),
	      formatMinute = format("%I:%M"),
	      formatHour = format("%I %p"),
	      formatDay = format("%a %d"),
	      formatWeek = format("%b %d"),
	      formatMonth = format("%B"),
	      formatYear = format("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond],
	    [second,  5,  5 * durationSecond],
	    [second, 15, 15 * durationSecond],
	    [second, 30, 30 * durationSecond],
	    [minute,  1,      durationMinute],
	    [minute,  5,  5 * durationMinute],
	    [minute, 15, 15 * durationMinute],
	    [minute, 30, 30 * durationMinute],
	    [  hour,  1,      durationHour  ],
	    [  hour,  3,  3 * durationHour  ],
	    [  hour,  6,  6 * durationHour  ],
	    [  hour, 12, 12 * durationHour  ],
	    [   day,  1,      durationDay   ],
	    [   day,  2,  2 * durationDay   ],
	    [  week,  1,      durationWeek  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target),
	          step;
	      if (i === tickIntervals.length) {
	        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	      return interval.every(step);
	    }

	    return interval;
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date);
	  };

	  scale.ticks = function(interval) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format(specifier);
	  };

	  scale.nice = function(interval) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1]))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	  };

	  return scale;
	}

	function time() {
	  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
	}

	function utcTime() {
	  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
	}

	function transformer$1() {
	  var x0 = 0,
	      x1 = 1,
	      t0,
	      t1,
	      k10,
	      transform,
	      interpolator = identity,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  function range(interpolate) {
	    return function(_) {
	      var r0, r1;
	      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
	    };
	  }

	  scale.range = range(d3Interpolate.interpolate);

	  scale.rangeRound = range(d3Interpolate.interpolateRound);

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
	    return scale;
	  };
	}

	function copy$1(source, target) {
	  return target
	      .domain(source.domain())
	      .interpolator(source.interpolator())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function sequential() {
	  var scale = linearish(transformer$1()(identity));

	  scale.copy = function() {
	    return copy$1(scale, sequential());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialLog() {
	  var scale = loggish(transformer$1()).domain([1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, sequentialLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSymlog() {
	  var scale = symlogish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialPow() {
	  var scale = powish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSqrt() {
	  return sequentialPow.apply(null, arguments).exponent(0.5);
	}

	function sequentialQuantile() {
	  var domain = [],
	      interpolator = identity;

	  function scale(x) {
	    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x, 1) - 1) / (domain.length - 1));
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return scale;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.range = function() {
	    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
	  };

	  scale.quantiles = function(n) {
	    return Array.from({length: n + 1}, (_, i) => d3Array.quantile(domain, i / n));
	  };

	  scale.copy = function() {
	    return sequentialQuantile(interpolator).domain(domain);
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function transformer$2() {
	  var x0 = 0,
	      x1 = 0.5,
	      x2 = 1,
	      s = 1,
	      t0,
	      t1,
	      t2,
	      k10,
	      k21,
	      interpolator = identity,
	      transform,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  function range(interpolate) {
	    return function(_) {
	      var r0, r1, r2;
	      return arguments.length ? ([r0, r1, r2] = _, interpolator = d3Interpolate.piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
	    };
	  }

	  scale.range = range(d3Interpolate.interpolate);

	  scale.rangeRound = range(d3Interpolate.interpolateRound);

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
	    return scale;
	  };
	}

	function diverging() {
	  var scale = linearish(transformer$2()(identity));

	  scale.copy = function() {
	    return copy$1(scale, diverging());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingLog() {
	  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, divergingLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSymlog() {
	  var scale = symlogish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingPow() {
	  var scale = powish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSqrt() {
	  return divergingPow.apply(null, arguments).exponent(0.5);
	}

	exports.scaleBand = band;
	exports.scaleDiverging = diverging;
	exports.scaleDivergingLog = divergingLog;
	exports.scaleDivergingPow = divergingPow;
	exports.scaleDivergingSqrt = divergingSqrt;
	exports.scaleDivergingSymlog = divergingSymlog;
	exports.scaleIdentity = identity$1;
	exports.scaleImplicit = implicit;
	exports.scaleLinear = linear;
	exports.scaleLog = log;
	exports.scaleOrdinal = ordinal;
	exports.scalePoint = point;
	exports.scalePow = pow;
	exports.scaleQuantile = quantile;
	exports.scaleQuantize = quantize;
	exports.scaleRadial = radial;
	exports.scaleSequential = sequential;
	exports.scaleSequentialLog = sequentialLog;
	exports.scaleSequentialPow = sequentialPow;
	exports.scaleSequentialQuantile = sequentialQuantile;
	exports.scaleSequentialSqrt = sequentialSqrt;
	exports.scaleSequentialSymlog = sequentialSymlog;
	exports.scaleSqrt = sqrt;
	exports.scaleSymlog = symlog;
	exports.scaleThreshold = threshold;
	exports.scaleTime = time;
	exports.scaleUtc = utcTime;
	exports.tickFormat = tickFormat;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v2.4.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function count(values, valueof) {
	  let count = 0;
	  if (valueof === undefined) {
	    for (let value of values) {
	      if (value != null && (value = +value) >= value) {
	        ++count;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
	        ++count;
	      }
	    }
	  }
	  return count;
	}

	function length(array) {
	  return array.length | 0;
	}

	function empty(length) {
	  return !(length > 0);
	}

	function arrayify(values) {
	  return typeof values !== "object" || "length" in values ? values : Array.from(values);
	}

	function reducer(reduce) {
	  return values => reduce(...values);
	}

	function cross(...values) {
	  const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
	  values = values.map(arrayify);
	  const lengths = values.map(length);
	  const j = values.length - 1;
	  const index = new Array(j + 1).fill(0);
	  const product = [];
	  if (j < 0 || lengths.some(empty)) return product;
	  while (true) {
	    product.push(index.map((j, i) => values[i][j]));
	    let i = j;
	    while (++index[i] === lengths[i]) {
	      if (i === 0) return reduce ? product.map(reduce) : product;
	      index[i--] = 0;
	    }
	  }
	}

	function cumsum(values, valueof) {
	  var sum = 0, index = 0;
	  return Float64Array.from(values, valueof === undefined
	    ? v => (sum += +v || 0)
	    : v => (sum += +valueof(v, index++, values) || 0));
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function variance(values, valueof) {
	  let count = 0;
	  let delta;
	  let mean = 0;
	  let sum = 0;
	  if (valueof === undefined) {
	    for (let value of values) {
	      if (value != null && (value = +value) >= value) {
	        delta = value - mean;
	        mean += delta / ++count;
	        sum += delta * (value - mean);
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
	        delta = value - mean;
	        mean += delta / ++count;
	        sum += delta * (value - mean);
	      }
	    }
	  }
	  if (count > 1) return sum / (count - 1);
	}

	function deviation(values, valueof) {
	  const v = variance(values, valueof);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  let min;
	  let max;
	  if (valueof === undefined) {
	    for (const value of values) {
	      if (value != null) {
	        if (min === undefined) {
	          if (value >= value) min = max = value;
	        } else {
	          if (min > value) min = value;
	          if (max < value) max = value;
	        }
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null) {
	        if (min === undefined) {
	          if (value >= value) min = max = value;
	        } else {
	          if (min > value) min = value;
	          if (max < value) max = value;
	        }
	      }
	    }
	  }
	  return [min, max];
	}

	function identity(x) {
	  return x;
	}

	function group(values, ...keys) {
	  return nest(values, identity, identity, keys);
	}

	function groups(values, ...keys) {
	  return nest(values, Array.from, identity, keys);
	}

	function rollup(values, reduce, ...keys) {
	  return nest(values, identity, reduce, keys);
	}

	function rollups(values, reduce, ...keys) {
	  return nest(values, Array.from, reduce, keys);
	}

	function nest(values, map, reduce, keys) {
	  return (function regroup(values, i) {
	    if (i >= keys.length) return reduce(values);
	    const groups = new Map();
	    const keyof = keys[i++];
	    let index = -1;
	    for (const value of values) {
	      const key = keyof(value, ++index, values);
	      const group = groups.get(key);
	      if (group) group.push(value);
	      else groups.set(key, [value]);
	    }
	    for (const [key, values] of groups) {
	      groups.set(key, regroup(values, i));
	    }
	    return map(groups);
	  })(values, 0);
	}

	var array = Array.prototype;

	var slice = array.slice;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
	}

	function bin() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    if (!Array.isArray(data)) data = Array.from(data);

	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function max(values, valueof) {
	  let max;
	  if (valueof === undefined) {
	    for (const value of values) {
	      if (value != null
	          && (max < value || (max === undefined && value >= value))) {
	        max = value;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null
	          && (max < value || (max === undefined && value >= value))) {
	        max = value;
	      }
	    }
	  }
	  return max;
	}

	function min(values, valueof) {
	  let min;
	  if (valueof === undefined) {
	    for (const value of values) {
	      if (value != null
	          && (min > value || (min === undefined && value >= value))) {
	        min = value;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null
	          && (min > value || (min === undefined && value >= value))) {
	        min = value;
	      }
	    }
	  }
	  return min;
	}

	// Based on https://github.com/mourner/quickselect
	// ISC license, Copyright 2018 Vladimir Agafonkin.
	function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
	  while (right > left) {
	    if (right - left > 600) {
	      const n = right - left + 1;
	      const m = k - left + 1;
	      const z = Math.log(n);
	      const s = 0.5 * Math.exp(2 * z / 3);
	      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	      quickselect(array, k, newLeft, newRight, compare);
	    }

	    const t = array[k];
	    let i = left;
	    let j = right;

	    swap(array, left, k);
	    if (compare(array[right], t) > 0) swap(array, left, right);

	    while (i < j) {
	      swap(array, i, j), ++i, --j;
	      while (compare(array[i], t) < 0) ++i;
	      while (compare(array[j], t) > 0) --j;
	    }

	    if (compare(array[left], t) === 0) swap(array, left, j);
	    else ++j, swap(array, j, right);

	    if (j <= k) left = j + 1;
	    if (k <= j) right = j - 1;
	  }
	  return array;
	}

	function swap(array, i, j) {
	  const t = array[i];
	  array[i] = array[j];
	  array[j] = t;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function* numbers(values, valueof) {
	  if (valueof === undefined) {
	    for (let value of values) {
	      if (value != null && (value = +value) >= value) {
	        yield value;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
	        yield value;
	      }
	    }
	  }
	}

	function quantile(values, p, valueof) {
	  values = Float64Array.from(numbers(values, valueof));
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return min(values);
	  if (p >= 1) return max(values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
	      value1 = min(values.subarray(i0 + 1));
	  return value0 + (value1 - value0) * (i - i0);
	}

	function quantileSorted(values, p, valueof = number) {
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
	}

	function maxIndex(values, valueof) {
	  let max;
	  let maxIndex = -1;
	  let index = -1;
	  if (valueof === undefined) {
	    for (const value of values) {
	      ++index;
	      if (value != null
	          && (max < value || (max === undefined && value >= value))) {
	        max = value, maxIndex = index;
	      }
	    }
	  } else {
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null
	          && (max < value || (max === undefined && value >= value))) {
	        max = value, maxIndex = index;
	      }
	    }
	  }
	  return maxIndex;
	}

	function mean(values, valueof) {
	  let count = 0;
	  let sum = 0;
	  if (valueof === undefined) {
	    for (let value of values) {
	      if (value != null && (value = +value) >= value) {
	        ++count, sum += value;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
	        ++count, sum += value;
	      }
	    }
	  }
	  if (count) return sum / count;
	}

	function median(values, valueof) {
	  return quantile(values, 0.5, valueof);
	}

	function* flatten(arrays) {
	  for (const array of arrays) {
	    yield* array;
	  }
	}

	function merge(arrays) {
	  return Array.from(flatten(arrays));
	}

	function minIndex(values, valueof) {
	  let min;
	  let minIndex = -1;
	  let index = -1;
	  if (valueof === undefined) {
	    for (const value of values) {
	      ++index;
	      if (value != null
	          && (min > value || (min === undefined && value >= value))) {
	        min = value, minIndex = index;
	      }
	    }
	  } else {
	    for (let value of values) {
	      if ((value = valueof(value, ++index, values)) != null
	          && (min > value || (min === undefined && value >= value))) {
	        min = value, minIndex = index;
	      }
	    }
	  }
	  return minIndex;
	}

	function pairs(values, pairof = pair) {
	  const pairs = [];
	  let previous;
	  let first = false;
	  for (const value of values) {
	    if (first) pairs.push(pairof(previous, value));
	    previous = value;
	    first = true;
	  }
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function permute(source, keys) {
	  return Array.from(keys, key => source[key]);
	}

	function least(values, compare = ascending) {
	  let min;
	  let defined = false;
	  if (compare.length === 1) {
	    let minValue;
	    for (const element of values) {
	      const value = compare(element);
	      if (defined
	          ? ascending(value, minValue) < 0
	          : ascending(value, value) === 0) {
	        min = element;
	        minValue = value;
	        defined = true;
	      }
	    }
	  } else {
	    for (const value of values) {
	      if (defined
	          ? compare(value, min) < 0
	          : compare(value, value) === 0) {
	        min = value;
	        defined = true;
	      }
	    }
	  }
	  return min;
	}

	function leastIndex(values, compare = ascending) {
	  if (compare.length === 1) return minIndex(values, compare);
	  let minValue;
	  let min = -1;
	  let index = -1;
	  for (const value of values) {
	    ++index;
	    if (min < 0
	        ? compare(value, value) === 0
	        : compare(value, minValue) < 0) {
	      minValue = value;
	      min = index;
	    }
	  }
	  return min;
	}

	function greatest(values, compare = ascending) {
	  let max;
	  let defined = false;
	  if (compare.length === 1) {
	    let maxValue;
	    for (const element of values) {
	      const value = compare(element);
	      if (defined
	          ? ascending(value, maxValue) > 0
	          : ascending(value, value) === 0) {
	        max = element;
	        maxValue = value;
	        defined = true;
	      }
	    }
	  } else {
	    for (const value of values) {
	      if (defined
	          ? compare(value, max) > 0
	          : compare(value, value) === 0) {
	        max = value;
	        defined = true;
	      }
	    }
	  }
	  return max;
	}

	function greatestIndex(values, compare = ascending) {
	  if (compare.length === 1) return maxIndex(values, compare);
	  let maxValue;
	  let max = -1;
	  let index = -1;
	  for (const value of values) {
	    ++index;
	    if (max < 0
	        ? compare(value, value) === 0
	        : compare(value, maxValue) > 0) {
	      maxValue = value;
	      max = index;
	    }
	  }
	  return max;
	}

	function scan(values, compare) {
	  const index = leastIndex(values, compare);
	  return index < 0 ? undefined : index;
	}

	function shuffle(array, i0 = 0, i1 = array.length) {
	  var m = i1 - (i0 = +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  let sum = 0;
	  if (valueof === undefined) {
	    for (let value of values) {
	      if (value = +value) {
	        sum += value;
	      }
	    }
	  } else {
	    let index = -1;
	    for (let value of values) {
	      if (value = +valueof(value, ++index, values)) {
	        sum += value;
	      }
	    }
	  }
	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length$1), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length$1(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.ascending = ascending;
	exports.bin = bin;
	exports.bisect = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.bisectRight = bisectRight;
	exports.bisector = bisector;
	exports.count = count;
	exports.cross = cross;
	exports.cumsum = cumsum;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.greatest = greatest;
	exports.greatestIndex = greatestIndex;
	exports.group = group;
	exports.groups = groups;
	exports.histogram = bin;
	exports.least = least;
	exports.leastIndex = leastIndex;
	exports.max = max;
	exports.maxIndex = maxIndex;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.minIndex = minIndex;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.quantileSorted = quantileSorted;
	exports.quickselect = quickselect;
	exports.range = range;
	exports.rollup = rollup;
	exports.rollups = rollups;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.ticks = ticks;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
	// https://github.com/bgrins/TinyColor
	// Brian Grinstead, MIT License

	(function(Math) {

	var trimLeft = /^\s+/,
	    trimRight = /\s+$/,
	    tinyCounter = 0,
	    mathRound = Math.round,
	    mathMin = Math.min,
	    mathMax = Math.max,
	    mathRandom = Math.random;

	function tinycolor (color, opts) {

	    color = (color) ? color : '';
	    opts = opts || { };

	    // If input is already a tinycolor, return itself
	    if (color instanceof tinycolor) {
	       return color;
	    }
	    // If we are called as a function, call using new instead
	    if (!(this instanceof tinycolor)) {
	        return new tinycolor(color, opts);
	    }

	    var rgb = inputToRGB(color);
	    this._originalInput = color,
	    this._r = rgb.r,
	    this._g = rgb.g,
	    this._b = rgb.b,
	    this._a = rgb.a,
	    this._roundA = mathRound(100*this._a) / 100,
	    this._format = opts.format || rgb.format;
	    this._gradientType = opts.gradientType;

	    // Don't let the range of [0,255] come back in [0,1].
	    // Potentially lose a little bit of precision here, but will fix issues where
	    // .5 gets interpreted as half of the total, instead of half of 1
	    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
	    if (this._r < 1) { this._r = mathRound(this._r); }
	    if (this._g < 1) { this._g = mathRound(this._g); }
	    if (this._b < 1) { this._b = mathRound(this._b); }

	    this._ok = rgb.ok;
	    this._tc_id = tinyCounter++;
	}

	tinycolor.prototype = {
	    isDark: function() {
	        return this.getBrightness() < 128;
	    },
	    isLight: function() {
	        return !this.isDark();
	    },
	    isValid: function() {
	        return this._ok;
	    },
	    getOriginalInput: function() {
	      return this._originalInput;
	    },
	    getFormat: function() {
	        return this._format;
	    },
	    getAlpha: function() {
	        return this._a;
	    },
	    getBrightness: function() {
	        //http://www.w3.org/TR/AERT#color-contrast
	        var rgb = this.toRgb();
	        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
	    },
	    getLuminance: function() {
	        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	        var rgb = this.toRgb();
	        var RsRGB, GsRGB, BsRGB, R, G, B;
	        RsRGB = rgb.r/255;
	        GsRGB = rgb.g/255;
	        BsRGB = rgb.b/255;

	        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
	        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
	        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
	        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
	    },
	    setAlpha: function(value) {
	        this._a = boundAlpha(value);
	        this._roundA = mathRound(100*this._a) / 100;
	        return this;
	    },
	    toHsv: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
	    },
	    toHsvString: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
	        return (this._a == 1) ?
	          "hsv("  + h + ", " + s + "%, " + v + "%)" :
	          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
	    },
	    toHsl: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
	    },
	    toHslString: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
	        return (this._a == 1) ?
	          "hsl("  + h + ", " + s + "%, " + l + "%)" :
	          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
	    },
	    toHex: function(allow3Char) {
	        return rgbToHex(this._r, this._g, this._b, allow3Char);
	    },
	    toHexString: function(allow3Char) {
	        return '#' + this.toHex(allow3Char);
	    },
	    toHex8: function(allow4Char) {
	        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
	    },
	    toHex8String: function(allow4Char) {
	        return '#' + this.toHex8(allow4Char);
	    },
	    toRgb: function() {
	        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
	    },
	    toRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
	          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
	    },
	    toPercentageRgb: function() {
	        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
	    },
	    toPercentageRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
	          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
	    },
	    toName: function() {
	        if (this._a === 0) {
	            return "transparent";
	        }

	        if (this._a < 1) {
	            return false;
	        }

	        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
	    },
	    toFilter: function(secondColor) {
	        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
	        var secondHex8String = hex8String;
	        var gradientType = this._gradientType ? "GradientType = 1, " : "";

	        if (secondColor) {
	            var s = tinycolor(secondColor);
	            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
	        }

	        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
	    },
	    toString: function(format) {
	        var formatSet = !!format;
	        format = format || this._format;

	        var formattedString = false;
	        var hasAlpha = this._a < 1 && this._a >= 0;
	        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

	        if (needsAlphaFormat) {
	            // Special case for "transparent", all other non-alpha formats
	            // will return rgba when there is transparency.
	            if (format === "name" && this._a === 0) {
	                return this.toName();
	            }
	            return this.toRgbString();
	        }
	        if (format === "rgb") {
	            formattedString = this.toRgbString();
	        }
	        if (format === "prgb") {
	            formattedString = this.toPercentageRgbString();
	        }
	        if (format === "hex" || format === "hex6") {
	            formattedString = this.toHexString();
	        }
	        if (format === "hex3") {
	            formattedString = this.toHexString(true);
	        }
	        if (format === "hex4") {
	            formattedString = this.toHex8String(true);
	        }
	        if (format === "hex8") {
	            formattedString = this.toHex8String();
	        }
	        if (format === "name") {
	            formattedString = this.toName();
	        }
	        if (format === "hsl") {
	            formattedString = this.toHslString();
	        }
	        if (format === "hsv") {
	            formattedString = this.toHsvString();
	        }

	        return formattedString || this.toHexString();
	    },
	    clone: function() {
	        return tinycolor(this.toString());
	    },

	    _applyModification: function(fn, args) {
	        var color = fn.apply(null, [this].concat([].slice.call(args)));
	        this._r = color._r;
	        this._g = color._g;
	        this._b = color._b;
	        this.setAlpha(color._a);
	        return this;
	    },
	    lighten: function() {
	        return this._applyModification(lighten, arguments);
	    },
	    brighten: function() {
	        return this._applyModification(brighten, arguments);
	    },
	    darken: function() {
	        return this._applyModification(darken, arguments);
	    },
	    desaturate: function() {
	        return this._applyModification(desaturate, arguments);
	    },
	    saturate: function() {
	        return this._applyModification(saturate, arguments);
	    },
	    greyscale: function() {
	        return this._applyModification(greyscale, arguments);
	    },
	    spin: function() {
	        return this._applyModification(spin, arguments);
	    },

	    _applyCombination: function(fn, args) {
	        return fn.apply(null, [this].concat([].slice.call(args)));
	    },
	    analogous: function() {
	        return this._applyCombination(analogous, arguments);
	    },
	    complement: function() {
	        return this._applyCombination(complement, arguments);
	    },
	    monochromatic: function() {
	        return this._applyCombination(monochromatic, arguments);
	    },
	    splitcomplement: function() {
	        return this._applyCombination(splitcomplement, arguments);
	    },
	    triad: function() {
	        return this._applyCombination(triad, arguments);
	    },
	    tetrad: function() {
	        return this._applyCombination(tetrad, arguments);
	    }
	};

	// If input is an object, force 1 into "1.0" to handle ratios properly
	// String input requires "1.0" as input, so 1 will be treated as 1
	tinycolor.fromRatio = function(color, opts) {
	    if (typeof color == "object") {
	        var newColor = {};
	        for (var i in color) {
	            if (color.hasOwnProperty(i)) {
	                if (i === "a") {
	                    newColor[i] = color[i];
	                }
	                else {
	                    newColor[i] = convertToPercentage(color[i]);
	                }
	            }
	        }
	        color = newColor;
	    }

	    return tinycolor(color, opts);
	};

	// Given a string or object, convert that input to RGB
	// Possible string inputs:
	//
	//     "red"
	//     "#f00" or "f00"
	//     "#ff0000" or "ff0000"
	//     "#ff000000" or "ff000000"
	//     "rgb 255 0 0" or "rgb (255, 0, 0)"
	//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
	//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
	//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
	//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
	//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
	//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
	//
	function inputToRGB(color) {

	    var rgb = { r: 0, g: 0, b: 0 };
	    var a = 1;
	    var s = null;
	    var v = null;
	    var l = null;
	    var ok = false;
	    var format = false;

	    if (typeof color == "string") {
	        color = stringInputToObject(color);
	    }

	    if (typeof color == "object") {
	        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
	            rgb = rgbToRgb(color.r, color.g, color.b);
	            ok = true;
	            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
	        }
	        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
	            s = convertToPercentage(color.s);
	            v = convertToPercentage(color.v);
	            rgb = hsvToRgb(color.h, s, v);
	            ok = true;
	            format = "hsv";
	        }
	        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
	            s = convertToPercentage(color.s);
	            l = convertToPercentage(color.l);
	            rgb = hslToRgb(color.h, s, l);
	            ok = true;
	            format = "hsl";
	        }

	        if (color.hasOwnProperty("a")) {
	            a = color.a;
	        }
	    }

	    a = boundAlpha(a);

	    return {
	        ok: ok,
	        format: color.format || format,
	        r: mathMin(255, mathMax(rgb.r, 0)),
	        g: mathMin(255, mathMax(rgb.g, 0)),
	        b: mathMin(255, mathMax(rgb.b, 0)),
	        a: a
	    };
	}


	// Conversion Functions
	// --------------------

	// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
	// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

	// `rgbToRgb`
	// Handle bounds / percentage checking to conform to CSS color spec
	// <http://www.w3.org/TR/css3-color/>
	// *Assumes:* r, g, b in [0, 255] or [0, 1]
	// *Returns:* { r, g, b } in [0, 255]
	function rgbToRgb(r, g, b){
	    return {
	        r: bound01(r, 255) * 255,
	        g: bound01(g, 255) * 255,
	        b: bound01(b, 255) * 255
	    };
	}

	// `rgbToHsl`
	// Converts an RGB color value to HSL.
	// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
	// *Returns:* { h, s, l } in [0,1]
	function rgbToHsl(r, g, b) {

	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);

	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, l = (max + min) / 2;

	    if(max == min) {
	        h = s = 0; // achromatic
	    }
	    else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }

	        h /= 6;
	    }

	    return { h: h, s: s, l: l };
	}

	// `hslToRgb`
	// Converts an HSL color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	function hslToRgb(h, s, l) {
	    var r, g, b;

	    h = bound01(h, 360);
	    s = bound01(s, 100);
	    l = bound01(l, 100);

	    function hue2rgb(p, q, t) {
	        if(t < 0) t += 1;
	        if(t > 1) t -= 1;
	        if(t < 1/6) return p + (q - p) * 6 * t;
	        if(t < 1/2) return q;
	        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	        return p;
	    }

	    if(s === 0) {
	        r = g = b = l; // achromatic
	    }
	    else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }

	    return { r: r * 255, g: g * 255, b: b * 255 };
	}

	// `rgbToHsv`
	// Converts an RGB color value to HSV
	// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	// *Returns:* { h, s, v } in [0,1]
	function rgbToHsv(r, g, b) {

	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);

	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, v = max;

	    var d = max - min;
	    s = max === 0 ? 0 : d / max;

	    if(max == min) {
	        h = 0; // achromatic
	    }
	    else {
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h /= 6;
	    }
	    return { h: h, s: s, v: v };
	}

	// `hsvToRgb`
	// Converts an HSV color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	 function hsvToRgb(h, s, v) {

	    h = bound01(h, 360) * 6;
	    s = bound01(s, 100);
	    v = bound01(v, 100);

	    var i = Math.floor(h),
	        f = h - i,
	        p = v * (1 - s),
	        q = v * (1 - f * s),
	        t = v * (1 - (1 - f) * s),
	        mod = i % 6,
	        r = [v, q, p, p, t, v][mod],
	        g = [t, v, v, q, p, p][mod],
	        b = [p, p, t, v, v, q][mod];

	    return { r: r * 255, g: g * 255, b: b * 255 };
	}

	// `rgbToHex`
	// Converts an RGB color to hex
	// Assumes r, g, and b are contained in the set [0, 255]
	// Returns a 3 or 6 character hex
	function rgbToHex(r, g, b, allow3Char) {

	    var hex = [
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16))
	    ];

	    // Return a 3 character hex if possible
	    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	    }

	    return hex.join("");
	}

	// `rgbaToHex`
	// Converts an RGBA color plus alpha transparency to hex
	// Assumes r, g, b are contained in the set [0, 255] and
	// a in [0, 1]. Returns a 4 or 8 character rgba hex
	function rgbaToHex(r, g, b, a, allow4Char) {

	    var hex = [
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16)),
	        pad2(convertDecimalToHex(a))
	    ];

	    // Return a 4 character hex if possible
	    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
	    }

	    return hex.join("");
	}

	// `rgbaToArgbHex`
	// Converts an RGBA color to an ARGB Hex8 string
	// Rarely used, but required for "toFilter()"
	function rgbaToArgbHex(r, g, b, a) {

	    var hex = [
	        pad2(convertDecimalToHex(a)),
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16))
	    ];

	    return hex.join("");
	}

	// `equals`
	// Can be called with any tinycolor input
	tinycolor.equals = function (color1, color2) {
	    if (!color1 || !color2) { return false; }
	    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
	};

	tinycolor.random = function() {
	    return tinycolor.fromRatio({
	        r: mathRandom(),
	        g: mathRandom(),
	        b: mathRandom()
	    });
	};


	// Modification Functions
	// ----------------------
	// Thanks to less.js for some of the basics here
	// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

	function desaturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s -= amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}

	function saturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s += amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}

	function greyscale(color) {
	    return tinycolor(color).desaturate(100);
	}

	function lighten (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l += amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}

	function brighten(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var rgb = tinycolor(color).toRgb();
	    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
	    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
	    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
	    return tinycolor(rgb);
	}

	function darken (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l -= amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}

	// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
	// Values outside of this range will be wrapped into this range.
	function spin(color, amount) {
	    var hsl = tinycolor(color).toHsl();
	    var hue = (hsl.h + amount) % 360;
	    hsl.h = hue < 0 ? 360 + hue : hue;
	    return tinycolor(hsl);
	}

	// Combination Functions
	// ---------------------
	// Thanks to jQuery xColor for some of the ideas behind these
	// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

	function complement(color) {
	    var hsl = tinycolor(color).toHsl();
	    hsl.h = (hsl.h + 180) % 360;
	    return tinycolor(hsl);
	}

	function triad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
	    ];
	}

	function tetrad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
	    ];
	}

	function splitcomplement(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
	        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
	    ];
	}

	function analogous(color, results, slices) {
	    results = results || 6;
	    slices = slices || 30;

	    var hsl = tinycolor(color).toHsl();
	    var part = 360 / slices;
	    var ret = [tinycolor(color)];

	    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
	        hsl.h = (hsl.h + part) % 360;
	        ret.push(tinycolor(hsl));
	    }
	    return ret;
	}

	function monochromatic(color, results) {
	    results = results || 6;
	    var hsv = tinycolor(color).toHsv();
	    var h = hsv.h, s = hsv.s, v = hsv.v;
	    var ret = [];
	    var modification = 1 / results;

	    while (results--) {
	        ret.push(tinycolor({ h: h, s: s, v: v}));
	        v = (v + modification) % 1;
	    }

	    return ret;
	}

	// Utility Functions
	// ---------------------

	tinycolor.mix = function(color1, color2, amount) {
	    amount = (amount === 0) ? 0 : (amount || 50);

	    var rgb1 = tinycolor(color1).toRgb();
	    var rgb2 = tinycolor(color2).toRgb();

	    var p = amount / 100;

	    var rgba = {
	        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
	        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
	        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
	        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
	    };

	    return tinycolor(rgba);
	};


	// Readability Functions
	// ---------------------
	// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

	// `contrast`
	// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
	tinycolor.readability = function(color1, color2) {
	    var c1 = tinycolor(color1);
	    var c2 = tinycolor(color2);
	    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
	};

	// `isReadable`
	// Ensure that foreground and background color combinations meet WCAG2 guidelines.
	// The third argument is an optional Object.
	//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
	//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
	// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

	// *Example*
	//    tinycolor.isReadable("#000", "#111") => false
	//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
	tinycolor.isReadable = function(color1, color2, wcag2) {
	    var readability = tinycolor.readability(color1, color2);
	    var wcag2Parms, out;

	    out = false;

	    wcag2Parms = validateWCAG2Parms(wcag2);
	    switch (wcag2Parms.level + wcag2Parms.size) {
	        case "AAsmall":
	        case "AAAlarge":
	            out = readability >= 4.5;
	            break;
	        case "AAlarge":
	            out = readability >= 3;
	            break;
	        case "AAAsmall":
	            out = readability >= 7;
	            break;
	    }
	    return out;

	};

	// `mostReadable`
	// Given a base color and a list of possible foreground or background
	// colors for that base, returns the most readable color.
	// Optionally returns Black or White if the most readable color is unreadable.
	// *Example*
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
	tinycolor.mostReadable = function(baseColor, colorList, args) {
	    var bestColor = null;
	    var bestScore = 0;
	    var readability;
	    var includeFallbackColors, level, size ;
	    args = args || {};
	    includeFallbackColors = args.includeFallbackColors ;
	    level = args.level;
	    size = args.size;

	    for (var i= 0; i < colorList.length ; i++) {
	        readability = tinycolor.readability(baseColor, colorList[i]);
	        if (readability > bestScore) {
	            bestScore = readability;
	            bestColor = tinycolor(colorList[i]);
	        }
	    }

	    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
	        return bestColor;
	    }
	    else {
	        args.includeFallbackColors=false;
	        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
	    }
	};


	// Big List of Colors
	// ------------------
	// <http://www.w3.org/TR/css3-color/#svg-color>
	var names = tinycolor.names = {
	    aliceblue: "f0f8ff",
	    antiquewhite: "faebd7",
	    aqua: "0ff",
	    aquamarine: "7fffd4",
	    azure: "f0ffff",
	    beige: "f5f5dc",
	    bisque: "ffe4c4",
	    black: "000",
	    blanchedalmond: "ffebcd",
	    blue: "00f",
	    blueviolet: "8a2be2",
	    brown: "a52a2a",
	    burlywood: "deb887",
	    burntsienna: "ea7e5d",
	    cadetblue: "5f9ea0",
	    chartreuse: "7fff00",
	    chocolate: "d2691e",
	    coral: "ff7f50",
	    cornflowerblue: "6495ed",
	    cornsilk: "fff8dc",
	    crimson: "dc143c",
	    cyan: "0ff",
	    darkblue: "00008b",
	    darkcyan: "008b8b",
	    darkgoldenrod: "b8860b",
	    darkgray: "a9a9a9",
	    darkgreen: "006400",
	    darkgrey: "a9a9a9",
	    darkkhaki: "bdb76b",
	    darkmagenta: "8b008b",
	    darkolivegreen: "556b2f",
	    darkorange: "ff8c00",
	    darkorchid: "9932cc",
	    darkred: "8b0000",
	    darksalmon: "e9967a",
	    darkseagreen: "8fbc8f",
	    darkslateblue: "483d8b",
	    darkslategray: "2f4f4f",
	    darkslategrey: "2f4f4f",
	    darkturquoise: "00ced1",
	    darkviolet: "9400d3",
	    deeppink: "ff1493",
	    deepskyblue: "00bfff",
	    dimgray: "696969",
	    dimgrey: "696969",
	    dodgerblue: "1e90ff",
	    firebrick: "b22222",
	    floralwhite: "fffaf0",
	    forestgreen: "228b22",
	    fuchsia: "f0f",
	    gainsboro: "dcdcdc",
	    ghostwhite: "f8f8ff",
	    gold: "ffd700",
	    goldenrod: "daa520",
	    gray: "808080",
	    green: "008000",
	    greenyellow: "adff2f",
	    grey: "808080",
	    honeydew: "f0fff0",
	    hotpink: "ff69b4",
	    indianred: "cd5c5c",
	    indigo: "4b0082",
	    ivory: "fffff0",
	    khaki: "f0e68c",
	    lavender: "e6e6fa",
	    lavenderblush: "fff0f5",
	    lawngreen: "7cfc00",
	    lemonchiffon: "fffacd",
	    lightblue: "add8e6",
	    lightcoral: "f08080",
	    lightcyan: "e0ffff",
	    lightgoldenrodyellow: "fafad2",
	    lightgray: "d3d3d3",
	    lightgreen: "90ee90",
	    lightgrey: "d3d3d3",
	    lightpink: "ffb6c1",
	    lightsalmon: "ffa07a",
	    lightseagreen: "20b2aa",
	    lightskyblue: "87cefa",
	    lightslategray: "789",
	    lightslategrey: "789",
	    lightsteelblue: "b0c4de",
	    lightyellow: "ffffe0",
	    lime: "0f0",
	    limegreen: "32cd32",
	    linen: "faf0e6",
	    magenta: "f0f",
	    maroon: "800000",
	    mediumaquamarine: "66cdaa",
	    mediumblue: "0000cd",
	    mediumorchid: "ba55d3",
	    mediumpurple: "9370db",
	    mediumseagreen: "3cb371",
	    mediumslateblue: "7b68ee",
	    mediumspringgreen: "00fa9a",
	    mediumturquoise: "48d1cc",
	    mediumvioletred: "c71585",
	    midnightblue: "191970",
	    mintcream: "f5fffa",
	    mistyrose: "ffe4e1",
	    moccasin: "ffe4b5",
	    navajowhite: "ffdead",
	    navy: "000080",
	    oldlace: "fdf5e6",
	    olive: "808000",
	    olivedrab: "6b8e23",
	    orange: "ffa500",
	    orangered: "ff4500",
	    orchid: "da70d6",
	    palegoldenrod: "eee8aa",
	    palegreen: "98fb98",
	    paleturquoise: "afeeee",
	    palevioletred: "db7093",
	    papayawhip: "ffefd5",
	    peachpuff: "ffdab9",
	    peru: "cd853f",
	    pink: "ffc0cb",
	    plum: "dda0dd",
	    powderblue: "b0e0e6",
	    purple: "800080",
	    rebeccapurple: "663399",
	    red: "f00",
	    rosybrown: "bc8f8f",
	    royalblue: "4169e1",
	    saddlebrown: "8b4513",
	    salmon: "fa8072",
	    sandybrown: "f4a460",
	    seagreen: "2e8b57",
	    seashell: "fff5ee",
	    sienna: "a0522d",
	    silver: "c0c0c0",
	    skyblue: "87ceeb",
	    slateblue: "6a5acd",
	    slategray: "708090",
	    slategrey: "708090",
	    snow: "fffafa",
	    springgreen: "00ff7f",
	    steelblue: "4682b4",
	    tan: "d2b48c",
	    teal: "008080",
	    thistle: "d8bfd8",
	    tomato: "ff6347",
	    turquoise: "40e0d0",
	    violet: "ee82ee",
	    wheat: "f5deb3",
	    white: "fff",
	    whitesmoke: "f5f5f5",
	    yellow: "ff0",
	    yellowgreen: "9acd32"
	};

	// Make it easy to access colors via `hexNames[hex]`
	var hexNames = tinycolor.hexNames = flip(names);


	// Utilities
	// ---------

	// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
	function flip(o) {
	    var flipped = { };
	    for (var i in o) {
	        if (o.hasOwnProperty(i)) {
	            flipped[o[i]] = i;
	        }
	    }
	    return flipped;
	}

	// Return a valid alpha value [0,1] with all invalid values being set to 1
	function boundAlpha(a) {
	    a = parseFloat(a);

	    if (isNaN(a) || a < 0 || a > 1) {
	        a = 1;
	    }

	    return a;
	}

	// Take input from [0, n] and return it as [0, 1]
	function bound01(n, max) {
	    if (isOnePointZero(n)) { n = "100%"; }

	    var processPercent = isPercentage(n);
	    n = mathMin(max, mathMax(0, parseFloat(n)));

	    // Automatically convert percentage into number
	    if (processPercent) {
	        n = parseInt(n * max, 10) / 100;
	    }

	    // Handle floating point rounding errors
	    if ((Math.abs(n - max) < 0.000001)) {
	        return 1;
	    }

	    // Convert into [0, 1] range if it isn't already
	    return (n % max) / parseFloat(max);
	}

	// Force a number between 0 and 1
	function clamp01(val) {
	    return mathMin(1, mathMax(0, val));
	}

	// Parse a base-16 hex value into a base-10 integer
	function parseIntFromHex(val) {
	    return parseInt(val, 16);
	}

	// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
	function isOnePointZero(n) {
	    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
	}

	// Check to see if string passed in is a percentage
	function isPercentage(n) {
	    return typeof n === "string" && n.indexOf('%') != -1;
	}

	// Force a hex value to have 2 characters
	function pad2(c) {
	    return c.length == 1 ? '0' + c : '' + c;
	}

	// Replace a decimal with it's percentage value
	function convertToPercentage(n) {
	    if (n <= 1) {
	        n = (n * 100) + "%";
	    }

	    return n;
	}

	// Converts a decimal to a hex value
	function convertDecimalToHex(d) {
	    return Math.round(parseFloat(d) * 255).toString(16);
	}
	// Converts a hex value to a decimal
	function convertHexToDecimal(h) {
	    return (parseIntFromHex(h) / 255);
	}

	var matchers = (function() {

	    // <http://www.w3.org/TR/css3-values/#integers>
	    var CSS_INTEGER = "[-\\+]?\\d+%?";

	    // <http://www.w3.org/TR/css3-values/#number-value>
	    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

	    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
	    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

	    // Actual matching.
	    // Parentheses and commas are optional, but not required.
	    // Whitespace can take the place of commas or opening paren
	    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

	    return {
	        CSS_UNIT: new RegExp(CSS_UNIT),
	        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
	        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
	        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
	        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
	        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
	        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
	        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	    };
	})();

	// `isValidCSSUnit`
	// Take in a single string / number and check to see if it looks like a CSS unit
	// (see `matchers` above for definition).
	function isValidCSSUnit(color) {
	    return !!matchers.CSS_UNIT.exec(color);
	}

	// `stringInputToObject`
	// Permissive string parsing.  Take in a number of formats, and output an object
	// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
	function stringInputToObject(color) {

	    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
	    var named = false;
	    if (names[color]) {
	        color = names[color];
	        named = true;
	    }
	    else if (color == 'transparent') {
	        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
	    }

	    // Try to match string input using regular expressions.
	    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
	    // Just return an object and let the conversion functions handle that.
	    // This way the result will be the same whether the tinycolor is initialized with string or object.
	    var match;
	    if ((match = matchers.rgb.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3] };
	    }
	    if ((match = matchers.rgba.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsl.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3] };
	    }
	    if ((match = matchers.hsla.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsv.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3] };
	    }
	    if ((match = matchers.hsva.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3], a: match[4] };
	    }
	    if ((match = matchers.hex8.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1]),
	            g: parseIntFromHex(match[2]),
	            b: parseIntFromHex(match[3]),
	            a: convertHexToDecimal(match[4]),
	            format: named ? "name" : "hex8"
	        };
	    }
	    if ((match = matchers.hex6.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1]),
	            g: parseIntFromHex(match[2]),
	            b: parseIntFromHex(match[3]),
	            format: named ? "name" : "hex"
	        };
	    }
	    if ((match = matchers.hex4.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1] + '' + match[1]),
	            g: parseIntFromHex(match[2] + '' + match[2]),
	            b: parseIntFromHex(match[3] + '' + match[3]),
	            a: convertHexToDecimal(match[4] + '' + match[4]),
	            format: named ? "name" : "hex8"
	        };
	    }
	    if ((match = matchers.hex3.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1] + '' + match[1]),
	            g: parseIntFromHex(match[2] + '' + match[2]),
	            b: parseIntFromHex(match[3] + '' + match[3]),
	            format: named ? "name" : "hex"
	        };
	    }

	    return false;
	}

	function validateWCAG2Parms(parms) {
	    // return valid WCAG2 parms for isReadable.
	    // If input parms are invalid, return {"level":"AA", "size":"small"}
	    var level, size;
	    parms = parms || {"level":"AA", "size":"small"};
	    level = (parms.level || "AA").toUpperCase();
	    size = (parms.size || "small").toLowerCase();
	    if (level !== "AA" && level !== "AAA") {
	        level = "AA";
	    }
	    if (size !== "small" && size !== "large") {
	        size = "small";
	    }
	    return {"level":level, "size":size};
	}

	// Node: Export function
	if (typeof module !== "undefined" && module.exports) {
	    module.exports = tinycolor;
	}
	// AMD/requirejs: Define the module
	else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {return tinycolor;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	// Browser: Expose to window
	else {
	    window.tinycolor = tinycolor;
	}

	})(Math);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var three$1 = __webpack_require__(41);
	var ThreeTrackballControls = _interopDefault(__webpack_require__(85));
	var OrbitControlsWrapper = _interopDefault(__webpack_require__(86));
	var FlyControlsWrapper = _interopDefault(__webpack_require__(87));
	var polished = __webpack_require__(88);
	var TWEEN = _interopDefault(__webpack_require__(173));
	var accessorFn = _interopDefault(__webpack_require__(78));
	var Kapsule = _interopDefault(__webpack_require__(76));

	function styleInject(css, ref) {
	  if (ref === void 0) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') {
	    return;
	  }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = ".scene-nav-info {\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n}\n\n.scene-tooltip {\n  color: lavender;\n  font-size: 15px;\n}\n\n.scene-nav-info, .scene-tooltip {\n  position: absolute;\n  font-family: sans-serif;\n  pointer-events: none;\n}";
	styleInject(css_248z);

	var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
	: {
	  WebGLRenderer: three$1.WebGLRenderer,
	  Scene: three$1.Scene,
	  PerspectiveCamera: three$1.PerspectiveCamera,
	  Raycaster: three$1.Raycaster,
	  TextureLoader: three$1.TextureLoader,
	  Vector2: three$1.Vector2,
	  Vector3: three$1.Vector3,
	  Color: three$1.Color,
	  Mesh: three$1.Mesh,
	  SphereGeometry: three$1.SphereGeometry,
	  MeshBasicMaterial: three$1.MeshBasicMaterial,
	  BackSide: three$1.BackSide,
	  EventDispatcher: three$1.EventDispatcher,
	  MOUSE: three$1.MOUSE,
	  Quaternion: three$1.Quaternion,
	  Spherical: three$1.Spherical,
	  Clock: three$1.Clock
	};
	var ThreeOrbitControls = OrbitControlsWrapper(three);
	var ThreeFlyControls = (FlyControlsWrapper(three), three.FlyControls);
	var threeRenderObjects = Kapsule({
	  props: {
	    width: {
	      "default": window.innerWidth,
	      onChange: function onChange(width, state, prevWidth) {
	        isNaN(width) && (state.width = prevWidth);
	      }
	    },
	    height: {
	      "default": window.innerHeight,
	      onChange: function onChange(height, state, prevHeight) {
	        isNaN(height) && (state.height = prevHeight);
	      }
	    },
	    backgroundColor: {
	      "default": '#000011'
	    },
	    backgroundImageUrl: {},
	    onBackgroundImageLoaded: {},
	    showNavInfo: {
	      "default": true
	    },
	    skyRadius: {
	      "default": 50000
	    },
	    objects: {
	      "default": []
	    },
	    postProcessingComposer: {
	      triggerUpdate: false
	    },
	    enablePointerInteraction: {
	      "default": true,
	      onChange: function onChange(_, state) {
	        // Reset hover state
	        state.hoverObj = null;
	        if (state.toolTipElem) state.toolTipElem.innerHTML = '';
	      },
	      triggerUpdate: false
	    },
	    lineHoverPrecision: {
	      "default": 1,
	      triggerUpdate: false
	    },
	    hoverOrderComparator: {
	      "default": function _default() {
	        return -1;
	      },
	      triggerUpdate: false
	    },
	    // keep existing order by default
	    tooltipContent: {
	      triggerUpdate: false
	    },
	    hoverDuringDrag: {
	      "default": false,
	      triggerUpdate: false
	    },
	    onHover: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onRightClick: {
	      triggerUpdate: false
	    }
	  },
	  methods: {
	    tick: function tick(state) {
	      if (state.initialised) {
	        state.controls.update && state.controls.update(state.clock.getDelta()); // timedelta is required for fly controls

	        state.postProcessingComposer ? state.postProcessingComposer.render() // if using postprocessing, render only the output of the
	        : state.renderer.render(state.scene, state.camera);

	        if (state.enablePointerInteraction) {
	          // Update tooltip and trigger onHover events
	          var topObject = null;

	          if (state.hoverDuringDrag || !state.controlsDragging) {
	            var raycaster = new three.Raycaster();
	            raycaster.params.Line.threshold = state.lineHoverPrecision; // set linePrecision

	            raycaster.setFromCamera(state.mousePos, state.camera);
	            var intersects = raycaster.intersectObjects(state.objects, true).map(function (_ref) {
	              var object = _ref.object;
	              return object;
	            }).sort(state.hoverOrderComparator);
	            topObject = intersects.length ? intersects[0] : null;
	          }

	          if (topObject !== state.hoverObj) {
	            state.onHover(topObject, state.hoverObj);
	            state.toolTipElem.innerHTML = topObject ? accessorFn(state.tooltipContent)(topObject) || '' : '';
	            state.hoverObj = topObject;
	          }
	        }

	        TWEEN.update(); // update camera animation tweens
	      }

	      return this;
	    },
	    cameraPosition: function cameraPosition(state, position, lookAt, transitionDuration) {
	      var camera = state.camera; // Setter

	      if (position && state.initialised) {
	        var finalPos = position;
	        var finalLookAt = lookAt || {
	          x: 0,
	          y: 0,
	          z: 0
	        };

	        if (!transitionDuration) {
	          // no animation
	          setCameraPos(finalPos);
	          setLookAt(finalLookAt);
	        } else {
	          var camPos = Object.assign({}, camera.position);
	          var camLookAt = getLookAt();
	          new TWEEN.Tween(camPos).to(finalPos, transitionDuration).easing(TWEEN.Easing.Quadratic.Out).onUpdate(setCameraPos).start(); // Face direction in 1/3rd of time

	          new TWEEN.Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(TWEEN.Easing.Quadratic.Out).onUpdate(setLookAt).start();
	        }

	        return this;
	      } // Getter


	      return Object.assign({}, camera.position, {
	        lookAt: getLookAt()
	      }); //

	      function setCameraPos(pos) {
	        var x = pos.x,
	            y = pos.y,
	            z = pos.z;
	        if (x !== undefined) camera.position.x = x;
	        if (y !== undefined) camera.position.y = y;
	        if (z !== undefined) camera.position.z = z;
	      }

	      function setLookAt(lookAt) {
	        state.controls.target = new three.Vector3(lookAt.x, lookAt.y, lookAt.z);
	      }

	      function getLookAt() {
	        return Object.assign(new three.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position));
	      }
	    },
	    renderer: function renderer(state) {
	      return state.renderer;
	    },
	    scene: function scene(state) {
	      return state.scene;
	    },
	    camera: function camera(state) {
	      return state.camera;
	    },
	    controls: function controls(state) {
	      return state.controls;
	    },
	    tbControls: function tbControls(state) {
	      return state.controls;
	    } // to be deprecated

	  },
	  stateInit: function stateInit() {
	    return {
	      scene: new three.Scene(),
	      camera: new three.PerspectiveCamera(),
	      clock: new three.Clock()
	    };
	  },
	  init: function init(domNode, state, _ref2) {
	    var _ref2$controlType = _ref2.controlType,
	        controlType = _ref2$controlType === void 0 ? 'trackball' : _ref2$controlType,
	        _ref2$rendererConfig = _ref2.rendererConfig,
	        rendererConfig = _ref2$rendererConfig === void 0 ? {} : _ref2$rendererConfig,
	        _ref2$waitForLoadComp = _ref2.waitForLoadComplete,
	        waitForLoadComplete = _ref2$waitForLoadComp === void 0 ? true : _ref2$waitForLoadComp;
	    // Wipe DOM
	    domNode.innerHTML = ''; // Add relative container

	    domNode.appendChild(state.container = document.createElement('div'));
	    state.container.style.position = 'relative'; // Add nav info section

	    state.container.appendChild(state.navInfo = document.createElement('div'));
	    state.navInfo.className = 'scene-nav-info';
	    state.navInfo.textContent = {
	      orbit: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
	      trackball: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
	      fly: 'WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw'
	    }[controlType] || '';
	    state.navInfo.style.display = state.showNavInfo ? null : 'none'; // Setup tooltip

	    state.toolTipElem = document.createElement('div');
	    state.toolTipElem.classList.add('scene-tooltip');
	    state.container.appendChild(state.toolTipElem); // Capture mouse coords on move

	    state.mousePos = new three.Vector2();
	    state.mousePos.x = -2; // Initialize off canvas

	    state.mousePos.y = -2;
	    state.container.addEventListener("mousemove", function (ev) {
	      if (state.enablePointerInteraction) {
	        // update the mouse pos
	        var offset = getOffset(state.container),
	            relPos = {
	          x: ev.pageX - offset.left,
	          y: ev.pageY - offset.top
	        };
	        state.mousePos.x = relPos.x / state.width * 2 - 1;
	        state.mousePos.y = -(relPos.y / state.height) * 2 + 1; // Move tooltip

	        state.toolTipElem.style.top = "".concat(relPos.y, "px");
	        state.toolTipElem.style.left = "".concat(relPos.x, "px");
	        state.toolTipElem.style.transform = "translate(-".concat(relPos.x / state.width * 100, "%, 21px)"); // adjust horizontal position to not exceed canvas boundaries
	      }

	      function getOffset(el) {
	        var rect = el.getBoundingClientRect(),
	            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
	            scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	        return {
	          top: rect.top + scrollTop,
	          left: rect.left + scrollLeft
	        };
	      }
	    }, false); // Handle click events on objs

	    state.container.addEventListener('mouseup', function (ev) {
	      if (state.ignoreOneClick) {
	        state.ignoreOneClick = false; // because of controls end event

	        return;
	      }

	      if (ev.button === 0) {
	        // left-click
	        state.onClick(state.hoverObj || null, ev); // trigger background clicks with null
	      }

	      if (ev.button === 2 && state.onRightClick) {
	        // right-click
	        state.onRightClick(state.hoverObj || null, ev);
	      }
	    }, false);
	    state.container.addEventListener('contextmenu', function (ev) {
	      if (state.onRightClick) ev.preventDefault(); // prevent default contextmenu behavior and allow mouseup to fire instead
	    }, false); // Setup renderer, camera and controls

	    state.renderer = new three.WebGLRenderer(Object.assign({
	      antialias: true,
	      alpha: true
	    }, rendererConfig));
	    state.renderer.setPixelRatio(window.devicePixelRatio);
	    state.container.appendChild(state.renderer.domElement); // configure controls

	    state.controls = new {
	      trackball: ThreeTrackballControls,
	      orbit: ThreeOrbitControls,
	      fly: ThreeFlyControls
	    }[controlType](state.camera, state.renderer.domElement);

	    if (controlType === 'fly') {
	      state.controls.movementSpeed = 300;
	      state.controls.rollSpeed = Math.PI / 6;
	      state.controls.dragToLook = true;
	    }

	    if (controlType === 'trackball' || controlType === 'orbit') {
	      state.controls.minDistance = 0.1;
	      state.controls.maxDistance = state.skyRadius;
	      state.controls.addEventListener('start', function () {
	        return state.controlsEngaged = true;
	      });
	      state.controls.addEventListener('change', function () {
	        if (state.controlsEngaged) {
	          state.controlsDragging = true;
	          state.ignoreOneClick = true;
	        }
	      });
	      state.controls.addEventListener('end', function () {
	        state.controlsEngaged = false;
	        state.controlsDragging = false;
	      });
	    }

	    state.renderer.setSize(state.width, state.height);
	    state.camera.aspect = state.width / state.height;
	    state.camera.updateProjectionMatrix();
	    state.camera.position.z = 1000; // add sky

	    state.scene.add(state.skysphere = new three.Mesh());
	    state.skysphere.visible = false;
	    state.loadComplete = state.scene.visible = !waitForLoadComplete;
	    window.scene = state.scene;
	  },
	  update: function update(state, changedProps) {
	    // resize canvas
	    if (state.width && state.height && (changedProps.hasOwnProperty('width') || changedProps.hasOwnProperty('height'))) {
	      state.container.style.width = state.width;
	      state.container.style.height = state.height;
	      state.renderer.setSize(state.width, state.height);
	      state.camera.aspect = state.width / state.height;
	      state.camera.updateProjectionMatrix();
	    }

	    if (changedProps.hasOwnProperty('skyRadius') && state.skyRadius) {
	      state.controls.hasOwnProperty('maxDistance') && changedProps.skyRadius && (state.controls.maxDistance = state.skyRadius);
	      state.camera.far = state.skyRadius * 2.5;
	      state.camera.updateProjectionMatrix();
	      state.skysphere.geometry = new three.SphereGeometry(state.skyRadius);
	    }

	    if (changedProps.hasOwnProperty('backgroundColor')) {
	      var alpha = polished.parseToRgb(state.backgroundColor).alpha;
	      if (alpha === undefined) alpha = 1;
	      state.renderer.setClearColor(new three.Color(polished.opacify(1, state.backgroundColor)), alpha);
	    }

	    if (changedProps.hasOwnProperty('backgroundImageUrl')) {
	      if (!state.backgroundImageUrl) {
	        state.skysphere.visible = false;
	        state.skysphere.material.map = null;
	        !state.loadComplete && finishLoad();
	      } else {
	        new three.TextureLoader().load(state.backgroundImageUrl, function (texture) {
	          state.skysphere.material = new three.MeshBasicMaterial({
	            map: texture,
	            side: three.BackSide
	          });
	          state.skysphere.visible = true; // triggered when background image finishes loading (asynchronously to allow 1 frame to load texture)

	          state.onBackgroundImageLoaded && setTimeout(state.onBackgroundImageLoaded);
	          !state.loadComplete && finishLoad();
	        });
	      }
	    }

	    changedProps.hasOwnProperty('showNavInfo') && (state.navInfo.style.display = state.showNavInfo ? null : 'none');

	    if (changedProps.hasOwnProperty('objects')) {
	      (changedProps.objects || []).forEach(function (obj) {
	        return state.scene.remove(obj);
	      }); // Clear the place

	      state.objects.forEach(function (obj) {
	        return state.scene.add(obj);
	      }); // Add to scene
	    } //


	    function finishLoad() {
	      state.loadComplete = state.scene.visible = true;
	    }
	  }
	});

	module.exports = threeRenderObjects;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @author Eberhard Graether / http://egraether.com/
	 * @author Mark Lundin 	/ http://mark-lundin.com
	 * @author Simone Manini / http://daron1337.github.io
	 * @author Luca Antiga 	/ http://lantiga.github.io

	 ** three-trackballcontrols module
	 ** @author Jon Lim / http://jonlim.ca
	 */

	var THREE = window.THREE || __webpack_require__(41);

	var TrackballControls;
	module.exports = TrackballControls = function ( object, domElement ) {

		var _this = this;
		var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

		this.object = object;
		this.domElement = ( domElement !== undefined ) ? domElement : document;

		// API

		this.enabled = true;

		this.screen = { left: 0, top: 0, width: 0, height: 0 };

		this.rotateSpeed = 1.0;
		this.zoomSpeed = 1.2;
		this.panSpeed = 0.3;

		this.noRotate = false;
		this.noZoom = false;
		this.noPan = false;

		this.staticMoving = false;
		this.dynamicDampingFactor = 0.2;

		this.minDistance = 0;
		this.maxDistance = Infinity;

		/**
		 * `KeyboardEvent.keyCode` values which should trigger the different 
		 * interaction states. Each element can be a single code or an array
		 * of codes. All elements are required.
		 */
		this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

		// internals

		this.target = new THREE.Vector3();

		var EPS = 0.000001;

		var lastPosition = new THREE.Vector3();

		var _state = STATE.NONE,
		_prevState = STATE.NONE,

		_eye = new THREE.Vector3(),

		_movePrev = new THREE.Vector2(),
		_moveCurr = new THREE.Vector2(),

		_lastAxis = new THREE.Vector3(),
		_lastAngle = 0,

		_zoomStart = new THREE.Vector2(),
		_zoomEnd = new THREE.Vector2(),

		_touchZoomDistanceStart = 0,
		_touchZoomDistanceEnd = 0,

		_panStart = new THREE.Vector2(),
		_panEnd = new THREE.Vector2();

		// for reset

		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.up0 = this.object.up.clone();

		// events

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };


		// methods

		this.handleResize = function () {

			if ( this.domElement === document ) {

				this.screen.left = 0;
				this.screen.top = 0;
				this.screen.width = window.innerWidth;
				this.screen.height = window.innerHeight;

			} else {

				var box = this.domElement.getBoundingClientRect();
				// adjustments come from similar code in the jquery offset() function
				var d = this.domElement.ownerDocument.documentElement;
				this.screen.left = box.left + window.pageXOffset - d.clientLeft;
				this.screen.top = box.top + window.pageYOffset - d.clientTop;
				this.screen.width = box.width;
				this.screen.height = box.height;

			}

		};

		this.handleEvent = function ( event ) {

			if ( typeof this[ event.type ] == 'function' ) {

				this[ event.type ]( event );

			}

		};

		var getMouseOnScreen = ( function () {

			var vector = new THREE.Vector2();

			return function getMouseOnScreen( pageX, pageY ) {

				vector.set(
					( pageX - _this.screen.left ) / _this.screen.width,
					( pageY - _this.screen.top ) / _this.screen.height
				);

				return vector;

			};

		}() );

		var getMouseOnCircle = ( function () {

			var vector = new THREE.Vector2();

			return function getMouseOnCircle( pageX, pageY ) {

				vector.set(
					( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),
					( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width ) // screen.width intentional
				);

				return vector;

			};

		}() );

		this.rotateCamera = ( function() {

			var axis = new THREE.Vector3(),
				quaternion = new THREE.Quaternion(),
				eyeDirection = new THREE.Vector3(),
				objectUpDirection = new THREE.Vector3(),
				objectSidewaysDirection = new THREE.Vector3(),
				moveDirection = new THREE.Vector3(),
				angle;

			return function rotateCamera() {

				moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
				angle = moveDirection.length();

				if ( angle ) {

					_eye.copy( _this.object.position ).sub( _this.target );

					eyeDirection.copy( _eye ).normalize();
					objectUpDirection.copy( _this.object.up ).normalize();
					objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();

					objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
					objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );

					moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );

					axis.crossVectors( moveDirection, _eye ).normalize();

					angle *= _this.rotateSpeed;
					quaternion.setFromAxisAngle( axis, angle );

					_eye.applyQuaternion( quaternion );
					_this.object.up.applyQuaternion( quaternion );

					_lastAxis.copy( axis );
					_lastAngle = angle;

				} else if ( ! _this.staticMoving && _lastAngle ) {

					_lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );
					_eye.copy( _this.object.position ).sub( _this.target );
					quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
					_eye.applyQuaternion( quaternion );
					_this.object.up.applyQuaternion( quaternion );

				}

				_movePrev.copy( _moveCurr );

			};

		}() );


		this.zoomCamera = function () {

			var factor;

			if ( _state === STATE.TOUCH_ZOOM_PAN ) {

				factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
				_touchZoomDistanceStart = _touchZoomDistanceEnd;
				_eye.multiplyScalar( factor );

			} else {

				factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

				if ( factor !== 1.0 && factor > 0.0 ) {

					_eye.multiplyScalar( factor );

				}

				if ( _this.staticMoving ) {

					_zoomStart.copy( _zoomEnd );

				} else {

					_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

				}

			}

		};

		this.panCamera = ( function() {

			var mouseChange = new THREE.Vector2(),
				objectUp = new THREE.Vector3(),
				pan = new THREE.Vector3();

			return function panCamera() {

				mouseChange.copy( _panEnd ).sub( _panStart );

				if ( mouseChange.lengthSq() ) {

					mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

					pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
					pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

					_this.object.position.add( pan );
					_this.target.add( pan );

					if ( _this.staticMoving ) {

						_panStart.copy( _panEnd );

					} else {

						_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

					}

				}

			};

		}() );

		this.checkDistances = function () {

			if ( ! _this.noZoom || ! _this.noPan ) {

				if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

					_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );
					_zoomStart.copy( _zoomEnd );

				}

				if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

					_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );
					_zoomStart.copy( _zoomEnd );

				}

			}

		};

		this.update = function () {

			_eye.subVectors( _this.object.position, _this.target );

			if ( ! _this.noRotate ) {

				_this.rotateCamera();

			}

			if ( ! _this.noZoom ) {

				_this.zoomCamera();

			}

			if ( ! _this.noPan ) {

				_this.panCamera();

			}

			_this.object.position.addVectors( _this.target, _eye );

			_this.checkDistances();

			_this.object.lookAt( _this.target );

			if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

				_this.dispatchEvent( changeEvent );

				lastPosition.copy( _this.object.position );

			}

		};

		this.reset = function () {

			_state = STATE.NONE;
			_prevState = STATE.NONE;

			_this.target.copy( _this.target0 );
			_this.object.position.copy( _this.position0 );
			_this.object.up.copy( _this.up0 );

			_eye.subVectors( _this.object.position, _this.target );

			_this.object.lookAt( _this.target );

			_this.dispatchEvent( changeEvent );

			lastPosition.copy( _this.object.position );

		};

		// helpers

		/**
		 * Checks if the pressed key is any of the configured modifier keys for
		 * a specified behavior.
		 * 
		 * @param {number | number[]} keys 
		 * @param {number} key 
		 * 
		 * @returns {boolean} `true` if `keys` contains or equals `key`
		 */
		function containsKey(keys, key) {
			if (Array.isArray(keys)) {
				return keys.indexOf(key) !== -1;
			} else {
				return keys === key;
			}
		}

		// listeners

		function keydown( event ) {

			if ( _this.enabled === false ) return;

			window.removeEventListener( 'keydown', keydown );

			_prevState = _state;

			if ( _state !== STATE.NONE ) {

				return;

			} else if ( containsKey( _this.keys[ STATE.ROTATE ], event.keyCode ) && ! _this.noRotate ) {

				_state = STATE.ROTATE;

			} else if ( containsKey( _this.keys[ STATE.ZOOM ], event.keyCode ) && ! _this.noZoom ) {

				_state = STATE.ZOOM;

			} else if ( containsKey( _this.keys[ STATE.PAN ], event.keyCode ) && ! _this.noPan ) {

				_state = STATE.PAN;

			}

		}

		function keyup( event ) {

			if ( _this.enabled === false ) return;

			_state = _prevState;

			window.addEventListener( 'keydown', keydown, false );

		}

		function mousedown( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			if ( _state === STATE.NONE ) {

				_state = event.button;

			}

			if ( _state === STATE.ROTATE && ! _this.noRotate ) {

				_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
				_movePrev.copy( _moveCurr );

			} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

				_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
				_zoomEnd.copy( _zoomStart );

			} else if ( _state === STATE.PAN && ! _this.noPan ) {

				_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
				_panEnd.copy( _panStart );

			}

			document.addEventListener( 'mousemove', mousemove, false );
			document.addEventListener( 'mouseup', mouseup, false );

			_this.dispatchEvent( startEvent );

		}

		function mousemove( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			if ( _state === STATE.ROTATE && ! _this.noRotate ) {

				_movePrev.copy( _moveCurr );
				_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );

			} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

				_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

			} else if ( _state === STATE.PAN && ! _this.noPan ) {

				_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

			}

		}

		function mouseup( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			_state = STATE.NONE;

			document.removeEventListener( 'mousemove', mousemove );
			document.removeEventListener( 'mouseup', mouseup );
			_this.dispatchEvent( endEvent );

		}

		function mousewheel( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.deltaMode ) {

				case 2:
					// Zoom in pages
					_zoomStart.y -= event.deltaY * 0.025;
					break;

				case 1:
					// Zoom in lines
					_zoomStart.y -= event.deltaY * 0.01;
					break;

				default:
					// undefined, 0, assume pixels
					_zoomStart.y -= event.deltaY * 0.00025;
					break;

			}

			_this.dispatchEvent( startEvent );
			_this.dispatchEvent( endEvent );

		}

		function touchstart( event ) {

			if ( _this.enabled === false ) return;

			switch ( event.touches.length ) {

				case 1:
					_state = STATE.TOUCH_ROTATE;
					_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
					_movePrev.copy( _moveCurr );
					break;

				default: // 2 or more
					_state = STATE.TOUCH_ZOOM_PAN;
					var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
					var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
					_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

					var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
					var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
					_panStart.copy( getMouseOnScreen( x, y ) );
					_panEnd.copy( _panStart );
					break;

			}

			_this.dispatchEvent( startEvent );

		}

		function touchmove( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.touches.length ) {

				case 1:
					_movePrev.copy( _moveCurr );
					_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
					break;

				default: // 2 or more
					var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
					var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
					_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

					var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
					var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
					_panEnd.copy( getMouseOnScreen( x, y ) );
					break;

			}

		}

		function touchend( event ) {

			if ( _this.enabled === false ) return;

			switch ( event.touches.length ) {

				case 0:
					_state = STATE.NONE;
					break;

				case 1:
					_state = STATE.TOUCH_ROTATE;
					_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
					_movePrev.copy( _moveCurr );
					break;

			}

			_this.dispatchEvent( endEvent );

		}

		function contextmenu( event ) {

			if ( _this.enabled === false ) return;

			event.preventDefault();

		}

		this.dispose = function() {

			this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
			this.domElement.removeEventListener( 'mousedown', mousedown, false );
			this.domElement.removeEventListener( 'wheel', mousewheel, false );

			this.domElement.removeEventListener( 'touchstart', touchstart, false );
			this.domElement.removeEventListener( 'touchend', touchend, false );
			this.domElement.removeEventListener( 'touchmove', touchmove, false );

			document.removeEventListener( 'mousemove', mousemove, false );
			document.removeEventListener( 'mouseup', mouseup, false );

			window.removeEventListener( 'keydown', keydown, false );
			window.removeEventListener( 'keyup', keyup, false );

		};

		this.domElement.addEventListener( 'contextmenu', contextmenu, false );
		this.domElement.addEventListener( 'mousedown', mousedown, false );
		this.domElement.addEventListener( 'wheel', mousewheel, false );

		this.domElement.addEventListener( 'touchstart', touchstart, false );
		this.domElement.addEventListener( 'touchend', touchend, false );
		this.domElement.addEventListener( 'touchmove', touchmove, false );

		window.addEventListener( 'keydown', keydown, false );
		window.addEventListener( 'keyup', keyup, false );

		this.handleResize();

		// force an update at start
		this.update();

	};

	function preventEvent( event ) { event.preventDefault(); }

	TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );


/***/ }),
/* 86 */
/***/ (function(module, exports) {

	module.exports = function( THREE ) {
		/**
		 * @author qiao / https://github.com/qiao
		 * @author mrdoob / http://mrdoob.com
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author erich666 / http://erichaines.com
		 */

	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe

		function OrbitControls( object, domElement ) {

			this.object = object;

			this.domElement = ( domElement !== undefined ) ? domElement : document;

			// Set to false to disable this control
			this.enabled = true;

			// "target" sets the location of focus, where the object orbits around
			this.target = new THREE.Vector3();

			// How far you can dolly in and out ( PerspectiveCamera only )
			this.minDistance = 0;
			this.maxDistance = Infinity;

			// How far you can zoom in and out ( OrthographicCamera only )
			this.minZoom = 0;
			this.maxZoom = Infinity;

			// How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.
			this.minPolarAngle = 0; // radians
			this.maxPolarAngle = Math.PI; // radians

			// How far you can orbit horizontally, upper and lower limits.
			// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
			this.minAzimuthAngle = - Infinity; // radians
			this.maxAzimuthAngle = Infinity; // radians

			// Set to true to enable damping (inertia)
			// If damping is enabled, you must call controls.update() in your animation loop
			this.enableDamping = false;
			this.dampingFactor = 0.25;

			// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
			// Set to false to disable zooming
			this.enableZoom = true;
			this.zoomSpeed = 1.0;

			// Set to false to disable rotating
			this.enableRotate = true;
			this.rotateSpeed = 1.0;

			// Set to false to disable panning
			this.enablePan = true;
			this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

			// Set to true to automatically rotate around the target
			// If auto-rotate is enabled, you must call controls.update() in your animation loop
			this.autoRotate = false;
			this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

			// Set to false to disable use of the keys
			this.enableKeys = true;

			// The four arrow keys
			this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

			// Mouse buttons
			this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

			// for reset
			this.target0 = this.target.clone();
			this.position0 = this.object.position.clone();
			this.zoom0 = this.object.zoom;

			//
			// public methods
			//

			this.getPolarAngle = function () {

				return spherical.phi;

			};

			this.getAzimuthalAngle = function () {

				return spherical.theta;

			};

			this.reset = function () {

				scope.target.copy( scope.target0 );
				scope.object.position.copy( scope.position0 );
				scope.object.zoom = scope.zoom0;

				scope.object.updateProjectionMatrix();
				scope.dispatchEvent( changeEvent );

				scope.update();

				state = STATE.NONE;

			};

			// this method is exposed, but perhaps it would be better if we can make it private...
			this.update = function() {

				var offset = new THREE.Vector3();

				// so camera.up is the orbit axis
				var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
				var quatInverse = quat.clone().inverse();

				var lastPosition = new THREE.Vector3();
				var lastQuaternion = new THREE.Quaternion();

				return function update () {

					var position = scope.object.position;

					offset.copy( position ).sub( scope.target );

					// rotate offset to "y-axis-is-up" space
					offset.applyQuaternion( quat );

					// angle from z-axis around y-axis
					spherical.setFromVector3( offset );

					if ( scope.autoRotate && state === STATE.NONE ) {

						rotateLeft( getAutoRotationAngle() );

					}

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

					// restrict theta to be between desired limits
					spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

					// restrict phi to be between desired limits
					spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

					spherical.makeSafe();


					spherical.radius *= scale;

					// restrict radius to be between desired limits
					spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

					// move target to panned location
					scope.target.add( panOffset );

					offset.setFromSpherical( spherical );

					// rotate offset back to "camera-up-vector-is-up" space
					offset.applyQuaternion( quatInverse );

					position.copy( scope.target ).add( offset );

					scope.object.lookAt( scope.target );

					if ( scope.enableDamping === true ) {

						sphericalDelta.theta *= ( 1 - scope.dampingFactor );
						sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					} else {

						sphericalDelta.set( 0, 0, 0 );

					}

					scale = 1;
					panOffset.set( 0, 0, 0 );

					// update condition is:
					// min(camera displacement, camera rotation in radians)^2 > EPS
					// using small-angle approximation cos(x/2) = 1 - x^2 / 8

					if ( zoomChanged ||
						lastPosition.distanceToSquared( scope.object.position ) > EPS ||
						8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

						scope.dispatchEvent( changeEvent );

						lastPosition.copy( scope.object.position );
						lastQuaternion.copy( scope.object.quaternion );
						zoomChanged = false;

						return true;

					}

					return false;

				};

			}();

			this.dispose = function() {

				scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
				scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
				scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

				scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
				scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
				scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );

				window.removeEventListener( 'keydown', onKeyDown, false );

				//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

			};

			//
			// internals
			//

			var scope = this;

			var changeEvent = { type: 'change' };
			var startEvent = { type: 'start' };
			var endEvent = { type: 'end' };

			var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

			var state = STATE.NONE;

			var EPS = 0.000001;

			// current position in spherical coordinates
			var spherical = new THREE.Spherical();
			var sphericalDelta = new THREE.Spherical();

			var scale = 1;
			var panOffset = new THREE.Vector3();
			var zoomChanged = false;

			var rotateStart = new THREE.Vector2();
			var rotateEnd = new THREE.Vector2();
			var rotateDelta = new THREE.Vector2();

			var panStart = new THREE.Vector2();
			var panEnd = new THREE.Vector2();
			var panDelta = new THREE.Vector2();

			var dollyStart = new THREE.Vector2();
			var dollyEnd = new THREE.Vector2();
			var dollyDelta = new THREE.Vector2();

			function getAutoRotationAngle() {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

			function getZoomScale() {

				return Math.pow( 0.95, scope.zoomSpeed );

			}

			function rotateLeft( angle ) {

				sphericalDelta.theta -= angle;

			}

			function rotateUp( angle ) {

				sphericalDelta.phi -= angle;

			}

			var panLeft = function() {

				var v = new THREE.Vector3();

				return function panLeft( distance, objectMatrix ) {

					v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
					v.multiplyScalar( - distance );

					panOffset.add( v );

				};

			}();

			var panUp = function() {

				var v = new THREE.Vector3();

				return function panUp( distance, objectMatrix ) {

					v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
					v.multiplyScalar( distance );

					panOffset.add( v );

				};

			}();

			// deltaX and deltaY are in pixels; right and down are positive
			var pan = function() {

				var offset = new THREE.Vector3();

				return function pan ( deltaX, deltaY ) {

					var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

					if ( scope.object instanceof THREE.PerspectiveCamera ) {

						// perspective
						var position = scope.object.position;
						offset.copy( position ).sub( scope.target );
						var targetDistance = offset.length();

						// half of the fov is center to top of screen
						targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

						// we actually don't use screenWidth, since perspective camera is fixed to screen height
						panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
						panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

					} else if ( scope.object instanceof THREE.OrthographicCamera ) {

						// orthographic
						panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
						panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

					} else {

						// camera neither orthographic nor perspective
						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
						scope.enablePan = false;

					}

				};

			}();

			function dollyIn( dollyScale ) {

				if ( scope.object instanceof THREE.PerspectiveCamera ) {

					scale /= dollyScale;

				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				} else {

					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;

				}

			}

			function dollyOut( dollyScale ) {

				if ( scope.object instanceof THREE.PerspectiveCamera ) {

					scale *= dollyScale;

				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				} else {

					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;

				}

			}

			//
			// event callbacks - update the object state
			//

			function handleMouseDownRotate( event ) {

				//console.log( 'handleMouseDownRotate' );

				rotateStart.set( event.clientX, event.clientY );

			}

			function handleMouseDownDolly( event ) {

				//console.log( 'handleMouseDownDolly' );

				dollyStart.set( event.clientX, event.clientY );

			}

			function handleMouseDownPan( event ) {

				//console.log( 'handleMouseDownPan' );

				panStart.set( event.clientX, event.clientY );

			}

			function handleMouseMoveRotate( event ) {

				//console.log( 'handleMouseMoveRotate' );

				rotateEnd.set( event.clientX, event.clientY );
				rotateDelta.subVectors( rotateEnd, rotateStart );

				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

				rotateStart.copy( rotateEnd );

				scope.update();

			}

			function handleMouseMoveDolly( event ) {

				//console.log( 'handleMouseMoveDolly' );

				dollyEnd.set( event.clientX, event.clientY );

				dollyDelta.subVectors( dollyEnd, dollyStart );

				if ( dollyDelta.y > 0 ) {

					dollyIn( getZoomScale() );

				} else if ( dollyDelta.y < 0 ) {

					dollyOut( getZoomScale() );

				}

				dollyStart.copy( dollyEnd );

				scope.update();

			}

			function handleMouseMovePan( event ) {

				//console.log( 'handleMouseMovePan' );

				panEnd.set( event.clientX, event.clientY );

				panDelta.subVectors( panEnd, panStart );

				pan( panDelta.x, panDelta.y );

				panStart.copy( panEnd );

				scope.update();

			}

			function handleMouseUp( event ) {

				//console.log( 'handleMouseUp' );

			}

			function handleMouseWheel( event ) {

				//console.log( 'handleMouseWheel' );

				if ( event.deltaY < 0 ) {

					dollyOut( getZoomScale() );

				} else if ( event.deltaY > 0 ) {

					dollyIn( getZoomScale() );

				}

				scope.update();

			}

			function handleKeyDown( event ) {

				//console.log( 'handleKeyDown' );

				switch ( event.keyCode ) {

					case scope.keys.UP:
						pan( 0, scope.keyPanSpeed );
						scope.update();
						break;

					case scope.keys.BOTTOM:
						pan( 0, - scope.keyPanSpeed );
						scope.update();
						break;

					case scope.keys.LEFT:
						pan( scope.keyPanSpeed, 0 );
						scope.update();
						break;

					case scope.keys.RIGHT:
						pan( - scope.keyPanSpeed, 0 );
						scope.update();
						break;

				}

			}

			function handleTouchStartRotate( event ) {

				//console.log( 'handleTouchStartRotate' );

				rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			}

			function handleTouchStartDolly( event ) {

				//console.log( 'handleTouchStartDolly' );

				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

				var distance = Math.sqrt( dx * dx + dy * dy );

				dollyStart.set( 0, distance );

			}

			function handleTouchStartPan( event ) {

				//console.log( 'handleTouchStartPan' );

				panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			}

			function handleTouchMoveRotate( event ) {

				//console.log( 'handleTouchMoveRotate' );

				rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				rotateDelta.subVectors( rotateEnd, rotateStart );

				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

				rotateStart.copy( rotateEnd );

				scope.update();

			}

			function handleTouchMoveDolly( event ) {

				//console.log( 'handleTouchMoveDolly' );

				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

				var distance = Math.sqrt( dx * dx + dy * dy );

				dollyEnd.set( 0, distance );

				dollyDelta.subVectors( dollyEnd, dollyStart );

				if ( dollyDelta.y > 0 ) {

					dollyOut( getZoomScale() );

				} else if ( dollyDelta.y < 0 ) {

					dollyIn( getZoomScale() );

				}

				dollyStart.copy( dollyEnd );

				scope.update();

			}

			function handleTouchMovePan( event ) {

				//console.log( 'handleTouchMovePan' );

				panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

				panDelta.subVectors( panEnd, panStart );

				pan( panDelta.x, panDelta.y );

				panStart.copy( panEnd );

				scope.update();

			}

			function handleTouchEnd( event ) {

				//console.log( 'handleTouchEnd' );

			}

			//
			// event handlers - FSM: listen for events and reset state
			//

			function onMouseDown( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();

				if ( event.button === scope.mouseButtons.ORBIT ) {

					if ( scope.enableRotate === false ) return;

					handleMouseDownRotate( event );

					state = STATE.ROTATE;

				} else if ( event.button === scope.mouseButtons.ZOOM ) {

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

				} else if ( event.button === scope.mouseButtons.PAN ) {

					if ( scope.enablePan === false ) return;

					handleMouseDownPan( event );

					state = STATE.PAN;

				}

				if ( state !== STATE.NONE ) {

					document.addEventListener( 'mousemove', onMouseMove, false );
					document.addEventListener( 'mouseup', onMouseUp, false );

					scope.dispatchEvent( startEvent );

				}

			}

			function onMouseMove( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();

				if ( state === STATE.ROTATE ) {

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

				} else if ( state === STATE.DOLLY ) {

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

				} else if ( state === STATE.PAN ) {

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

				}

			}

			function onMouseUp( event ) {

				if ( scope.enabled === false ) return;

				handleMouseUp( event );

				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( endEvent );

				state = STATE.NONE;

			}

			function onMouseWheel( event ) {

				if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

				event.preventDefault();
				event.stopPropagation();

				handleMouseWheel( event );

				scope.dispatchEvent( startEvent ); // not sure why these are here...
				scope.dispatchEvent( endEvent );

			}

			function onKeyDown( event ) {

				if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

				handleKeyDown( event );

			}

			function onTouchStart( event ) {

				if ( scope.enabled === false ) return;

				switch ( event.touches.length ) {

					case 1:	// one-fingered touch: rotate

						if ( scope.enableRotate === false ) return;

						handleTouchStartRotate( event );

						state = STATE.TOUCH_ROTATE;

						break;

					case 2:	// two-fingered touch: dolly

						if ( scope.enableZoom === false ) return;

						handleTouchStartDolly( event );

						state = STATE.TOUCH_DOLLY;

						break;

					case 3: // three-fingered touch: pan

						if ( scope.enablePan === false ) return;

						handleTouchStartPan( event );

						state = STATE.TOUCH_PAN;

						break;

					default:

						state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.dispatchEvent( startEvent );

				}

			}

			function onTouchMove( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();
				event.stopPropagation();

				switch ( event.touches.length ) {

					case 1: // one-fingered touch: rotate

						if ( scope.enableRotate === false ) return;
						if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

						handleTouchMoveRotate( event );

						break;

					case 2: // two-fingered touch: dolly

						if ( scope.enableZoom === false ) return;
						if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

						handleTouchMoveDolly( event );

						break;

					case 3: // three-fingered touch: pan

						if ( scope.enablePan === false ) return;
						if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

						handleTouchMovePan( event );

						break;

					default:

						state = STATE.NONE;

				}

			}

			function onTouchEnd( event ) {

				if ( scope.enabled === false ) return;

				handleTouchEnd( event );

				scope.dispatchEvent( endEvent );

				state = STATE.NONE;

			}

			function onContextMenu( event ) {

				event.preventDefault();

			}

			//

			scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

			scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

			scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

			window.addEventListener( 'keydown', onKeyDown, false );

			// force an update at start

			this.update();

		};

		OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
		OrbitControls.prototype.constructor = OrbitControls;

		Object.defineProperties( OrbitControls.prototype, {

			center: {

				get: function () {

					console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
					return this.target;

				}

			},

			// backward compatibility

			noZoom: {

				get: function () {

					console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
					return ! this.enableZoom;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
					this.enableZoom = ! value;

				}

			},

			noRotate: {

				get: function () {

					console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
					return ! this.enableRotate;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
					this.enableRotate = ! value;

				}

			},

			noPan: {

				get: function () {

					console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
					return ! this.enablePan;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
					this.enablePan = ! value;

				}

			},

			noKeys: {

				get: function () {

					console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
					return ! this.enableKeys;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
					this.enableKeys = ! value;

				}

			},

			staticMoving : {

				get: function () {

					console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
					return ! this.enableDamping;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
					this.enableDamping = ! value;

				}

			},

			dynamicDampingFactor : {

				get: function () {

					console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
					return this.dampingFactor;

				},

				set: function ( value ) {

					console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
					this.dampingFactor = value;

				}

			}

		} );

		return OrbitControls;
	};


/***/ }),
/* 87 */
/***/ (function(module, exports) {

	

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author paulirish / http://paulirish.com/
	 */


	module.exports = function(THREE) {

	    THREE.FlyControls = function ( object, domElement, opts ) {

	        this.object = object;

		this.domElement = ( domElement !== undefined ) ? domElement : document;
		if ( domElement ) this.domElement.setAttribute( 'tabindex', - 1 );

		// API

		this.movementSpeed = 1.0;
		this.rollSpeed = 0.005;

		this.dragToLook = false;
		this.autoForward = false;

		// disable default target object behavior

		// internals

		this.tmpQuaternion = new THREE.Quaternion();

		this.mouseStatus = 0;

		this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
		this.moveVector = new THREE.Vector3( 0, 0, 0 );
		this.rotationVector = new THREE.Vector3( 0, 0, 0 );

		this.keydown = function ( event ) {

			if ( event.altKey ) {

				return;

			}

			//event.preventDefault();

			switch ( event.keyCode ) {

				case 16: /* shift */ this.movementSpeedMultiplier = .1; break;

				case 87: /*W*/ this.moveState.forward = 1; break;
				case 83: /*S*/ this.moveState.back = 1; break;

				case 65: /*A*/ this.moveState.left = 1; break;
				case 68: /*D*/ this.moveState.right = 1; break;

				case 82: /*R*/ this.moveState.up = 1; break;
				case 70: /*F*/ this.moveState.down = 1; break;

				case 38: /*up*/ this.moveState.pitchUp = 1; break;
				case 40: /*down*/ this.moveState.pitchDown = 1; break;

				case 37: /*left*/ this.moveState.yawLeft = 1; break;
				case 39: /*right*/ this.moveState.yawRight = 1; break;

				case 81: /*Q*/ this.moveState.rollLeft = 1; break;
				case 69: /*E*/ this.moveState.rollRight = 1; break;

			}

			this.updateMovementVector();
			this.updateRotationVector();

		};

		this.keyup = function ( event ) {

			switch ( event.keyCode ) {

				case 16: /* shift */ this.movementSpeedMultiplier = 1; break;

				case 87: /*W*/ this.moveState.forward = 0; break;
				case 83: /*S*/ this.moveState.back = 0; break;

				case 65: /*A*/ this.moveState.left = 0; break;
				case 68: /*D*/ this.moveState.right = 0; break;

				case 82: /*R*/ this.moveState.up = 0; break;
				case 70: /*F*/ this.moveState.down = 0; break;

				case 38: /*up*/ this.moveState.pitchUp = 0; break;
				case 40: /*down*/ this.moveState.pitchDown = 0; break;

				case 37: /*left*/ this.moveState.yawLeft = 0; break;
				case 39: /*right*/ this.moveState.yawRight = 0; break;

				case 81: /*Q*/ this.moveState.rollLeft = 0; break;
				case 69: /*E*/ this.moveState.rollRight = 0; break;

			}

			this.updateMovementVector();
			this.updateRotationVector();

		};

		this.mousedown = function ( event ) {

			if ( this.domElement !== document ) {

				this.domElement.focus();

			}

			event.preventDefault();
			event.stopPropagation();

			if ( this.dragToLook ) {

				this.mouseStatus ++;

			} else {

				switch ( event.button ) {

					case 0: this.moveState.forward = 1; break;
					case 2: this.moveState.back = 1; break;

				}

				this.updateMovementVector();

			}

		};

		this.mousemove = function ( event ) {

			if ( ! this.dragToLook || this.mouseStatus > 0 ) {

				var container = this.getContainerDimensions();
				var halfWidth = container.size[ 0 ] / 2;
				var halfHeight = container.size[ 1 ] / 2;

				this.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;
				this.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

				this.updateRotationVector();

			}

		};

		this.mouseup = function ( event ) {

			event.preventDefault();
			event.stopPropagation();

			if ( this.dragToLook ) {

				this.mouseStatus --;

				this.moveState.yawLeft = this.moveState.pitchDown = 0;

			} else {

				switch ( event.button ) {

					case 0: this.moveState.forward = 0; break;
					case 2: this.moveState.back = 0; break;

				}

				this.updateMovementVector();

			}

			this.updateRotationVector();

		};

		this.update = function ( delta ) {

			var moveMult = delta * this.movementSpeed;
			var rotMult = delta * this.rollSpeed;

			this.object.translateX( this.moveVector.x * moveMult );
			this.object.translateY( this.moveVector.y * moveMult );
			this.object.translateZ( this.moveVector.z * moveMult );

			this.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();
			this.object.quaternion.multiply( this.tmpQuaternion );

			// expose the rotation vector for convenience
			this.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );


		};

		this.updateMovementVector = function () {

			var forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0;

			this.moveVector.x = ( - this.moveState.left + this.moveState.right );
			this.moveVector.y = ( - this.moveState.down + this.moveState.up );
			this.moveVector.z = ( - forward + this.moveState.back );

			//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

		};

		this.updateRotationVector = function () {

			this.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp );
			this.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft );
			this.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft );

			//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

		};

		this.getContainerDimensions = function () {

			if ( this.domElement != document ) {

				return {
					size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
					offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
				};

			} else {

				return {
					size: [ window.innerWidth, window.innerHeight ],
					offset: [ 0, 0 ]
				};

			}

		};

		function bind( scope, fn ) {

			return function () {

				fn.apply( scope, arguments );

			};

		}

		function contextmenu( event ) {

			event.preventDefault();

		}

		this.dispose = function () {

			this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
			this.domElement.removeEventListener( 'mousedown', _mousedown, false );
			this.domElement.removeEventListener( 'mousemove', _mousemove, false );
			this.domElement.removeEventListener( 'mouseup', _mouseup, false );

			window.removeEventListener( 'keydown', _keydown, false );
			window.removeEventListener( 'keyup', _keyup, false );

		};

		var _mousemove = bind( this, this.mousemove );
		var _mousedown = bind( this, this.mousedown );
		var _mouseup = bind( this, this.mouseup );
		var _keydown = bind( this, this.keydown );
		var _keyup = bind( this, this.keyup );

		this.domElement.addEventListener( 'contextmenu', contextmenu, false );

		this.domElement.addEventListener( 'mousemove', _mousemove, false );
		this.domElement.addEventListener( 'mousedown', _mousedown, false );
		this.domElement.addEventListener( 'mouseup', _mouseup, false );

		window.addEventListener( 'keydown', _keydown, false );
		window.addEventListener( 'keyup', _keyup, false );

		this.updateMovementVector();
		this.updateRotationVector();

	    };

	};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _math = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(89));

	exports.math = _math["default"];

	var _cssVar = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(93));

	exports.cssVar = _cssVar["default"];

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	exports.directionalProperty = _directionalProperty["default"];

	var _em = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(96));

	exports.em = _em["default"];

	var _getValueAndUnit = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(100));

	exports.getValueAndUnit = _getValueAndUnit["default"];

	var _modularScale = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(101));

	exports.modularScale = _modularScale["default"];

	var _rem = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(102));

	exports.rem = _rem["default"];

	var _stripUnit = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(99));

	exports.stripUnit = _stripUnit["default"];

	var _between = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(103));

	exports.between = _between["default"];

	var _clearFix = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(104));

	exports.clearFix = _clearFix["default"];

	var _cover = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(105));

	exports.cover = _cover["default"];

	var _ellipsis = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(106));

	exports.ellipsis = _ellipsis["default"];

	var _fluidRange = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(107));

	exports.fluidRange = _fluidRange["default"];

	var _fontFace = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(108));

	exports.fontFace = _fontFace["default"];

	var _hideText = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(109));

	exports.hideText = _hideText["default"];

	var _hideVisually = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(110));

	exports.hideVisually = _hideVisually["default"];

	var _hiDPI = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(111));

	exports.hiDPI = _hiDPI["default"];

	var _linearGradient = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(112));

	exports.linearGradient = _linearGradient["default"];

	var _normalize = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(114));

	exports.normalize = _normalize["default"];

	var _radialGradient = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(115));

	exports.radialGradient = _radialGradient["default"];

	var _retinaImage = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(116));

	exports.retinaImage = _retinaImage["default"];

	var _timingFunctions = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(117));

	exports.timingFunctions = _timingFunctions["default"];

	var _triangle = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(118));

	exports.triangle = _triangle["default"];

	var _wordWrap = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(119));

	exports.wordWrap = _wordWrap["default"];

	var _adjustHue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(120));

	exports.adjustHue = _adjustHue["default"];

	var _complement = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(135));

	exports.complement = _complement["default"];

	var _darken = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(136));

	exports.darken = _darken["default"];

	var _desaturate = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(138));

	exports.desaturate = _desaturate["default"];

	var _getContrast = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(139));

	exports.getContrast = _getContrast["default"];

	var _getLuminance = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(140));

	exports.getLuminance = _getLuminance["default"];

	var _grayscale = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(141));

	exports.grayscale = _grayscale["default"];

	var _hsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(127));

	exports.hsl = _hsl["default"];

	var _hsla = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(131));

	exports.hsla = _hsla["default"];

	var _hslToColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(142));

	exports.hslToColorString = _hslToColorString["default"];

	var _invert = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(143));

	exports.invert = _invert["default"];

	var _lighten = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(144));

	exports.lighten = _lighten["default"];

	var _meetsContrastGuidelines = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(145));

	exports.meetsContrastGuidelines = _meetsContrastGuidelines["default"];

	var _mix = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(146));

	exports.mix = _mix["default"];

	var _opacify = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(147));

	exports.opacify = _opacify["default"];

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	exports.parseToHsl = _parseToHsl["default"];

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	exports.parseToRgb = _parseToRgb["default"];

	var _readableColor = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(148));

	exports.readableColor = _readableColor["default"];

	var _rgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(132));

	exports.rgb = _rgb["default"];

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	exports.rgba = _rgba["default"];

	var _rgbToColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(149));

	exports.rgbToColorString = _rgbToColorString["default"];

	var _saturate = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(150));

	exports.saturate = _saturate["default"];

	var _setHue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(151));

	exports.setHue = _setHue["default"];

	var _setLightness = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(152));

	exports.setLightness = _setLightness["default"];

	var _setSaturation = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(153));

	exports.setSaturation = _setSaturation["default"];

	var _shade = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(154));

	exports.shade = _shade["default"];

	var _tint = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(155));

	exports.tint = _tint["default"];

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	exports.toColorString = _toColorString["default"];

	var _transparentize = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(156));

	exports.transparentize = _transparentize["default"];

	var _animation = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(157));

	exports.animation = _animation["default"];

	var _backgroundImages = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(158));

	exports.backgroundImages = _backgroundImages["default"];

	var _backgrounds = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(159));

	exports.backgrounds = _backgrounds["default"];

	var _border = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(160));

	exports.border = _border["default"];

	var _borderColor = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(161));

	exports.borderColor = _borderColor["default"];

	var _borderRadius = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(162));

	exports.borderRadius = _borderRadius["default"];

	var _borderStyle = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(163));

	exports.borderStyle = _borderStyle["default"];

	var _borderWidth = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(164));

	exports.borderWidth = _borderWidth["default"];

	var _buttons = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(165));

	exports.buttons = _buttons["default"];

	var _margin = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(167));

	exports.margin = _margin["default"];

	var _padding = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(168));

	exports.padding = _padding["default"];

	var _position = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(169));

	exports.position = _position["default"];

	var _size = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(170));

	exports.size = _size["default"];

	var _textInputs = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(171));

	exports.textInputs = _textInputs["default"];

	var _transitions = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(172));

	exports.transitions = _transitions["default"];

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = math;

	var _defaultMathSymbols = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(90));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	var unitRegExp = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g; // Merges additional math functionality into the defaults.

	function mergeSymbolMaps(additionalSymbols) {
	  var symbolMap = {};
	  symbolMap.symbols = additionalSymbols ? _extends({}, _defaultMathSymbols["default"].symbols, {}, additionalSymbols.symbols) : _extends({}, _defaultMathSymbols["default"].symbols);
	  return symbolMap;
	}

	function exec(operators, values) {
	  var _ref;

	  var op = operators.pop();
	  values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));
	  return op.precedence;
	}

	function calculate(expression, additionalSymbols) {
	  var symbolMap = mergeSymbolMaps(additionalSymbols);
	  var match;
	  var operators = [symbolMap.symbols['('].prefix];
	  var values = [];
	  var pattern = new RegExp( // Pattern for numbers
	  "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
	  Object.keys(symbolMap.symbols).map(function (key) {
	    return symbolMap.symbols[key];
	  }) // longer symbols should be listed first
	  // $FlowFixMe
	  .sort(function (a, b) {
	    return b.symbol.length - a.symbol.length;
	  }) // $FlowFixMe
	  .map(function (val) {
	    return val.regSymbol;
	  }).join('|') + "|(\\S)", 'g');
	  pattern.lastIndex = 0; // Reset regular expression object

	  var afterValue = false;

	  do {
	    match = pattern.exec(expression);

	    var _ref2 = match || [')', undefined],
	        token = _ref2[0],
	        bad = _ref2[1];

	    var notNumber = symbolMap.symbols[token];
	    var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;
	    var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix; // Check for syntax errors:

	    if (bad || (afterValue ? notAfterValue : notNewValue)) {
	      throw new _errors["default"](37, match ? match.index : expression.length, expression);
	    }

	    if (afterValue) {
	      // We either have an infix or postfix operator (they should be mutually exclusive)
	      var curr = notNumber.postfix || notNumber.infix;

	      do {
	        var prev = operators[operators.length - 1];
	        if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break; // Apply previous operator, since it has precedence over current one
	      } while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function


	      afterValue = curr.notation === 'postfix';

	      if (curr.symbol !== ')') {
	        operators.push(curr); // Postfix always has precedence over any operator that follows after it

	        if (afterValue) exec(operators, values);
	      }
	    } else if (notNumber) {
	      // prefix operator or function
	      operators.push(notNumber.prefix || notNumber.func);

	      if (notNumber.func) {
	        // Require an opening parenthesis
	        match = pattern.exec(expression);

	        if (!match || match[0] !== '(') {
	          throw new _errors["default"](38, match ? match.index : expression.length, expression);
	        }
	      }
	    } else {
	      // number
	      values.push(+token);
	      afterValue = true;
	    }
	  } while (match && operators.length);

	  if (operators.length) {
	    throw new _errors["default"](39, match ? match.index : expression.length, expression);
	  } else if (match) {
	    throw new _errors["default"](40, match ? match.index : expression.length, expression);
	  } else {
	    return values.pop();
	  }
	}

	function reverseString(str) {
	  return str.split('').reverse().join('');
	}
	/**
	 * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.
	 *
	 *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).
	 *
	 * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   fontSize: math('12rem + 8rem'),
	 *   fontSize: math('(12px + 2px) * 3'),
	 *   fontSize: math('3px^2 + sqrt(4)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   fontSize: ${math('12rem + 8rem')};
	 *   fontSize: ${math('(12px + 2px) * 3')};
	 *   fontSize: ${math('3px^2 + sqrt(4)')};
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   fontSize: '20rem',
	 *   fontSize: '42px',
	 *   fontSize: '11px',
	 * }
	 */


	function math(formula, additionalSymbols) {
	  var reversedFormula = reverseString(formula);
	  var formulaMatch = reversedFormula.match(unitRegExp); // Check that all units are the same

	  if (formulaMatch && !formulaMatch.every(function (unit) {
	    return unit === formulaMatch[0];
	  })) {
	    throw new _errors["default"](41);
	  }

	  var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, ''));
	  return "" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : '');
	}

	module.exports = exports.default;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function last() {
	  var _ref;

	  return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];
	}

	function negation(a) {
	  return -a;
	}

	function addition(a, b) {
	  return a + b;
	}

	function subtraction(a, b) {
	  return a - b;
	}

	function multiplication(a, b) {
	  return a * b;
	}

	function division(a, b) {
	  return a / b;
	}

	function factorial(a) {
	  if (a % 1 || !(+a >= 0)) return NaN;
	  if (a > 170) return Infinity;else if (a === 0) return 1;else {
	    return a * factorial(a - 1);
	  }
	}

	function power(a, b) {
	  return Math.pow(a, b);
	}

	function sqrt(a) {
	  return Math.sqrt(a);
	}

	function max() {
	  return Math.max.apply(Math, arguments);
	}

	function min() {
	  return Math.min.apply(Math, arguments);
	}

	function comma() {
	  return Array.of.apply(Array, arguments);
	}

	var defaultMathSymbols = {
	  symbols: {
	    '!': {
	      postfix: {
	        symbol: '!',
	        f: factorial,
	        notation: 'postfix',
	        precedence: 6,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: '!',
	      regSymbol: '!'
	    },
	    '^': {
	      infix: {
	        symbol: '^',
	        f: power,
	        notation: 'infix',
	        precedence: 5,
	        rightToLeft: 1,
	        argCount: 2
	      },
	      symbol: '^',
	      regSymbol: '\\^'
	    },
	    '*': {
	      infix: {
	        symbol: '*',
	        f: multiplication,
	        notation: 'infix',
	        precedence: 4,
	        rightToLeft: 0,
	        argCount: 2
	      },
	      symbol: '*',
	      regSymbol: '\\*'
	    },
	    '/': {
	      infix: {
	        symbol: '/',
	        f: division,
	        notation: 'infix',
	        precedence: 4,
	        rightToLeft: 0,
	        argCount: 2
	      },
	      symbol: '/',
	      regSymbol: '/'
	    },
	    '+': {
	      infix: {
	        symbol: '+',
	        f: addition,
	        notation: 'infix',
	        precedence: 2,
	        rightToLeft: 0,
	        argCount: 2
	      },
	      prefix: {
	        symbol: '+',
	        f: last,
	        notation: 'prefix',
	        precedence: 3,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: '+',
	      regSymbol: '\\+'
	    },
	    '-': {
	      infix: {
	        symbol: '-',
	        f: subtraction,
	        notation: 'infix',
	        precedence: 2,
	        rightToLeft: 0,
	        argCount: 2
	      },
	      prefix: {
	        symbol: '-',
	        f: negation,
	        notation: 'prefix',
	        precedence: 3,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: '-',
	      regSymbol: '-'
	    },
	    ',': {
	      infix: {
	        symbol: ',',
	        f: comma,
	        notation: 'infix',
	        precedence: 1,
	        rightToLeft: 0,
	        argCount: 2
	      },
	      symbol: ',',
	      regSymbol: ','
	    },
	    '(': {
	      prefix: {
	        symbol: '(',
	        f: last,
	        notation: 'prefix',
	        precedence: 0,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: '(',
	      regSymbol: '\\('
	    },
	    ')': {
	      postfix: {
	        symbol: ')',
	        f: undefined,
	        notation: 'postfix',
	        precedence: 0,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: ')',
	      regSymbol: '\\)'
	    },
	    min: {
	      func: {
	        symbol: 'min',
	        f: min,
	        notation: 'func',
	        precedence: 0,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: 'min',
	      regSymbol: 'min\\b'
	    },
	    max: {
	      func: {
	        symbol: 'max',
	        f: max,
	        notation: 'func',
	        precedence: 0,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: 'max',
	      regSymbol: 'max\\b'
	    },
	    sqrt: {
	      func: {
	        symbol: 'sqrt',
	        f: sqrt,
	        notation: 'func',
	        precedence: 0,
	        rightToLeft: 0,
	        argCount: 1
	      },
	      symbol: 'sqrt',
	      regSymbol: 'sqrt\\b'
	    }
	  }
	};
	var _default = defaultMathSymbols;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

	function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

	function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js

	/**
	 * Parse errors.md and turn it into a simple hash of code: message
	 * @private
	 */
	var ERRORS = {
	  "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
	  "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
	  "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
	  "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
	  "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
	  "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
	  "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
	  "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
	  "9": "Please provide a number of steps to the modularScale helper.\n\n",
	  "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
	  "11": "Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\n\n",
	  "12": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\n\n",
	  "13": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\n\n",
	  "14": "Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
	  "15": "Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
	  "16": "You must provide a template to this method.\n\n",
	  "17": "You passed an unsupported selector state to this method.\n\n",
	  "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
	  "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
	  "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
	  "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
	  "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
	  "23": "fontFace expects a name of a font-family.\n\n",
	  "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
	  "25": "fontFace expects localFonts to be an array.\n\n",
	  "26": "fontFace expects fileFormats to be an array.\n\n",
	  "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
	  "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
	  "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
	  "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
	  "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
	  "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
	  "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
	  "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
	  "35": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
	  "36": "Property must be a string value.\n\n",
	  "37": "Syntax Error at %s.\n\n",
	  "38": "Formula contains a function that needs parentheses at %s.\n\n",
	  "39": "Formula is missing closing parenthesis at %s.\n\n",
	  "40": "Formula has too many closing parentheses at %s.\n\n",
	  "41": "All values in a formula must have the same unit or be unitless.\n\n",
	  "42": "Please provide a number of steps to the modularScale helper.\n\n",
	  "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
	  "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
	  "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
	  "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
	  "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
	  "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
	  "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
	  "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
	  "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
	  "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
	  "53": "fontFace expects localFonts to be an array.\n\n",
	  "54": "fontFace expects fileFormats to be an array.\n\n",
	  "55": "fontFace expects a name of a font-family.\n\n",
	  "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
	  "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
	  "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
	  "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
	  "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
	  "61": "Property must be a string value.\n\n",
	  "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
	  "63": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
	  "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
	  "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
	  "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
	  "67": "You must provide a template to this method.\n\n",
	  "68": "You passed an unsupported selector state to this method.\n\n",
	  "69": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\n\n",
	  "70": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\n\n",
	  "71": "Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
	  "72": "Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
	  "73": "Please provide a valid CSS variable.\n\n",
	  "74": "CSS variable not found.\n"
	};
	/**
	 * super basic version of sprintf
	 * @private
	 */

	function format() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  var a = args[0];
	  var b = [];
	  var c;

	  for (c = 1; c < args.length; c += 1) {
	    b.push(args[c]);
	  }

	  b.forEach(function (d) {
	    a = a.replace(/%[a-z]/, d);
	  });
	  return a;
	}
	/**
	 * Create an error file out of errors.md for development and a simple web link to the full errors
	 * in production mode.
	 * @private
	 */


	var PolishedError = /*#__PURE__*/function (_Error) {
	  _inheritsLoose(PolishedError, _Error);

	  function PolishedError(code) {
	    var _this;

	    if (process.env.NODE_ENV === 'production') {
	      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/master/src/internalHelpers/errors.md#" + code + " for more information.") || this;
	    } else {
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
	    }

	    return _assertThisInitialized(_this);
	  }

	  return PolishedError;
	}( /*#__PURE__*/_wrapNativeSuper(Error));

	exports["default"] = PolishedError;
	module.exports = exports.default;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)))

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = cssVar;

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var cssVariableRegex = /--[\S]*/g;
	/**
	 * Fetches the value of a passed CSS Variable.
	 *
	 * Passthrough can be enabled (off by default) for when you are unsure of the input and want non-variable values to be returned instead of an error.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   'background': cssVar('--background-color'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${cssVar('--background-color')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   'background': 'red'
	 * }
	 */

	function cssVar(cssVariable, passThrough) {
	  if (!cssVariable || !cssVariable.match(cssVariableRegex)) {
	    if (passThrough) return cssVariable;
	    throw new _errors["default"](73);
	  }

	  var variableValue;
	  /* eslint-disable */

	  /* istanbul ignore next */

	  if (document.documentElement !== null) {
	    variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);
	  }
	  /* eslint-enable */


	  if (variableValue) {
	    return variableValue;
	  } else {
	    throw new _errors["default"](74);
	  }
	}

	module.exports = exports.default;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = directionalProperty;

	var _capitalizeString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(95));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var positionMap = ['Top', 'Right', 'Bottom', 'Left'];

	function generateProperty(property, position) {
	  if (!property) return position.toLowerCase();
	  var splitProperty = property.split('-');

	  if (splitProperty.length > 1) {
	    splitProperty.splice(1, 0, position);
	    return splitProperty.reduce(function (acc, val) {
	      return "" + acc + (0, _capitalizeString["default"])(val);
	    });
	  }

	  var joinedProperty = property.replace(/([a-z])([A-Z])/g, "$1" + position + "$2");
	  return property === joinedProperty ? "" + property + position : joinedProperty;
	}

	function generateStyles(property, valuesWithDefaults) {
	  var styles = {};

	  for (var i = 0; i < valuesWithDefaults.length; i += 1) {
	    if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {
	      styles[generateProperty(property, positionMap[i])] = valuesWithDefaults[i];
	    }
	  }

	  return styles;
	}
	/**
	 * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'paddingTop': '12px',
	 *   'paddingRight': '24px',
	 *   'paddingBottom': '36px',
	 *   'paddingLeft': '48px'
	 * }
	 */


	function directionalProperty(property) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  //  prettier-ignore
	  var firstValue = values[0],
	      _values$ = values[1],
	      secondValue = _values$ === void 0 ? firstValue : _values$,
	      _values$2 = values[2],
	      thirdValue = _values$2 === void 0 ? firstValue : _values$2,
	      _values$3 = values[3],
	      fourthValue = _values$3 === void 0 ? secondValue : _values$3;
	  var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
	  return generateStyles(property, valuesWithDefaults);
	}

	module.exports = exports.default;

/***/ }),
/* 95 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	// @private
	function capitalizeString(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

	var _default = capitalizeString;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _pxto = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(97));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a
	 * second argument to the function.
	 * @function
	 * @param {string|number} pxval
	 * @param {string|number} [base='16px']
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   'height': em('16px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   height: ${em('16px')}
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   'height': '1em'
	 * }
	 */
	var em = /*#__PURE__*/(0, _pxto["default"])('em');
	var _default = em;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _endsWith = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(98));

	var _stripUnit = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(99));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Factory function that creates pixel-to-x converters
	 * @private
	 */
	var pxtoFactory = function pxtoFactory(to) {
	  return function (pxval, base) {
	    if (base === void 0) {
	      base = '16px';
	    }

	    var newPxval = pxval;
	    var newBase = base;

	    if (typeof pxval === 'string') {
	      if (!(0, _endsWith["default"])(pxval, 'px')) {
	        throw new _errors["default"](69, to, pxval);
	      }

	      newPxval = (0, _stripUnit["default"])(pxval);
	    }

	    if (typeof base === 'string') {
	      if (!(0, _endsWith["default"])(base, 'px')) {
	        throw new _errors["default"](70, to, base);
	      }

	      newBase = (0, _stripUnit["default"])(base);
	    }

	    if (typeof newPxval === 'string') {
	      throw new _errors["default"](71, pxval, to);
	    }

	    if (typeof newBase === 'string') {
	      throw new _errors["default"](72, base, to);
	    }

	    return "" + newPxval / newBase + to;
	  };
	};

	var _default = pxtoFactory;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = _default;

	/**
	 * Check if a string ends with something
	 * @private
	 */
	function _default(string, suffix) {
	  return string.substr(-suffix.length) === suffix;
	}

	module.exports = exports.default;

/***/ }),
/* 99 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = stripUnit;
	var cssRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
	/**
	 * Returns a given CSS value minus its unit of measure.
	 *
	 * @deprecated - stripUnit's unitReturn functionality has been marked for deprecation in polished 4.0. It's functionality has been been moved to getUnitAndValue.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   '--dimension': stripUnit('100px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   --dimension: ${stripUnit('100px')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   '--dimension': 100
	 * }
	 */

	function stripUnit(value, unitReturn) {
	  if (typeof value !== 'string') return unitReturn ? [value, undefined] : value;
	  var matchedValue = value.match(cssRegex);

	  if (unitReturn) {
	    // eslint-disable-next-line no-console
	    console.warn("stripUnit's unitReturn functionality has been marked for deprecation in polished 4.0. It's functionality has been been moved to getUnitAndValue.");
	    if (matchedValue) return [parseFloat(value), matchedValue[2]];
	    return [value, undefined];
	  }

	  if (matchedValue) return parseFloat(value);
	  return value;
	}

	module.exports = exports.default;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = getValueAndUnit;
	var cssRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
	/**
	 * Returns a given CSS value and its unit as elements of an array.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   '--dimension': getValueAndUnit('100px')[0],
	 *   '--unit': getValueAndUnit('100px')[1],
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   --dimension: ${getValueAndUnit('100px')[0]};
	 *   --unit: ${getValueAndUnit('100px')[1]};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   '--dimension': 100,
	 *   '--unit': 'px',
	 * }
	 */

	function getValueAndUnit(value) {
	  if (typeof value !== 'string') return [value, ''];
	  var matchedValue = value.match(cssRegex);
	  if (matchedValue) return [parseFloat(value), matchedValue[2]];
	  return [value, undefined];
	}

	module.exports = exports.default;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = modularScale;
	exports.ratioNames = void 0;

	var _getValueAndUnit = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(100));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var ratioNames = {
	  minorSecond: 1.067,
	  majorSecond: 1.125,
	  minorThird: 1.2,
	  majorThird: 1.25,
	  perfectFourth: 1.333,
	  augFourth: 1.414,
	  perfectFifth: 1.5,
	  minorSixth: 1.6,
	  goldenSection: 1.618,
	  majorSixth: 1.667,
	  minorSeventh: 1.778,
	  majorSeventh: 1.875,
	  octave: 2,
	  majorTenth: 2.5,
	  majorEleventh: 2.667,
	  majorTwelfth: 3,
	  doubleOctave: 4
	};
	exports.ratioNames = ratioNames;

	function getRatio(ratioName) {
	  return ratioNames[ratioName];
	}
	/**
	 * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *    // Increment two steps up the default scale
	 *   'fontSize': modularScale(2)
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *    // Increment two steps up the default scale
	 *   fontSize: ${modularScale(2)}
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   'fontSize': '1.77689em'
	 * }
	 */


	function modularScale(steps, base, ratio) {
	  if (base === void 0) {
	    base = '1em';
	  }

	  if (ratio === void 0) {
	    ratio = 1.333;
	  }

	  if (typeof steps !== 'number') {
	    throw new _errors["default"](42);
	  }

	  if (typeof ratio === 'string' && !ratioNames[ratio]) {
	    throw new _errors["default"](43);
	  }

	  var _ref = typeof base === 'string' ? (0, _getValueAndUnit["default"])(base) : [base, ''],
	      realBase = _ref[0],
	      unit = _ref[1];

	  var realRatio = typeof ratio === 'string' ? getRatio(ratio) : ratio;

	  if (typeof realBase === 'string') {
	    throw new _errors["default"](44, base);
	  }

	  return "" + realBase * Math.pow(realRatio, steps) + (unit || '');
	}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _pxto = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(97));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a
	 * second argument to the function.
	 * @function
	 * @param {string|number} pxval
	 * @param {string|number} [base='16px']
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   'height': rem('16px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   height: ${rem('16px')}
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   'height': '1rem'
	 * }
	 */
	var rem = /*#__PURE__*/(0, _pxto["default"])('rem');
	var _default = rem;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = between;

	var _getValueAndUnit5 = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(100));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   fontSize: between('20px', '100px', '400px', '1000px'),
	 *   fontSize: between('20px', '100px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   fontSize: ${between('20px', '100px', '400px', '1000px')};
	 *   fontSize: ${between('20px', '100px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * h1: {
	 *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',
	 *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'
	 * }
	 */
	function between(fromSize, toSize, minScreen, maxScreen) {
	  if (minScreen === void 0) {
	    minScreen = '320px';
	  }

	  if (maxScreen === void 0) {
	    maxScreen = '1200px';
	  }

	  var _getValueAndUnit = (0, _getValueAndUnit5["default"])(fromSize),
	      unitlessFromSize = _getValueAndUnit[0],
	      fromSizeUnit = _getValueAndUnit[1];

	  var _getValueAndUnit2 = (0, _getValueAndUnit5["default"])(toSize),
	      unitlessToSize = _getValueAndUnit2[0],
	      toSizeUnit = _getValueAndUnit2[1];

	  var _getValueAndUnit3 = (0, _getValueAndUnit5["default"])(minScreen),
	      unitlessMinScreen = _getValueAndUnit3[0],
	      minScreenUnit = _getValueAndUnit3[1];

	  var _getValueAndUnit4 = (0, _getValueAndUnit5["default"])(maxScreen),
	      unitlessMaxScreen = _getValueAndUnit4[0],
	      maxScreenUnit = _getValueAndUnit4[1];

	  if (typeof unitlessMinScreen !== 'number' || typeof unitlessMaxScreen !== 'number' || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {
	    throw new _errors["default"](47);
	  }

	  if (typeof unitlessFromSize !== 'number' || typeof unitlessToSize !== 'number' || fromSizeUnit !== toSizeUnit) {
	    throw new _errors["default"](48);
	  }

	  var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);
	  var base = unitlessToSize - slope * unitlessMaxScreen;
	  return "calc(" + base.toFixed(2) + (fromSizeUnit || '') + " + " + (100 * slope).toFixed(2) + "vw)";
	}

	module.exports = exports.default;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = clearFix;

	/**
	 * CSS to contain a float (credit to CSSMojo).
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *    ...clearFix(),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${clearFix()}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * '&::after': {
	 *   'clear': 'both',
	 *   'content': '""',
	 *   'display': 'table'
	 * }
	 */
	function clearFix(parent) {
	  var _ref;

	  if (parent === void 0) {
	    parent = '&';
	  }

	  var pseudoSelector = parent + "::after";
	  return _ref = {}, _ref[pseudoSelector] = {
	    clear: 'both',
	    content: '""',
	    display: 'table'
	  }, _ref;
	}

	module.exports = exports.default;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = cover;

	/**
	 * CSS to fully cover an area. Can optionally be passed an offset to act as a "padding".
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...cover()
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${cover()}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   'position': 'absolute',
	 *   'top': '0',
	 *   'right: '0',
	 *   'bottom': '0',
	 *   'left: '0'
	 * }
	 */
	function cover(offset) {
	  if (offset === void 0) {
	    offset = 0;
	  }

	  return {
	    position: 'absolute',
	    top: offset,
	    right: offset,
	    bottom: offset,
	    left: offset
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 106 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = ellipsis;

	/**
	 * CSS to represent truncated text with an ellipsis.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...ellipsis('250px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${ellipsis('250px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   'display': 'inline-block',
	 *   'maxWidth': '250px',
	 *   'overflow': 'hidden',
	 *   'textOverflow': 'ellipsis',
	 *   'whiteSpace': 'nowrap',
	 *   'wordWrap': 'normal'
	 * }
	 */
	function ellipsis(width) {
	  if (width === void 0) {
	    width = '100%';
	  }

	  return {
	    display: 'inline-block',
	    maxWidth: width,
	    overflow: 'hidden',
	    textOverflow: 'ellipsis',
	    whiteSpace: 'nowrap',
	    wordWrap: 'normal'
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = fluidRange;

	var _between = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(103));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...fluidRange(
	 *    {
	 *        prop: 'padding',
	 *        fromSize: '20px',
	 *        toSize: '100px',
	 *      },
	 *      '400px',
	 *      '1000px',
	 *    )
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${fluidRange(
	 *      {
	 *        prop: 'padding',
	 *        fromSize: '20px',
	 *        toSize: '100px',
	 *      },
	 *      '400px',
	 *      '1000px',
	 *    )}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   "@media (min-width: 1000px)": Object {
	 *     "padding": "100px",
	 *   },
	 *   "@media (min-width: 400px)": Object {
	 *     "padding": "calc(-33.33333333333334px + 13.333333333333334vw)",
	 *   },
	 *   "padding": "20px",
	 * }
	 */
	function fluidRange(cssProp, minScreen, maxScreen) {
	  if (minScreen === void 0) {
	    minScreen = '320px';
	  }

	  if (maxScreen === void 0) {
	    maxScreen = '1200px';
	  }

	  if (!Array.isArray(cssProp) && typeof cssProp !== 'object' || cssProp === null) {
	    throw new _errors["default"](49);
	  }

	  if (Array.isArray(cssProp)) {
	    var mediaQueries = {};
	    var fallbacks = {};

	    for (var _iterator = cssProp, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	      var _extends2, _extends3;

	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var obj = _ref;

	      if (!obj.prop || !obj.fromSize || !obj.toSize) {
	        throw new _errors["default"](50);
	      }

	      fallbacks[obj.prop] = obj.fromSize;
	      mediaQueries["@media (min-width: " + minScreen + ")"] = _extends({}, mediaQueries["@media (min-width: " + minScreen + ")"], (_extends2 = {}, _extends2[obj.prop] = (0, _between["default"])(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));
	      mediaQueries["@media (min-width: " + maxScreen + ")"] = _extends({}, mediaQueries["@media (min-width: " + maxScreen + ")"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));
	    }

	    return _extends({}, fallbacks, {}, mediaQueries);
	  } else {
	    var _ref2, _ref3, _ref4;

	    if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {
	      throw new _errors["default"](51);
	    }

	    return _ref4 = {}, _ref4[cssProp.prop] = cssProp.fromSize, _ref4["@media (min-width: " + minScreen + ")"] = (_ref2 = {}, _ref2[cssProp.prop] = (0, _between["default"])(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref2), _ref4["@media (min-width: " + maxScreen + ")"] = (_ref3 = {}, _ref3[cssProp.prop] = cssProp.toSize, _ref3), _ref4;
	  }
	}

	module.exports = exports.default;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = fontFace;

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var dataURIRegex = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i;
	var formatHintMap = {
	  woff: 'woff',
	  woff2: 'woff2',
	  ttf: 'truetype',
	  otf: 'opentype',
	  eot: 'embedded-opentype',
	  svg: 'svg',
	  svgz: 'svg'
	};

	function generateFormatHint(format, formatHint) {
	  if (!formatHint) return '';
	  return " format(\"" + formatHintMap[format] + "\")";
	}

	function isDataURI(fontFilePath) {
	  return !!fontFilePath.match(dataURIRegex);
	}

	function generateFileReferences(fontFilePath, fileFormats, formatHint) {
	  if (isDataURI(fontFilePath)) {
	    return "url(\"" + fontFilePath + "\")" + generateFormatHint(fileFormats[0], formatHint);
	  }

	  var fileFontReferences = fileFormats.map(function (format) {
	    return "url(\"" + fontFilePath + "." + format + "\")" + generateFormatHint(format, formatHint);
	  });
	  return fileFontReferences.join(', ');
	}

	function generateLocalReferences(localFonts) {
	  var localFontReferences = localFonts.map(function (font) {
	    return "local(\"" + font + "\")";
	  });
	  return localFontReferences.join(', ');
	}

	function generateSources(fontFilePath, localFonts, fileFormats, formatHint) {
	  var fontReferences = [];
	  if (localFonts) fontReferences.push(generateLocalReferences(localFonts));

	  if (fontFilePath) {
	    fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));
	  }

	  return fontReferences.join(', ');
	}
	/**
	 * CSS for a @font-face declaration.
	 *
	 * @example
	 * // Styles as object basic usage
	 * const styles = {
	 *    ...fontFace({
	 *      'fontFamily': 'Sans-Pro',
	 *      'fontFilePath': 'path/to/file'
	 *    })
	 * }
	 *
	 * // styled-components basic usage
	 * const GlobalStyle = createGlobalStyle`${
	 *   fontFace({
	 *     'fontFamily': 'Sans-Pro',
	 *     'fontFilePath': 'path/to/file'
	 *   }
	 * )}`
	 *
	 * // CSS as JS Output
	 *
	 * '@font-face': {
	 *   'fontFamily': 'Sans-Pro',
	 *   'src': 'url("path/to/file.eot"), url("path/to/file.woff2"), url("path/to/file.woff"), url("path/to/file.ttf"), url("path/to/file.svg")',
	 * }
	 */


	function fontFace(_ref) {
	  var fontFamily = _ref.fontFamily,
	      fontFilePath = _ref.fontFilePath,
	      fontStretch = _ref.fontStretch,
	      fontStyle = _ref.fontStyle,
	      fontVariant = _ref.fontVariant,
	      fontWeight = _ref.fontWeight,
	      _ref$fileFormats = _ref.fileFormats,
	      fileFormats = _ref$fileFormats === void 0 ? ['eot', 'woff2', 'woff', 'ttf', 'svg'] : _ref$fileFormats,
	      _ref$formatHint = _ref.formatHint,
	      formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint,
	      localFonts = _ref.localFonts,
	      unicodeRange = _ref.unicodeRange,
	      fontDisplay = _ref.fontDisplay,
	      fontVariationSettings = _ref.fontVariationSettings,
	      fontFeatureSettings = _ref.fontFeatureSettings;
	  // Error Handling
	  if (!fontFamily) throw new _errors["default"](55);

	  if (!fontFilePath && !localFonts) {
	    throw new _errors["default"](52);
	  }

	  if (localFonts && !Array.isArray(localFonts)) {
	    throw new _errors["default"](53);
	  }

	  if (!Array.isArray(fileFormats)) {
	    throw new _errors["default"](54);
	  }

	  var fontFaceDeclaration = {
	    '@font-face': {
	      fontFamily: fontFamily,
	      src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),
	      unicodeRange: unicodeRange,
	      fontStretch: fontStretch,
	      fontStyle: fontStyle,
	      fontVariant: fontVariant,
	      fontWeight: fontWeight,
	      fontDisplay: fontDisplay,
	      fontVariationSettings: fontVariationSettings,
	      fontFeatureSettings: fontFeatureSettings
	    }
	  }; // Removes undefined fields for cleaner css object.

	  return JSON.parse(JSON.stringify(fontFaceDeclaration));
	}

	module.exports = exports.default;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hideText;

	/**
	 * CSS to hide text to show a background image in a SEO-friendly way.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   'backgroundImage': 'url(logo.png)',
	 *   ...hideText(),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   backgroundImage: url(logo.png);
	 *   ${hideText()};
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * 'div': {
	 *   'backgroundImage': 'url(logo.png)',
	 *   'textIndent': '101%',
	 *   'overflow': 'hidden',
	 *   'whiteSpace': 'nowrap',
	 * }
	 */
	function hideText() {
	  return {
	    textIndent: '101%',
	    overflow: 'hidden',
	    whiteSpace: 'nowrap'
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hideVisually;

	/**
	 * CSS to hide content visually but remain accessible to screen readers.
	 * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...hideVisually(),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${hideVisually()};
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * 'div': {
	 *   'border': '0',
	 *   'clip': 'rect(0 0 0 0)',
	 *   'height': '1px',
	 *   'margin': '-1px',
	 *   'overflow': 'hidden',
	 *   'padding': '0',
	 *   'position': 'absolute',
	 *   'whiteSpace': 'nowrap',
	 *   'width': '1px',
	 * }
	 */
	function hideVisually() {
	  return {
	    border: '0',
	    clip: 'rect(0 0 0 0)',
	    height: '1px',
	    margin: '-1px',
	    overflow: 'hidden',
	    padding: '0',
	    position: 'absolute',
	    whiteSpace: 'nowrap',
	    width: '1px'
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 111 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hiDPI;

	/**
	 * Generates a media query to target HiDPI devices.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *  [hiDPI(1.5)]: {
	 *    width: 200px;
	 *  }
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${hiDPI(1.5)} {
	 *     width: 200px;
	 *   }
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	 *  only screen and (min--moz-device-pixel-ratio: 1.5),
	 *  only screen and (-o-min-device-pixel-ratio: 1.5/1),
	 *  only screen and (min-resolution: 144dpi),
	 *  only screen and (min-resolution: 1.5dppx)': {
	 *   'width': '200px',
	 * }
	 */
	function hiDPI(ratio) {
	  if (ratio === void 0) {
	    ratio = 1.3;
	  }

	  return "\n    @media only screen and (-webkit-min-device-pixel-ratio: " + ratio + "),\n    only screen and (min--moz-device-pixel-ratio: " + ratio + "),\n    only screen and (-o-min-device-pixel-ratio: " + ratio + "/1),\n    only screen and (min-resolution: " + Math.round(ratio * 96) + "dpi),\n    only screen and (min-resolution: " + ratio + "dppx)\n  ";
	}

	module.exports = exports.default;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = linearGradient;

	var _constructGradientValue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(113));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _templateObject() {
	  var data = _taggedTemplateLiteralLoose(["linear-gradient(", "", ")"]);

	  _templateObject = function _templateObject() {
	    return data;
	  };

	  return data;
	}

	function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

	/**
	 * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...linearGradient({
	        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],
	        toDirection: 'to top right',
	        fallback: '#FFF',
	      })
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${linearGradient({
	        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],
	        toDirection: 'to top right',
	        fallback: '#FFF',
	      })}
	 *`
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   'backgroundColor': '#FFF',
	 *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',
	 * }
	 */
	function linearGradient(_ref) {
	  var colorStops = _ref.colorStops,
	      fallback = _ref.fallback,
	      _ref$toDirection = _ref.toDirection,
	      toDirection = _ref$toDirection === void 0 ? '' : _ref$toDirection;

	  if (!colorStops || colorStops.length < 2) {
	    throw new _errors["default"](56);
	  }

	  return {
	    backgroundColor: fallback || colorStops[0].split(' ')[0],
	    backgroundImage: (0, _constructGradientValue["default"])(_templateObject(), toDirection, colorStops.join(', '))
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function constructGradientValue(literals) {
	  var template = '';

	  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    substitutions[_key - 1] = arguments[_key];
	  }

	  for (var i = 0; i < literals.length; i += 1) {
	    template += literals[i];

	    if (i === substitutions.length - 1 && substitutions[i]) {
	      var definedValues = substitutions.filter(function (substitute) {
	        return !!substitute;
	      }); // Adds leading coma if properties preceed color-stops

	      if (definedValues.length > 1) {
	        template = template.slice(0, -1);
	        template += ", " + substitutions[i]; // No trailing space if color-stops is the only param provided
	      } else if (definedValues.length === 1) {
	        template += "" + substitutions[i];
	      }
	    } else if (substitutions[i]) {
	      template += substitutions[i] + " ";
	    }
	  }

	  return template.trim();
	}

	var _default = constructGradientValue;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = normalize;

	/**
	 * CSS to normalize abnormalities across browsers (normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css)
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *    ...normalize(),
	 * }
	 *
	 * // styled-components usage
	 * const GlobalStyle = createGlobalStyle`${normalize()}`
	 *
	 * // CSS as JS Output
	 *
	 * html {
	 *   lineHeight: 1.15,
	 *   textSizeAdjust: 100%,
	 * } ...
	 */
	function normalize() {
	  var _ref;

	  return [(_ref = {
	    html: {
	      lineHeight: '1.15',
	      textSizeAdjust: '100%'
	    },
	    body: {
	      margin: '0'
	    },
	    h1: {
	      fontSize: '2em',
	      margin: '0.67em 0'
	    },
	    hr: {
	      boxSizing: 'content-box',
	      height: '0',
	      overflow: 'visible'
	    },
	    pre: {
	      fontFamily: 'monospace, monospace',
	      fontSize: '1em'
	    },
	    a: {
	      backgroundColor: 'transparent'
	    },
	    'abbr[title]': {
	      borderBottom: 'none',
	      textDecoration: 'underline'
	    }
	  }, _ref["b,\n    strong"] = {
	    fontWeight: 'bolder'
	  }, _ref["code,\n    kbd,\n    samp"] = {
	    fontFamily: 'monospace, monospace',
	    fontSize: '1em'
	  }, _ref.small = {
	    fontSize: '80%'
	  }, _ref["sub,\n    sup"] = {
	    fontSize: '75%',
	    lineHeight: '0',
	    position: 'relative',
	    verticalAlign: 'baseline'
	  }, _ref.sub = {
	    bottom: '-0.25em'
	  }, _ref.sup = {
	    top: '-0.5em'
	  }, _ref.img = {
	    borderStyle: 'none'
	  }, _ref["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = {
	    fontFamily: 'inherit',
	    fontSize: '100%',
	    lineHeight: '1.15',
	    margin: '0'
	  }, _ref["button,\n    input"] = {
	    overflow: 'visible'
	  }, _ref["button,\n    select"] = {
	    textTransform: 'none'
	  }, _ref["button,\n    html [type=\"button\"],\n    [type=\"reset\"],\n    [type=\"submit\"]"] = {
	    WebkitAppearance: 'button'
	  }, _ref["button::-moz-focus-inner,\n    [type=\"button\"]::-moz-focus-inner,\n    [type=\"reset\"]::-moz-focus-inner,\n    [type=\"submit\"]::-moz-focus-inner"] = {
	    borderStyle: 'none',
	    padding: '0'
	  }, _ref["button:-moz-focusring,\n    [type=\"button\"]:-moz-focusring,\n    [type=\"reset\"]:-moz-focusring,\n    [type=\"submit\"]:-moz-focusring"] = {
	    outline: '1px dotted ButtonText'
	  }, _ref.fieldset = {
	    padding: '0.35em 0.625em 0.75em'
	  }, _ref.legend = {
	    boxSizing: 'border-box',
	    color: 'inherit',
	    display: 'table',
	    maxWidth: '100%',
	    padding: '0',
	    whiteSpace: 'normal'
	  }, _ref.progress = {
	    verticalAlign: 'baseline'
	  }, _ref.textarea = {
	    overflow: 'auto'
	  }, _ref["[type=\"checkbox\"],\n    [type=\"radio\"]"] = {
	    boxSizing: 'border-box',
	    padding: '0'
	  }, _ref["[type=\"number\"]::-webkit-inner-spin-button,\n    [type=\"number\"]::-webkit-outer-spin-button"] = {
	    height: 'auto'
	  }, _ref['[type="search"]'] = {
	    WebkitAppearance: 'textfield',
	    outlineOffset: '-2px'
	  }, _ref['[type="search"]::-webkit-search-decoration'] = {
	    WebkitAppearance: 'none'
	  }, _ref['::-webkit-file-upload-button'] = {
	    WebkitAppearance: 'button',
	    font: 'inherit'
	  }, _ref.details = {
	    display: 'block'
	  }, _ref.summary = {
	    display: 'list-item'
	  }, _ref.template = {
	    display: 'none'
	  }, _ref['[hidden]'] = {
	    display: 'none'
	  }, _ref), {
	    'abbr[title]': {
	      textDecoration: 'underline dotted'
	    }
	  }];
	}

	module.exports = exports.default;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = radialGradient;

	var _constructGradientValue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(113));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _templateObject() {
	  var data = _taggedTemplateLiteralLoose(["radial-gradient(", "", "", "", ")"]);

	  _templateObject = function _templateObject() {
	    return data;
	  };

	  return data;
	}

	function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

	/**
	 * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...radialGradient({
	 *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],
	 *     extent: 'farthest-corner at 45px 45px',
	 *     position: 'center',
	 *     shape: 'ellipse',
	 *   })
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${radialGradient({
	 *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],
	 *     extent: 'farthest-corner at 45px 45px',
	 *     position: 'center',
	 *     shape: 'ellipse',
	 *   })}
	 *`
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *   'backgroundColor': '#00FFFF',
	 *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',
	 * }
	 */
	function radialGradient(_ref) {
	  var colorStops = _ref.colorStops,
	      _ref$extent = _ref.extent,
	      extent = _ref$extent === void 0 ? '' : _ref$extent,
	      fallback = _ref.fallback,
	      _ref$position = _ref.position,
	      position = _ref$position === void 0 ? '' : _ref$position,
	      _ref$shape = _ref.shape,
	      shape = _ref$shape === void 0 ? '' : _ref$shape;

	  if (!colorStops || colorStops.length < 2) {
	    throw new _errors["default"](57);
	  }

	  return {
	    backgroundColor: fallback || colorStops[0].split(' ')[0],
	    backgroundImage: (0, _constructGradientValue["default"])(_templateObject(), position, shape, extent, colorStops.join(', '))
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = retinaImage;

	var _hiDPI = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(111));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * A helper to generate a retina background image and non-retina
	 * background image. The retina background image will output to a HiDPI media query. The mixin uses
	 * a _2x.png filename suffix by default.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *  ...retinaImage('my-img')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${retinaImage('my-img')}
	 * `
	 *
	 * // CSS as JS Output
	 * div {
	 *   backgroundImage: 'url(my-img.png)',
	 *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),
	 *    only screen and (min--moz-device-pixel-ratio: 1.3),
	 *    only screen and (-o-min-device-pixel-ratio: 1.3/1),
	 *    only screen and (min-resolution: 144dpi),
	 *    only screen and (min-resolution: 1.5dppx)': {
	 *     backgroundImage: 'url(my-img_2x.png)',
	 *   }
	 * }
	 */
	function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {
	  var _ref;

	  if (extension === void 0) {
	    extension = 'png';
	  }

	  if (retinaSuffix === void 0) {
	    retinaSuffix = '_2x';
	  }

	  if (!filename) {
	    throw new _errors["default"](58);
	  } // Replace the dot at the beginning of the passed extension if one exists


	  var ext = extension.replace(/^\./, '');
	  var rFilename = retinaFilename ? retinaFilename + "." + ext : "" + filename + retinaSuffix + "." + ext;
	  return _ref = {
	    backgroundImage: "url(" + filename + "." + ext + ")"
	  }, _ref[(0, _hiDPI["default"])()] = _extends({
	    backgroundImage: "url(" + rFilename + ")"
	  }, backgroundSize ? {
	    backgroundSize: backgroundSize
	  } : {}), _ref;
	}

	module.exports = exports.default;

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = timingFunctions;

	/* eslint-disable key-spacing */
	var functionsMap = {
	  easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',
	  easeInCirc: 'cubic-bezier(0.600,  0.040, 0.980, 0.335)',
	  easeInCubic: 'cubic-bezier(0.550,  0.055, 0.675, 0.190)',
	  easeInExpo: 'cubic-bezier(0.950,  0.050, 0.795, 0.035)',
	  easeInQuad: 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',
	  easeInQuart: 'cubic-bezier(0.895,  0.030, 0.685, 0.220)',
	  easeInQuint: 'cubic-bezier(0.755,  0.050, 0.855, 0.060)',
	  easeInSine: 'cubic-bezier(0.470,  0.000, 0.745, 0.715)',
	  easeOutBack: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',
	  easeOutCubic: 'cubic-bezier(0.215,  0.610, 0.355, 1.000)',
	  easeOutCirc: 'cubic-bezier(0.075,  0.820, 0.165, 1.000)',
	  easeOutExpo: 'cubic-bezier(0.190,  1.000, 0.220, 1.000)',
	  easeOutQuad: 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',
	  easeOutQuart: 'cubic-bezier(0.165,  0.840, 0.440, 1.000)',
	  easeOutQuint: 'cubic-bezier(0.230,  1.000, 0.320, 1.000)',
	  easeOutSine: 'cubic-bezier(0.390,  0.575, 0.565, 1.000)',
	  easeInOutBack: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',
	  easeInOutCirc: 'cubic-bezier(0.785,  0.135, 0.150, 0.860)',
	  easeInOutCubic: 'cubic-bezier(0.645,  0.045, 0.355, 1.000)',
	  easeInOutExpo: 'cubic-bezier(1.000,  0.000, 0.000, 1.000)',
	  easeInOutQuad: 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',
	  easeInOutQuart: 'cubic-bezier(0.770,  0.000, 0.175, 1.000)',
	  easeInOutQuint: 'cubic-bezier(0.860,  0.000, 0.070, 1.000)',
	  easeInOutSine: 'cubic-bezier(0.445,  0.050, 0.550, 0.950)'
	};
	/* eslint-enable key-spacing */

	function getTimingFunction(functionName) {
	  return functionsMap[functionName];
	}
	/**
	 * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   'transitionTimingFunction': timingFunctions('easeInQuad')
	 * }
	 *
	 * // styled-components usage
	 *  const div = styled.div`
	 *   transitionTimingFunction: ${timingFunctions('easeInQuad')};
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * 'div': {
	 *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',
	 * }
	 */


	function timingFunctions(timingFunction) {
	  return getTimingFunction(timingFunction);
	}

	module.exports = exports.default;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = triangle;

	var _getValueAndUnit = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(100));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var getBorderWidth = function getBorderWidth(pointingDirection, height, width) {
	  var fullWidth = "" + width[0] + (width[1] || '');
	  var halfWidth = "" + width[0] / 2 + (width[1] || '');
	  var fullHeight = "" + height[0] + (height[1] || '');
	  var halfHeight = "" + height[0] / 2 + (height[1] || '');

	  switch (pointingDirection) {
	    case 'top':
	      return "0 " + halfWidth + " " + fullHeight + " " + halfWidth;

	    case 'topLeft':
	      return fullWidth + " " + fullHeight + " 0 0";

	    case 'left':
	      return halfHeight + " " + fullWidth + " " + halfHeight + " 0";

	    case 'bottomLeft':
	      return fullWidth + " 0 0 " + fullHeight;

	    case 'bottom':
	      return fullHeight + " " + halfWidth + " 0 " + halfWidth;

	    case 'bottomRight':
	      return "0 0 " + fullWidth + " " + fullHeight;

	    case 'right':
	      return halfHeight + " 0 " + halfHeight + " " + fullWidth;

	    case 'topRight':
	    default:
	      return "0 " + fullWidth + " " + fullHeight + " 0";
	  }
	};

	var getBorderColor = function getBorderColor(pointingDirection, foregroundColor, backgroundColor) {
	  switch (pointingDirection) {
	    case 'top':
	    case 'bottomRight':
	      return backgroundColor + " " + backgroundColor + " " + foregroundColor + " " + backgroundColor;

	    case 'right':
	    case 'bottomLeft':
	      return backgroundColor + " " + backgroundColor + " " + backgroundColor + " " + foregroundColor;

	    case 'bottom':
	    case 'topLeft':
	      return foregroundColor + " " + backgroundColor + " " + backgroundColor + " " + backgroundColor;

	    case 'left':
	    case 'topRight':
	      return backgroundColor + " " + foregroundColor + " " + backgroundColor + " " + backgroundColor;

	    default:
	      throw new _errors["default"](59);
	  }
	};
	/**
	 * CSS to represent triangle with any pointing direction with an optional background color.
	 *
	 * @example
	 * // Styles as object usage
	 *
	 * const styles = {
	 *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })
	 * }
	 *
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}
	 *
	 *
	 * // CSS as JS Output
	 *
	 * div: {
	 *  'borderColor': 'transparent transparent transparent red',
	 *  'borderStyle': 'solid',
	 *  'borderWidth': '50px 0 50px 100px',
	 *  'height': '0',
	 *  'width': '0',
	 * }
	 */


	function triangle(_ref) {
	  var pointingDirection = _ref.pointingDirection,
	      height = _ref.height,
	      width = _ref.width,
	      foregroundColor = _ref.foregroundColor,
	      _ref$backgroundColor = _ref.backgroundColor,
	      backgroundColor = _ref$backgroundColor === void 0 ? 'transparent' : _ref$backgroundColor;
	  var widthAndUnit = (0, _getValueAndUnit["default"])(width);
	  var heightAndUnit = (0, _getValueAndUnit["default"])(height);

	  if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {
	    throw new _errors["default"](60);
	  }

	  return {
	    width: '0',
	    height: '0',
	    borderColor: getBorderColor(pointingDirection, foregroundColor, backgroundColor),
	    borderStyle: 'solid',
	    borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 119 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = wordWrap;

	/**
	 * Provides an easy way to change the `wordWrap` property.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...wordWrap('break-word')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${wordWrap('break-word')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * const styles = {
	 *   overflowWrap: 'break-word',
	 *   wordWrap: 'break-word',
	 *   wordBreak: 'break-all',
	 * }
	 */
	function wordWrap(wrap) {
	  if (wrap === void 0) {
	    wrap = 'break-word';
	  }

	  var wordBreak = wrap === 'break-word' ? 'break-all' : wrap;
	  return {
	    overflowWrap: wrap,
	    wordWrap: wrap,
	    wordBreak: wordBreak
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Changes the hue of the color. Hue is a number between 0 to 360. The first
	 * argument for adjustHue is the amount of degrees the color is rotated around
	 * the color wheel, always producing a positive hue value.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: adjustHue(180, '#448'),
	 *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${adjustHue(180, '#448')};
	 *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#888844";
	 *   background: "rgba(136,136,68,0.7)";
	 * }
	 */
	function adjustHue(degree, color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    hue: hslColor.hue + parseFloat(degree)
	  }));
	} // prettier-ignore


	var curriedAdjustHue = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(adjustHue);
	var _default = curriedAdjustHue;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = parseToHsl;

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	var _rgbToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(125));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns an HslColor or HslaColor object. This utility function is only useful
	 * if want to extract a color component. With the color util `toColorString` you
	 * can convert a HslColor or HslaColor object back to a string.
	 *
	 * @example
	 * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
	 * const color1 = parseToHsl('rgb(255, 0, 0)');
	 * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
	 * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
	 */
	function parseToHsl(color) {
	  // Note: At a later stage we can optimize this function as right now a hsl
	  // color would be parsed converted to rgb values and converted back to hsl.
	  return (0, _rgbToHsl["default"])((0, _parseToRgb["default"])(color));
	}

	module.exports = exports.default;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = parseToRgb;

	var _hslToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(123));

	var _nameToHex = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(124));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var hexRegex = /^#[a-fA-F0-9]{6}$/;
	var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
	var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
	var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
	var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
	var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
	var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
	var hslaRegex = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
	/**
	 * Returns an RgbColor or RgbaColor object. This utility function is only useful
	 * if want to extract a color component. With the color util `toColorString` you
	 * can convert a RgbColor or RgbaColor object back to a string.
	 *
	 * @example
	 * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
	 * const color1 = parseToRgb('rgb(255, 0, 0)');
	 * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
	 * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
	 */

	function parseToRgb(color) {
	  if (typeof color !== 'string') {
	    throw new _errors["default"](3);
	  }

	  var normalizedColor = (0, _nameToHex["default"])(color);

	  if (normalizedColor.match(hexRegex)) {
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
	      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
	      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
	    };
	  }

	  if (normalizedColor.match(hexRgbaRegex)) {
	    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
	      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
	      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
	      alpha: alpha
	    };
	  }

	  if (normalizedColor.match(reducedHexRegex)) {
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
	      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
	      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
	    };
	  }

	  if (normalizedColor.match(reducedRgbaHexRegex)) {
	    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
	      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
	      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
	      alpha: _alpha
	    };
	  }

	  var rgbMatched = rgbRegex.exec(normalizedColor);

	  if (rgbMatched) {
	    return {
	      red: parseInt("" + rgbMatched[1], 10),
	      green: parseInt("" + rgbMatched[2], 10),
	      blue: parseInt("" + rgbMatched[3], 10)
	    };
	  }

	  var rgbaMatched = rgbaRegex.exec(normalizedColor);

	  if (rgbaMatched) {
	    return {
	      red: parseInt("" + rgbaMatched[1], 10),
	      green: parseInt("" + rgbaMatched[2], 10),
	      blue: parseInt("" + rgbaMatched[3], 10),
	      alpha: parseFloat("" + rgbaMatched[4])
	    };
	  }

	  var hslMatched = hslRegex.exec(normalizedColor);

	  if (hslMatched) {
	    var hue = parseInt("" + hslMatched[1], 10);
	    var saturation = parseInt("" + hslMatched[2], 10) / 100;
	    var lightness = parseInt("" + hslMatched[3], 10) / 100;
	    var rgbColorString = "rgb(" + (0, _hslToRgb["default"])(hue, saturation, lightness) + ")";
	    var hslRgbMatched = rgbRegex.exec(rgbColorString);

	    if (!hslRgbMatched) {
	      throw new _errors["default"](4, normalizedColor, rgbColorString);
	    }

	    return {
	      red: parseInt("" + hslRgbMatched[1], 10),
	      green: parseInt("" + hslRgbMatched[2], 10),
	      blue: parseInt("" + hslRgbMatched[3], 10)
	    };
	  }

	  var hslaMatched = hslaRegex.exec(normalizedColor);

	  if (hslaMatched) {
	    var _hue = parseInt("" + hslaMatched[1], 10);

	    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

	    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

	    var _rgbColorString = "rgb(" + (0, _hslToRgb["default"])(_hue, _saturation, _lightness) + ")";

	    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

	    if (!_hslRgbMatched) {
	      throw new _errors["default"](4, normalizedColor, _rgbColorString);
	    }

	    return {
	      red: parseInt("" + _hslRgbMatched[1], 10),
	      green: parseInt("" + _hslRgbMatched[2], 10),
	      blue: parseInt("" + _hslRgbMatched[3], 10),
	      alpha: parseFloat("" + hslaMatched[4])
	    };
	  }

	  throw new _errors["default"](5);
	}

	module.exports = exports.default;

/***/ }),
/* 123 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function colorToInt(color) {
	  return Math.round(color * 255);
	}

	function convertToInt(red, green, blue) {
	  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
	}

	function hslToRgb(hue, saturation, lightness, convert) {
	  if (convert === void 0) {
	    convert = convertToInt;
	  }

	  if (saturation === 0) {
	    // achromatic
	    return convert(lightness, lightness, lightness);
	  } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


	  var huePrime = (hue % 360 + 360) % 360 / 60;
	  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
	  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
	  var red = 0;
	  var green = 0;
	  var blue = 0;

	  if (huePrime >= 0 && huePrime < 1) {
	    red = chroma;
	    green = secondComponent;
	  } else if (huePrime >= 1 && huePrime < 2) {
	    red = secondComponent;
	    green = chroma;
	  } else if (huePrime >= 2 && huePrime < 3) {
	    green = chroma;
	    blue = secondComponent;
	  } else if (huePrime >= 3 && huePrime < 4) {
	    green = secondComponent;
	    blue = chroma;
	  } else if (huePrime >= 4 && huePrime < 5) {
	    red = secondComponent;
	    blue = chroma;
	  } else if (huePrime >= 5 && huePrime < 6) {
	    red = chroma;
	    blue = secondComponent;
	  }

	  var lightnessModification = lightness - chroma / 2;
	  var finalRed = red + lightnessModification;
	  var finalGreen = green + lightnessModification;
	  var finalBlue = blue + lightnessModification;
	  return convert(finalRed, finalGreen, finalBlue);
	}

	var _default = hslToRgb;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 124 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;
	var namedColorMap = {
	  aliceblue: 'f0f8ff',
	  antiquewhite: 'faebd7',
	  aqua: '00ffff',
	  aquamarine: '7fffd4',
	  azure: 'f0ffff',
	  beige: 'f5f5dc',
	  bisque: 'ffe4c4',
	  black: '000',
	  blanchedalmond: 'ffebcd',
	  blue: '0000ff',
	  blueviolet: '8a2be2',
	  brown: 'a52a2a',
	  burlywood: 'deb887',
	  cadetblue: '5f9ea0',
	  chartreuse: '7fff00',
	  chocolate: 'd2691e',
	  coral: 'ff7f50',
	  cornflowerblue: '6495ed',
	  cornsilk: 'fff8dc',
	  crimson: 'dc143c',
	  cyan: '00ffff',
	  darkblue: '00008b',
	  darkcyan: '008b8b',
	  darkgoldenrod: 'b8860b',
	  darkgray: 'a9a9a9',
	  darkgreen: '006400',
	  darkgrey: 'a9a9a9',
	  darkkhaki: 'bdb76b',
	  darkmagenta: '8b008b',
	  darkolivegreen: '556b2f',
	  darkorange: 'ff8c00',
	  darkorchid: '9932cc',
	  darkred: '8b0000',
	  darksalmon: 'e9967a',
	  darkseagreen: '8fbc8f',
	  darkslateblue: '483d8b',
	  darkslategray: '2f4f4f',
	  darkslategrey: '2f4f4f',
	  darkturquoise: '00ced1',
	  darkviolet: '9400d3',
	  deeppink: 'ff1493',
	  deepskyblue: '00bfff',
	  dimgray: '696969',
	  dimgrey: '696969',
	  dodgerblue: '1e90ff',
	  firebrick: 'b22222',
	  floralwhite: 'fffaf0',
	  forestgreen: '228b22',
	  fuchsia: 'ff00ff',
	  gainsboro: 'dcdcdc',
	  ghostwhite: 'f8f8ff',
	  gold: 'ffd700',
	  goldenrod: 'daa520',
	  gray: '808080',
	  green: '008000',
	  greenyellow: 'adff2f',
	  grey: '808080',
	  honeydew: 'f0fff0',
	  hotpink: 'ff69b4',
	  indianred: 'cd5c5c',
	  indigo: '4b0082',
	  ivory: 'fffff0',
	  khaki: 'f0e68c',
	  lavender: 'e6e6fa',
	  lavenderblush: 'fff0f5',
	  lawngreen: '7cfc00',
	  lemonchiffon: 'fffacd',
	  lightblue: 'add8e6',
	  lightcoral: 'f08080',
	  lightcyan: 'e0ffff',
	  lightgoldenrodyellow: 'fafad2',
	  lightgray: 'd3d3d3',
	  lightgreen: '90ee90',
	  lightgrey: 'd3d3d3',
	  lightpink: 'ffb6c1',
	  lightsalmon: 'ffa07a',
	  lightseagreen: '20b2aa',
	  lightskyblue: '87cefa',
	  lightslategray: '789',
	  lightslategrey: '789',
	  lightsteelblue: 'b0c4de',
	  lightyellow: 'ffffe0',
	  lime: '0f0',
	  limegreen: '32cd32',
	  linen: 'faf0e6',
	  magenta: 'f0f',
	  maroon: '800000',
	  mediumaquamarine: '66cdaa',
	  mediumblue: '0000cd',
	  mediumorchid: 'ba55d3',
	  mediumpurple: '9370db',
	  mediumseagreen: '3cb371',
	  mediumslateblue: '7b68ee',
	  mediumspringgreen: '00fa9a',
	  mediumturquoise: '48d1cc',
	  mediumvioletred: 'c71585',
	  midnightblue: '191970',
	  mintcream: 'f5fffa',
	  mistyrose: 'ffe4e1',
	  moccasin: 'ffe4b5',
	  navajowhite: 'ffdead',
	  navy: '000080',
	  oldlace: 'fdf5e6',
	  olive: '808000',
	  olivedrab: '6b8e23',
	  orange: 'ffa500',
	  orangered: 'ff4500',
	  orchid: 'da70d6',
	  palegoldenrod: 'eee8aa',
	  palegreen: '98fb98',
	  paleturquoise: 'afeeee',
	  palevioletred: 'db7093',
	  papayawhip: 'ffefd5',
	  peachpuff: 'ffdab9',
	  peru: 'cd853f',
	  pink: 'ffc0cb',
	  plum: 'dda0dd',
	  powderblue: 'b0e0e6',
	  purple: '800080',
	  rebeccapurple: '639',
	  red: 'f00',
	  rosybrown: 'bc8f8f',
	  royalblue: '4169e1',
	  saddlebrown: '8b4513',
	  salmon: 'fa8072',
	  sandybrown: 'f4a460',
	  seagreen: '2e8b57',
	  seashell: 'fff5ee',
	  sienna: 'a0522d',
	  silver: 'c0c0c0',
	  skyblue: '87ceeb',
	  slateblue: '6a5acd',
	  slategray: '708090',
	  slategrey: '708090',
	  snow: 'fffafa',
	  springgreen: '00ff7f',
	  steelblue: '4682b4',
	  tan: 'd2b48c',
	  teal: '008080',
	  thistle: 'd8bfd8',
	  tomato: 'ff6347',
	  turquoise: '40e0d0',
	  violet: 'ee82ee',
	  wheat: 'f5deb3',
	  white: 'fff',
	  whitesmoke: 'f5f5f5',
	  yellow: 'ff0',
	  yellowgreen: '9acd32'
	};
	/**
	 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
	 * @private
	 */

	function nameToHex(color) {
	  if (typeof color !== 'string') return color;
	  var normalizedColorName = color.toLowerCase();
	  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
	}

	var _default = nameToHex;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 125 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function rgbToHsl(color) {
	  // make sure rgb are contained in a set of [0, 255]
	  var red = color.red / 255;
	  var green = color.green / 255;
	  var blue = color.blue / 255;
	  var max = Math.max(red, green, blue);
	  var min = Math.min(red, green, blue);
	  var lightness = (max + min) / 2;

	  if (max === min) {
	    // achromatic
	    if (color.alpha !== undefined) {
	      return {
	        hue: 0,
	        saturation: 0,
	        lightness: lightness,
	        alpha: color.alpha
	      };
	    } else {
	      return {
	        hue: 0,
	        saturation: 0,
	        lightness: lightness
	      };
	    }
	  }

	  var hue;
	  var delta = max - min;
	  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);

	  switch (max) {
	    case red:
	      hue = (green - blue) / delta + (green < blue ? 6 : 0);
	      break;

	    case green:
	      hue = (blue - red) / delta + 2;
	      break;

	    default:
	      // blue case
	      hue = (red - green) / delta + 4;
	      break;
	  }

	  hue *= 60;

	  if (color.alpha !== undefined) {
	    return {
	      hue: hue,
	      saturation: saturation,
	      lightness: lightness,
	      alpha: color.alpha
	    };
	  }

	  return {
	    hue: hue,
	    saturation: saturation,
	    lightness: lightness
	  };
	}

	var _default = rgbToHsl;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = toColorString;

	var _hsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(127));

	var _hsla = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(131));

	var _rgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(132));

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var isRgb = function isRgb(color) {
	  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
	};

	var isRgba = function isRgba(color) {
	  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
	};

	var isHsl = function isHsl(color) {
	  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
	};

	var isHsla = function isHsla(color) {
	  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
	};
	/**
	 * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
	 * This util is useful in case you only know on runtime which color object is
	 * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: toColorString({ red: 255, green: 205, blue: 100 }),
	 *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
	 *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
	 *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
	 *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
	 *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
	 *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#ffcd64";
	 *   background: "rgba(255,205,100,0.72)";
	 *   background: "#00f";
	 *   background: "rgba(179,25,25,0.72)";
	 * }
	 */


	function toColorString(color) {
	  if (typeof color !== 'object') throw new _errors["default"](8);
	  if (isRgba(color)) return (0, _rgba["default"])(color);
	  if (isRgb(color)) return (0, _rgb["default"])(color);
	  if (isHsla(color)) return (0, _hsla["default"])(color);
	  if (isHsl(color)) return (0, _hsl["default"])(color);
	  throw new _errors["default"](8);
	}

	module.exports = exports.default;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hsl;

	var _hslToHex = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(128));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a string value for the color. The returned result is the smallest possible hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: hsl(359, 0.75, 0.4),
	 *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${hsl(359, 0.75, 0.4)};
	 *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#b3191c";
	 *   background: "#b3191c";
	 * }
	 */
	function hsl(value, saturation, lightness) {
	  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
	    return (0, _hslToHex["default"])(value, saturation, lightness);
	  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
	    return (0, _hslToHex["default"])(value.hue, value.saturation, value.lightness);
	  }

	  throw new _errors["default"](1);
	}

	module.exports = exports.default;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _hslToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(123));

	var _reduceHexValue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(129));

	var _numberToHex = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(130));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function colorToHex(color) {
	  return (0, _numberToHex["default"])(Math.round(color * 255));
	}

	function convertToHex(red, green, blue) {
	  return (0, _reduceHexValue["default"])("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
	}

	function hslToHex(hue, saturation, lightness) {
	  return (0, _hslToRgb["default"])(hue, saturation, lightness, convertToHex);
	}

	var _default = hslToHex;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	/**
	 * Reduces hex values if possible e.g. #ff8866 to #f86
	 * @private
	 */
	var reduceHexValue = function reduceHexValue(value) {
	  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
	    return "#" + value[1] + value[3] + value[5];
	  }

	  return value;
	};

	var _default = reduceHexValue;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function numberToHex(value) {
	  var hex = value.toString(16);
	  return hex.length === 1 ? "0" + hex : hex;
	}

	var _default = numberToHex;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hsla;

	var _hslToHex = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(128));

	var _hslToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(123));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: hsla(359, 0.75, 0.4, 0.7),
	 *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
	 *   background: hsla(359, 0.75, 0.4, 1),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${hsla(359, 0.75, 0.4, 0.7)};
	 *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
	 *   background: ${hsla(359, 0.75, 0.4, 1)};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "rgba(179,25,28,0.7)";
	 *   background: "rgba(179,25,28,0.7)";
	 *   background: "#b3191c";
	 * }
	 */
	function hsla(value, saturation, lightness, alpha) {
	  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
	    return alpha >= 1 ? (0, _hslToHex["default"])(value, saturation, lightness) : "rgba(" + (0, _hslToRgb["default"])(value, saturation, lightness) + "," + alpha + ")";
	  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
	    return value.alpha >= 1 ? (0, _hslToHex["default"])(value.hue, value.saturation, value.lightness) : "rgba(" + (0, _hslToRgb["default"])(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
	  }

	  throw new _errors["default"](2);
	}

	module.exports = exports.default;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = rgb;

	var _reduceHexValue = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(129));

	var _numberToHex = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(130));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a string value for the color. The returned result is the smallest possible hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: rgb(255, 205, 100),
	 *   background: rgb({ red: 255, green: 205, blue: 100 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${rgb(255, 205, 100)};
	 *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#ffcd64";
	 *   background: "#ffcd64";
	 * }
	 */
	function rgb(value, green, blue) {
	  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
	    return (0, _reduceHexValue["default"])("#" + (0, _numberToHex["default"])(value) + (0, _numberToHex["default"])(green) + (0, _numberToHex["default"])(blue));
	  } else if (typeof value === 'object' && green === undefined && blue === undefined) {
	    return (0, _reduceHexValue["default"])("#" + (0, _numberToHex["default"])(value.red) + (0, _numberToHex["default"])(value.green) + (0, _numberToHex["default"])(value.blue));
	  }

	  throw new _errors["default"](6);
	}

	module.exports = exports.default;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = rgba;

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	var _rgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(132));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
	 *
	 * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: rgba(255, 205, 100, 0.7),
	 *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
	 *   background: rgba(255, 205, 100, 1),
	 *   background: rgba('#ffffff', 0.4),
	 *   background: rgba('black', 0.7),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${rgba(255, 205, 100, 0.7)};
	 *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
	 *   background: ${rgba(255, 205, 100, 1)};
	 *   background: ${rgba('#ffffff', 0.4)};
	 *   background: ${rgba('black', 0.7)};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "rgba(255,205,100,0.7)";
	 *   background: "rgba(255,205,100,0.7)";
	 *   background: "#ffcd64";
	 *   background: "rgba(255,255,255,0.4)";
	 *   background: "rgba(0,0,0,0.7)";
	 * }
	 */
	function rgba(firstValue, secondValue, thirdValue, fourthValue) {
	  if (typeof firstValue === 'string' && typeof secondValue === 'number') {
	    var rgbValue = (0, _parseToRgb["default"])(firstValue);
	    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
	  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
	    return fourthValue >= 1 ? (0, _rgb["default"])(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
	  } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
	    return firstValue.alpha >= 1 ? (0, _rgb["default"])(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
	  }

	  throw new _errors["default"](7);
	}

	module.exports = exports.default;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = curry;

	// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
	// eslint-disable-next-line no-unused-vars
	// eslint-disable-next-line no-unused-vars
	// eslint-disable-next-line no-redeclare
	function curried(f, length, acc) {
	  return function fn() {
	    // eslint-disable-next-line prefer-rest-params
	    var combined = acc.concat(Array.prototype.slice.call(arguments));
	    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
	  };
	} // eslint-disable-next-line no-redeclare


	function curry(f) {
	  // eslint-disable-line no-redeclare
	  return curried(f, f.length, []);
	}

	module.exports = exports.default;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = complement;

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: complement('#448'),
	 *   background: complement('rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${complement('#448')};
	 *   background: ${complement('rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#884";
	 *   background: "rgba(153,153,153,0.7)";
	 * }
	 */
	function complement(color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    hue: (hslColor.hue + 180) % 360
	  }));
	}

	module.exports = exports.default;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Returns a string value for the darkened color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: darken(0.2, '#FFCD64'),
	 *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${darken(0.2, '#FFCD64')};
	 *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#ffbd31";
	 *   background: "rgba(255,189,49,0.7)";
	 * }
	 */
	function darken(amount, color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    lightness: (0, _guard["default"])(0, 1, hslColor.lightness - parseFloat(amount))
	  }));
	} // prettier-ignore


	var curriedDarken = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(darken);
	var _default = curriedDarken;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	function guard(lowerBoundary, upperBoundary, value) {
	  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
	}

	var _default = guard;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Decreases the intensity of a color. Its range is between 0 to 1. The first
	 * argument of the desaturate function is the amount by how much the color
	 * intensity should be decreased.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: desaturate(0.2, '#CCCD64'),
	 *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${desaturate(0.2, '#CCCD64')};
	 *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#b8b979";
	 *   background: "rgba(184,185,121,0.7)";
	 * }
	 */
	function desaturate(amount, color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    saturation: (0, _guard["default"])(0, 1, hslColor.saturation - parseFloat(amount))
	  }));
	} // prettier-ignore


	var curriedDesaturate = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(desaturate);
	var _default = curriedDesaturate;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = getContrast;

	var _getLuminance = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(140));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns the contrast ratio between two colors based on
	 * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).
	 *
	 * @example
	 * const contrastRatio = getContrast('#444', '#fff');
	 */
	function getContrast(color1, color2) {
	  var luminance1 = (0, _getLuminance["default"])(color1);
	  var luminance2 = (0, _getLuminance["default"])(color2);
	  return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));
	}

	module.exports = exports.default;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = getLuminance;

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Returns a number (float) representing the luminance of a color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',
	 *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?
	 *                             'rgba(58, 133, 255, 1)' :
	 *                             'rgba(255, 57, 149, 1)',
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};
	 *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?
	 *                             'rgba(58, 133, 255, 1)' :
	 *                             'rgba(255, 57, 149, 1)'};
	 *
	 * // CSS in JS Output
	 *
	 * div {
	 *   background: "#CCCD64";
	 *   background: "rgba(58, 133, 255, 1)";
	 * }
	 */
	function getLuminance(color) {
	  if (color === 'transparent') return 0;
	  var rgbColor = (0, _parseToRgb["default"])(color);

	  var _Object$keys$map = Object.keys(rgbColor).map(function (key) {
	    var channel = rgbColor[key] / 255;
	    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
	  }),
	      r = _Object$keys$map[0],
	      g = _Object$keys$map[1],
	      b = _Object$keys$map[2];

	  return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));
	}

	module.exports = exports.default;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = grayscale;

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Converts the color to a grayscale, by reducing its saturation to 0.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: grayscale('#CCCD64'),
	 *   background: grayscale('rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${grayscale('#CCCD64')};
	 *   background: ${grayscale('rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#999";
	 *   background: "rgba(153,153,153,0.7)";
	 * }
	 */
	function grayscale(color) {
	  if (color === 'transparent') return color;
	  return (0, _toColorString["default"])(_extends({}, (0, _parseToHsl["default"])(color), {
	    saturation: 0
	  }));
	}

	module.exports = exports.default;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = hslToColorString;

	var _hsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(127));

	var _hsla = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(131));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Converts a HslColor or HslaColor object to a color string.
	 * This util is useful in case you only know on runtime which color object is
	 * used. Otherwise we recommend to rely on `hsl` or `hsla`.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
	 *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
	 *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#00f";
	 *   background: "rgba(179,25,25,0.72)";
	 * }
	 */
	function hslToColorString(color) {
	  if (typeof color === 'object' && typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number') {
	    if (color.alpha && typeof color.alpha === 'number') {
	      return (0, _hsla["default"])({
	        hue: color.hue,
	        saturation: color.saturation,
	        lightness: color.lightness,
	        alpha: color.alpha
	      });
	    }

	    return (0, _hsl["default"])({
	      hue: color.hue,
	      saturation: color.saturation,
	      lightness: color.lightness
	    });
	  }

	  throw new _errors["default"](45);
	}

	module.exports = exports.default;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = invert;

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Inverts the red, green and blue values of a color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: invert('#CCCD64'),
	 *   background: invert('rgba(101,100,205,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${invert('#CCCD64')};
	 *   background: ${invert('rgba(101,100,205,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#33329b";
	 *   background: "rgba(154,155,50,0.7)";
	 * }
	 */
	function invert(color) {
	  if (color === 'transparent') return color; // parse color string to rgb

	  var value = (0, _parseToRgb["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, value, {
	    red: 255 - value.red,
	    green: 255 - value.green,
	    blue: 255 - value.blue
	  }));
	}

	module.exports = exports.default;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Returns a string value for the lightened color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: lighten(0.2, '#CCCD64'),
	 *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${lighten(0.2, '#FFCD64')};
	 *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#e5e6b1";
	 *   background: "rgba(229,230,177,0.7)";
	 * }
	 */
	function lighten(amount, color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    lightness: (0, _guard["default"])(0, 1, hslColor.lightness + parseFloat(amount))
	  }));
	} // prettier-ignore


	var curriedLighten = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(lighten);
	var _default = curriedLighten;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = meetsContrastGuidelines;

	var _getContrast = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(139));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Determines which contrast guidelines have been met for two colors.
	 * Based on the [contrast calculations recommended by W3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html).
	 *
	 * @example
	 * const scores = meetsContrastGuidelines('#444', '#fff');
	 */
	function meetsContrastGuidelines(color1, color2) {
	  var contrastRatio = (0, _getContrast["default"])(color1, color2);
	  return {
	    AA: contrastRatio >= 4.5,
	    AALarge: contrastRatio >= 3,
	    AAA: contrastRatio >= 7,
	    AAALarge: contrastRatio >= 4.5
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: mix(0.5, '#f00', '#00f')
	 *   background: mix(0.25, '#f00', '#00f')
	 *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${mix(0.5, '#f00', '#00f')};
	 *   background: ${mix(0.25, '#f00', '#00f')};
	 *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#7f007f";
	 *   background: "#3f00bf";
	 *   background: "rgba(63, 0, 191, 0.75)";
	 * }
	 */
	function mix(weight, color, otherColor) {
	  if (color === 'transparent') return otherColor;
	  if (otherColor === 'transparent') return color;
	  if (weight === 0) return otherColor;
	  var parsedColor1 = (0, _parseToRgb["default"])(color);

	  var color1 = _extends({}, parsedColor1, {
	    alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1
	  });

	  var parsedColor2 = (0, _parseToRgb["default"])(otherColor);

	  var color2 = _extends({}, parsedColor2, {
	    alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1
	  }); // The formula is copied from the original Sass implementation:
	  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method


	  var alphaDelta = color1.alpha - color2.alpha;
	  var x = parseFloat(weight) * 2 - 1;
	  var y = x * alphaDelta === -1 ? x : x + alphaDelta;
	  var z = 1 + x * alphaDelta;
	  var weight1 = (y / z + 1) / 2.0;
	  var weight2 = 1 - weight1;
	  var mixedColor = {
	    red: Math.floor(color1.red * weight1 + color2.red * weight2),
	    green: Math.floor(color1.green * weight1 + color2.green * weight2),
	    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),
	    alpha: color1.alpha * (parseFloat(weight) / 1.0) + color2.alpha * (1 - parseFloat(weight) / 1.0)
	  };
	  return (0, _rgba["default"])(mixedColor);
	} // prettier-ignore


	var curriedMix = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string, string> */
	)(mix);
	var _default = curriedMix;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Increases the opacity of a color. Its range for the amount is between 0 to 1.
	 *
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');
	 *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),
	 *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};
	 *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},
	 *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#fff";
	 *   background: "rgba(255,255,255,0.7)";
	 *   background: "rgba(255,0,0,0.7)";
	 * }
	 */
	function opacify(amount, color) {
	  if (color === 'transparent') return color;
	  var parsedColor = (0, _parseToRgb["default"])(color);
	  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

	  var colorWithAlpha = _extends({}, parsedColor, {
	    alpha: (0, _guard["default"])(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
	  });

	  return (0, _rgba["default"])(colorWithAlpha);
	} // prettier-ignore


	var curriedOpacify = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(opacify);
	var _default = curriedOpacify;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = readableColor;

	var _getContrast = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(139));

	var _getLuminance = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(140));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var defaultLightReturnColor = '#000';
	var defaultDarkReturnColor = '#fff';
	/**
	 * Returns black or white (or optional light and dark return colors) for best
	 * contrast depending on the luminosity of the given color.
	 * When passing custom return colors, set `strict` to `true` to ensure that the
	 * return color always meets or exceeds WCAG level AA or greater. If this test
	 * fails, the default return color (black or white) is returned in place of the
	 * custom return color.
	 *
	 * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   color: readableColor('#000'),
	 *   color: readableColor('black', '#001', '#ff8'),
	 *   color: readableColor('white', '#001', '#ff8'),
	 *   color: readableColor('red', '#333', '#ddd', true)
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   color: ${readableColor('#000')};
	 *   color: ${readableColor('black', '#001', '#ff8')};
	 *   color: ${readableColor('white', '#001', '#ff8')};
	 *   color: ${readableColor('red', '#333', '#ddd', true)};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   color: "#fff";
	 *   color: "#ff8";
	 *   color: "#001";
	 *   color: "#000";
	 * }
	 */

	function readableColor(color, lightReturnColor, darkReturnColor, strict) {
	  if (lightReturnColor === void 0) {
	    lightReturnColor = defaultLightReturnColor;
	  }

	  if (darkReturnColor === void 0) {
	    darkReturnColor = defaultDarkReturnColor;
	  }

	  if (strict === void 0) {
	    strict = false;
	  }

	  var isLightColor = (0, _getLuminance["default"])(color) > 0.179;
	  var preferredReturnColor = isLightColor ? lightReturnColor : darkReturnColor; // TODO: Make `strict` the default behaviour in the next major release.
	  // Without `strict`, this may return a color that does not meet WCAG AA.

	  if (!strict || (0, _getContrast["default"])(color, preferredReturnColor) >= 4.5) {
	    return preferredReturnColor;
	  }

	  return isLightColor ? defaultLightReturnColor : defaultDarkReturnColor;
	}

	module.exports = exports.default;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = rgbToColorString;

	var _rgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(132));

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Converts a RgbColor or RgbaColor object to a color string.
	 * This util is useful in case you only know on runtime which color object is
	 * used. Otherwise we recommend to rely on `rgb` or `rgba`.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),
	 *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};
	 *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#ffcd64";
	 *   background: "rgba(255,205,100,0.72)";
	 * }
	 */
	function rgbToColorString(color) {
	  if (typeof color === 'object' && typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number') {
	    if (color.alpha && typeof color.alpha === 'number') {
	      return (0, _rgba["default"])({
	        red: color.red,
	        green: color.green,
	        blue: color.blue,
	        alpha: color.alpha
	      });
	    }

	    return (0, _rgb["default"])({
	      red: color.red,
	      green: color.green,
	      blue: color.blue
	    });
	  }

	  throw new _errors["default"](46);
	}

	module.exports = exports.default;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Increases the intensity of a color. Its range is between 0 to 1. The first
	 * argument of the saturate function is the amount by how much the color
	 * intensity should be increased.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: saturate(0.2, '#CCCD64'),
	 *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${saturate(0.2, '#FFCD64')};
	 *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#e0e250";
	 *   background: "rgba(224,226,80,0.7)";
	 * }
	 */
	function saturate(amount, color) {
	  if (color === 'transparent') return color;
	  var hslColor = (0, _parseToHsl["default"])(color);
	  return (0, _toColorString["default"])(_extends({}, hslColor, {
	    saturation: (0, _guard["default"])(0, 1, hslColor.saturation + parseFloat(amount))
	  }));
	} // prettier-ignore


	var curriedSaturate = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(saturate);
	var _default = curriedSaturate;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Sets the hue of a color to the provided value. The hue range can be
	 * from 0 and 359.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: setHue(42, '#CCCD64'),
	 *   background: setHue('244', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${setHue(42, '#CCCD64')};
	 *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#cdae64";
	 *   background: "rgba(107,100,205,0.7)";
	 * }
	 */
	function setHue(hue, color) {
	  if (color === 'transparent') return color;
	  return (0, _toColorString["default"])(_extends({}, (0, _parseToHsl["default"])(color), {
	    hue: parseFloat(hue)
	  }));
	} // prettier-ignore


	var curriedSetHue = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(setHue);
	var _default = curriedSetHue;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Sets the lightness of a color to the provided value. The lightness range can be
	 * from 0 and 1.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: setLightness(0.2, '#CCCD64'),
	 *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${setLightness(0.2, '#CCCD64')};
	 *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#4d4d19";
	 *   background: "rgba(223,224,159,0.7)";
	 * }
	 */
	function setLightness(lightness, color) {
	  if (color === 'transparent') return color;
	  return (0, _toColorString["default"])(_extends({}, (0, _parseToHsl["default"])(color), {
	    lightness: parseFloat(lightness)
	  }));
	} // prettier-ignore


	var curriedSetLightness = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(setLightness);
	var _default = curriedSetLightness;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _parseToHsl = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(121));

	var _toColorString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(126));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Sets the saturation of a color to the provided value. The saturation range can be
	 * from 0 and 1.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: setSaturation(0.2, '#CCCD64'),
	 *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${setSaturation(0.2, '#CCCD64')};
	 *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#adad84";
	 *   background: "rgba(228,229,76,0.7)";
	 * }
	 */
	function setSaturation(saturation, color) {
	  if (color === 'transparent') return color;
	  return (0, _toColorString["default"])(_extends({}, (0, _parseToHsl["default"])(color), {
	    saturation: parseFloat(saturation)
	  }));
	} // prettier-ignore


	var curriedSetSaturation = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(setSaturation);
	var _default = curriedSetSaturation;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _mix = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(146));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shades a color by mixing it with black. `shade` can produce
	 * hue shifts, where as `darken` manipulates the luminance channel and therefore
	 * doesn't produce hue shifts.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: shade(0.25, '#00f')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${shade(0.25, '#00f')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#00003f";
	 * }
	 */
	function shade(percentage, color) {
	  if (color === 'transparent') return color;
	  return (0, _mix["default"])(parseFloat(percentage), 'rgb(0, 0, 0)', color);
	} // prettier-ignore


	var curriedShade = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(shade);
	var _default = curriedShade;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _mix = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(146));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Tints a color by mixing it with white. `tint` can produce
	 * hue shifts, where as `lighten` manipulates the luminance channel and therefore
	 * doesn't produce hue shifts.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: tint(0.25, '#00f')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${tint(0.25, '#00f')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#bfbfff";
	 * }
	 */
	function tint(percentage, color) {
	  if (color === 'transparent') return color;
	  return (0, _mix["default"])(parseFloat(percentage), 'rgb(255, 255, 255)', color);
	} // prettier-ignore


	var curriedTint = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(tint);
	var _default = curriedTint;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _curry = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(134));

	var _guard = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(137));

	var _rgba = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(133));

	var _parseToRgb = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(122));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	/**
	 * Decreases the opacity of a color. Its range for the amount is between 0 to 1.
	 *
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: transparentize(0.1, '#fff');
	 *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),
	 *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${transparentize(0.1, '#fff')};
	 *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')},
	 *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')},
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "rgba(255,255,255,0.9)";
	 *   background: "rgba(255,255,255,0.8)";
	 *   background: "rgba(255,0,0,0.3)";
	 * }
	 */
	function transparentize(amount, color) {
	  if (color === 'transparent') return color;
	  var parsedColor = (0, _parseToRgb["default"])(color);
	  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

	  var colorWithAlpha = _extends({}, parsedColor, {
	    alpha: (0, _guard["default"])(0, 1, (alpha * 100 - parseFloat(amount) * 100) / 100)
	  });

	  return (0, _rgba["default"])(colorWithAlpha);
	} // prettier-ignore


	var curriedTransparentize = /*#__PURE__*/(0, _curry["default"]
	/* ::<number | string, string, string> */
	)(transparentize);
	var _default = curriedTransparentize;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = animation;

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand for easily setting the animation property. Allows either multiple arrays with animations
	 * or a single animation spread over the arguments.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'animation': 'rotate 1s ease-in-out, colorchange 2s'
	 * }
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...animation('rotate', '1s', 'ease-in-out')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${animation('rotate', '1s', 'ease-in-out')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'animation': 'rotate 1s ease-in-out'
	 * }
	 */
	function animation() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  // Allow single or multiple animations passed
	  var multiMode = Array.isArray(args[0]);

	  if (!multiMode && args.length > 8) {
	    throw new _errors["default"](64);
	  }

	  var code = args.map(function (arg) {
	    if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {
	      throw new _errors["default"](65);
	    }

	    if (Array.isArray(arg) && arg.length > 8) {
	      throw new _errors["default"](66);
	    }

	    return Array.isArray(arg) ? arg.join(' ') : arg;
	  }).join(', ');
	  return {
	    animation: code
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = backgroundImages;

	/**
	 * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...backgroundImages('url("/image/background.jpg")', 'linear-gradient(red, green)')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${backgroundImages('url("/image/background.jpg")', 'linear-gradient(red, green)')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'backgroundImage': 'url("/image/background.jpg"), linear-gradient(red, green)'
	 * }
	 */
	function backgroundImages() {
	  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
	    properties[_key] = arguments[_key];
	  }

	  return {
	    backgroundImage: properties.join(', ')
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = backgrounds;

	/**
	 * Shorthand that accepts any number of background values as parameters for creating a single background statement.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...backgrounds('url("/image/background.jpg")', 'linear-gradient(red, green)', 'center no-repeat')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${backgrounds('url("/image/background.jpg")', 'linear-gradient(red, green)', 'center no-repeat')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'background': 'url("/image/background.jpg"), linear-gradient(red, green), center no-repeat'
	 * }
	 */
	function backgrounds() {
	  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
	    properties[_key] = arguments[_key];
	  }

	  return {
	    background: properties.join(', ')
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = border;

	var _capitalizeString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(95));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var sideMap = ['top', 'right', 'bottom', 'left'];
	/**
	 * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...border('1px', 'solid', 'red')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${border('1px', 'solid', 'red')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderColor': 'red',
	 *   'borderStyle': 'solid',
	 *   'borderWidth': `1px`,
	 * }
	 *
	 * // Styles as object usage
	 * const styles = {
	 *   ...border('top', '1px', 'solid', 'red')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${border('top', '1px', 'solid', 'red')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderTopColor': 'red',
	 *   'borderTopStyle': 'solid',
	 *   'borderTopWidth': `1px`,
	 * }
	 */

	function border(sideKeyword) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  if (typeof sideKeyword === 'string' && sideMap.indexOf(sideKeyword) >= 0) {
	    var _ref;

	    return _ref = {}, _ref["border" + (0, _capitalizeString["default"])(sideKeyword) + "Width"] = values[0], _ref["border" + (0, _capitalizeString["default"])(sideKeyword) + "Style"] = values[1], _ref["border" + (0, _capitalizeString["default"])(sideKeyword) + "Color"] = values[2], _ref;
	  } else {
	    values.unshift(sideKeyword);
	    return {
	      borderWidth: values[0],
	      borderStyle: values[1],
	      borderColor: values[2]
	    };
	  }
	}

	module.exports = exports.default;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = borderColor;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...borderColor('red', 'green', 'blue', 'yellow')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${borderColor('red', 'green', 'blue', 'yellow')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderTopColor': 'red',
	 *   'borderRightColor': 'green',
	 *   'borderBottomColor': 'blue',
	 *   'borderLeftColor': 'yellow'
	 * }
	 */
	function borderColor() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  return _directionalProperty["default"].apply(void 0, ['borderColor'].concat(values));
	}

	module.exports = exports.default;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = borderRadius;

	var _capitalizeString = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(95));

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...borderRadius('top', '5px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${borderRadius('top', '5px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderTopRightRadius': '5px',
	 *   'borderTopLeftRadius': '5px',
	 * }
	 */
	function borderRadius(side, radius) {
	  var uppercaseSide = (0, _capitalizeString["default"])(side);

	  if (!radius && radius !== 0) {
	    throw new _errors["default"](62);
	  }

	  if (uppercaseSide === 'Top' || uppercaseSide === 'Bottom') {
	    var _ref;

	    return _ref = {}, _ref["border" + uppercaseSide + "RightRadius"] = radius, _ref["border" + uppercaseSide + "LeftRadius"] = radius, _ref;
	  }

	  if (uppercaseSide === 'Left' || uppercaseSide === 'Right') {
	    var _ref2;

	    return _ref2 = {}, _ref2["borderTop" + uppercaseSide + "Radius"] = radius, _ref2["borderBottom" + uppercaseSide + "Radius"] = radius, _ref2;
	  }

	  throw new _errors["default"](63);
	}

	module.exports = exports.default;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = borderStyle;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...borderStyle('solid', 'dashed', 'dotted', 'double')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderTopStyle': 'solid',
	 *   'borderRightStyle': 'dashed',
	 *   'borderBottomStyle': 'dotted',
	 *   'borderLeftStyle': 'double'
	 * }
	 */
	function borderStyle() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  return _directionalProperty["default"].apply(void 0, ['borderStyle'].concat(values));
	}

	module.exports = exports.default;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = borderWidth;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...borderWidth('12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${borderWidth('12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'borderTopWidth': '12px',
	 *   'borderRightWidth': '24px',
	 *   'borderBottomWidth': '36px',
	 *   'borderLeftWidth': '48px'
	 * }
	 */
	function borderWidth() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  return _directionalProperty["default"].apply(void 0, ['borderWidth'].concat(values));
	}

	module.exports = exports.default;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = buttons;

	var _statefulSelectors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(166));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var stateMap = [undefined, null, 'active', 'focus', 'hover'];

	function template(state) {
	  return "button" + state + ",\n  input[type=\"button\"]" + state + ",\n  input[type=\"reset\"]" + state + ",\n  input[type=\"submit\"]" + state;
	}
	/**
	 * Populates selectors that target all buttons. You can pass optional states to append to the selectors.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   [buttons('active')]: {
	 *     'border': 'none'
	 *   }
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   > ${buttons('active')} {
	 *     border: none;
	 *   }
	 * `
	 *
	 * // CSS in JS Output
	 *
	 *  'button:active,
	 *  'input[type="button"]:active,
	 *  'input[type=\"reset\"]:active,
	 *  'input[type=\"submit\"]:active: {
	 *   'border': 'none'
	 * }
	 */


	function buttons() {
	  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
	    states[_key] = arguments[_key];
	  }

	  return (0, _statefulSelectors["default"])(states, template, stateMap);
	}

	module.exports = exports.default;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = void 0;

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function generateSelectors(template, state) {
	  var stateSuffix = state ? ":" + state : '';
	  return template(stateSuffix);
	}
	/**
	 * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.
	 * @private
	 */


	function statefulSelectors(states, template, stateMap) {
	  if (!template) throw new _errors["default"](67);
	  if (states.length === 0) return generateSelectors(template, null);
	  var selectors = [];

	  for (var i = 0; i < states.length; i += 1) {
	    if (stateMap && stateMap.indexOf(states[i]) < 0) {
	      throw new _errors["default"](68);
	    }

	    selectors.push(generateSelectors(template, states[i]));
	  }

	  selectors = selectors.join(',');
	  return selectors;
	}

	var _default = statefulSelectors;
	exports["default"] = _default;
	module.exports = exports.default;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = margin;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...margin('12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${margin('12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'marginTop': '12px',
	 *   'marginRight': '24px',
	 *   'marginBottom': '36px',
	 *   'marginLeft': '48px'
	 * }
	 */
	function margin() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  return _directionalProperty["default"].apply(void 0, ['margin'].concat(values));
	}

	module.exports = exports.default;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = padding;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...padding('12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${padding('12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'paddingTop': '12px',
	 *   'paddingRight': '24px',
	 *   'paddingBottom': '36px',
	 *   'paddingLeft': '48px'
	 * }
	 */
	function padding() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  return _directionalProperty["default"].apply(void 0, ['padding'].concat(values));
	}

	module.exports = exports.default;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = position;

	var _directionalProperty = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(94));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	var positionMap = ['absolute', 'fixed', 'relative', 'static', 'sticky'];
	/**
	 * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...position('12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${position('12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'top': '12px',
	 *   'right': '24px',
	 *   'bottom': '36px',
	 *   'left': '48px'
	 * }
	 *
	 * // Styles as object usage
	 * const styles = {
	 *   ...position('absolute', '12px', '24px', '36px', '48px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${position('absolute', '12px', '24px', '36px', '48px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'position': 'absolute',
	 *   'top': '12px',
	 *   'right': '24px',
	 *   'bottom': '36px',
	 *   'left': '48px'
	 * }
	 */

	function position(firstValue) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  if (positionMap.indexOf(firstValue) >= 0 && firstValue) {
	    return _extends({}, _directionalProperty["default"].apply(void 0, [''].concat(values)), {
	      position: firstValue
	    });
	  } else {
	    return _directionalProperty["default"].apply(void 0, ['', firstValue].concat(values));
	  }
	}

	module.exports = exports.default;

/***/ }),
/* 170 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = size;

	/**
	 * Shorthand to set the height and width properties in a single statement.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...size('300px', '250px')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${size('300px', '250px')}
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'height': '300px',
	 *   'width': '250px',
	 * }
	 */
	function size(height, width) {
	  if (width === void 0) {
	    width = height;
	  }

	  return {
	    height: height,
	    width: width
	  };
	}

	module.exports = exports.default;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = textInputs;

	var _statefulSelectors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(166));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var stateMap = [undefined, null, 'active', 'focus', 'hover'];

	function template(state) {
	  return "input[type=\"color\"]" + state + ",\n    input[type=\"date\"]" + state + ",\n    input[type=\"datetime\"]" + state + ",\n    input[type=\"datetime-local\"]" + state + ",\n    input[type=\"email\"]" + state + ",\n    input[type=\"month\"]" + state + ",\n    input[type=\"number\"]" + state + ",\n    input[type=\"password\"]" + state + ",\n    input[type=\"search\"]" + state + ",\n    input[type=\"tel\"]" + state + ",\n    input[type=\"text\"]" + state + ",\n    input[type=\"time\"]" + state + ",\n    input[type=\"url\"]" + state + ",\n    input[type=\"week\"]" + state + ",\n    input:not([type])" + state + ",\n    textarea" + state;
	}
	/**
	 * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   [textInputs('active')]: {
	 *     'border': 'none'
	 *   }
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   > ${textInputs('active')} {
	 *     border: none;
	 *   }
	 * `
	 *
	 * // CSS in JS Output
	 *
	 *  'input[type="color"]:active,
	 *  input[type="date"]:active,
	 *  input[type="datetime"]:active,
	 *  input[type="datetime-local"]:active,
	 *  input[type="email"]:active,
	 *  input[type="month"]:active,
	 *  input[type="number"]:active,
	 *  input[type="password"]:active,
	 *  input[type="search"]:active,
	 *  input[type="tel"]:active,
	 *  input[type="text"]:active,
	 *  input[type="time"]:active,
	 *  input[type="url"]:active,
	 *  input[type="week"]:active,
	 *  input:not([type]):active,
	 *  textarea:active': {
	 *   'border': 'none'
	 * }
	 */


	function textInputs() {
	  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {
	    states[_key] = arguments[_key];
	  }

	  return (0, _statefulSelectors["default"])(states, template, stateMap);
	}

	module.exports = exports.default;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = transitions;

	var _errors = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/__webpack_require__(91));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	/**
	 * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same transition values to (second parameter).
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),
	 *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};
	 *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};
	 * `
	 *
	 * // CSS as JS Output
	 *
	 * div {
	 *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'
	 *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',
	 * }
	 */
	function transitions() {
	  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
	    properties[_key] = arguments[_key];
	  }

	  if (Array.isArray(properties[0]) && properties.length === 2) {
	    var value = properties[1];

	    if (typeof value !== 'string') {
	      throw new _errors["default"](61);
	    }

	    var transitionsString = properties[0].map(function (property) {
	      return property + " " + value;
	    }).join(', ');
	    return {
	      transition: transitionsString
	    };
	  } else {
	    return {
	      transition: properties.join(', ')
	    };
	  }
	}

	module.exports = exports.default;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var version = '18.5.0';

	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */


	var _Group = function () {
		this._tweens = {};
		this._tweensAddedDuringUpdate = {};
	};

	_Group.prototype = {
		getAll: function () {

			return Object.keys(this._tweens).map(function (tweenId) {
				return this._tweens[tweenId];
			}.bind(this));

		},

		removeAll: function () {

			this._tweens = {};

		},

		add: function (tween) {

			this._tweens[tween.getId()] = tween;
			this._tweensAddedDuringUpdate[tween.getId()] = tween;

		},

		remove: function (tween) {

			delete this._tweens[tween.getId()];
			delete this._tweensAddedDuringUpdate[tween.getId()];

		},

		update: function (time, preserve) {

			var tweenIds = Object.keys(this._tweens);

			if (tweenIds.length === 0) {
				return false;
			}

			time = time !== undefined ? time : TWEEN.now();

			// Tweens are updated in "batches". If you add a new tween during an
			// update, then the new tween will be updated in the next batch.
			// If you remove a tween during an update, it may or may not be updated.
			// However, if the removed tween was added during the current batch,
			// then it will not be updated.
			while (tweenIds.length > 0) {
				this._tweensAddedDuringUpdate = {};

				for (var i = 0; i < tweenIds.length; i++) {

					var tween = this._tweens[tweenIds[i]];

					if (tween && tween.update(time) === false) {
						tween._isPlaying = false;

						if (!preserve) {
							delete this._tweens[tweenIds[i]];
						}
					}
				}

				tweenIds = Object.keys(this._tweensAddedDuringUpdate);
			}

			return true;

		}
	};

	var TWEEN = new _Group();

	TWEEN.Group = _Group;
	TWEEN._nextId = 0;
	TWEEN.nextId = function () {
		return TWEEN._nextId++;
	};


	// Include a performance.now polyfill.
	// In node.js, use process.hrtime.
	if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
		TWEEN.now = function () {
			var time = process.hrtime();

			// Convert [seconds, nanoseconds] to milliseconds.
			return time[0] * 1000 + time[1] / 1000000;
		};
	}
	// In a browser, use self.performance.now if it is available.
	else if (typeof (self) !== 'undefined' &&
	         self.performance !== undefined &&
			 self.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		TWEEN.now = self.performance.now.bind(self.performance);
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
		TWEEN.now = Date.now;
	}
	// Otherwise, use 'new Date().getTime()'.
	else {
		TWEEN.now = function () {
			return new Date().getTime();
		};
	}


	TWEEN.Tween = function (object, group) {
		this._isPaused = false;
		this._pauseStart = null;
		this._object = object;
		this._valuesStart = {};
		this._valuesEnd = {};
		this._valuesStartRepeat = {};
		this._duration = 1000;
		this._repeat = 0;
		this._repeatDelayTime = undefined;
		this._yoyo = false;
		this._isPlaying = false;
		this._reversed = false;
		this._delayTime = 0;
		this._startTime = null;
		this._easingFunction = TWEEN.Easing.Linear.None;
		this._interpolationFunction = TWEEN.Interpolation.Linear;
		this._chainedTweens = [];
		this._onStartCallback = null;
		this._onStartCallbackFired = false;
		this._onUpdateCallback = null;
		this._onRepeatCallback = null;
		this._onCompleteCallback = null;
		this._onStopCallback = null;
		this._group = group || TWEEN;
		this._id = TWEEN.nextId();

	};

	TWEEN.Tween.prototype = {
		getId: function () {
			return this._id;
		},

		isPlaying: function () {
			return this._isPlaying;
		},

		isPaused: function () {
			return this._isPaused;
		},

		to: function (properties, duration) {

			this._valuesEnd = Object.create(properties);

			if (duration !== undefined) {
				this._duration = duration;
			}

			return this;

		},

		duration: function duration(d) {
			this._duration = d;
			return this;
		},

		start: function (time) {

			this._group.add(this);

			this._isPlaying = true;

			this._isPaused = false;

			this._onStartCallbackFired = false;

			this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
			this._startTime += this._delayTime;

			for (var property in this._valuesEnd) {

				// Check if an Array was provided as property value
				if (this._valuesEnd[property] instanceof Array) {

					if (this._valuesEnd[property].length === 0) {
						continue;
					}

					// Create a local copy of the Array with the start value at the front
					this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

				}

				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (this._object[property] === undefined) {
					continue;
				}

				// Save the starting value, but only once.
				if (typeof(this._valuesStart[property]) === 'undefined') {
					this._valuesStart[property] = this._object[property];
				}

				if ((this._valuesStart[property] instanceof Array) === false) {
					this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}

				this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

			}

			return this;

		},

		stop: function () {

			if (!this._isPlaying) {
				return this;
			}

			this._group.remove(this);

			this._isPlaying = false;

			this._isPaused = false;

			if (this._onStopCallback !== null) {
				this._onStopCallback(this._object);
			}

			this.stopChainedTweens();
			return this;

		},

		end: function () {

			this.update(Infinity);
			return this;

		},

		pause: function(time) {

			if (this._isPaused || !this._isPlaying) {
				return this;
			}

			this._isPaused = true;

			this._pauseStart = time === undefined ? TWEEN.now() : time;

			this._group.remove(this);

			return this;

		},

		resume: function(time) {

			if (!this._isPaused || !this._isPlaying) {
				return this;
			}

			this._isPaused = false;

			this._startTime += (time === undefined ? TWEEN.now() : time)
				- this._pauseStart;

			this._pauseStart = 0;

			this._group.add(this);

			return this;

		},

		stopChainedTweens: function () {

			for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
				this._chainedTweens[i].stop();
			}

		},

		group: function (group) {
			this._group = group;
			return this;
		},

		delay: function (amount) {

			this._delayTime = amount;
			return this;

		},

		repeat: function (times) {

			this._repeat = times;
			return this;

		},

		repeatDelay: function (amount) {

			this._repeatDelayTime = amount;
			return this;

		},

		yoyo: function (yoyo) {

			this._yoyo = yoyo;
			return this;

		},

		easing: function (easingFunction) {

			this._easingFunction = easingFunction;
			return this;

		},

		interpolation: function (interpolationFunction) {

			this._interpolationFunction = interpolationFunction;
			return this;

		},

		chain: function () {

			this._chainedTweens = arguments;
			return this;

		},

		onStart: function (callback) {

			this._onStartCallback = callback;
			return this;

		},

		onUpdate: function (callback) {

			this._onUpdateCallback = callback;
			return this;

		},

		onRepeat: function onRepeat(callback) {

			this._onRepeatCallback = callback;
			return this;

		},

		onComplete: function (callback) {

			this._onCompleteCallback = callback;
			return this;

		},

		onStop: function (callback) {

			this._onStopCallback = callback;
			return this;

		},

		update: function (time) {

			var property;
			var elapsed;
			var value;

			if (time < this._startTime) {
				return true;
			}

			if (this._onStartCallbackFired === false) {

				if (this._onStartCallback !== null) {
					this._onStartCallback(this._object);
				}

				this._onStartCallbackFired = true;
			}

			elapsed = (time - this._startTime) / this._duration;
			elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

			value = this._easingFunction(elapsed);

			for (property in this._valuesEnd) {

				// Don't update properties that do not exist in the source object
				if (this._valuesStart[property] === undefined) {
					continue;
				}

				var start = this._valuesStart[property] || 0;
				var end = this._valuesEnd[property];

				if (end instanceof Array) {

					this._object[property] = this._interpolationFunction(end, value);

				} else {

					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof (end) === 'string') {

						if (end.charAt(0) === '+' || end.charAt(0) === '-') {
							end = start + parseFloat(end);
						} else {
							end = parseFloat(end);
						}
					}

					// Protect against non numeric properties.
					if (typeof (end) === 'number') {
						this._object[property] = start + (end - start) * value;
					}

				}

			}

			if (this._onUpdateCallback !== null) {
				this._onUpdateCallback(this._object, elapsed);
			}

			if (elapsed === 1) {

				if (this._repeat > 0) {

					if (isFinite(this._repeat)) {
						this._repeat--;
					}

					// Reassign starting values, restart by making startTime = now
					for (property in this._valuesStartRepeat) {

						if (typeof (this._valuesEnd[property]) === 'string') {
							this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
						}

						if (this._yoyo) {
							var tmp = this._valuesStartRepeat[property];

							this._valuesStartRepeat[property] = this._valuesEnd[property];
							this._valuesEnd[property] = tmp;
						}

						this._valuesStart[property] = this._valuesStartRepeat[property];

					}

					if (this._yoyo) {
						this._reversed = !this._reversed;
					}

					if (this._repeatDelayTime !== undefined) {
						this._startTime = time + this._repeatDelayTime;
					} else {
						this._startTime = time + this._delayTime;
					}

					if (this._onRepeatCallback !== null) {
						this._onRepeatCallback(this._object);
					}

					return true;

				} else {

					if (this._onCompleteCallback !== null) {

						this._onCompleteCallback(this._object);
					}

					for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						this._chainedTweens[i].start(this._startTime + this._duration);
					}

					return false;

				}

			}

			return true;

		}
	};


	TWEEN.Easing = {

		Linear: {

			None: function (k) {

				return k;

			}

		},

		Quadratic: {

			In: function (k) {

				return k * k;

			},

			Out: function (k) {

				return k * (2 - k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}

				return - 0.5 * (--k * (k - 2) - 1);

			}

		},

		Cubic: {

			In: function (k) {

				return k * k * k;

			},

			Out: function (k) {

				return --k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k + 2);

			}

		},

		Quartic: {

			In: function (k) {

				return k * k * k * k;

			},

			Out: function (k) {

				return 1 - (--k * k * k * k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}

				return - 0.5 * ((k -= 2) * k * k * k - 2);

			}

		},

		Quintic: {

			In: function (k) {

				return k * k * k * k * k;

			},

			Out: function (k) {

				return --k * k * k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k * k * k + 2);

			}

		},

		Sinusoidal: {

			In: function (k) {

				return 1 - Math.cos(k * Math.PI / 2);

			},

			Out: function (k) {

				return Math.sin(k * Math.PI / 2);

			},

			InOut: function (k) {

				return 0.5 * (1 - Math.cos(Math.PI * k));

			}

		},

		Exponential: {

			In: function (k) {

				return k === 0 ? 0 : Math.pow(1024, k - 1);

			},

			Out: function (k) {

				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

			},

			InOut: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}

				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

			}

		},

		Circular: {

			In: function (k) {

				return 1 - Math.sqrt(1 - k * k);

			},

			Out: function (k) {

				return Math.sqrt(1 - (--k * k));

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}

				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

			}

		},

		Elastic: {

			In: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

			},

			Out: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

			},

			InOut: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				k *= 2;

				if (k < 1) {
					return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
				}

				return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

			}

		},

		Back: {

			In: function (k) {

				var s = 1.70158;

				return k * k * ((s + 1) * k - s);

			},

			Out: function (k) {

				var s = 1.70158;

				return --k * k * ((s + 1) * k + s) + 1;

			},

			InOut: function (k) {

				var s = 1.70158 * 1.525;

				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}

				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

			}

		},

		Bounce: {

			In: function (k) {

				return 1 - TWEEN.Easing.Bounce.Out(1 - k);

			},

			Out: function (k) {

				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}

			},

			InOut: function (k) {

				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}

				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

			}

		}

	};

	TWEEN.Interpolation = {

		Linear: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

		},

		Bezier: function (v, k) {

			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;

			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}

			return b;

		},

		CatmullRom: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;

			if (v[0] === v[m]) {

				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}

				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

			} else {

				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}

				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}

				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

			}

		},

		Utils: {

			Linear: function (p0, p1, t) {

				return (p1 - p0) * t + p0;

			},

			Bernstein: function (n, i) {

				var fc = TWEEN.Interpolation.Utils.Factorial;

				return fc(n) / fc(i) / fc(n - i);

			},

			Factorial: (function () {

				var a = [1];

				return function (n) {

					var s = 1;

					if (a[n]) {
						return a[n];
					}

					for (var i = n; i > 1; i--) {
						s *= i;
					}

					a[n] = s;
					return s;

				};

			})(),

			CatmullRom: function (p0, p1, p2, p3, t) {

				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;

				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

			}

		}

	};
	TWEEN.version = version;

	module.exports = TWEEN;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)))

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var d3Selection = __webpack_require__(11);
	var d3Zoom = __webpack_require__(39);
	var d3Drag = __webpack_require__(10);
	var throttle = _interopDefault(__webpack_require__(175));
	var TWEEN = _interopDefault(__webpack_require__(173));
	var Kapsule = _interopDefault(__webpack_require__(76));
	var accessorFn = _interopDefault(__webpack_require__(78));
	var ColorTracker = _interopDefault(__webpack_require__(176));
	var d3Force3d = __webpack_require__(44);
	var Bezier = _interopDefault(__webpack_require__(177));
	var indexBy = _interopDefault(__webpack_require__(80));
	var d3Scale = __webpack_require__(81);
	var d3ScaleChromatic = __webpack_require__(36);

	function styleInject(css, ref) {
	  if (ref === void 0) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') {
	    return;
	  }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z = ".graph-tooltip {\n  position: absolute;\n  transform: translate(-50%, 25px);\n  font-family: sans-serif;\n  font-size: 16px;\n  padding: 4px;\n  border-radius: 3px;\n  color: #eee;\n  background: rgba(0,0,0,0.65);\n  visibility: hidden; /* by default */\n}\n\n.grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n";
	styleInject(css_248z);

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(n);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var autoColorScale = d3Scale.scaleOrdinal(d3ScaleChromatic.schemePaired); // Autoset attribute colorField by colorByAccessor property
	// If an object has already a color, don't set it
	// Objects can be nodes or links

	function autoColorObjects(objects, colorByAccessor, colorField) {
	  if (!colorByAccessor || typeof colorField !== 'string') return;
	  objects.filter(function (obj) {
	    return !obj[colorField];
	  }).forEach(function (obj) {
	    obj[colorField] = autoColorScale(colorByAccessor(obj));
	  });
	}

	function getDagDepths (_ref, idAccessor) {
	  var nodes = _ref.nodes,
	      links = _ref.links;
	  // linked graph
	  var graph = {};
	  nodes.forEach(function (node) {
	    return graph[idAccessor(node)] = {
	      data: node,
	      out: [],
	      depth: -1
	    };
	  });
	  links.forEach(function (_ref2) {
	    var source = _ref2.source,
	        target = _ref2.target;
	    var sourceId = getNodeId(source);
	    var targetId = getNodeId(target);
	    if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
	    if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
	    var sourceNode = graph[sourceId];
	    var targetNode = graph[targetId];
	    sourceNode.out.push(targetNode);

	    function getNodeId(node) {
	      return _typeof(node) === 'object' ? idAccessor(node) : node;
	    }
	  });
	  traverse(Object.values(graph)); // cleanup

	  Object.keys(graph).forEach(function (id) {
	    return graph[id] = graph[id].depth;
	  });
	  return graph;

	  function traverse(nodes) {
	    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    var currentDepth = nodeStack.length;

	    for (var i = 0, l = nodes.length; i < l; i++) {
	      var node = nodes[i];

	      if (nodeStack.indexOf(node) !== -1) {
	        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {
	          return idAccessor(d.data);
	        });
	        throw "Invalid DAG structure! Found cycle in node path: ".concat(loop.join(' -> '), ".");
	      }

	      if (currentDepth > node.depth) {
	        // Don't unnecessarily revisit chunks of the graph
	        node.depth = currentDepth;
	        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]));
	      }
	    }
	  }
	}

	var DAG_LEVEL_NODE_RATIO = 2;
	var CanvasForceGraph = Kapsule({
	  props: {
	    graphData: {
	      "default": {
	        nodes: [],
	        links: []
	      },
	      onChange: function onChange(_, state) {
	        state.engineRunning = false;
	      } // Pause simulation

	    },
	    dagMode: {
	      onChange: function onChange(dagMode, state) {
	        // td, bu, lr, rl, radialin, radialout
	        !dagMode && (state.graphData.nodes || []).forEach(function (n) {
	          return n.fx = n.fy = undefined;
	        }); // unfix nodes when disabling dag mode
	      }
	    },
	    dagLevelDistance: {},
	    nodeRelSize: {
	      "default": 4,
	      triggerUpdate: false
	    },
	    // area per val unit
	    nodeId: {
	      "default": 'id'
	    },
	    nodeVal: {
	      "default": 'val',
	      triggerUpdate: false
	    },
	    nodeColor: {
	      "default": 'color',
	      triggerUpdate: false
	    },
	    nodeAutoColorBy: {},
	    nodeCanvasObject: {
	      triggerUpdate: false
	    },
	    nodeCanvasObjectMode: {
	      "default": function _default() {
	        return 'replace';
	      },
	      triggerUpdate: false
	    },
	    nodeVisibility: {
	      "default": true,
	      triggerUpdate: false
	    },
	    linkSource: {
	      "default": 'source'
	    },
	    linkTarget: {
	      "default": 'target'
	    },
	    linkVisibility: {
	      "default": true,
	      triggerUpdate: false
	    },
	    linkColor: {
	      "default": 'color',
	      triggerUpdate: false
	    },
	    linkAutoColorBy: {},
	    linkLineDash: {
	      triggerUpdate: false
	    },
	    linkWidth: {
	      "default": 1,
	      triggerUpdate: false
	    },
	    linkCurvature: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    linkCanvasObject: {
	      triggerUpdate: false
	    },
	    linkCanvasObjectMode: {
	      "default": function _default() {
	        return 'replace';
	      },
	      triggerUpdate: false
	    },
	    linkDirectionalArrowLength: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    linkDirectionalArrowColor: {
	      triggerUpdate: false
	    },
	    linkDirectionalArrowRelPos: {
	      "default": 0.5,
	      triggerUpdate: false
	    },
	    // value between 0<>1 indicating the relative pos along the (exposed) line
	    linkDirectionalParticles: {
	      "default": 0
	    },
	    // animate photons travelling in the link direction
	    linkDirectionalParticleSpeed: {
	      "default": 0.01,
	      triggerUpdate: false
	    },
	    // in link length ratio per frame
	    linkDirectionalParticleWidth: {
	      "default": 4,
	      triggerUpdate: false
	    },
	    linkDirectionalParticleColor: {
	      triggerUpdate: false
	    },
	    globalScale: {
	      "default": 1,
	      triggerUpdate: false
	    },
	    d3AlphaDecay: {
	      "default": 0.0228,
	      triggerUpdate: false,
	      onChange: function onChange(alphaDecay, state) {
	        state.forceLayout.alphaDecay(alphaDecay);
	      }
	    },
	    d3AlphaTarget: {
	      "default": 0,
	      triggerUpdate: false,
	      onChange: function onChange(alphaTarget, state) {
	        state.forceLayout.alphaTarget(alphaTarget);
	      }
	    },
	    d3VelocityDecay: {
	      "default": 0.4,
	      triggerUpdate: false,
	      onChange: function onChange(velocityDecay, state) {
	        state.forceLayout.velocityDecay(velocityDecay);
	      }
	    },
	    warmupTicks: {
	      "default": 0,
	      triggerUpdate: false
	    },
	    // how many times to tick the force engine at init before starting to render
	    cooldownTicks: {
	      "default": Infinity,
	      triggerUpdate: false
	    },
	    cooldownTime: {
	      "default": 15000,
	      triggerUpdate: false
	    },
	    // ms
	    onUpdate: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onFinishUpdate: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onEngineTick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onEngineStop: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    isShadow: {
	      "default": false,
	      triggerUpdate: false
	    }
	  },
	  methods: {
	    // Expose d3 forces for external manipulation
	    d3Force: function d3Force(state, forceName, forceFn) {
	      if (forceFn === undefined) {
	        return state.forceLayout.force(forceName); // Force getter
	      }

	      state.forceLayout.force(forceName, forceFn); // Force setter

	      return this;
	    },
	    d3ReheatSimulation: function d3ReheatSimulation(state) {
	      state.forceLayout.alpha(1);
	      this.resetCountdown();
	      return this;
	    },
	    // reset cooldown state
	    resetCountdown: function resetCountdown(state) {
	      state.cntTicks = 0;
	      state.startTickTime = new Date();
	      state.engineRunning = true;
	      return this;
	    },
	    tickFrame: function tickFrame(state) {
	      !state.isShadow && layoutTick();
	      paintLinks();
	      !state.isShadow && paintArrows();
	      !state.isShadow && paintPhotons();
	      paintNodes();
	      return this; //

	      function layoutTick() {
	        if (state.engineRunning) {
	          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime) {
	            state.engineRunning = false; // Stop ticking graph

	            state.onEngineStop();
	          } else {
	            state.forceLayout.tick(); // Tick it

	            state.onEngineTick();
	          }
	        }
	      }

	      function paintNodes() {
	        var getVisibility = accessorFn(state.nodeVisibility);
	        var getVal = accessorFn(state.nodeVal);
	        var getColor = accessorFn(state.nodeColor);
	        var getNodeCanvasObjectMode = accessorFn(state.nodeCanvasObjectMode);
	        var ctx = state.ctx; // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)

	        var padAmount = state.isShadow / state.globalScale;
	        var visibleNodes = state.graphData.nodes.filter(getVisibility);
	        ctx.save();
	        visibleNodes.forEach(function (node) {
	          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);

	          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {
	            // Custom node before/replace paint
	            state.nodeCanvasObject(node, ctx, state.globalScale, state.isShadow);

	            if (nodeCanvasObjectMode === 'replace') {
	              ctx.restore();
	              return;
	            }
	          } // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)


	          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;
	          ctx.beginPath();
	          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
	          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';
	          ctx.fill();

	          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {
	            // Custom node after paint
	            state.nodeCanvasObject(node, state.ctx, state.globalScale);
	          }
	        });
	        ctx.restore();
	      }

	      function paintLinks() {
	        var getVisibility = accessorFn(state.linkVisibility);
	        var getColor = accessorFn(state.linkColor);
	        var getWidth = accessorFn(state.linkWidth);
	        var getLineDash = accessorFn(state.linkLineDash);
	        var getCurvature = accessorFn(state.linkCurvature);
	        var getLinkCanvasObjectMode = accessorFn(state.linkCanvasObjectMode);
	        var ctx = state.ctx; // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)

	        var padAmount = state.isShadow * 2;
	        var visibleLinks = state.graphData.links.filter(getVisibility);
	        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links

	        var beforeCustomLinks = [],
	            afterCustomLinks = [],
	            defaultPaintLinks = visibleLinks;

	        if (state.linkCanvasObject) {
	          var replaceCustomLinks = [],
	              otherCustomLinks = [];
	          visibleLinks.forEach(function (d) {
	            return ({
	              before: beforeCustomLinks,
	              after: afterCustomLinks,
	              replace: replaceCustomLinks
	            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);
	          });
	          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);
	          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);
	        } // Custom link before paints


	        ctx.save();
	        beforeCustomLinks.forEach(function (link) {
	          return state.linkCanvasObject(link, ctx, state.globalScale);
	        });
	        ctx.restore(); // Bundle strokes per unique color/width/dash for performance optimization

	        var linksPerColor = indexBy(defaultPaintLinks, [getColor, getWidth, getLineDash]);
	        ctx.save();
	        Object.entries(linksPerColor).forEach(function (_ref) {
	          var _ref2 = _slicedToArray(_ref, 2),
	              color = _ref2[0],
	              linksPerWidth = _ref2[1];

	          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;
	          Object.entries(linksPerWidth).forEach(function (_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 2),
	                width = _ref4[0],
	                linesPerLineDash = _ref4[1];

	            var lineWidth = (width || 1) / state.globalScale + padAmount;
	            Object.entries(linesPerLineDash).forEach(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 2),
	                  dashSegments = _ref6[0],
	                  links = _ref6[1];

	              var lineDashSegments = getLineDash(links[0]);
	              ctx.beginPath();
	              links.forEach(function (link) {
	                var start = link.source;
	                var end = link.target;
	                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	                ctx.moveTo(start.x, start.y);
	                var controlPoints = link.__controlPoints;

	                if (!controlPoints) {
	                  // Straight line
	                  ctx.lineTo(end.x, end.y);
	                } else {
	                  // Use quadratic curves for regular lines and bezier for loops
	                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));
	                }
	              });
	              ctx.strokeStyle = lineColor;
	              ctx.lineWidth = lineWidth;
	              ctx.setLineDash(lineDashSegments || []);
	              ctx.stroke();
	            });
	          });
	        });
	        ctx.restore(); // Custom link after paints

	        ctx.save();
	        afterCustomLinks.forEach(function (link) {
	          return state.linkCanvasObject(link, ctx, state.globalScale);
	        });
	        ctx.restore(); //

	        function calcLinkControlPoints(link) {
	          var curvature = getCurvature(link);

	          if (!curvature) {
	            // straight line
	            link.__controlPoints = null;
	            return;
	          }

	          var start = link.source;
	          var end = link.target;
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length

	          if (l > 0) {
	            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle

	            var d = l * curvature; // control point distance

	            var cp = {
	              // control point
	              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),
	              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)
	            };
	            link.__controlPoints = [cp.x, cp.y];
	          } else {
	            // Same point, draw a loop
	            var _d = curvature * 70;

	            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];
	          }
	        }
	      }

	      function paintArrows() {
	        var ARROW_WH_RATIO = 1.6;
	        var ARROW_VLEN_RATIO = 0.2;
	        var getLength = accessorFn(state.linkDirectionalArrowLength);
	        var getRelPos = accessorFn(state.linkDirectionalArrowRelPos);
	        var getVisibility = accessorFn(state.linkVisibility);
	        var getColor = accessorFn(state.linkDirectionalArrowColor || state.linkColor);
	        var getNodeVal = accessorFn(state.nodeVal);
	        var ctx = state.ctx;
	        ctx.save();
	        state.graphData.links.filter(getVisibility).forEach(function (link) {
	          var arrowLength = getLength(link);
	          if (!arrowLength || arrowLength < 0) return;
	          var start = link.source;
	          var end = link.target;
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;
	          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;
	          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));
	          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';
	          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2; // Construct bezier for curved lines

	          var bzLine = link.__controlPoints && _construct(Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));

	          var getCoordsAlongLine = bzLine ? function (t) {
	            return bzLine.get(t);
	          } // get position along bezier line
	          : function (t) {
	            return {
	              // straight line: interpolate linearly
	              x: start.x + (end.x - start.x) * t || 0,
	              y: start.y + (end.y - start.y) * t || 0
	            };
	          };
	          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
	          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
	          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);
	          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);
	          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);
	          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;
	          ctx.beginPath();
	          ctx.moveTo(arrowHead.x, arrowHead.y);
	          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));
	          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);
	          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));
	          ctx.fillStyle = arrowColor;
	          ctx.fill();
	        });
	        ctx.restore();
	      }

	      function paintPhotons() {
	        var getNumPhotons = accessorFn(state.linkDirectionalParticles);
	        var getSpeed = accessorFn(state.linkDirectionalParticleSpeed);
	        var getDiameter = accessorFn(state.linkDirectionalParticleWidth);
	        var getVisibility = accessorFn(state.linkVisibility);
	        var getColor = accessorFn(state.linkDirectionalParticleColor || state.linkColor);
	        var ctx = state.ctx;
	        ctx.save();
	        state.graphData.links.filter(getVisibility).forEach(function (link) {
	          var numCyclePhotons = getNumPhotons(link);
	          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;
	          var start = link.source;
	          var end = link.target;
	          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

	          var particleSpeed = getSpeed(link);
	          var photons = link.__photons || [];
	          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);
	          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';
	          ctx.fillStyle = photonColor; // Construct bezier for curved lines

	          var bzLine = link.__controlPoints ? _construct(Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;
	          var cyclePhotonIdx = 0;
	          var needsCleanup = false; // whether some photons need to be removed from list

	          photons.forEach(function (photon) {
	            var singleHop = !!photon.__singleHop;

	            if (!photon.hasOwnProperty('__progressRatio')) {
	              photon.__progressRatio = singleHop ? 0 : cyclePhotonIdx / numCyclePhotons;
	            }

	            !singleHop && cyclePhotonIdx++; // increase regular photon index

	            photon.__progressRatio += particleSpeed;

	            if (photon.__progressRatio >= 1) {
	              if (!singleHop) {
	                photon.__progressRatio = photon.__progressRatio % 1;
	              } else {
	                needsCleanup = true;
	                return;
	              }
	            }

	            var photonPosRatio = photon.__progressRatio;
	            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line
	            : {
	              // straight line: interpolate linearly
	              x: start.x + (end.x - start.x) * photonPosRatio || 0,
	              y: start.y + (end.y - start.y) * photonPosRatio || 0
	            };
	            ctx.beginPath();
	            ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);
	            ctx.fill();
	          });

	          if (needsCleanup) {
	            // remove expired single hop photons
	            link.__photons = link.__photons.filter(function (photon) {
	              return !photon.__singleHop || photon.__progressRatio <= 1;
	            });
	          }
	        });
	        ctx.restore();
	      }
	    },
	    emitParticle: function emitParticle(state, link) {
	      if (link) {
	        !link.__photons && (link.__photons = []);

	        link.__photons.push({
	          __singleHop: true
	        }); // add a single hop particle

	      }

	      return this;
	    }
	  },
	  stateInit: function stateInit() {
	    return {
	      forceLayout: d3Force3d.forceSimulation().force('link', d3Force3d.forceLink()).force('charge', d3Force3d.forceManyBody()).force('center', d3Force3d.forceCenter()).force('dagRadial', null).stop(),
	      engineRunning: false
	    };
	  },
	  init: function init(canvasCtx, state) {
	    // Main canvas object to manipulate
	    state.ctx = canvasCtx;
	  },
	  update: function update(state) {
	    state.engineRunning = false; // Pause simulation

	    state.onUpdate();

	    if (state.nodeAutoColorBy !== null) {
	      // Auto add color to uncolored nodes
	      autoColorObjects(state.graphData.nodes, accessorFn(state.nodeAutoColorBy), state.nodeColor);
	    }

	    if (state.linkAutoColorBy !== null) {
	      // Auto add color to uncolored links
	      autoColorObjects(state.graphData.links, accessorFn(state.linkAutoColorBy), state.linkColor);
	    } // parse links


	    state.graphData.links.forEach(function (link) {
	      link.source = link[state.linkSource];
	      link.target = link[state.linkTarget];
	    });

	    if (!state.isShadow) {
	      // Add photon particles
	      var linkParticlesAccessor = accessorFn(state.linkDirectionalParticles);
	      state.graphData.links.forEach(function (link) {
	        var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));

	        if (numPhotons) {
	          link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {
	            return {};
	          });
	        } else {
	          delete link.__photons;
	        }
	      });
	    } // Feed data to force-directed layout


	    state.forceLayout.stop().alpha(1) // re-heat the simulation
	    .nodes(state.graphData.nodes); // add links (if link force is still active)

	    var linkForce = state.forceLayout.force('link');

	    if (linkForce) {
	      linkForce.id(function (d) {
	        return d[state.nodeId];
	      }).links(state.graphData.links);
	    } // setup dag force constraints


	    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {
	      return node[state.nodeId];
	    });
	    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
	    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1); // Fix nodes to x,y for dag mode

	    if (state.dagMode) {
	      var getFFn = function getFFn(fix, invert) {
	        return function (node) {
	          return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
	        };
	      };

	      var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');
	      var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'bu');
	      state.graphData.nodes.forEach(function (node) {
	        node.fx = fxFn(node);
	        node.fy = fyFn(node);
	      });
	    } // Use radial force for radial dags


	    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? d3Force3d.forceRadial(function (node) {
	      var nodeDepth = nodeDepths[node[state.nodeId]];
	      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
	    }).strength(1) : null);

	    for (var i = 0; i < state.warmupTicks; i++) {
	      state.forceLayout.tick();
	    } // Initial ticks before starting to render


	    this.resetCountdown();
	    state.onFinishUpdate();
	  }
	});

	function linkKapsule (kapsulePropNames, kapsuleType) {
	  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];
	  var dummyK = new kapsuleType(); // To extract defaults

	  return {
	    linkProp: function linkProp(prop) {
	      // link property config
	      return {
	        "default": dummyK[prop](),
	        onChange: function onChange(v, state) {
	          propNames.forEach(function (propName) {
	            return state[propName][prop](v);
	          });
	        },
	        triggerUpdate: false
	      };
	    },
	    linkMethod: function linkMethod(method) {
	      // link method pass-through
	      return function (state) {
	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }

	        var returnVals = [];
	        propNames.forEach(function (propName) {
	          var kapsuleInstance = state[propName];
	          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);

	          if (returnVal !== kapsuleInstance) {
	            returnVals.push(returnVal);
	          }
	        });
	        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule
	      };
	    }
	  };
	}

	var HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement

	var ZOOM2NODES_FACTOR = 4; // Expose config from forceGraph

	var bindFG = linkKapsule('forceGraph', CanvasForceGraph);
	var bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);
	var linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'dagMode', 'dagLevelDistance', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {
	  return _defineProperty({}, p, bindFG.linkProp(p));
	})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {
	  return _defineProperty({}, p, bindBoth.linkProp(p));
	}))));
	var linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {
	  return _defineProperty({}, p, bindFG.linkMethod(p));
	})));

	function adjustCanvasSize(state) {
	  if (state.canvas) {
	    var curWidth = state.canvas.width;
	    var curHeight = state.canvas.height;

	    if (curWidth === 300 && curHeight === 150) {
	      // Default canvas dimensions
	      curWidth = curHeight = 0;
	    }

	    var pxScale = window.devicePixelRatio; // 2 on retina displays

	    curWidth /= pxScale;
	    curHeight /= pxScale; // Resize canvases

	    [state.canvas, state.shadowCanvas].forEach(function (canvas) {
	      // Element size
	      canvas.style.width = "".concat(state.width, "px");
	      canvas.style.height = "".concat(state.height, "px"); // Memory size (scaled to avoid blurriness)

	      canvas.width = state.width * pxScale;
	      canvas.height = state.height * pxScale; // Normalize coordinate system to use css pixels (on init only)

	      if (!curWidth && !curHeight) {
	        canvas.getContext('2d').scale(pxScale, pxScale);
	      }
	    }); // Relative center panning based on 0,0

	    var k = d3Zoom.zoomTransform(state.canvas).k;
	    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);
	  }
	}

	function resetTransform(ctx) {
	  var pxRatio = window.devicePixelRatio;
	  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);
	}

	function clearCanvas(ctx, width, height) {
	  ctx.save();
	  resetTransform(ctx); // reset transform

	  ctx.clearRect(0, 0, width, height);
	  ctx.restore(); //restore transforms
	} //


	var forceGraph = Kapsule({
	  props: _objectSpread2({
	    width: {
	      "default": window.innerWidth,
	      onChange: function onChange(_, state) {
	        return adjustCanvasSize(state);
	      },
	      triggerUpdate: false
	    },
	    height: {
	      "default": window.innerHeight,
	      onChange: function onChange(_, state) {
	        return adjustCanvasSize(state);
	      },
	      triggerUpdate: false
	    },
	    graphData: {
	      "default": {
	        nodes: [],
	        links: []
	      },
	      onChange: function onChange(d, state) {
	        if (d.nodes.length || d.links.length) {
	          console.info('force-graph loading', d.nodes.length + ' nodes', d.links.length + ' links');
	        }

	        [{
	          type: 'Node',
	          objs: d.nodes
	        }, {
	          type: 'Link',
	          objs: d.links
	        }].forEach(hexIndex);
	        state.forceGraph.graphData(d);
	        state.shadowGraph.graphData(d);

	        function hexIndex(_ref4) {
	          var type = _ref4.type,
	              objs = _ref4.objs;
	          objs.filter(function (d) {
	            if (!d.hasOwnProperty('__indexColor')) return true;
	            var cur = state.colorTracker.lookup(d.__indexColor);
	            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;
	          }).forEach(function (d) {
	            // store object lookup color
	            d.__indexColor = state.colorTracker.register({
	              type: type,
	              d: d
	            });
	          });
	        }
	      },
	      triggerUpdate: false
	    },
	    backgroundColor: {
	      onChange: function onChange(color, state) {
	        state.canvas && color && (state.canvas.style.background = color);
	      },
	      triggerUpdate: false
	    },
	    nodeLabel: {
	      "default": 'name',
	      triggerUpdate: false
	    },
	    linkLabel: {
	      "default": 'name',
	      triggerUpdate: false
	    },
	    linkHoverPrecision: {
	      "default": 4,
	      triggerUpdate: false
	    },
	    enableNodeDrag: {
	      "default": true,
	      triggerUpdate: false
	    },
	    enableZoomPanInteraction: {
	      "default": true,
	      triggerUpdate: false
	    },
	    enablePointerInteraction: {
	      "default": true,
	      onChange: function onChange(_, state) {
	        state.hoverObj = null;
	      },
	      triggerUpdate: false
	    },
	    onNodeDrag: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeDragEnd: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onNodeRightClick: {
	      triggerUpdate: false
	    },
	    onNodeHover: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onLinkClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onLinkRightClick: {
	      triggerUpdate: false
	    },
	    onLinkHover: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onBackgroundClick: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onBackgroundRightClick: {
	      triggerUpdate: false
	    },
	    onZoom: {
	      "default": function _default() {},
	      triggerUpdate: false
	    },
	    onZoomEnd: {
	      "default": function _default() {},
	      triggerUpdate: false
	    }
	  }, linkedProps),
	  aliases: {
	    // Prop names supported for backwards compatibility
	    stopAnimation: 'pauseAnimation'
	  },
	  methods: _objectSpread2({
	    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {
	      var t = d3Zoom.zoomTransform(state.canvas);
	      return {
	        x: x * t.k + t.x,
	        y: y * t.k + t.y
	      };
	    },
	    screen2GraphCoords: function screen2GraphCoords(state, x, y) {
	      var t = d3Zoom.zoomTransform(state.canvas);
	      return {
	        x: (x - t.x) / t.k,
	        y: (y - t.y) / t.k
	      };
	    },
	    centerAt: function centerAt(state, x, y, transitionDuration) {
	      if (!state.canvas) return null; // no canvas yet
	      // setter

	      if (x !== undefined || y !== undefined) {
	        var finalPos = Object.assign({}, x !== undefined ? {
	          x: x
	        } : {}, y !== undefined ? {
	          y: y
	        } : {});

	        if (!transitionDuration) {
	          // no animation
	          setCenter(finalPos);
	        } else {
	          new TWEEN.Tween(getCenter()).to(finalPos, transitionDuration).easing(TWEEN.Easing.Quadratic.Out).onUpdate(setCenter).start();
	        }

	        return this;
	      } // getter


	      return getCenter(); //

	      function getCenter() {
	        var t = d3Zoom.zoomTransform(state.canvas);
	        return {
	          x: (state.width / 2 - t.x) / t.k,
	          y: (state.height / 2 - t.y) / t.k
	        };
	      }

	      function setCenter(_ref5) {
	        var x = _ref5.x,
	            y = _ref5.y;
	        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);
	      }
	    },
	    zoom: function zoom(state, k, transitionDuration) {
	      if (!state.canvas) return null; // no canvas yet
	      // setter

	      if (k !== undefined) {
	        if (!transitionDuration) {
	          // no animation
	          setZoom(k);
	        } else {
	          new TWEEN.Tween({
	            k: getZoom()
	          }).to({
	            k: k
	          }, transitionDuration).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function (_ref6) {
	            var k = _ref6.k;
	            return setZoom(k);
	          }).start();
	        }

	        return this;
	      } // getter


	      return getZoom(); //

	      function getZoom() {
	        return d3Zoom.zoomTransform(state.canvas).k;
	      }

	      function setZoom(k) {
	        state.zoom.scaleTo(state.zoom.__baseElem, k);
	      }
	    },
	    pauseAnimation: function pauseAnimation(state) {
	      if (state.animationFrameRequestId) {
	        cancelAnimationFrame(state.animationFrameRequestId);
	        state.animationFrameRequestId = null;
	      }

	      return this;
	    },
	    resumeAnimation: function resumeAnimation(state) {
	      if (!state.animationFrameRequestId) {
	        this._animationCycle();
	      }

	      return this;
	    },
	    _destructor: function _destructor() {
	      this.pauseAnimation();
	      this.graphData({
	        nodes: [],
	        links: []
	      });
	    }
	  }, linkedMethods),
	  stateInit: function stateInit() {
	    return {
	      lastSetZoom: 1,
	      forceGraph: new CanvasForceGraph(),
	      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),
	      colorTracker: new ColorTracker() // indexed objects for rgb lookup

	    };
	  },
	  init: function init(domNode, state) {
	    // Wipe DOM
	    domNode.innerHTML = ''; // Container anchor for canvas and tooltip

	    var container = document.createElement('div');
	    container.style.position = 'relative';
	    domNode.appendChild(container);
	    state.canvas = document.createElement('canvas');
	    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;
	    container.appendChild(state.canvas);
	    state.shadowCanvas = document.createElement('canvas'); // Show shadow canvas
	    //state.shadowCanvas.style.position = 'absolute';
	    //state.shadowCanvas.style.top = '0';
	    //state.shadowCanvas.style.left = '0';
	    //container.appendChild(state.shadowCanvas);

	    var ctx = state.canvas.getContext('2d');
	    var shadowCtx = state.shadowCanvas.getContext('2d'); // Setup node drag interaction

	    d3Selection.select(state.canvas).call(d3Drag.drag().subject(function () {
	      if (!state.enableNodeDrag) {
	        return null;
	      }

	      var obj = state.hoverObj;
	      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes
	    }).on('start', function () {
	      var obj = d3Selection.event.subject;
	      obj.__initialDragPos = {
	        x: obj.x,
	        y: obj.y,
	        fx: obj.fx,
	        fy: obj.fy
	      }; // keep engine running at low intensity throughout drag

	      if (!d3Selection.event.active) {
	        obj.fx = obj.x;
	        obj.fy = obj.y; // Fix points
	      } // drag cursor


	      state.canvas.classList.add('grabbable');
	    }).on('drag', function () {
	      var obj = d3Selection.event.subject;
	      var initPos = obj.__initialDragPos;
	      var dragPos = d3Selection.event;
	      var k = d3Zoom.zoomTransform(state.canvas).k;
	      var translate = {
	        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,
	        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y
	      }; // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start

	      ['x', 'y'].forEach(function (c) {
	        return obj["f".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;
	      }); // prevent freeze while dragging

	      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag
	      .resetCountdown(); // prevent freeze while dragging

	      obj.__dragged = true;
	      state.onNodeDrag(obj, translate);
	    }).on('end', function () {
	      var obj = d3Selection.event.subject;
	      var initPos = obj.__initialDragPos;
	      var translate = {
	        x: obj.x - initPos.x,
	        y: obj.y - initPos.y
	      };

	      if (initPos.fx === undefined) {
	        obj.fx = undefined;
	      }

	      if (initPos.fy === undefined) {
	        obj.fy = undefined;
	      }

	      delete obj.__initialDragPos;
	      state.forceGraph.d3AlphaTarget(0) // release engine low intensity
	      .resetCountdown(); // let the engine readjust after releasing fixed nodes
	      // drag cursor

	      state.canvas.classList.remove('grabbable');

	      if (obj.__dragged) {
	        delete obj.__dragged;
	        state.onNodeDragEnd(obj, translate);
	      }
	    })); // Setup zoom / pan interaction

	    state.zoom = d3Zoom.zoom();
	    state.zoom(state.zoom.__baseElem = d3Selection.select(state.canvas)); // Attach controlling elem for easy access

	    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom


	    state.zoom.filter(function () {
	      return state.enableZoomPanInteraction ? !d3Selection.event.button : false;
	    }) // disable zoom interaction
	    .scaleExtent([0.01, 1000]).on('zoom', function () {
	      var t = d3Zoom.zoomTransform(this); // Same as d3.event.transform

	      [ctx, shadowCtx].forEach(function (c) {
	        resetTransform(c);
	        c.translate(t.x, t.y);
	        c.scale(t.k, t.k);
	      });
	      state.onZoom(_objectSpread2({}, t));
	    }).on('end', function () {
	      var t = d3Zoom.zoomTransform(this); // Same as d3.event.transform

	      state.onZoomEnd(_objectSpread2({}, t));
	    });
	    adjustCanvasSize(state);
	    state.forceGraph.onFinishUpdate(function () {
	      // re-zoom, if still in default position (not user modified)
	      if (d3Zoom.zoomTransform(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {
	        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));
	      }
	    }); // Setup tooltip

	    var toolTipElem = document.createElement('div');
	    toolTipElem.classList.add('graph-tooltip');
	    container.appendChild(toolTipElem); // Capture mouse coords on move

	    var mousePos = {
	      x: -1e12,
	      y: -1e12
	    };
	    state.canvas.addEventListener('mousemove', function (ev) {
	      // update the mouse pos
	      var offset = getOffset(container);
	      mousePos.x = ev.pageX - offset.left;
	      mousePos.y = ev.pageY - offset.top; // Move tooltip

	      toolTipElem.style.top = "".concat(mousePos.y, "px");
	      toolTipElem.style.left = "".concat(mousePos.x, "px"); //

	      function getOffset(el) {
	        var rect = el.getBoundingClientRect(),
	            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
	            scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	        return {
	          top: rect.top + scrollTop,
	          left: rect.left + scrollLeft
	        };
	      }
	    }, false); // Handle click events on nodes/links

	    container.addEventListener('click', function (ev) {
	      if (state.hoverObj) {
	        state["on".concat(state.hoverObj.type, "Click")](state.hoverObj.d, ev);
	      } else {
	        state.onBackgroundClick(ev);
	      }
	    }, false); // Handle right-click events

	    container.addEventListener('contextmenu', function (ev) {
	      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior

	      ev.preventDefault();

	      if (state.hoverObj) {
	        var fn = state["on".concat(state.hoverObj.type, "RightClick")];
	        fn && fn(state.hoverObj.d, ev);
	      } else {
	        state.onBackgroundRightClick && state.onBackgroundRightClick(ev);
	      }

	      return false;
	    }, false);
	    state.forceGraph(ctx);
	    state.shadowGraph(shadowCtx); //

	    var refreshShadowCanvas = throttle(function () {
	      // wipe canvas
	      clearCanvas(shadowCtx, state.width, state.height); // Adjust link hover area

	      state.shadowGraph.linkWidth(function (l) {
	        return accessorFn(state.linkWidth)(l) + state.linkHoverPrecision;
	      }); // redraw

	      var t = d3Zoom.zoomTransform(state.canvas);
	      state.shadowGraph.globalScale(t.k).tickFrame();
	    }, HOVER_CANVAS_THROTTLE_DELAY); // Kick-off renderer

	    (this._animationCycle = function animate() {
	      // IIFE
	      if (state.enablePointerInteraction) {
	        // Update tooltip and trigger onHover events
	        // Lookup object per pixel color
	        var pxScale = window.devicePixelRatio;
	        var px = mousePos.x > 0 && mousePos.y > 0 ? shadowCtx.getImageData(mousePos.x * pxScale, mousePos.y * pxScale, 1, 1) : null;
	        var obj = px ? state.colorTracker.lookup(px.data) : null;

	        if (obj !== state.hoverObj) {
	          var prevObj = state.hoverObj;
	          var prevObjType = prevObj ? prevObj.type : null;
	          var objType = obj ? obj.type : null;

	          if (prevObjType && prevObjType !== objType) {
	            // Hover out
	            state["on".concat(prevObjType, "Hover")](null, prevObj.d);
	          }

	          if (objType) {
	            // Hover in
	            state["on".concat(objType, "Hover")](obj.d, prevObjType === objType ? prevObj.d : null);
	          }

	          var tooltipContent = obj ? accessorFn(state["".concat(obj.type.toLowerCase(), "Label")])(obj.d) || '' : '';
	          toolTipElem.style.visibility = tooltipContent ? 'visible' : 'hidden';
	          toolTipElem.innerHTML = tooltipContent;
	          state.hoverObj = obj;
	        }

	        refreshShadowCanvas();
	      } // Wipe canvas


	      clearCanvas(ctx, state.width, state.height); // Frame cycle

	      var t = d3Zoom.zoomTransform(state.canvas);
	      state.forceGraph.globalScale(t.k).tickFrame();
	      TWEEN.update(); // update canvas animation tweens

	      state.animationFrameRequestId = requestAnimationFrame(animate);
	    })();
	  },
	  update: function updateFn(state) {}
	});

	module.exports = forceGraph;


/***/ }),
/* 175 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;

	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }

	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  if (isObject(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = throttle;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var tinyColor = _interopDefault(__webpack_require__(83));

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	var ENTROPY = 123; // Raise numbers to prevent collisions in lower indexes

	var int2HexColor = function int2HexColor(num) {
	  return "#".concat(Math.min(num, Math.pow(2, 24)).toString(16).padStart(6, '0'));
	};

	var rgb2Int = function rgb2Int(r, g, b) {
	  return (r << 16) + (g << 8) + b;
	};

	var colorStr2Int = function colorStr2Int(str) {
	  var _tinyColor$toRgb = tinyColor(str).toRgb(),
	      r = _tinyColor$toRgb.r,
	      g = _tinyColor$toRgb.g,
	      b = _tinyColor$toRgb.b;

	  return rgb2Int(r, g, b);
	};

	var checksum = function checksum(n, csBits) {
	  return n * ENTROPY % Math.pow(2, csBits);
	};

	var _default = /*#__PURE__*/function () {
	  function _default() {
	    var csBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;

	    _classCallCheck(this, _default);

	    this.csBits = csBits; // How many bits to reserve for checksum. Will eat away into the usable size of the registry.

	    this.registry = ['__reserved for background__']; // indexed objects for rgb lookup;
	  }

	  _createClass(_default, [{
	    key: "register",
	    value: function register(obj) {
	      if (this.registry.length >= Math.pow(2, 24 - this.csBits)) {
	        // color has 24 bits (-checksum)
	        return null; // Registry is full
	      }

	      var idx = this.registry.length;
	      var cs = checksum(idx, this.csBits);
	      var color = int2HexColor(idx + (cs << 24 - this.csBits));
	      this.registry.push(obj);
	      return color;
	    }
	  }, {
	    key: "lookup",
	    value: function lookup(color) {
	      var n = typeof color === 'string' ? colorStr2Int(color) : rgb2Int.apply(void 0, _toConsumableArray(color));
	      if (!n) return null; // 0 index is reserved for background

	      var idx = n & Math.pow(2, 24 - this.csBits) - 1; // registry index

	      var cs = n >> 24 - this.csBits & Math.pow(2, this.csBits) - 1; // extract bits reserved for checksum

	      if (checksum(idx, this.csBits) !== cs || idx >= this.registry.length) return null; // failed checksum or registry out of bounds

	      return this.registry[idx];
	    }
	  }]);

	  return _default;
	}();

	module.exports = _default;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(178);


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	  A javascript Bezier curve library by Pomax.

	  Based on http://pomax.github.io/bezierinfo

	  This code is MIT licensed.
	**/
	(function() {
	  "use strict";

	  // math-inlining.
	  var abs = Math.abs,
	    min = Math.min,
	    max = Math.max,
	    cos = Math.cos,
	    sin = Math.sin,
	    acos = Math.acos,
	    sqrt = Math.sqrt,
	    pi = Math.PI,
	    // a zero coordinate, which is surprisingly useful
	    ZERO = { x: 0, y: 0, z: 0 };

	  // quite needed
	  var utils = __webpack_require__(179);

	  // only used for outlines atm.
	  var PolyBezier = __webpack_require__(180);

	  /**
	   * Bezier curve constructor. The constructor argument can be one of three things:
	   *
	   * 1. array/4 of {x:..., y:..., z:...}, z optional
	   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
	   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
	   *
	   */
	  var Bezier = function(coords) {
	    var args = coords && coords.forEach ? coords : [].slice.call(arguments);
	    var coordlen = false;
	    if (typeof args[0] === "object") {
	      coordlen = args.length;
	      var newargs = [];
	      args.forEach(function(point) {
	        ["x", "y", "z"].forEach(function(d) {
	          if (typeof point[d] !== "undefined") {
	            newargs.push(point[d]);
	          }
	        });
	      });
	      args = newargs;
	    }
	    var higher = false;
	    var len = args.length;
	    if (coordlen) {
	      if (coordlen > 4) {
	        if (arguments.length !== 1) {
	          throw new Error(
	            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
	          );
	        }
	        higher = true;
	      }
	    } else {
	      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
	        if (arguments.length !== 1) {
	          throw new Error(
	            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
	          );
	        }
	      }
	    }
	    var _3d =
	      (!higher && (len === 9 || len === 12)) ||
	      (coords && coords[0] && typeof coords[0].z !== "undefined");
	    this._3d = _3d;
	    var points = [];
	    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
	      var point = {
	        x: args[idx],
	        y: args[idx + 1]
	      };
	      if (_3d) {
	        point.z = args[idx + 2];
	      }
	      points.push(point);
	    }
	    this.order = points.length - 1;
	    this.points = points;
	    var dims = ["x", "y"];
	    if (_3d) dims.push("z");
	    this.dims = dims;
	    this.dimlen = dims.length;

	    (function(curve) {
	      var order = curve.order;
	      var points = curve.points;
	      var a = utils.align(points, { p1: points[0], p2: points[order] });
	      for (var i = 0; i < a.length; i++) {
	        if (abs(a[i].y) > 0.0001) {
	          curve._linear = false;
	          return;
	        }
	      }
	      curve._linear = true;
	    })(this);

	    this._t1 = 0;
	    this._t2 = 1;
	    this.update();
	  };

	  var svgToBeziers = __webpack_require__(181);

	  /**
	   * turn an svg <path> d attribute into a sequence of Bezier segments.
	   */
	  Bezier.SVGtoBeziers = function(d) {
	    return svgToBeziers(Bezier, d);
	  };

	  function getABC(n, S, B, E, t) {
	    if (typeof t === "undefined") {
	      t = 0.5;
	    }
	    var u = utils.projectionratio(t, n),
	      um = 1 - u,
	      C = {
	        x: u * S.x + um * E.x,
	        y: u * S.y + um * E.y
	      },
	      s = utils.abcratio(t, n),
	      A = {
	        x: B.x + (B.x - C.x) / s,
	        y: B.y + (B.y - C.y) / s
	      };
	    return { A: A, B: B, C: C };
	  }

	  Bezier.quadraticFromPoints = function(p1, p2, p3, t) {
	    if (typeof t === "undefined") {
	      t = 0.5;
	    }
	    // shortcuts, although they're really dumb
	    if (t === 0) {
	      return new Bezier(p2, p2, p3);
	    }
	    if (t === 1) {
	      return new Bezier(p1, p2, p2);
	    }
	    // real fitting.
	    var abc = getABC(2, p1, p2, p3, t);
	    return new Bezier(p1, abc.A, p3);
	  };

	  Bezier.cubicFromPoints = function(S, B, E, t, d1) {
	    if (typeof t === "undefined") {
	      t = 0.5;
	    }
	    var abc = getABC(3, S, B, E, t);
	    if (typeof d1 === "undefined") {
	      d1 = utils.dist(B, abc.C);
	    }
	    var d2 = d1 * (1 - t) / t;

	    var selen = utils.dist(S, E),
	      lx = (E.x - S.x) / selen,
	      ly = (E.y - S.y) / selen,
	      bx1 = d1 * lx,
	      by1 = d1 * ly,
	      bx2 = d2 * lx,
	      by2 = d2 * ly;
	    // derivation of new hull coordinates
	    var e1 = { x: B.x - bx1, y: B.y - by1 },
	      e2 = { x: B.x + bx2, y: B.y + by2 },
	      A = abc.A,
	      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },
	      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },
	      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },
	      nc2 = {
	        x: E.x + (v2.x - E.x) / (1 - t),
	        y: E.y + (v2.y - E.y) / (1 - t)
	      };
	    // ...done
	    return new Bezier(S, nc1, nc2, E);
	  };

	  var getUtils = function() {
	    return utils;
	  };

	  Bezier.getUtils = getUtils;

	  Bezier.PolyBezier = PolyBezier;

	  Bezier.prototype = {
	    getUtils: getUtils,
	    valueOf: function() {
	      return this.toString();
	    },
	    toString: function() {
	      return utils.pointsToString(this.points);
	    },
	    toSVG: function(relative) {
	      if (this._3d) return false;
	      var p = this.points,
	        x = p[0].x,
	        y = p[0].y,
	        s = ["M", x, y, this.order === 2 ? "Q" : "C"];
	      for (var i = 1, last = p.length; i < last; i++) {
	        s.push(p[i].x);
	        s.push(p[i].y);
	      }
	      return s.join(" ");
	    },
	    setRatios: function(ratios) {
	      if (ratios.length !== this.points.length) {
	        throw new Error("incorrect number of ratio values");
	      }
	      this.ratios = ratios;
	      this._lut = []; //  invalidate any precomputed LUT
	    },
	    verify: function() {
	      var print = this.coordDigest();
	      if (print !== this._print) {
	        this._print = print;
	        this.update();
	      }
	    },
	    coordDigest: function() {
	      return this.points.map(function(c,pos) {
	        return '' + pos + c.x + c.y + (c.z?c.z:0);
	      }).join('');
	    },
	    update: function(newprint) {
	      // invalidate any precomputed LUT
	      this._lut = [];
	      this.dpoints = utils.derive(this.points, this._3d);
	      this.computedirection();
	    },
	    computedirection: function() {
	      var points = this.points;
	      var angle = utils.angle(points[0], points[this.order], points[1]);
	      this.clockwise = angle > 0;
	    },
	    length: function() {
	      return utils.length(this.derivative.bind(this));
	    },
	    _lut: [],
	    getLUT: function(steps) {
	      this.verify();
	      steps = steps || 100;
	      if (this._lut.length === steps) {
	        return this._lut;
	      }
	      this._lut = [];
	      // We want a range from 0 to 1 inclusive, so
	      // we decrement and then use <= rather than <:
	      steps--;
	      for (var t = 0; t <= steps; t++) {
	        this._lut.push(this.compute(t / steps));
	      }
	      return this._lut;
	    },
	    on: function(point, error) {
	      error = error || 5;
	      var lut = this.getLUT(),
	        hits = [],
	        c,
	        t = 0;
	      for (var i = 0; i < lut.length; i++) {
	        c = lut[i];
	        if (utils.dist(c, point) < error) {
	          hits.push(c);
	          t += i / lut.length;
	        }
	      }
	      if (!hits.length) return false;
	      return (t /= hits.length);
	    },
	    project: function(point) {
	      // step 1: coarse check
	      var LUT = this.getLUT(),
	        l = LUT.length - 1,
	        closest = utils.closest(LUT, point),
	        mdist = closest.mdist,
	        mpos = closest.mpos;

	      // step 2: fine check
	      var ft,
	        t,
	        p,
	        d,
	        t1 = (mpos - 1) / l,
	        t2 = (mpos + 1) / l,
	        step = 0.1 / l;
	      mdist += 1;
	      for (t = t1, ft = t; t < t2 + step; t += step) {
	        p = this.compute(t);
	        d = utils.dist(point, p);
	        if (d < mdist) {
	          mdist = d;
	          ft = t;
	        }
	      }
	      p = this.compute(ft);
	      p.t = ft;
	      p.d = mdist;
	      return p;
	    },
	    get: function(t) {
	      return this.compute(t);
	    },
	    point: function(idx) {
	      return this.points[idx];
	    },
	    compute: function(t) {
	      if (this.ratios) return utils.computeWithRatios(t, this.points, this.ratios, this._3d);
	      return utils.compute(t, this.points, this._3d, this.ratios);
	    },
	    raise: function() {
	      var p = this.points,
	        np = [p[0]],
	        i,
	        k = p.length,
	        pi,
	        pim;
	      for (var i = 1; i < k; i++) {
	        pi = p[i];
	        pim = p[i - 1];
	        np[i] = {
	          x: (k - i) / k * pi.x + i / k * pim.x,
	          y: (k - i) / k * pi.y + i / k * pim.y
	        };
	      }
	      np[k] = p[k - 1];
	      return new Bezier(np);
	    },
	    derivative: function(t) {
	      var mt = 1 - t,
	        a,
	        b,
	        c = 0,
	        p = this.dpoints[0];
	      if (this.order === 2) {
	        p = [p[0], p[1], ZERO];
	        a = mt;
	        b = t;
	      }
	      if (this.order === 3) {
	        a = mt * mt;
	        b = mt * t * 2;
	        c = t * t;
	      }
	      var ret = {
	        x: a * p[0].x + b * p[1].x + c * p[2].x,
	        y: a * p[0].y + b * p[1].y + c * p[2].y
	      };
	      if (this._3d) {
	        ret.z = a * p[0].z + b * p[1].z + c * p[2].z;
	      }
	      return ret;
	    },
	    curvature: function(t) {
	      return utils.curvature(t, this.points, this._3d);
	    },
	    inflections: function() {
	      return utils.inflections(this.points);
	    },
	    normal: function(t) {
	      return this._3d ? this.__normal3(t) : this.__normal2(t);
	    },
	    __normal2: function(t) {
	      var d = this.derivative(t);
	      var q = sqrt(d.x * d.x + d.y * d.y);
	      return { x: -d.y / q, y: d.x / q };
	    },
	    __normal3: function(t) {
	      // see http://stackoverflow.com/questions/25453159
	      var r1 = this.derivative(t),
	        r2 = this.derivative(t + 0.01),
	        q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
	        q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
	      r1.x /= q1;
	      r1.y /= q1;
	      r1.z /= q1;
	      r2.x /= q2;
	      r2.y /= q2;
	      r2.z /= q2;
	      // cross product
	      var c = {
	        x: r2.y * r1.z - r2.z * r1.y,
	        y: r2.z * r1.x - r2.x * r1.z,
	        z: r2.x * r1.y - r2.y * r1.x
	      };
	      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
	      c.x /= m;
	      c.y /= m;
	      c.z /= m;
	      // rotation matrix
	      var R = [
	        c.x * c.x,
	        c.x * c.y - c.z,
	        c.x * c.z + c.y,
	        c.x * c.y + c.z,
	        c.y * c.y,
	        c.y * c.z - c.x,
	        c.x * c.z - c.y,
	        c.y * c.z + c.x,
	        c.z * c.z
	      ];
	      // normal vector:
	      var n = {
	        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
	        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
	        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
	      };
	      return n;
	    },
	    hull: function(t) {
	      var p = this.points,
	        _p = [],
	        pt,
	        q = [],
	        idx = 0,
	        i = 0,
	        l = 0;
	      q[idx++] = p[0];
	      q[idx++] = p[1];
	      q[idx++] = p[2];
	      if (this.order === 3) {
	        q[idx++] = p[3];
	      }
	      // we lerp between all points at each iteration, until we have 1 point left.
	      while (p.length > 1) {
	        _p = [];
	        for (i = 0, l = p.length - 1; i < l; i++) {
	          pt = utils.lerp(t, p[i], p[i + 1]);
	          q[idx++] = pt;
	          _p.push(pt);
	        }
	        p = _p;
	      }
	      return q;
	    },
	    split: function(t1, t2) {
	      // shortcuts
	      if (t1 === 0 && !!t2) {
	        return this.split(t2).left;
	      }
	      if (t2 === 1) {
	        return this.split(t1).right;
	      }

	      // no shortcut: use "de Casteljau" iteration.
	      var q = this.hull(t1);
	      var result = {
	        left:
	          this.order === 2
	            ? new Bezier([q[0], q[3], q[5]])
	            : new Bezier([q[0], q[4], q[7], q[9]]),
	        right:
	          this.order === 2
	            ? new Bezier([q[5], q[4], q[2]])
	            : new Bezier([q[9], q[8], q[6], q[3]]),
	        span: q
	      };

	      // make sure we bind _t1/_t2 information!
	      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
	      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
	      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
	      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);

	      // if we have no t2, we're done
	      if (!t2) {
	        return result;
	      }

	      // if we have a t2, split again:
	      t2 = utils.map(t2, t1, 1, 0, 1);
	      var subsplit = result.right.split(t2);
	      return subsplit.left;
	    },
	    extrema: function() {
	      var dims = this.dims,
	        result = {},
	        roots = [],
	        p,
	        mfn;
	      dims.forEach(
	        function(dim) {
	          mfn = function(v) {
	            return v[dim];
	          };
	          p = this.dpoints[0].map(mfn);
	          result[dim] = utils.droots(p);
	          if (this.order === 3) {
	            p = this.dpoints[1].map(mfn);
	            result[dim] = result[dim].concat(utils.droots(p));
	          }
	          result[dim] = result[dim].filter(function(t) {
	            return t >= 0 && t <= 1;
	          });
	          roots = roots.concat(result[dim].sort(utils.numberSort));
	        }.bind(this)
	      );
	      roots = roots.sort(utils.numberSort).filter(function(v, idx) {
	        return roots.indexOf(v) === idx;
	      });
	      result.values = roots;
	      return result;
	    },
	    bbox: function() {
	      var extrema = this.extrema(),
	        result = {};
	      this.dims.forEach(
	        function(d) {
	          result[d] = utils.getminmax(this, d, extrema[d]);
	        }.bind(this)
	      );
	      return result;
	    },
	    overlaps: function(curve) {
	      var lbbox = this.bbox(),
	        tbbox = curve.bbox();
	      return utils.bboxoverlap(lbbox, tbbox);
	    },
	    offset: function(t, d) {
	      if (typeof d !== "undefined") {
	        var c = this.get(t);
	        var n = this.normal(t);
	        var ret = {
	          c: c,
	          n: n,
	          x: c.x + n.x * d,
	          y: c.y + n.y * d
	        };
	        if (this._3d) {
	          ret.z = c.z + n.z * d;
	        }
	        return ret;
	      }
	      if (this._linear) {
	        var nv = this.normal(0);
	        var coords = this.points.map(function(p) {
	          var ret = {
	            x: p.x + t * nv.x,
	            y: p.y + t * nv.y
	          };
	          if (p.z && n.z) {
	            ret.z = p.z + t * nv.z;
	          }
	          return ret;
	        });
	        return [new Bezier(coords)];
	      }
	      var reduced = this.reduce();
	      return reduced.map(function(s) {
	        if (s._linear) {
	          return s.offset(t)[0];
	        }
	        return s.scale(t);
	      });
	    },
	    simple: function() {
	      if (this.order === 3) {
	        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
	        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
	        if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;
	      }
	      var n1 = this.normal(0);
	      var n2 = this.normal(1);
	      var s = n1.x * n2.x + n1.y * n2.y;
	      if (this._3d) {
	        s += n1.z * n2.z;
	      }
	      var angle = abs(acos(s));
	      return angle < pi / 3;
	    },
	    reduce: function() {
	      var i,
	        t1 = 0,
	        t2 = 0,
	        step = 0.01,
	        segment,
	        pass1 = [],
	        pass2 = [];
	      // first pass: split on extrema
	      var extrema = this.extrema().values;
	      if (extrema.indexOf(0) === -1) {
	        extrema = [0].concat(extrema);
	      }
	      if (extrema.indexOf(1) === -1) {
	        extrema.push(1);
	      }

	      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
	        t2 = extrema[i];
	        segment = this.split(t1, t2);
	        segment._t1 = t1;
	        segment._t2 = t2;
	        pass1.push(segment);
	        t1 = t2;
	      }

	      // second pass: further reduce these segments to simple segments
	      pass1.forEach(function(p1) {
	        t1 = 0;
	        t2 = 0;
	        while (t2 <= 1) {
	          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
	            segment = p1.split(t1, t2);
	            if (!segment.simple()) {
	              t2 -= step;
	              if (abs(t1 - t2) < step) {
	                // we can never form a reduction
	                return [];
	              }
	              segment = p1.split(t1, t2);
	              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
	              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
	              pass2.push(segment);
	              t1 = t2;
	              break;
	            }
	          }
	        }
	        if (t1 < 1) {
	          segment = p1.split(t1, 1);
	          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
	          segment._t2 = p1._t2;
	          pass2.push(segment);
	        }
	      });
	      return pass2;
	    },
	    scale: function(d) {
	      var order = this.order;
	      var distanceFn = false;
	      if (typeof d === "function") {
	        distanceFn = d;
	      }
	      if (distanceFn && order === 2) {
	        return this.raise().scale(distanceFn);
	      }

	      // TODO: add special handling for degenerate (=linear) curves.
	      var clockwise = this.clockwise;
	      var r1 = distanceFn ? distanceFn(0) : d;
	      var r2 = distanceFn ? distanceFn(1) : d;
	      var v = [this.offset(0, 10), this.offset(1, 10)];
	      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
	      if (!o) {
	        throw new Error("cannot scale this curve. Try reducing it first.");
	      }
	      // move all points by distance 'd' wrt the origin 'o'
	      var points = this.points,
	        np = [];

	      // move end points by fixed distance along normal.
	      [0, 1].forEach(
	        function(t) {
	          var p = (np[t * order] = utils.copy(points[t * order]));
	          p.x += (t ? r2 : r1) * v[t].n.x;
	          p.y += (t ? r2 : r1) * v[t].n.y;
	        }.bind(this)
	      );

	      if (!distanceFn) {
	        // move control points to lie on the intersection of the offset
	        // derivative vector, and the origin-through-control vector
	        [0, 1].forEach(
	          function(t) {
	            if (this.order === 2 && !!t) return;
	            var p = np[t * order];
	            var d = this.derivative(t);
	            var p2 = { x: p.x + d.x, y: p.y + d.y };
	            np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);
	          }.bind(this)
	        );
	        return new Bezier(np);
	      }

	      // move control points by "however much necessary to
	      // ensure the correct tangent to endpoint".
	      [0, 1].forEach(
	        function(t) {
	          if (this.order === 2 && !!t) return;
	          var p = points[t + 1];
	          var ov = {
	            x: p.x - o.x,
	            y: p.y - o.y
	          };
	          var rc = distanceFn ? distanceFn((t + 1) / order) : d;
	          if (distanceFn && !clockwise) rc = -rc;
	          var m = sqrt(ov.x * ov.x + ov.y * ov.y);
	          ov.x /= m;
	          ov.y /= m;
	          np[t + 1] = {
	            x: p.x + rc * ov.x,
	            y: p.y + rc * ov.y
	          };
	        }.bind(this)
	      );
	      return new Bezier(np);
	    },
	    outline: function(d1, d2, d3, d4) {
	      d2 = typeof d2 === "undefined" ? d1 : d2;
	      var reduced = this.reduce(),
	        len = reduced.length,
	        fcurves = [],
	        bcurves = [],
	        p,
	        alen = 0,
	        tlen = this.length();

	      var graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

	      function linearDistanceFunction(s, e, tlen, alen, slen) {
	        return function(v) {
	          var f1 = alen / tlen,
	            f2 = (alen + slen) / tlen,
	            d = e - s;
	          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
	        };
	      }

	      // form curve oulines
	      reduced.forEach(function(segment) {
	        slen = segment.length();
	        if (graduated) {
	          fcurves.push(
	            segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
	          );
	          bcurves.push(
	            segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
	          );
	        } else {
	          fcurves.push(segment.scale(d1));
	          bcurves.push(segment.scale(-d2));
	        }
	        alen += slen;
	      });

	      // reverse the "return" outline
	      bcurves = bcurves
	        .map(function(s) {
	          p = s.points;
	          if (p[3]) {
	            s.points = [p[3], p[2], p[1], p[0]];
	          } else {
	            s.points = [p[2], p[1], p[0]];
	          }
	          return s;
	        })
	        .reverse();

	      // form the endcaps as lines
	      var fs = fcurves[0].points[0],
	        fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
	        bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
	        be = bcurves[0].points[0],
	        ls = utils.makeline(bs, fs),
	        le = utils.makeline(fe, be),
	        segments = [ls]
	          .concat(fcurves)
	          .concat([le])
	          .concat(bcurves),
	        slen = segments.length;

	      return new PolyBezier(segments);
	    },
	    outlineshapes: function(d1, d2, curveIntersectionThreshold) {
	      d2 = d2 || d1;
	      var outline = this.outline(d1, d2).curves;
	      var shapes = [];
	      for (var i = 1, len = outline.length; i < len / 2; i++) {
	        var shape = utils.makeshape(
	          outline[i],
	          outline[len - i],
	          curveIntersectionThreshold
	        );
	        shape.startcap.virtual = i > 1;
	        shape.endcap.virtual = i < len / 2 - 1;
	        shapes.push(shape);
	      }
	      return shapes;
	    },
	    intersects: function(curve, curveIntersectionThreshold) {
	      if (!curve) return this.selfintersects(curveIntersectionThreshold);
	      if (curve.p1 && curve.p2) {
	        return this.lineIntersects(curve);
	      }
	      if (curve instanceof Bezier) {
	        curve = curve.reduce();
	      }
	      return this.curveintersects(
	        this.reduce(),
	        curve,
	        curveIntersectionThreshold
	      );
	    },
	    lineIntersects: function(line) {
	      var mx = min(line.p1.x, line.p2.x),
	        my = min(line.p1.y, line.p2.y),
	        MX = max(line.p1.x, line.p2.x),
	        MY = max(line.p1.y, line.p2.y),
	        self = this;
	      return utils.roots(this.points, line).filter(function(t) {
	        var p = self.get(t);
	        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
	      });
	    },
	    selfintersects: function(curveIntersectionThreshold) {
	      var reduced = this.reduce();
	      // "simple" curves cannot intersect with their direct
	      // neighbour, so for each segment X we check whether
	      // it intersects [0:x-2][x+2:last].
	      var i,
	        len = reduced.length - 2,
	        results = [],
	        result,
	        left,
	        right;
	      for (i = 0; i < len; i++) {
	        left = reduced.slice(i, i + 1);
	        right = reduced.slice(i + 2);
	        result = this.curveintersects(left, right, curveIntersectionThreshold);
	        results = results.concat(result);
	      }
	      return results;
	    },
	    curveintersects: function(c1, c2, curveIntersectionThreshold) {
	      var pairs = [];
	      // step 1: pair off any overlapping segments
	      c1.forEach(function(l) {
	        c2.forEach(function(r) {
	          if (l.overlaps(r)) {
	            pairs.push({ left: l, right: r });
	          }
	        });
	      });
	      // step 2: for each pairing, run through the convergence algorithm.
	      var intersections = [];
	      pairs.forEach(function(pair) {
	        var result = utils.pairiteration(
	          pair.left,
	          pair.right,
	          curveIntersectionThreshold
	        );
	        if (result.length > 0) {
	          intersections = intersections.concat(result);
	        }
	      });
	      return intersections;
	    },
	    arcs: function(errorThreshold) {
	      errorThreshold = errorThreshold || 0.5;
	      var circles = [];
	      return this._iterate(errorThreshold, circles);
	    },
	    _error: function(pc, np1, s, e) {
	      var q = (e - s) / 4,
	        c1 = this.get(s + q),
	        c2 = this.get(e - q),
	        ref = utils.dist(pc, np1),
	        d1 = utils.dist(pc, c1),
	        d2 = utils.dist(pc, c2);
	      return abs(d1 - ref) + abs(d2 - ref);
	    },
	    _iterate: function(errorThreshold, circles) {
	      var t_s = 0,
	        t_e = 1,
	        safety;
	      // we do a binary search to find the "good `t` closest to no-longer-good"
	      do {
	        safety = 0;

	        // step 1: start with the maximum possible arc
	        t_e = 1;

	        // points:
	        var np1 = this.get(t_s),
	          np2,
	          np3,
	          arc,
	          prev_arc;

	        // booleans:
	        var curr_good = false,
	          prev_good = false,
	          done;

	        // numbers:
	        var t_m = t_e,
	          prev_e = 1,
	          step = 0;

	        // step 2: find the best possible arc
	        do {
	          prev_good = curr_good;
	          prev_arc = arc;
	          t_m = (t_s + t_e) / 2;
	          step++;

	          np2 = this.get(t_m);
	          np3 = this.get(t_e);

	          arc = utils.getccenter(np1, np2, np3);

	          //also save the t values
	          arc.interval = {
	            start: t_s,
	            end: t_e
	          };

	          var error = this._error(arc, np1, t_s, t_e);
	          curr_good = error <= errorThreshold;

	          done = prev_good && !curr_good;
	          if (!done) prev_e = t_e;

	          // this arc is fine: we can move 'e' up to see if we can find a wider arc
	          if (curr_good) {
	            // if e is already at max, then we're done for this arc.
	            if (t_e >= 1) {
	              // make sure we cap at t=1
	              arc.interval.end = prev_e = 1;
	              prev_arc = arc;
	              // if we capped the arc segment to t=1 we also need to make sure that
	              // the arc's end angle is correct with respect to the bezier end point.
	              if (t_e > 1) {
	                var d = {
	                  x: arc.x + arc.r * cos(arc.e),
	                  y: arc.y + arc.r * sin(arc.e)
	                };
	                arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
	              }
	              break;
	            }
	            // if not, move it up by half the iteration distance
	            t_e = t_e + (t_e - t_s) / 2;
	          } else {
	            // this is a bad arc: we need to move 'e' down to find a good arc
	            t_e = t_m;
	          }
	        } while (!done && safety++ < 100);

	        if (safety >= 100) {
	          break;
	        }

	        // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

	        prev_arc = prev_arc ? prev_arc : arc;
	        circles.push(prev_arc);
	        t_s = prev_e;
	      } while (t_e < 1);
	      return circles;
	    }
	  };

	  module.exports = Bezier;
	})();


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	  "use strict";

	  // math-inlining.
	  var abs = Math.abs,
	    cos = Math.cos,
	    sin = Math.sin,
	    acos = Math.acos,
	    atan2 = Math.atan2,
	    sqrt = Math.sqrt,
	    pow = Math.pow,
	    // cube root function yielding real roots
	    crt = function(v) {
	      return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
	    },
	    // trig constants
	    pi = Math.PI,
	    tau = 2 * pi,
	    quart = pi / 2,
	    // float precision significant decimal
	    epsilon = 0.000001,
	    // extremas used in bbox calculation and similar algorithms
	    nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
	    nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
	    // a zero coordinate, which is surprisingly useful
	    ZERO = { x: 0, y: 0, z: 0 };

	  // Bezier utility functions
	  var utils = {
	    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
	    Tvalues: [
	      -0.0640568928626056260850430826247450385909,
	      0.0640568928626056260850430826247450385909,
	      -0.1911188674736163091586398207570696318404,
	      0.1911188674736163091586398207570696318404,
	      -0.3150426796961633743867932913198102407864,
	      0.3150426796961633743867932913198102407864,
	      -0.4337935076260451384870842319133497124524,
	      0.4337935076260451384870842319133497124524,
	      -0.5454214713888395356583756172183723700107,
	      0.5454214713888395356583756172183723700107,
	      -0.6480936519369755692524957869107476266696,
	      0.6480936519369755692524957869107476266696,
	      -0.7401241915785543642438281030999784255232,
	      0.7401241915785543642438281030999784255232,
	      -0.8200019859739029219539498726697452080761,
	      0.8200019859739029219539498726697452080761,
	      -0.8864155270044010342131543419821967550873,
	      0.8864155270044010342131543419821967550873,
	      -0.9382745520027327585236490017087214496548,
	      0.9382745520027327585236490017087214496548,
	      -0.9747285559713094981983919930081690617411,
	      0.9747285559713094981983919930081690617411,
	      -0.9951872199970213601799974097007368118745,
	      0.9951872199970213601799974097007368118745
	    ],

	    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
	    Cvalues: [
	      0.1279381953467521569740561652246953718517,
	      0.1279381953467521569740561652246953718517,
	      0.1258374563468282961213753825111836887264,
	      0.1258374563468282961213753825111836887264,
	      0.121670472927803391204463153476262425607,
	      0.121670472927803391204463153476262425607,
	      0.1155056680537256013533444839067835598622,
	      0.1155056680537256013533444839067835598622,
	      0.1074442701159656347825773424466062227946,
	      0.1074442701159656347825773424466062227946,
	      0.0976186521041138882698806644642471544279,
	      0.0976186521041138882698806644642471544279,
	      0.086190161531953275917185202983742667185,
	      0.086190161531953275917185202983742667185,
	      0.0733464814110803057340336152531165181193,
	      0.0733464814110803057340336152531165181193,
	      0.0592985849154367807463677585001085845412,
	      0.0592985849154367807463677585001085845412,
	      0.0442774388174198061686027482113382288593,
	      0.0442774388174198061686027482113382288593,
	      0.0285313886289336631813078159518782864491,
	      0.0285313886289336631813078159518782864491,
	      0.0123412297999871995468056670700372915759,
	      0.0123412297999871995468056670700372915759
	    ],

	    arcfn: function(t, derivativeFn) {
	      var d = derivativeFn(t);
	      var l = d.x * d.x + d.y * d.y;
	      if (typeof d.z !== "undefined") {
	        l += d.z * d.z;
	      }
	      return sqrt(l);
	    },

	    compute: function(t, points, _3d) {
	      // shortcuts
	      if (t === 0) {
	        return points[0];
	      }

	      var order = points.length-1;

	      if (t === 1) {
	        return points[order];
	      }

	      var p = points;
	      var mt = 1 - t;

	      // constant?
	      if (order === 0) {
	        return points[0];
	      }

	      // linear?
	      if (order === 1) {
	        ret = {
	          x: mt * p[0].x + t * p[1].x,
	          y: mt * p[0].y + t * p[1].y
	        };
	        if (_3d) {
	          ret.z = mt * p[0].z + t * p[1].z;
	        }
	        return ret;
	      }

	      // quadratic/cubic curve?
	      if (order < 4) {
	        var mt2 = mt * mt,
	          t2 = t * t,
	          a,
	          b,
	          c,
	          d = 0;
	        if (order === 2) {
	          p = [p[0], p[1], p[2], ZERO];
	          a = mt2;
	          b = mt * t * 2;
	          c = t2;
	        } else if (order === 3) {
	          a = mt2 * mt;
	          b = mt2 * t * 3;
	          c = mt * t2 * 3;
	          d = t * t2;
	        }
	        var ret = {
	          x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
	          y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
	        };
	        if (_3d) {
	          ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
	        }
	        return ret;
	      }

	      // higher order curves: use de Casteljau's computation
	      var dCpts = JSON.parse(JSON.stringify(points));
	      while (dCpts.length > 1) {
	        for (var i = 0; i < dCpts.length - 1; i++) {
	          dCpts[i] = {
	            x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
	            y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t
	          };
	          if (typeof dCpts[i].z !== "undefined") {
	            dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
	          }
	        }
	        dCpts.splice(dCpts.length - 1, 1);
	      }
	      return dCpts[0];
	    },

	    computeWithRatios: function (t, points, ratios, _3d) {
	      var mt = 1 - t, r = ratios, p = points, d;
	      var f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3];

	      // spec for linear
	      f1 *= mt;
	      f2 *= t;

	      if (p.length === 2) {
	        d = f1 + f2;
	        return {
	          x: (f1 * p[0].x + f2 * p[1].x)/d,
	          y: (f1 * p[0].y + f2 * p[1].y)/d,
	          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z)/d
	        };
	      }

	      // upgrade to quadratic
	      f1 *= mt;
	      f2 *= 2 * mt;
	      f3 *= t * t;

	      if (p.length === 3) {
	        d = f1 + f2 + f3;
	        return {
	          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x)/d,
	          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y)/d,
	          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z)/d
	        };
	      }

	      // upgrade to cubic
	      f1 *= mt;
	      f2 *= 1.5 * mt;
	      f3 *= 3 * mt;
	      f4 *= t * t * t;

	      if (p.length === 4) {
	        d = f1 + f2 + f3 + f4;
	        return {
	          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x)/d,
	          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y)/d,
	          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z)/d
	        };
	      }
	    },

	    derive: function (points, _3d) {
	      var dpoints = [];
	      for (var p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
	        var list = [];
	        for (var j = 0, dpt; j < c; j++) {
	          dpt = {
	            x: c * (p[j + 1].x - p[j].x),
	            y: c * (p[j + 1].y - p[j].y)
	          };
	          if (_3d) {
	            dpt.z = c * (p[j + 1].z - p[j].z);
	          }
	          list.push(dpt);
	        }
	        dpoints.push(list);
	        p = list;
	      }
	      return dpoints;
	    },

	    between: function(v, m, M) {
	      return (
	        (m <= v && v <= M) ||
	        utils.approximately(v, m) ||
	        utils.approximately(v, M)
	      );
	    },

	    approximately: function(a, b, precision) {
	      return abs(a - b) <= (precision || epsilon);
	    },

	    length: function(derivativeFn) {
	      var z = 0.5,
	        sum = 0,
	        len = utils.Tvalues.length,
	        i,
	        t;
	      for (i = 0; i < len; i++) {
	        t = z * utils.Tvalues[i] + z;
	        sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);
	      }
	      return z * sum;
	    },

	    map: function(v, ds, de, ts, te) {
	      var d1 = de - ds,
	        d2 = te - ts,
	        v2 = v - ds,
	        r = v2 / d1;
	      return ts + d2 * r;
	    },

	    lerp: function(r, v1, v2) {
	      var ret = {
	        x: v1.x + r * (v2.x - v1.x),
	        y: v1.y + r * (v2.y - v1.y)
	      };
	      if (!!v1.z && !!v2.z) {
	        ret.z = v1.z + r * (v2.z - v1.z);
	      }
	      return ret;
	    },

	    pointToString: function(p) {
	      var s = p.x + "/" + p.y;
	      if (typeof p.z !== "undefined") {
	        s += "/" + p.z;
	      }
	      return s;
	    },

	    pointsToString: function(points) {
	      return "[" + points.map(utils.pointToString).join(", ") + "]";
	    },

	    copy: function(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    },

	    angle: function(o, v1, v2) {
	      var dx1 = v1.x - o.x,
	        dy1 = v1.y - o.y,
	        dx2 = v2.x - o.x,
	        dy2 = v2.y - o.y,
	        cross = dx1 * dy2 - dy1 * dx2,
	        dot = dx1 * dx2 + dy1 * dy2;
	      return atan2(cross, dot);
	    },

	    // round as string, to avoid rounding errors
	    round: function(v, d) {
	      var s = "" + v;
	      var pos = s.indexOf(".");
	      return parseFloat(s.substring(0, pos + 1 + d));
	    },

	    dist: function(p1, p2) {
	      var dx = p1.x - p2.x,
	        dy = p1.y - p2.y;
	      return sqrt(dx * dx + dy * dy);
	    },

	    closest: function(LUT, point) {
	      var mdist = pow(2, 63),
	        mpos,
	        d;
	      LUT.forEach(function(p, idx) {
	        d = utils.dist(point, p);
	        if (d < mdist) {
	          mdist = d;
	          mpos = idx;
	        }
	      });
	      return { mdist: mdist, mpos: mpos };
	    },

	    abcratio: function(t, n) {
	      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
	      if (n !== 2 && n !== 3) {
	        return false;
	      }
	      if (typeof t === "undefined") {
	        t = 0.5;
	      } else if (t === 0 || t === 1) {
	        return t;
	      }
	      var bottom = pow(t, n) + pow(1 - t, n),
	        top = bottom - 1;
	      return abs(top / bottom);
	    },

	    projectionratio: function(t, n) {
	      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
	      if (n !== 2 && n !== 3) {
	        return false;
	      }
	      if (typeof t === "undefined") {
	        t = 0.5;
	      } else if (t === 0 || t === 1) {
	        return t;
	      }
	      var top = pow(1 - t, n),
	        bottom = pow(t, n) + top;
	      return top / bottom;
	    },

	    lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
	      var nx =
	          (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
	        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
	        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	      if (d == 0) {
	        return false;
	      }
	      return { x: nx / d, y: ny / d };
	    },

	    lli4: function(p1, p2, p3, p4) {
	      var x1 = p1.x,
	        y1 = p1.y,
	        x2 = p2.x,
	        y2 = p2.y,
	        x3 = p3.x,
	        y3 = p3.y,
	        x4 = p4.x,
	        y4 = p4.y;
	      return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
	    },

	    lli: function(v1, v2) {
	      return utils.lli4(v1, v1.c, v2, v2.c);
	    },

	    makeline: function(p1, p2) {
	      var Bezier = __webpack_require__(178);
	      var x1 = p1.x,
	        y1 = p1.y,
	        x2 = p2.x,
	        y2 = p2.y,
	        dx = (x2 - x1) / 3,
	        dy = (y2 - y1) / 3;
	      return new Bezier(
	        x1,
	        y1,
	        x1 + dx,
	        y1 + dy,
	        x1 + 2 * dx,
	        y1 + 2 * dy,
	        x2,
	        y2
	      );
	    },

	    findbbox: function(sections) {
	      var mx = nMax,
	        my = nMax,
	        MX = nMin,
	        MY = nMin;
	      sections.forEach(function(s) {
	        var bbox = s.bbox();
	        if (mx > bbox.x.min) mx = bbox.x.min;
	        if (my > bbox.y.min) my = bbox.y.min;
	        if (MX < bbox.x.max) MX = bbox.x.max;
	        if (MY < bbox.y.max) MY = bbox.y.max;
	      });
	      return {
	        x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
	        y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
	      };
	    },

	    shapeintersections: function(
	      s1,
	      bbox1,
	      s2,
	      bbox2,
	      curveIntersectionThreshold
	    ) {
	      if (!utils.bboxoverlap(bbox1, bbox2)) return [];
	      var intersections = [];
	      var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
	      var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
	      a1.forEach(function(l1) {
	        if (l1.virtual) return;
	        a2.forEach(function(l2) {
	          if (l2.virtual) return;
	          var iss = l1.intersects(l2, curveIntersectionThreshold);
	          if (iss.length > 0) {
	            iss.c1 = l1;
	            iss.c2 = l2;
	            iss.s1 = s1;
	            iss.s2 = s2;
	            intersections.push(iss);
	          }
	        });
	      });
	      return intersections;
	    },

	    makeshape: function(forward, back, curveIntersectionThreshold) {
	      var bpl = back.points.length;
	      var fpl = forward.points.length;
	      var start = utils.makeline(back.points[bpl - 1], forward.points[0]);
	      var end = utils.makeline(forward.points[fpl - 1], back.points[0]);
	      var shape = {
	        startcap: start,
	        forward: forward,
	        back: back,
	        endcap: end,
	        bbox: utils.findbbox([start, forward, back, end])
	      };
	      var self = utils;
	      shape.intersections = function(s2) {
	        return self.shapeintersections(
	          shape,
	          shape.bbox,
	          s2,
	          s2.bbox,
	          curveIntersectionThreshold
	        );
	      };
	      return shape;
	    },

	    getminmax: function(curve, d, list) {
	      if (!list) return { min: 0, max: 0 };
	      var min = nMax,
	        max = nMin,
	        t,
	        c;
	      if (list.indexOf(0) === -1) {
	        list = [0].concat(list);
	      }
	      if (list.indexOf(1) === -1) {
	        list.push(1);
	      }
	      for (var i = 0, len = list.length; i < len; i++) {
	        t = list[i];
	        c = curve.get(t);
	        if (c[d] < min) {
	          min = c[d];
	        }
	        if (c[d] > max) {
	          max = c[d];
	        }
	      }
	      return { min: min, mid: (min + max) / 2, max: max, size: max - min };
	    },

	    align: function(points, line) {
	      var tx = line.p1.x,
	        ty = line.p1.y,
	        a = -atan2(line.p2.y - ty, line.p2.x - tx),
	        d = function(v) {
	          return {
	            x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),
	            y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)
	          };
	        };
	      return points.map(d);
	    },

	    roots: function(points, line) {
	      line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
	      var order = points.length - 1;
	      var p = utils.align(points, line);
	      var reduce = function(t) {
	        return 0 <= t && t <= 1;
	      };

	      if (order === 2) {
	        var a = p[0].y,
	          b = p[1].y,
	          c = p[2].y,
	          d = a - 2 * b + c;
	        if (d !== 0) {
	          var m1 = -sqrt(b * b - a * c),
	            m2 = -a + b,
	            v1 = -(m1 + m2) / d,
	            v2 = -(-m1 + m2) / d;
	          return [v1, v2].filter(reduce);
	        } else if (b !== c && d === 0) {
	          return [(2*b - c)/(2*b - 2*c)].filter(reduce);
	        }
	        return [];
	      }

	      // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
	      var pa = p[0].y,
	        pb = p[1].y,
	        pc = p[2].y,
	        pd = p[3].y,
	        d = -pa + 3 * pb - 3 * pc + pd,
	        a = 3 * pa - 6 * pb + 3 * pc,
	        b = -3 * pa + 3 * pb,
	        c = pa;

	      if (utils.approximately(d, 0)) {
	        // this is not a cubic curve.
	        if (utils.approximately(a, 0)) {
	          // in fact, this is not a quadratic curve either.
	          if (utils.approximately(b, 0)) {
	            // in fact in fact, there are no solutions.
	            return [];
	          }
	          // linear solution:
	          return [-c / b].filter(reduce);
	        }
	        // quadratic solution:
	        var q = sqrt(b * b - 4 * a * c),
	          a2 = 2 * a;
	        return [(q - b) / a2, (-b - q) / a2].filter(reduce);
	      }

	      // at this point, we know we need a cubic solution:

	      a /= d;
	      b /= d;
	      c /= d;

	      var p = (3 * b - a * a) / 3,
	        p3 = p / 3,
	        q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
	        q2 = q / 2,
	        discriminant = q2 * q2 + p3 * p3 * p3,
	        u1,
	        v1,
	        x1,
	        x2,
	        x3;
	      if (discriminant < 0) {
	        var mp3 = -p / 3,
	          mp33 = mp3 * mp3 * mp3,
	          r = sqrt(mp33),
	          t = -q / (2 * r),
	          cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
	          phi = acos(cosphi),
	          crtr = crt(r),
	          t1 = 2 * crtr;
	        x1 = t1 * cos(phi / 3) - a / 3;
	        x2 = t1 * cos((phi + tau) / 3) - a / 3;
	        x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;
	        return [x1, x2, x3].filter(reduce);
	      } else if (discriminant === 0) {
	        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
	        x1 = 2 * u1 - a / 3;
	        x2 = -u1 - a / 3;
	        return [x1, x2].filter(reduce);
	      } else {
	        var sd = sqrt(discriminant);
	        u1 = crt(-q2 + sd);
	        v1 = crt(q2 + sd);
	        return [u1 - v1 - a / 3].filter(reduce);
	      }
	    },

	    droots: function(p) {
	      // quadratic roots are easy
	      if (p.length === 3) {
	        var a = p[0],
	          b = p[1],
	          c = p[2],
	          d = a - 2 * b + c;
	        if (d !== 0) {
	          var m1 = -sqrt(b * b - a * c),
	            m2 = -a + b,
	            v1 = -(m1 + m2) / d,
	            v2 = -(-m1 + m2) / d;
	          return [v1, v2];
	        } else if (b !== c && d === 0) {
	          return [(2 * b - c) / (2 * (b - c))];
	        }
	        return [];
	      }

	      // linear roots are even easier
	      if (p.length === 2) {
	        var a = p[0],
	          b = p[1];
	        if (a !== b) {
	          return [a / (a - b)];
	        }
	        return [];
	      }
	    },

	    curvature: function(t, points, _3d, kOnly) {
	      var dpoints = utils.derive(points);
	      var d1 = dpoints[0];
	      var d2 = dpoints[1];
	      var num, dnm, adk, dk, k=0, r=0;

	      //
	      // We're using the following formula for curvature:
	      //
	      //              x'y" - y'x"
	      //   k(t) = ------------------
	      //           (x'² + y'²)^(3/2)
	      //
	      // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
	      //
	      // With it corresponding 3D counterpart:
	      //
	      //          sqrt( (y'z" - y"z')² + (z'x" - z"x')² + (x'y" - x"y')²)
	      //   k(t) = -------------------------------------------------------
	      //                     (x'² + y'² + z'²)^(3/2)
	      //

	      var d = utils.compute(t, d1);
	      var dd = utils.compute(t, d2);
	      var qdsum = d.x*d.x + d.y*d.y;
	      if (_3d) {
	        num = sqrt(
	          pow(d.y*dd.z - dd.y*d.z, 2) +
	          pow(d.z*dd.x - dd.z*d.x, 2) +
	          pow(d.x*dd.y - dd.x*d.y, 2)
	        );
	        dnm = pow(qdsum + d.z*d.z, 3/2);
	      } else {
	        num = d.x*dd.y - d.y*dd.x;
	        dnm = pow(qdsum, 3/2);
	      }

	      if (num === 0 || dnm === 0) {
	        return { k:0, r:0 };
	      }

	      k = num/dnm;
	      r = dnm/num;

	      // We're also computing the derivative of kappa, because
	      // there is value in knowing the rate of change for the
	      // curvature along the curve. And we're just going to
	      // ballpark it based on an epsilon.
	      if (!kOnly) {
	        // compute k'(t) based on the interval before, and after it,
	        // to at least try to not introduce forward/backward pass bias.
	        var pk = utils.curvature(t-0.001, points, _3d, true).k;
	        var nk = utils.curvature(t+0.001, points, _3d, true).k;
	        dk = ((nk-k) + (k-pk))/2;
	        adk = (abs(nk-k) + abs(k-pk))/2;
	      }

	      return { k: k, r: r, dk: dk, adk:adk, };
	    },

	    inflections: function(points) {
	      if (points.length < 4) return [];

	      // FIXME: TODO: add in inflection abstraction for quartic+ curves?

	      var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
	        a = p[2].x * p[1].y,
	        b = p[3].x * p[1].y,
	        c = p[1].x * p[2].y,
	        d = p[3].x * p[2].y,
	        v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
	        v2 = 18 * (3 * a - b - 3 * c),
	        v3 = 18 * (c - a);

	      if (utils.approximately(v1, 0)) {
	        if (!utils.approximately(v2, 0)) {
	          var t = -v3 / v2;
	          if (0 <= t && t <= 1) return [t];
	        }
	        return [];
	      }

	      var trm = v2 * v2 - 4 * v1 * v3,
	        sq = Math.sqrt(trm),
	        d = 2 * v1;

	      if (utils.approximately(d, 0)) return [];

	      return [(sq - v2) / d, -(v2 + sq) / d].filter(function(r) {
	        return 0 <= r && r <= 1;
	      });
	    },

	    bboxoverlap: function(b1, b2) {
	      var dims = ["x", "y"],
	        len = dims.length,
	        i,
	        dim,
	        l,
	        t,
	        d;
	      for (i = 0; i < len; i++) {
	        dim = dims[i];
	        l = b1[dim].mid;
	        t = b2[dim].mid;
	        d = (b1[dim].size + b2[dim].size) / 2;
	        if (abs(l - t) >= d) return false;
	      }
	      return true;
	    },

	    expandbox: function(bbox, _bbox) {
	      if (_bbox.x.min < bbox.x.min) {
	        bbox.x.min = _bbox.x.min;
	      }
	      if (_bbox.y.min < bbox.y.min) {
	        bbox.y.min = _bbox.y.min;
	      }
	      if (_bbox.z && _bbox.z.min < bbox.z.min) {
	        bbox.z.min = _bbox.z.min;
	      }
	      if (_bbox.x.max > bbox.x.max) {
	        bbox.x.max = _bbox.x.max;
	      }
	      if (_bbox.y.max > bbox.y.max) {
	        bbox.y.max = _bbox.y.max;
	      }
	      if (_bbox.z && _bbox.z.max > bbox.z.max) {
	        bbox.z.max = _bbox.z.max;
	      }
	      bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
	      bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
	      if (bbox.z) {
	        bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
	      }
	      bbox.x.size = bbox.x.max - bbox.x.min;
	      bbox.y.size = bbox.y.max - bbox.y.min;
	      if (bbox.z) {
	        bbox.z.size = bbox.z.max - bbox.z.min;
	      }
	    },

	    pairiteration: function(c1, c2, curveIntersectionThreshold) {
	      var c1b = c1.bbox(),
	        c2b = c2.bbox(),
	        r = 100000,
	        threshold = curveIntersectionThreshold || 0.5;
	      if (
	        c1b.x.size + c1b.y.size < threshold &&
	        c2b.x.size + c2b.y.size < threshold
	      ) {
	        return [
	          ((r * (c1._t1 + c1._t2) / 2) | 0) / r +
	            "/" +
	            ((r * (c2._t1 + c2._t2) / 2) | 0) / r
	        ];
	      }
	      var cc1 = c1.split(0.5),
	        cc2 = c2.split(0.5),
	        pairs = [
	          { left: cc1.left, right: cc2.left },
	          { left: cc1.left, right: cc2.right },
	          { left: cc1.right, right: cc2.right },
	          { left: cc1.right, right: cc2.left }
	        ];
	      pairs = pairs.filter(function(pair) {
	        return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
	      });
	      var results = [];
	      if (pairs.length === 0) return results;
	      pairs.forEach(function(pair) {
	        results = results.concat(
	          utils.pairiteration(pair.left, pair.right, threshold)
	        );
	      });
	      results = results.filter(function(v, i) {
	        return results.indexOf(v) === i;
	      });
	      return results;
	    },

	    getccenter: function(p1, p2, p3) {
	      var dx1 = p2.x - p1.x,
	        dy1 = p2.y - p1.y,
	        dx2 = p3.x - p2.x,
	        dy2 = p3.y - p2.y;
	      var dx1p = dx1 * cos(quart) - dy1 * sin(quart),
	        dy1p = dx1 * sin(quart) + dy1 * cos(quart),
	        dx2p = dx2 * cos(quart) - dy2 * sin(quart),
	        dy2p = dx2 * sin(quart) + dy2 * cos(quart);
	      // chord midpoints
	      var mx1 = (p1.x + p2.x) / 2,
	        my1 = (p1.y + p2.y) / 2,
	        mx2 = (p2.x + p3.x) / 2,
	        my2 = (p2.y + p3.y) / 2;
	      // midpoint offsets
	      var mx1n = mx1 + dx1p,
	        my1n = my1 + dy1p,
	        mx2n = mx2 + dx2p,
	        my2n = my2 + dy2p;
	      // intersection of these lines:
	      var arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
	        r = utils.dist(arc, p1),
	        // arc start/end values, over mid point:
	        s = atan2(p1.y - arc.y, p1.x - arc.x),
	        m = atan2(p2.y - arc.y, p2.x - arc.x),
	        e = atan2(p3.y - arc.y, p3.x - arc.x),
	        _;
	      // determine arc direction (cw/ccw correction)
	      if (s < e) {
	        // if s<m<e, arc(s, e)
	        // if m<s<e, arc(e, s + tau)
	        // if s<e<m, arc(e, s + tau)
	        if (s > m || m > e) {
	          s += tau;
	        }
	        if (s > e) {
	          _ = e;
	          e = s;
	          s = _;
	        }
	      } else {
	        // if e<m<s, arc(e, s)
	        // if m<e<s, arc(s, e + tau)
	        // if e<s<m, arc(s, e + tau)
	        if (e < m && m < s) {
	          _ = e;
	          e = s;
	          s = _;
	        } else {
	          e += tau;
	        }
	      }
	      // assign and done.
	      arc.s = s;
	      arc.e = e;
	      arc.r = r;
	      return arc;
	    },

	    numberSort: function(a, b) {
	      return a - b;
	    }
	  };

	  module.exports = utils;
	})();


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	(function() {
	  "use strict";

	  var utils = __webpack_require__(179);

	  /**
	   * Poly Bezier
	   * @param {[type]} curves [description]
	   */
	  var PolyBezier = function(curves) {
	    this.curves = [];
	    this._3d = false;
	    if (!!curves) {
	      this.curves = curves;
	      this._3d = this.curves[0]._3d;
	    }
	  };

	  PolyBezier.prototype = {
	    valueOf: function() {
	      return this.toString();
	    },
	    toString: function() {
	      return (
	        "[" +
	        this.curves
	          .map(function(curve) {
	            return utils.pointsToString(curve.points);
	          })
	          .join(", ") +
	        "]"
	      );
	    },
	    addCurve: function(curve) {
	      this.curves.push(curve);
	      this._3d = this._3d || curve._3d;
	    },
	    length: function() {
	      return this.curves
	        .map(function(v) {
	          return v.length();
	        })
	        .reduce(function(a, b) {
	          return a + b;
	        });
	    },
	    curve: function(idx) {
	      return this.curves[idx];
	    },
	    bbox: function() {
	      var c = this.curves;
	      var bbox = c[0].bbox();
	      for (var i = 1; i < c.length; i++) {
	        utils.expandbox(bbox, c[i].bbox());
	      }
	      return bbox;
	    },
	    offset: function(d) {
	      var offset = [];
	      this.curves.forEach(function(v) {
	        offset = offset.concat(v.offset(d));
	      });
	      return new PolyBezier(offset);
	    }
	  };

	  module.exports = PolyBezier;
	})();


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	var normalise = __webpack_require__(182);

	var M = { x: false, y: false };

	function makeBezier(Bezier, term, values) {
	  if (term === 'Z') return;
	  if (term === 'M') {
	    M = {x: values[0], y: values[1]};
	    return;
	  }
	  // ES7: new Bezier(M.x, M.y, ...values)
	  var cvalues = [false, M.x, M.y].concat(values);
	  var PreboundConstructor = Bezier.bind.apply(Bezier, cvalues)
	  var curve = new PreboundConstructor();
	  var last = values.slice(-2);
	  M = { x : last[0], y: last[1] };
	  return curve;
	}

	function convertPath(Bezier, d) {
	  var terms = normalise(d).split(" "),
	    term,
	    matcher = new RegExp("[MLCQZ]", ""),
	    segment,
	    values,
	    segments = [],
	    ARGS = { "C": 6, "Q": 4, "L": 2, "M": 2};

	  while (terms.length) {
	    term = terms.splice(0,1)[0];
	    if (matcher.test(term)) {
	      values = terms.splice(0, ARGS[term]).map(parseFloat);
	      segment = makeBezier(Bezier, term, values);
	      if (segment) segments.push(segment);
	    }
	  }

	  return new Bezier.PolyBezier(segments);
	}

	module.exports = convertPath;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

	/**
	 * Normalise an SVG path to absolute coordinates
	 * and full commands, rather than relative coordinates
	 * and/or shortcut commands.
	 */
	function normalizePath(d) {
	  // preprocess "d" so that we have spaces between values
	  d = d
	    .replace(/,/g, " ") // replace commas with spaces
	    .replace(/-/g, " - ") // add spacing around minus signs
	    .replace(/-\s+/g, "-") // remove spacing to the right of minus signs.
	    .replace(/([a-zA-Z])/g, " $1 ");

	  // set up the variables used in this function
	  var instructions = d.replace(/([a-zA-Z])\s?/g, "|$1").split("|"),
	    instructionLength = instructions.length,
	    i,
	    instruction,
	    op,
	    lop,
	    args = [],
	    alen,
	    a,
	    sx = 0,
	    sy = 0,
	    x = 0,
	    y = 0,
	    cx = 0,
	    cy = 0,
	    cx2 = 0,
	    cy2 = 0,
	    normalized = "";

	  // we run through the instruction list starting at 1, not 0,
	  // because we split up "|M x y ...." so the first element will
	  // always be an empty string. By design.
	  for (i = 1; i < instructionLength; i++) {
	    // which instruction is this?
	    instruction = instructions[i];
	    op = instruction.substring(0, 1);
	    lop = op.toLowerCase();

	    // what are the arguments? note that we need to convert
	    // all strings into numbers, or + will do silly things.
	    args = instruction
	      .replace(op, "")
	      .trim()
	      .split(" ");
	    args = args
	      .filter(function(v) {
	        return v !== "";
	      })
	      .map(parseFloat);
	    alen = args.length;

	    // we could use a switch, but elaborate code in a "case" with
	    // fallthrough is just horrid to read. So let's use ifthen
	    // statements instead.

	    // moveto command (plus possible lineto)
	    if (lop === "m") {
	      normalized += "M ";
	      if (op === "m") {
	        x += args[0];
	        y += args[1];
	      } else {
	        x = args[0];
	        y = args[1];
	      }
	      // records start position, for dealing
	      // with the shape close operator ('Z')
	      sx = x;
	      sy = y;
	      normalized += x + " " + y + " ";
	      if (alen > 2) {
	        for (a = 0; a < alen; a += 2) {
	          if (op === "m") {
	            x += args[a];
	            y += args[a + 1];
	          } else {
	            x = args[a];
	            y = args[a + 1];
	          }
	          normalized += ["L",x,y,''].join(" ");
	        }
	      }
	    } else if (lop === "l") {
	      // lineto commands
	      for (a = 0; a < alen; a += 2) {
	        if (op === "l") {
	          x += args[a];
	          y += args[a + 1];
	        } else {
	          x = args[a];
	          y = args[a + 1];
	        }
	        normalized += ["L",x,y,''].join(" ");
	      }
	    } else if (lop === "h") {
	      for (a = 0; a < alen; a++) {
	        if (op === "h") {
	          x += args[a];
	        } else {
	          x = args[a];
	        }
	        normalized += ["L",x,y,''].join(" ");
	      }
	    } else if (lop === "v") {
	      for (a = 0; a < alen; a++) {
	        if (op === "v") {
	          y += args[a];
	        } else {
	          y = args[a];
	        }
	        normalized += ["L",x,y,''].join(" ");
	      }
	    } else if (lop === "q") {
	      // quadratic curveto commands
	      for (a = 0; a < alen; a += 4) {
	        if (op === "q") {
	          cx = x + args[a];
	          cy = y + args[a + 1];
	          x += args[a + 2];
	          y += args[a + 3];
	        } else {
	          cx = args[a];
	          cy = args[a + 1];
	          x = args[a + 2];
	          y = args[a + 3];
	        }
	        normalized += ["Q",cx,cy,x,y,''].join(" ");
	      }
	    } else if (lop === "t") {
	      for (a = 0; a < alen; a += 2) {
	        // reflect previous cx/cy over x/y
	        cx = x + (x - cx);
	        cy = y + (y - cy);
	        // then get real end point
	        if (op === "t") {
	          x += args[a];
	          y += args[a + 1];
	        } else {
	          x = args[a];
	          y = args[a + 1];
	        }
	        normalized += ["Q",cx,cy,x,y,''].join(" ");
	      }
	    } else if (lop === "c") {
	      // cubic curveto commands
	      for (a = 0; a < alen; a += 6) {
	        if (op === "c") {
	          cx = x + args[a];
	          cy = y + args[a + 1];
	          cx2 = x + args[a + 2];
	          cy2 = y + args[a + 3];
	          x += args[a + 4];
	          y += args[a + 5];
	        } else {
	          cx = args[a];
	          cy = args[a + 1];
	          cx2 = args[a + 2];
	          cy2 = args[a + 3];
	          x = args[a + 4];
	          y = args[a + 5];
	        }
	        normalized += ["C",cx,cy,cx2,cy2,x,y,''].join(" ");
	      }
	    } else if (lop === "s") {
	      for (a = 0; a < alen; a += 4) {
	        // reflect previous cx2/cy2 over x/y
	        cx = x + (x - cx2);
	        cy = y + (y - cy2);
	        // then get real control and end point
	        if (op === "s") {
	          cx2 = x + args[a];
	          cy2 = y + args[a + 1];
	          x += args[a + 2];
	          y += args[a + 3];
	        } else {
	          cx2 = args[a];
	          cy2 = args[a + 1];
	          x = args[a + 2];
	          y = args[a + 3];
	        }
	        normalized +=["C",cx,cy,cx2,cy2,x,y,''].join(" ");
	      }
	    } else if (lop === "z") {
	      normalized += "Z ";
	      // not unimportant: path closing changes the current x/y coordinate
	      x = sx;
	      y = sy;
	    }
	  }
	  return normalized.trim();
	}

	module.exports = normalizePath;


/***/ })
/******/ ])});;